<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>桃花岛杂货铺</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dongxiem.github.io/"/>
  <updated>2020-08-21T12:32:58.574Z</updated>
  <id>https://dongxiem.github.io/</id>
  
  <author>
    <name>Garmen Lee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>go 基础 - go的命令源码文件</title>
    <link href="https://dongxiem.github.io/2020/05/15/go-ji-chu-go-de-ming-ling-yuan-ma-wen-jian/"/>
    <id>https://dongxiem.github.io/2020/05/15/go-ji-chu-go-de-ming-ling-yuan-ma-wen-jian/</id>
    <published>2020-05-15T07:48:25.000Z</published>
    <updated>2020-08-21T12:32:58.574Z</updated>
    
    <summary type="html">
    
      Go的源码文件主要分为三种：命令源码文件、库源码文件和测试源码文件，这里对Go的命令源码文件进行一个简单的认识和介绍
    
    </summary>
    
    
      <category term="go基础" scheme="https://dongxiem.github.io/categories/go%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="go" scheme="https://dongxiem.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go 基础 - go的环境变量</title>
    <link href="https://dongxiem.github.io/2020/05/15/go-ji-chu-go-de-huan-jing-bian-liang/"/>
    <id>https://dongxiem.github.io/2020/05/15/go-ji-chu-go-de-huan-jing-bian-liang/</id>
    <published>2020-05-15T04:11:25.000Z</published>
    <updated>2020-08-21T12:32:47.474Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-三个环境变量&quot;&gt;&lt;a href=&quot;#1-三个环境变量&quot; class=&quot;headerlink&quot; title=&quot;1.三个环境变量&quot;&gt;&lt;/a&gt;1.三个环境变量&lt;/h1&gt;&lt;p&gt;刚接触go的时候很头疼，一下子需要我配置三个环境变量，这三个环境变量看起来很让人头疼，感觉起来三个环境变量的意思大致，区分度不高，这三个环境变量也就是 &lt;code&gt;GOROOT&lt;/code&gt;、&lt;code&gt;GOPATH&lt;/code&gt; 和 &lt;code&gt;GOBIN&lt;/code&gt;。这里简单介绍一下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GOROOT：Go 语言安装根目录的路径，也就是 GO 语言的安装路径。&lt;/li&gt;
&lt;li&gt;GOPATH：若干工作区目录的路径。是我们自己定义的工作空间。&lt;/li&gt;
&lt;li&gt;GOBIN：GO 程序生成的可执行文件（executable file）的路径。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中最让人头疼的就是这个GOROOT，看起来似是而非的感觉，那么GOPATH 有什么意义吗？&lt;/p&gt;
&lt;p&gt;这里可以把 GOPATH 简单理解成 Go 语言的工作目录，它的值是一个目录的路径，也可以是多个目录路径，每个目录都代表 Go 语言的一个工作区（workspace）。&lt;/p&gt;
&lt;p&gt;我们需要利于这些工作区，去放置 Go 语言的源码文件（source file），以及安装（install）后的归档文件（archive file，也就是以“.a”为扩展名的文件）和可执行文件（executable file）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这个GOPATH 其实很重要，为什么这么说呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为Go 语言项目在其&lt;u&gt;生命周期内的所有操作（编码、依赖管理、构建、测试、安装等）&lt;/u&gt;基本上都是围绕着 GOPATH 和工作区进行的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="go基础" scheme="https://dongxiem.github.io/categories/go%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="go" scheme="https://dongxiem.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发 - 多线程：线程间通信交替打印</title>
    <link href="https://dongxiem.github.io/2020/04/16/java-bing-fa-duo-xian-cheng-xian-cheng-jian-tong-xin-jiao-ti-da-yin/"/>
    <id>https://dongxiem.github.io/2020/04/16/java-bing-fa-duo-xian-cheng-xian-cheng-jian-tong-xin-jiao-ti-da-yin/</id>
    <published>2020-04-16T12:23:17.345Z</published>
    <updated>2020-08-21T12:34:36.378Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.前言&quot;&gt;&lt;/a&gt;1.前言&lt;/h1&gt;&lt;p&gt;这一部分，我通过一个经典的问题来引出几个线程间通信的方法，即：三个线程如何实现交替打印ABC？&lt;/p&gt;
&lt;h1 id=&quot;2-代码实现&quot;&gt;&lt;a href=&quot;#2-代码实现&quot; class=&quot;headerlink&quot; title=&quot;2.代码实现&quot;&gt;&lt;/a&gt;2.代码实现&lt;/h1&gt;&lt;h2 id=&quot;2-1-Synchronized&quot;&gt;&lt;a href=&quot;#2-1-Synchronized&quot; class=&quot;headerlink&quot; title=&quot;2.1 Synchronized&quot;&gt;&lt;/a&gt;2.1 Synchronized&lt;/h2&gt;&lt;p&gt;基本思路：使用同步块和wait、notify的方法控制三个线程的执行次序。具体方法如下：从大的方向上来讲，该问题为三线程间的同步唤醒操作，主要的目的就是&lt;code&gt;ThreadA-&amp;gt;ThreadB-&amp;gt;ThreadC-&amp;gt;ThreadA&lt;/code&gt;循环执行三个线程。为了控制线程执行的顺序，那么就必须要确定唤醒、等待的顺序，所以每一个线程必须同时持有两个对象锁，才能进行打印操作。一个对象锁是prev，就是前一个线程所对应的对象锁，其主要作用是保证当前线程一定是在前一个线程操作完成后（即前一个线程释放了其对应的对象锁）才开始执行。还有一个锁就是自身对象锁。主要的思想就是，为了控制执行的顺序，必须要先持有prev锁（也就前一个线程要释放其自身对象锁），然后当前线程再申请自己对象锁，两者兼备时打印。之后首先调用&lt;code&gt;self.notify()&lt;/code&gt;唤醒下一个等待线程（注意notify不会立即释放对象锁，只有等到同步块代码执行完毕后才会释放），再调用&lt;code&gt;prev.wait()&lt;/code&gt;立即释放prev对象锁，当前线程进入休眠，等待其他线程的notify操作再次唤醒。&lt;/p&gt;
&lt;p&gt;下面程序可以看到程序一共定义了a,b,c三个对象锁，分别对应A、B、C三个线程。A线程最先运行，A线程按顺序申请c,a对象锁，打印操作后按顺序释放a,c对象锁，并且通过notify操作唤醒线程B。线程B首先等待获取A锁，再申请B锁，后打印B，再释放B，A锁，唤醒C。线程C等待B锁，再申请C锁，后打印C，再释放C,B锁，唤醒A。看起来似乎没什么问题，但如果你仔细想一下，就会发现有问题，就是初始条件，三个线程必须按照A,B,C的顺序来启动，但是这种假设依赖于JVM中线程调度、执行的顺序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java多线程与并发" scheme="https://dongxiem.github.io/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java" scheme="https://dongxiem.github.io/tags/Java/"/>
    
      <category term="并发" scheme="https://dongxiem.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="AQS" scheme="https://dongxiem.github.io/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发 - CAS 分析</title>
    <link href="https://dongxiem.github.io/2020/04/16/java-bing-fa-cas-fen-xi/"/>
    <id>https://dongxiem.github.io/2020/04/16/java-bing-fa-cas-fen-xi/</id>
    <published>2020-04-16T04:14:14.000Z</published>
    <updated>2020-08-21T12:35:11.959Z</updated>
    
    <summary type="html">
    
      主要解释了一下什么是CAS，及CAS会遇到的一些问题，还有其解决方法。
    
    </summary>
    
    
      <category term="Java多线程与并发" scheme="https://dongxiem.github.io/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java" scheme="https://dongxiem.github.io/tags/Java/"/>
    
      <category term="并发" scheme="https://dongxiem.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发 - AQS：自定义同步工具</title>
    <link href="https://dongxiem.github.io/2020/04/14/java-bing-fa-aqs-zi-ding-yi-tong-bu-gong-ju/"/>
    <id>https://dongxiem.github.io/2020/04/14/java-bing-fa-aqs-zi-ding-yi-tong-bu-gong-ju/</id>
    <published>2020-04-14T06:13:45.000Z</published>
    <updated>2020-08-21T12:35:04.130Z</updated>
    
    <summary type="html">
    
      了解AQS之后，自己尝试根据AQS的框架写出一个同步工具。
    
    </summary>
    
    
      <category term="Java多线程与并发" scheme="https://dongxiem.github.io/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java" scheme="https://dongxiem.github.io/tags/Java/"/>
    
      <category term="并发" scheme="https://dongxiem.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发 - AQS：LockSupport阻塞唤醒线程</title>
    <link href="https://dongxiem.github.io/2020/04/11/java-bing-fa-aqs-locksupport-zu-sai-huan-xing-xian-cheng/"/>
    <id>https://dongxiem.github.io/2020/04/11/java-bing-fa-aqs-locksupport-zu-sai-huan-xing-xian-cheng/</id>
    <published>2020-04-11T09:59:56.974Z</published>
    <updated>2020-08-21T12:35:07.712Z</updated>
    
    <summary type="html">
    
      主要了解了一下LockSupport是什么，几个方法，及其源码的实现。
    
    </summary>
    
    
      <category term="Java多线程与并发" scheme="https://dongxiem.github.io/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java" scheme="https://dongxiem.github.io/tags/Java/"/>
    
      <category term="并发" scheme="https://dongxiem.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发 - 多线程：FutureTask源码分析</title>
    <link href="https://dongxiem.github.io/2020/04/10/java-bing-fa-duo-xian-cheng-futuretask-yuan-ma-fen-xi/"/>
    <id>https://dongxiem.github.io/2020/04/10/java-bing-fa-duo-xian-cheng-futuretask-yuan-ma-fen-xi/</id>
    <published>2020-04-10T11:29:28.949Z</published>
    <updated>2020-08-21T12:34:41.227Z</updated>
    
    <summary type="html">
    
      这篇文章主要分析了什么是FutureTask，还对其源码进行了分析。
    
    </summary>
    
    
      <category term="Java多线程与并发" scheme="https://dongxiem.github.io/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java" scheme="https://dongxiem.github.io/tags/Java/"/>
    
      <category term="并发" scheme="https://dongxiem.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发 - 多线程：线程池的使用</title>
    <link href="https://dongxiem.github.io/2020/04/08/java-bing-fa-duo-xian-cheng-xian-cheng-chi-de-shi-yong/"/>
    <id>https://dongxiem.github.io/2020/04/08/java-bing-fa-duo-xian-cheng-xian-cheng-chi-de-shi-yong/</id>
    <published>2020-04-08T11:40:29.117Z</published>
    <updated>2020-08-21T12:33:35.218Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-如何配置线程池&quot;&gt;&lt;a href=&quot;#1-如何配置线程池&quot; class=&quot;headerlink&quot; title=&quot;1 如何配置线程池&quot;&gt;&lt;/a&gt;1 如何配置线程池&lt;/h1&gt;&lt;p&gt;如果我们设置的线程池数量太小的话，如果同一时间有大量任务/请求需要处理，可能会导致大量的请求/任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务/请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。这样很明显是有问题的！ CPU 根本没有得到充分利用。&lt;/p&gt;
&lt;p&gt;但是，如果我们设置线程数量太大，大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。&lt;/p&gt;
&lt;p&gt;注：上下文切换的解释&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;上下文切换通常是计算密集型的&lt;/strong&gt;。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。&lt;/li&gt;
&lt;li&gt;Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要肯定的一点是：线程池肯定是不是越大越好。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java多线程与并发" scheme="https://dongxiem.github.io/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java" scheme="https://dongxiem.github.io/tags/Java/"/>
    
      <category term="并发" scheme="https://dongxiem.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="多线程" scheme="https://dongxiem.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发 - 多线程：线程创建的几种方式</title>
    <link href="https://dongxiem.github.io/2020/04/01/java-bing-fa-duo-xian-cheng-xian-cheng-chuang-jian-de-ji-chong-fang-shi/"/>
    <id>https://dongxiem.github.io/2020/04/01/java-bing-fa-duo-xian-cheng-xian-cheng-chuang-jian-de-ji-chong-fang-shi/</id>
    <published>2020-04-01T05:55:16.877Z</published>
    <updated>2020-08-21T12:34:23.615Z</updated>
    
    <summary type="html">
    
      主要讲述了两种实现线程（继承Thread类与实现Runnable接口）的方式，还提到了如何进行使用函数式编程进行实现，给出了一些相对应的Demo，可方便快速理解。然后我对Thread类进行了一个简单的源码分析，然后对比了submit和execute，最后还进行了一些相关的比较，更加清晰的进行各种方法之间的联系与差异。
    
    </summary>
    
    
      <category term="Java多线程与并发" scheme="https://dongxiem.github.io/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java" scheme="https://dongxiem.github.io/tags/Java/"/>
    
      <category term="并发" scheme="https://dongxiem.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发 - Synchronized 与其他一些锁机制的对比</title>
    <link href="https://dongxiem.github.io/2020/03/31/java-bing-fa-synchronized-yu-qi-ta-yi-xie-suo-ji-zhi-de-dui-bi/"/>
    <id>https://dongxiem.github.io/2020/03/31/java-bing-fa-synchronized-yu-qi-ta-yi-xie-suo-ji-zhi-de-dui-bi/</id>
    <published>2020-03-31T09:18:02.720Z</published>
    <updated>2020-08-21T12:35:42.864Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.前言&quot;&gt;&lt;/a&gt;1.前言&lt;/h1&gt;&lt;p&gt;我们前面已经 Synchronized 在JDK1.6 进行哪一些方面的优化，通过这些底层的优化之后Synchronized  变得好用了很多，那么它究竟和其他锁机制有什么差别？换种方式说，我在进行编程的过程中，究竟要如何进行选择？什么时候应该选择Synchronized？而什么时候不选用Synchronized而选用其他的锁机制。&lt;/p&gt;
&lt;p&gt;总感觉学习了Synchronized之后，对于其内部原理熟悉了，不知道有没有其他人跟我一样困惑，我究竟该何时进行使用它呢？在哪个场景下我该第一时间想到这货？我觉得进行选择还应该先进行对比，将和我们之前学习到的一些同步机制进行联系起来，有对比才有总结，尽量多进行比较，多点思考，才有更深入的理解与认识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java多线程与并发" scheme="https://dongxiem.github.io/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java" scheme="https://dongxiem.github.io/tags/Java/"/>
    
      <category term="并发" scheme="https://dongxiem.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发 - Synchronized 几种使用方式</title>
    <link href="https://dongxiem.github.io/2020/03/31/java-bing-fa-synchronized-ji-chong-shi-yong-fang-shi/"/>
    <id>https://dongxiem.github.io/2020/03/31/java-bing-fa-synchronized-ji-chong-shi-yong-fang-shi/</id>
    <published>2020-03-31T09:17:42.429Z</published>
    <updated>2020-08-21T12:35:30.768Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-概括&quot;&gt;&lt;a href=&quot;#1-概括&quot; class=&quot;headerlink&quot; title=&quot;1.概括&quot;&gt;&lt;/a&gt;1.概括&lt;/h1&gt;&lt;p&gt;Synchronized 可以有几种修饰方法，总体使用如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/31/HiZIwJm32rGoFPv.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java多线程与并发" scheme="https://dongxiem.github.io/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java" scheme="https://dongxiem.github.io/tags/Java/"/>
    
      <category term="并发" scheme="https://dongxiem.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发 - Synchronized 原理分析</title>
    <link href="https://dongxiem.github.io/2020/03/31/java-bing-fa-synchronized-yuan-li-fen-xi/"/>
    <id>https://dongxiem.github.io/2020/03/31/java-bing-fa-synchronized-yuan-li-fen-xi/</id>
    <published>2020-03-31T09:16:59.531Z</published>
    <updated>2020-08-21T12:35:48.544Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.概述&quot;&gt;&lt;/a&gt;1.概述&lt;/h1&gt;&lt;p&gt;JDK1.6 之后 Synchronized  的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。&lt;/p&gt;
&lt;p&gt;Java中的&lt;code&gt;synchronized&lt;/code&gt; 的偏向锁、轻量级锁、重量级锁三种形式，分别对应了锁只被一个线程持有、不同线程交替持有锁、多线程竞争锁三种情况。当条件不满足时，锁会按偏向锁-&amp;gt;轻量级锁-&amp;gt;重量级锁 的顺序升级。JVM种的锁也是能降级的，只不过条件很苛刻，可以相当于没有了，策略是为了提高获得锁和释放锁的效率。&lt;/p&gt;
&lt;p&gt;所以对Synchronized 的重点分析应该是其升级流程，以前是我觉得So easy，不就这几个状态升上去而已，不过在某天看了 &lt;a href=&quot;https://github.com/farmerjohngit/myblog/issues/12&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;死磕Synchronized底层实现&lt;/a&gt; 之后，发现我还是太嫩了，这才是真正的深入，也许对知识的求知就该如此不断的进行深入，对于Synchronized 还是有很多值得发现的知识，以下记录了学习到的一些笔记，大概对一整个锁的升级流程有了一些认识和了解。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;锁升级的过程可以具体看该图，大致的流程框架图很清晰（文末已注明出处）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/31/nCGAmlfKqzhjdv1.png&quot; alt=&quot;Synchronized锁升级流程图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java多线程与并发" scheme="https://dongxiem.github.io/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java" scheme="https://dongxiem.github.io/tags/Java/"/>
    
      <category term="并发" scheme="https://dongxiem.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发 - 多线程：深入线程池原理</title>
    <link href="https://dongxiem.github.io/2020/03/31/java-bing-fa-duo-xian-cheng-shen-ru-xian-cheng-chi-yuan-li/"/>
    <id>https://dongxiem.github.io/2020/03/31/java-bing-fa-duo-xian-cheng-shen-ru-xian-cheng-chi-yuan-li/</id>
    <published>2020-03-31T08:37:47.116Z</published>
    <updated>2020-08-21T12:33:14.836Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-线程池简介&quot;&gt;&lt;a href=&quot;#1-线程池简介&quot; class=&quot;headerlink&quot; title=&quot;1.线程池简介&quot;&gt;&lt;/a&gt;1.线程池简介&lt;/h1&gt;&lt;h2 id=&quot;1-1-线程池是什么？&quot;&gt;&lt;a href=&quot;#1-1-线程池是什么？&quot; class=&quot;headerlink&quot; title=&quot;1.1 线程池是什么？&quot;&gt;&lt;/a&gt;1.1 线程池是什么？&lt;/h2&gt;&lt;p&gt;线程池（Thread Pool）是一种基于池化思想管理线程的工具，经常出现在多线程服务器中，如MySQL。&lt;/p&gt;
&lt;p&gt;线程池可以简单看做是一组线程的集合，通过使用线程池，我们可以方便的复用线程，避免了频繁创建和销毁线程所带来的开销。在应用上，线程池可应用在后端相关服务中。比如 Web 服务器，数据库服务器等。以 Web 服务器为例，假如 Web 服务器会收到大量短时的 HTTP 请求，如果此时我们简单的为每个 HTTP 请求创建一个处理线程，那么服务器的资源将会很快被耗尽。当然我们也可以自己去管理并复用已创建的线程，以限制资源的消耗量，但这样会使用程序的逻辑变复杂。好在，幸运的是，我们不必那样做。在 JDK 1.5 中，官方已经提供了强大的线程池工具类。通过使用这些工具类，我们可以用低廉的代价使用多线程技术。&lt;/p&gt;
&lt;p&gt;线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。线程池维护多个线程，等待监督管理者分配可并发执行的任务。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java多线程与并发" scheme="https://dongxiem.github.io/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java" scheme="https://dongxiem.github.io/tags/Java/"/>
    
      <category term="并发" scheme="https://dongxiem.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发 - AQS：框架分析</title>
    <link href="https://dongxiem.github.io/2020/03/31/java-bing-fa-aqs-kuang-jia-fen-xi/"/>
    <id>https://dongxiem.github.io/2020/03/31/java-bing-fa-aqs-kuang-jia-fen-xi/</id>
    <published>2020-03-31T07:46:37.472Z</published>
    <updated>2020-08-21T12:34:59.454Z</updated>
    
    <summary type="html">
    
      AbstractQueuedSynchronizer 整个流程的分析，并深入了解了一下其源码，主要分为独占模式和共享模式。
    
    </summary>
    
    
      <category term="Java多线程与并发" scheme="https://dongxiem.github.io/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java" scheme="https://dongxiem.github.io/tags/Java/"/>
    
      <category term="并发" scheme="https://dongxiem.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="AQS" scheme="https://dongxiem.github.io/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发 - 锁相关：Condition接口分析</title>
    <link href="https://dongxiem.github.io/2020/03/31/java-bing-fa-suo-xiang-guan-condition-jie-kou-fen-xi/"/>
    <id>https://dongxiem.github.io/2020/03/31/java-bing-fa-suo-xiang-guan-condition-jie-kou-fen-xi/</id>
    <published>2020-03-31T07:46:37.472Z</published>
    <updated>2020-08-21T12:34:53.609Z</updated>
    
    <summary type="html">
    
      主要讲述了一些Condition接口的方法左右及源码分析，同时进行了一些比较分析
    
    </summary>
    
    
      <category term="Java多线程与并发" scheme="https://dongxiem.github.io/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java" scheme="https://dongxiem.github.io/tags/Java/"/>
    
      <category term="并发" scheme="https://dongxiem.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发 - 多线程：如何停止一个线程</title>
    <link href="https://dongxiem.github.io/2020/03/31/java-bing-fa-duo-xian-cheng-ru-he-ting-zhi-yi-ge-xian-cheng/"/>
    <id>https://dongxiem.github.io/2020/03/31/java-bing-fa-duo-xian-cheng-ru-he-ting-zhi-yi-ge-xian-cheng/</id>
    <published>2020-03-31T07:40:36.399Z</published>
    <updated>2020-08-21T12:33:02.907Z</updated>
    
    <summary type="html">
    
      总结了一些停止线程的方法及对比了两种判断是否中断方法(interrupted和isInterrupted)的区别，主要讲述了两种利用interrupt进行停止线程工作的方法（interrupt配合异常抛出及interrupt配合退出标志），接着讲述了sleep状态下停止线程会发生什么，最后讲述了stop这个方法为什么被摒弃。
    
    </summary>
    
    
      <category term="Java多线程与并发" scheme="https://dongxiem.github.io/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java" scheme="https://dongxiem.github.io/tags/Java/"/>
    
      <category term="并发" scheme="https://dongxiem.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java 集合框架 - HashMap 认识与理解</title>
    <link href="https://dongxiem.github.io/2020/03/31/java-ji-he-kuang-jia-hashmap-ren-shi-yu-li-jie/"/>
    <id>https://dongxiem.github.io/2020/03/31/java-ji-he-kuang-jia-hashmap-ren-shi-yu-li-jie/</id>
    <published>2020-03-31T07:29:58.483Z</published>
    <updated>2020-08-21T12:36:01.219Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.前言&quot;&gt;&lt;/a&gt;1.前言&lt;/h1&gt;&lt;p&gt;关于HashMap 其实还是有很多困惑的，学习了这么长时间，一边记录遇到的一些问题，一边整理笔记，如下所示。&lt;/p&gt;
&lt;h1 id=&quot;2-主要一些知识点&quot;&gt;&lt;a href=&quot;#2-主要一些知识点&quot; class=&quot;headerlink&quot; title=&quot;2.主要一些知识点&quot;&gt;&lt;/a&gt;2.主要一些知识点&lt;/h1&gt;&lt;h2 id=&quot;2-1-HashMap-底层结构的一些问题与解答&quot;&gt;&lt;a href=&quot;#2-1-HashMap-底层结构的一些问题与解答&quot; class=&quot;headerlink&quot; title=&quot;2.1 HashMap 底层结构的一些问题与解答&quot;&gt;&lt;/a&gt;2.1 HashMap 底层结构的一些问题与解答&lt;/h2&gt;&lt;p&gt;关于HashMap 的底层数据结构，我有以下这么几个疑问，当时也是查看书籍和百度谷歌了好一会儿，然后连带着寻找到其他的一些问题，如下。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;数组与链表相关&quot;&gt;&lt;a href=&quot;#数组与链表相关&quot; class=&quot;headerlink&quot; title=&quot;数组与链表相关&quot;&gt;&lt;/a&gt;数组与链表相关&lt;/h3&gt;&lt;p&gt;关于底层数据结构为什么采用 数组+链表 这么一种组合的几个问题：&lt;/p&gt;
&lt;h4 id=&quot;1-为什么用数组-链表？&quot;&gt;&lt;a href=&quot;#1-为什么用数组-链表？&quot; class=&quot;headerlink&quot; title=&quot;1.为什么用数组+链表？&quot;&gt;&lt;/a&gt;&lt;strong&gt;1.为什么用数组+链表？&lt;/strong&gt;&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;我认为数组是用来确定桶的位置，利用元素的key的hash值对数组长度取模得到.&lt;/li&gt;
&lt;li&gt;链表是用来解决hash冲突问题，当出现hash值一样的情形，就在数组上的对应位置形成一条链表。&lt;/li&gt;
&lt;li&gt;注：这里的hash值并不是指hashcode，而是将hashcode高低十六位异或过的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;2-那使用LinkedList代替数组结构可以么？&quot;&gt;&lt;a href=&quot;#2-那使用LinkedList代替数组结构可以么？&quot; class=&quot;headerlink&quot; title=&quot;2.那使用LinkedList代替数组结构可以么？&quot;&gt;&lt;/a&gt;&lt;strong&gt;2.那使用LinkedList代替数组结构可以么？&lt;/strong&gt;&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;这里的意思是，源码中是这样的：&lt;code&gt;Entry[] table = new Entry[capacity];&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;ps：Entry就是一个链表节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;那我用下面这样表示：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;List&amp;lt;Entry&amp;gt; table = new LinkedList&amp;lt;Entry&amp;gt;();&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;所以没毛病是可以使用LinkedList代替数组结构&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;3-那既然是可以的，为什么HashMap不用LinkedList，而选用数组&quot;&gt;&lt;a href=&quot;#3-那既然是可以的，为什么HashMap不用LinkedList，而选用数组&quot; class=&quot;headerlink&quot; title=&quot;3.那既然是可以的，为什么HashMap不用LinkedList，而选用数组?&quot;&gt;&lt;/a&gt;&lt;strong&gt;3.那既然是可以的，为什么HashMap不用LinkedList，而选用数组?&lt;/strong&gt;&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;因为用数组效率最高！在HashMap中，定位桶的位置是利用元素的key的哈希值对数组长度取模得到。此时，我们已得到桶的位置。显然数组的查找效率比LinkedList大。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;4-继续挖一下，那ArrayList，底层也是数组，查找也快啊，为什么不用ArrayList&quot;&gt;&lt;a href=&quot;#4-继续挖一下，那ArrayList，底层也是数组，查找也快啊，为什么不用ArrayList&quot; class=&quot;headerlink&quot; title=&quot;4.继续挖一下，那ArrayList，底层也是数组，查找也快啊，为什么不用ArrayList?&quot;&gt;&lt;/a&gt;&lt;strong&gt;4.继续挖一下，那ArrayList，底层也是数组，查找也快啊，为什么不用ArrayList?&lt;/strong&gt;&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;因为采用基本数组结构，扩容机制可以自己定义，HashMap中数组扩容刚好是2的次幂，在做取模运算的效率高。而ArrayList的扩容机制是1.5倍扩容。&lt;/li&gt;
&lt;li&gt;而为什么需要两倍扩容，现在此处存疑，在下面我会进行展开分析一下。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java集合" scheme="https://dongxiem.github.io/categories/Java%E9%9B%86%E5%90%88/"/>
    
    
      <category term="Java" scheme="https://dongxiem.github.io/tags/Java/"/>
    
      <category term="集合" scheme="https://dongxiem.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Java 集合框架 - HashMap 分析</title>
    <link href="https://dongxiem.github.io/2020/03/29/java-ji-he-kuang-jia-hashmap-fen-xi/"/>
    <id>https://dongxiem.github.io/2020/03/29/java-ji-he-kuang-jia-hashmap-fen-xi/</id>
    <published>2020-03-29T12:00:56.331Z</published>
    <updated>2020-08-21T12:35:51.177Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-HashMap实现原理&quot;&gt;&lt;a href=&quot;#1-HashMap实现原理&quot; class=&quot;headerlink&quot; title=&quot;1.HashMap实现原理&quot;&gt;&lt;/a&gt;1.HashMap实现原理&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;简述HashMap的工作原理：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HashMap是&lt;strong&gt;基于散列法（又称哈希法）的原理&lt;/strong&gt;，使用&lt;code&gt;put(key, value)&lt;/code&gt;存储对象到HashMap中，使用&lt;code&gt;get(key)&lt;/code&gt;从HashMap中获取对象。使用HashMap进行查询和修改的速度都很快，平均时间复杂度O(1)。HashMap非线程安全，如果需要考虑并发，则需要使用ConcurrentHashMap，且HashMap不保证存储元素的序列；&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java集合" scheme="https://dongxiem.github.io/categories/Java%E9%9B%86%E5%90%88/"/>
    
    
      <category term="Java" scheme="https://dongxiem.github.io/tags/Java/"/>
    
      <category term="集合" scheme="https://dongxiem.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>桃花岛杂货铺</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dongxiem.github.io/"/>
  <updated>2020-10-06T08:11:35.516Z</updated>
  <id>https://dongxiem.github.io/</id>
  
  <author>
    <name>Garmen Lee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>golang gin(1) - 整体框架分析</title>
    <link href="https://dongxiem.github.io/2020/08/12/golang-gin-1-zheng-ti-kuang-jia-fen-xi/"/>
    <id>https://dongxiem.github.io/2020/08/12/golang-gin-1-zheng-ti-kuang-jia-fen-xi/</id>
    <published>2020-08-12T12:41:25.000Z</published>
    <updated>2020-10-06T08:11:35.516Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-Gin-简明介绍&quot;&gt;&lt;a href=&quot;#1-Gin-简明介绍&quot; class=&quot;headerlink&quot; title=&quot;1.Gin 简明介绍&quot;&gt;&lt;/a&gt;1.Gin 简明介绍&lt;/h1&gt;&lt;p&gt;gin 是什么？官方给的解释为：Gin 是一个用 Go (Golang) 编写的 HTTP web 框架。 它是一个类似于 &lt;a href=&quot;https://github.com/go-martini/martini&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;martini&lt;/a&gt; 但拥有更好性能的 API 框架, 优于 &lt;a href=&quot;https://github.com/julienschmidt/httprouter&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;httprouter&lt;/a&gt;，速度提高了近 40 倍。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Gin is a HTTP web framework written in Go (Golang). It features a Martini-like API with much better performance – up to 40 times faster. If you need smashing performance, get yourself some Gin.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200922104010.jpeg&quot; alt=&quot;Gin&quot;&gt;&lt;/p&gt;
&lt;p&gt;gin 有一下的一些特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;快速：基于 Radix 树的路由，小内存占用。没有反射。可预测的 API 性能。&lt;/li&gt;
&lt;li&gt;支持中间件：传入的 HTTP 请求可以由一系列中间件和最终操作来处理。 例如：Logger，Authorization，GZIP，最终操作 DB。&lt;/li&gt;
&lt;li&gt;Crash 处理：Gin 可以 catch 一个发生在 HTTP 请求中的 panic 并 recover 它。这样，你的服务器将始终可用。例如，你可以向 Sentry 报告这个 panic！&lt;/li&gt;
&lt;li&gt;JSON 验证：Gin 可以解析并验证请求的 JSON，例如检查所需值的存在。&lt;/li&gt;
&lt;li&gt;路由组：更好地组织路由。是否需要授权，不同的 API 版本…… 此外，这些组可以无限制地嵌套而不会降低性能。&lt;/li&gt;
&lt;li&gt;错误管理：Gin 提供了一种方便的方法来收集 HTTP 请求期间发生的所有错误。最终，中间件可以将它们写入日志文件，数据库并通过网络发送。&lt;/li&gt;
&lt;li&gt;内置渲染：Gin 为 JSON，XML 和 HTML 渲染提供了易于使用的 API。&lt;/li&gt;
&lt;li&gt;可扩展性：新建一个中间件非常简单，去查看示例代码吧。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://dongxiem.github.io/categories/golang/"/>
    
    
      <category term="go" scheme="https://dongxiem.github.io/tags/go/"/>
    
      <category term="gin" scheme="https://dongxiem.github.io/tags/gin/"/>
    
  </entry>
  
  <entry>
    <title>golang 源码剖析 - Defer关键字</title>
    <link href="https://dongxiem.github.io/2020/07/08/golang-yuan-ma-pou-xi-defer-guan-jian-zi/"/>
    <id>https://dongxiem.github.io/2020/07/08/golang-yuan-ma-pou-xi-defer-guan-jian-zi/</id>
    <published>2020-07-08T13:23:51.000Z</published>
    <updated>2020-10-06T08:23:32.079Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot;
        
      
    
    </summary>
    
    
      <category term="golang" scheme="https://dongxiem.github.io/categories/golang/"/>
    
    
      <category term="go" scheme="https://dongxiem.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang 源码剖析 - Context上下文</title>
    <link href="https://dongxiem.github.io/2020/07/05/golang-yuan-ma-pou-xi-context-shang-xia-wen/"/>
    <id>https://dongxiem.github.io/2020/07/05/golang-yuan-ma-pou-xi-context-shang-xia-wen/</id>
    <published>2020-07-05T15:41:55.000Z</published>
    <updated>2020-10-06T08:18:17.758Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot;
        
      
    
    </summary>
    
    
      <category term="golang" scheme="https://dongxiem.github.io/categories/golang/"/>
    
    
      <category term="go" scheme="https://dongxiem.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang 源码剖析 - Select多路选择</title>
    <link href="https://dongxiem.github.io/2020/06/30/golang-yuan-ma-pou-xi-select-duo-lu-xuan-ze/"/>
    <id>https://dongxiem.github.io/2020/06/30/golang-yuan-ma-pou-xi-select-duo-lu-xuan-ze/</id>
    <published>2020-06-30T15:33:15.000Z</published>
    <updated>2020-10-06T08:16:20.989Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot;
        
      
    
    </summary>
    
    
      <category term="golang" scheme="https://dongxiem.github.io/categories/golang/"/>
    
    
      <category term="go" scheme="https://dongxiem.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang Sync包源码剖析(7) - sync.Cond</title>
    <link href="https://dongxiem.github.io/2020/06/22/golang-sync-bao-yuan-ma-pou-xi-7-sync.cond/"/>
    <id>https://dongxiem.github.io/2020/06/22/golang-sync-bao-yuan-ma-pou-xi-7-sync.cond/</id>
    <published>2020-06-22T05:13:25.000Z</published>
    <updated>2020-09-28T04:21:10.883Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot;
        
      
    
    </summary>
    
    
      <category term="golang" scheme="https://dongxiem.github.io/categories/golang/"/>
    
    
      <category term="go" scheme="https://dongxiem.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang Sync包源码剖析(6) - sync.Once</title>
    <link href="https://dongxiem.github.io/2020/06/19/golang-sync-bao-yuan-ma-pou-xi-6-sync.once/"/>
    <id>https://dongxiem.github.io/2020/06/19/golang-sync-bao-yuan-ma-pou-xi-6-sync.once/</id>
    <published>2020-06-19T12:32:35.000Z</published>
    <updated>2020-09-28T04:19:44.265Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot;
        
      
    
    </summary>
    
    
      <category term="golang" scheme="https://dongxiem.github.io/categories/golang/"/>
    
    
      <category term="go" scheme="https://dongxiem.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang Sync包源码剖析(5) - sync.Pool</title>
    <link href="https://dongxiem.github.io/2020/06/16/golang-sync-bao-yuan-ma-pou-xi-5-sync.pool/"/>
    <id>https://dongxiem.github.io/2020/06/16/golang-sync-bao-yuan-ma-pou-xi-5-sync.pool/</id>
    <published>2020-06-16T12:19:25.000Z</published>
    <updated>2020-09-28T04:19:31.935Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot;
        
      
    
    </summary>
    
    
      <category term="golang" scheme="https://dongxiem.github.io/categories/golang/"/>
    
    
      <category term="go" scheme="https://dongxiem.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang Sync包源码剖析(4) - sync.Map</title>
    <link href="https://dongxiem.github.io/2020/06/12/golang-sync-bao-yuan-ma-pou-xi-4-sync.map/"/>
    <id>https://dongxiem.github.io/2020/06/12/golang-sync-bao-yuan-ma-pou-xi-4-sync.map/</id>
    <published>2020-06-12T14:12:25.000Z</published>
    <updated>2020-09-27T14:02:54.080Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot;
        
      
    
    </summary>
    
    
      <category term="golang" scheme="https://dongxiem.github.io/categories/golang/"/>
    
    
      <category term="go" scheme="https://dongxiem.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang Sync包源码剖析(3) - sync.WaitGroup</title>
    <link href="https://dongxiem.github.io/2020/06/09/golang-sync-bao-yuan-ma-pou-xi-3-sync.waitgroup/"/>
    <id>https://dongxiem.github.io/2020/06/09/golang-sync-bao-yuan-ma-pou-xi-3-sync.waitgroup/</id>
    <published>2020-06-09T04:25:21.000Z</published>
    <updated>2020-10-06T07:35:24.578Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-sync-WaitGroup-介绍&quot;&gt;&lt;a href=&quot;#1-sync-WaitGroup-介绍&quot; class=&quot;headerlink&quot; title=&quot;1.sync.WaitGroup 介绍&quot;&gt;&lt;/a&gt;1.sync.WaitGroup 介绍&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://sourcegraph.com/github.com/golang/go@master/-/blob/src/sync/waitgroup.go#L21:2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sync.WaitGroup&lt;/a&gt; 按照官方注释给的解释，它可以等待一组 Goroutine 集合的结束，主 &lt;code&gt;goroutine&lt;/code&gt; 通过调用 &lt;code&gt;Add()&lt;/code&gt; 函数来设置一定数量进行等待的 &lt;code&gt;goroutines&lt;/code&gt; ，然后其余的一些 &lt;code&gt;goroutines&lt;/code&gt; 则进行各自的运行结束之后再调用 &lt;code&gt;Done()&lt;/code&gt;，这样一来，等待的主 &lt;code&gt;goroutine&lt;/code&gt; 会阻塞知道其余所有 &lt;code&gt;goroutines&lt;/code&gt;都结束。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A WaitGroup waits for a collection of goroutines to finish.The main goroutine calls Add to set the number of goroutines to wait for. Then each of the goroutines runs and calls Done when finished. At the same time, Wait can be used to block until all goroutines have finished.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://dongxiem.github.io/categories/golang/"/>
    
    
      <category term="go" scheme="https://dongxiem.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang Sync包源码剖析(2) - sync.RWMutex</title>
    <link href="https://dongxiem.github.io/2020/06/07/golang-sync-bao-yuan-ma-pou-xi-2-sync.rwmutex/"/>
    <id>https://dongxiem.github.io/2020/06/07/golang-sync-bao-yuan-ma-pou-xi-2-sync.rwmutex/</id>
    <published>2020-06-07T13:22:25.000Z</published>
    <updated>2020-10-05T12:37:57.460Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-sync-RWMutex-介绍&quot;&gt;&lt;a href=&quot;#1-sync-RWMutex-介绍&quot; class=&quot;headerlink&quot; title=&quot;1.sync.RWMutex 介绍&quot;&gt;&lt;/a&gt;1.sync.RWMutex 介绍&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://sourcegraph.com/github.com/golang/go@master/-/blob/src/sync/rwmutex.go#L5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Sync.RWMutex&lt;/a&gt; 官方给出的定义是读/写互斥锁，锁可以由任意数量的读者或单个写者持有。 &lt;code&gt;RWMutex&lt;/code&gt;的零值是未锁定的互斥锁。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A RWMutex is a reader/writer mutual exclusion lock. The lock can be held by an arbitrary number of readers or a single writer. The zero value for a RWMutex is an unlocked mutex.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其包含了四种方法，如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(rw *RWMutex)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Lock&lt;/span&gt;         // 提供写锁加锁操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(rw *RWMutex)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;RLock&lt;/span&gt;        // 提供读锁加锁操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(rw *RWMutex)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;RUnlock&lt;/span&gt;      // 提供读锁解锁操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(rw *RWMutex)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Unlock&lt;/span&gt;       // 提供写锁解锁操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;这四个方法的源码解析在下面可以深入理解，可以大概了解到在 &lt;code&gt;RWMutex&lt;/code&gt; 读操作可并发重入，而写操作是互斥的，读写锁通常用互斥锁、条件变量、信号量实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://dongxiem.github.io/categories/golang/"/>
    
    
      <category term="go" scheme="https://dongxiem.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang Sync包源码剖析(1) - sync.Mutex</title>
    <link href="https://dongxiem.github.io/2020/06/05/golang-sync-bao-yuan-ma-pou-xi-1-sync.mutex/"/>
    <id>https://dongxiem.github.io/2020/06/05/golang-sync-bao-yuan-ma-pou-xi-1-sync.mutex/</id>
    <published>2020-06-05T14:12:25.000Z</published>
    <updated>2020-10-06T07:48:00.238Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-Sync包-简明介绍&quot;&gt;&lt;a href=&quot;#1-Sync包-简明介绍&quot; class=&quot;headerlink&quot; title=&quot;1.Sync包 简明介绍&quot;&gt;&lt;/a&gt;1.Sync包 简明介绍&lt;/h1&gt;&lt;p&gt;&lt;code&gt;golang&lt;/code&gt; 语言有着天生适合高并发的特性，作为原生支持用户态进程（&lt;code&gt;Goroutine&lt;/code&gt;）的语言，当涉及到并发编程，多线程编程时候，则离不开锁相关的概念了，于是编写 &lt;code&gt;golang&lt;/code&gt; 源码的大叔们就给了&lt;a href=&quot;https://sourcegraph.com/github.com/golang/go@master/-/tree/src/sync&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;src/sync&lt;/a&gt; 这么个包，通过浏览源码可以知道&lt;a href=&quot;https://sourcegraph.com/github.com/golang/go@master/-/tree/src/sync&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;src/sync&lt;/a&gt;包中提供了用于同步的一些基本原语，可以说这是一个很重要的的包了，如果掌握这个包，在编写代码的工程中肯定能够大有帮助，这个包大体上有：&lt;a href=&quot;https://sourcegraph.com/github.com/golang/go@master/-/blob/src/sync/mutex.go#L11&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sync.Mutex&lt;/a&gt;、&lt;a href=&quot;https://sourcegraph.com/github.com/golang/go@master/-/blob/src/sync/rwmutex.go#L7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sync.RWMutex&lt;/a&gt;、&lt;a href=&quot;https://sourcegraph.com/github.com/golang/go@master/-/blob/src/sync/waitgroup.go#L7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sync.WaitGroup&lt;/a&gt;、&lt;a href=&quot;https://sourcegraph.com/github.com/golang/go@master/-/blob/src/sync/map.go#L7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sync.Map&lt;/a&gt;、&lt;a href=&quot;https://sourcegraph.com/github.com/golang/go@master/-/blob/src/sync/pool.go#L44&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sync.Pool&lt;/a&gt;、&lt;a href=&quot;https://sourcegraph.com/github.com/golang/go@master/-/blob/src/sync/once.go#L7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sync.Once&lt;/a&gt;、&lt;a href=&quot;https://sourcegraph.com/github.com/golang/go@master/-/blob/src/sync/cond.go#L5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sync.Cond&lt;/a&gt;，也可以看一下官方给的sync包的一些方法解释： &lt;a href=&quot;https://golang.org/pkg/sync/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;sync&lt;/code&gt;&lt;/a&gt; ，同时为了节省一下 Clone 源码时间，或者只想简单回顾一下源码，这里给了快捷的入口：&lt;a href=&quot;https://sourcegraph.com/github.com/golang/go@master/-/tree/src/sync&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;src/sync&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在并发编程中，同步原语或者锁，他们的主要作用是保证多个线程或者多个&lt;code&gt;goroutine&lt;/code&gt;在访问同一片内存时不会出现混乱的问题，这个是一个非常重要的内容，很多人在编写代码的时候常常没有注重对这些并发访问的内容进行关注，导致出现事故也不清楚是什么原因，而&lt;a href=&quot;https://golang.org/pkg/sync/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;sync&lt;/code&gt;&lt;/a&gt; 包中所有的结构都适用于&lt;code&gt;goroutine&lt;/code&gt;并发执行的情况，需要好好掌握。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="go" scheme="https://dongxiem.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang 基础 - 关于使用Type定义类型的几个问题</title>
    <link href="https://dongxiem.github.io/2020/06/04/golang-ji-chu-guan-yu-shi-yong-type-ding-yi-lei-xing-de-ji-ge-wen-ti/"/>
    <id>https://dongxiem.github.io/2020/06/04/golang-ji-chu-guan-yu-shi-yong-type-ding-yi-lei-xing-de-ji-ge-wen-ti/</id>
    <published>2020-06-04T03:11:04.000Z</published>
    <updated>2020-10-06T08:05:16.475Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;从一道题目开始入手Type的一些具体知识，可以想想打印结果是什么？&lt;/p&gt;
&lt;p&gt;这里涉及到的是一些golang语言中的Type的一些基础知识，不要再犯迷糊了，好好地加深一下认识~&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; main&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;fmt&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 1--&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; T &lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt;{}&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 2--&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; X &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 3--&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; Y = &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; t T = &lt;span class=&quot;string&quot;&gt;&quot;abc&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; x X = &lt;span class=&quot;string&quot;&gt;&quot;abc&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; y Y = &lt;span class=&quot;string&quot;&gt;&quot;abc&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fmt.Println(t == x)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fmt.Println(t == &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;(x))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fmt.Println(t == y)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fmt.Println(t == &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;(y))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://dongxiem.github.io/categories/golang/"/>
    
    
      <category term="go" scheme="https://dongxiem.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang 源码剖析 - Channel的底层原理</title>
    <link href="https://dongxiem.github.io/2020/06/02/golang-yuan-ma-pou-xi-channel-de-di-ceng-yuan-li/"/>
    <id>https://dongxiem.github.io/2020/06/02/golang-yuan-ma-pou-xi-channel-de-di-ceng-yuan-li/</id>
    <published>2020-06-02T14:41:25.000Z</published>
    <updated>2020-10-06T08:22:52.000Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot;
        
      
    
    </summary>
    
    
      <category term="golang" scheme="https://dongxiem.github.io/categories/golang/"/>
    
    
      <category term="go" scheme="https://dongxiem.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang 并发 - Channel的一些实现</title>
    <link href="https://dongxiem.github.io/2020/05/29/golang-bing-fa-channel-de-yi-xie-shi-xian/"/>
    <id>https://dongxiem.github.io/2020/05/29/golang-bing-fa-channel-de-yi-xie-shi-xian/</id>
    <published>2020-05-29T08:21:14.000Z</published>
    <updated>2020-09-28T03:31:14.218Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-使用无缓存Channel进行goroutine通信&quot;&gt;&lt;a href=&quot;#1-使用无缓存Channel进行goroutine通信&quot; class=&quot;headerlink&quot; title=&quot;1.使用无缓存Channel进行goroutine通信&quot;&gt;&lt;/a&gt;1.使用无缓存Channel进行goroutine通信&lt;/h1&gt;&lt;p&gt;在前面的关于Channel的一些认识当中，我们了解基于无缓存Channels的发送和接收操作将导致两个goroutine做一次同步操作，故无缓存Channels有时候也被称为同步Channels，那么我们就可以使用无缓存的Channel进行简单的goroutine通信了，代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; main&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;fmt&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;time&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// make一个无缓存channel&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ch := &lt;span class=&quot;built_in&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        fmt.Println(&lt;span class=&quot;string&quot;&gt;&quot;三秒之后开始启动！&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 等待三秒&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        time.Sleep(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; * time.Second)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ch &amp;lt;- &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// 信号发送&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    }()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;- ch &lt;span class=&quot;comment&quot;&gt;// 信号接收&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;close&lt;/span&gt;(ch) &lt;span class=&quot;comment&quot;&gt;// 关闭通道&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fmt.Println(&lt;span class=&quot;string&quot;&gt;&quot;收到通知！&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://dongxiem.github.io/categories/golang/"/>
    
    
      <category term="go" scheme="https://dongxiem.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang 并发 - Channel的深入了解</title>
    <link href="https://dongxiem.github.io/2020/05/25/golang-bing-fa-channel-de-shen-ru-liao-jie/"/>
    <id>https://dongxiem.github.io/2020/05/25/golang-bing-fa-channel-de-shen-ru-liao-jie/</id>
    <published>2020-05-25T03:41:15.000Z</published>
    <updated>2020-09-28T03:32:28.328Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-Channels是什么？&quot;&gt;&lt;a href=&quot;#1-Channels是什么？&quot; class=&quot;headerlink&quot; title=&quot;1.Channels是什么？&quot;&gt;&lt;/a&gt;1.Channels是什么？&lt;/h1&gt;&lt;p&gt;这里又可以搬出知乎名言了，在认识一件事物之前，先问问是什么，再回答为什么！直接来说，一个Channel 是一个通信机制，它&lt;strong&gt;可以让一个Goroutine 通过它给另一个Goroutine 发送值信息&lt;/strong&gt;。每个Channel 都有一个特殊的类型，也就是Channels可发送数据的类型（例如：一个可以发送int类型数据的Channel 一般写为chan int）。&lt;/p&gt;
&lt;p&gt;在我们常见的一些语言中，多个线程传递数据的方式一般都是共享内存，&lt;u&gt;为了解决线程冲突的问题，我们需要限制同一时间能够读写这些变量的线程数量&lt;/u&gt;。而Golang 语言提供了一种不同与使用使用共享内存加互斥锁也能进行通信的并发模型，也就是&lt;strong&gt;通信顺序进程（Communicating sequential processes，CSP）&lt;/strong&gt;。其中Goroutine 和 Channel 分别对应 CSP 中的实体和传递信息的媒介，Go 语言中的 Goroutine 会通过 Channel 传递数据。这也是Golang一直提倡的&lt;strong&gt;不要通过共享内存的方式进行通信，而是应该通过通信的方式共享内存&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;目前的 Channel 收发操作均遵循了先入先出（FIFO）的设计，而且&lt;strong&gt;带缓存区和不带缓存区的 Channel 都会遵循先入先出对数据进行接收和发送&lt;/strong&gt;（关于带缓存区与不带缓存区在下面会提及），具体规则如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先从 Channel 读取数据的 Goroutine 会先接收到数据； &lt;/li&gt;
&lt;li&gt;先向 Channel 发送数据的 Goroutine 会得到先发送数据的权利；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过源码查看我们可知，Channel 在运行时使用 &lt;a href=&quot;https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L32&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;runtime.hchan&lt;/a&gt; 结构体进行表示，而这玩意最后包含这一个互斥锁用于保护成员变量，所以从某种程度上说，Channel 是一个&lt;u&gt;用于同步和通信的有锁队列&lt;/u&gt;。具体数据结构如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; hchan &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    qcount   &lt;span class=&quot;keyword&quot;&gt;uint&lt;/span&gt;           &lt;span class=&quot;comment&quot;&gt;// total data in the queue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dataqsiz &lt;span class=&quot;keyword&quot;&gt;uint&lt;/span&gt;           &lt;span class=&quot;comment&quot;&gt;// size of the circular queue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    buf      unsafe.Pointer &lt;span class=&quot;comment&quot;&gt;// points to an array of dataqsiz elements&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    elemsize &lt;span class=&quot;keyword&quot;&gt;uint16&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    closed   &lt;span class=&quot;keyword&quot;&gt;uint32&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    elemtype *_type &lt;span class=&quot;comment&quot;&gt;// element type&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sendx    &lt;span class=&quot;keyword&quot;&gt;uint&lt;/span&gt;   &lt;span class=&quot;comment&quot;&gt;// send index&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    recvx    &lt;span class=&quot;keyword&quot;&gt;uint&lt;/span&gt;   &lt;span class=&quot;comment&quot;&gt;// receive index&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    recvq    waitq  &lt;span class=&quot;comment&quot;&gt;// list of recv waiters&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sendq    waitq  &lt;span class=&quot;comment&quot;&gt;// list of send waiters&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// lock protects all fields in hchan, as well as several&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// fields in sudogs blocked on this channel.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Do not change another G&#39;s status while holding this lock&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// (in particular, do not ready a G), as this can deadlock&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// with stack shrinking.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    lock mutex&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://dongxiem.github.io/categories/golang/"/>
    
    
      <category term="go" scheme="https://dongxiem.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang 源码剖析 - Map映射</title>
    <link href="https://dongxiem.github.io/2020/05/18/golang-yuan-ma-pou-xi-map-ying-she/"/>
    <id>https://dongxiem.github.io/2020/05/18/golang-yuan-ma-pou-xi-map-ying-she/</id>
    <published>2020-05-18T13:31:25.000Z</published>
    <updated>2020-10-06T08:07:00.683Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot;
        
      
    
    </summary>
    
    
      <category term="golang" scheme="https://dongxiem.github.io/categories/golang/"/>
    
    
      <category term="go" scheme="https://dongxiem.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang 源码剖析 - Slice切片</title>
    <link href="https://dongxiem.github.io/2020/05/12/golang-yuan-ma-pou-xi-slice-qie-pian/"/>
    <id>https://dongxiem.github.io/2020/05/12/golang-yuan-ma-pou-xi-slice-qie-pian/</id>
    <published>2020-05-12T13:31:25.000Z</published>
    <updated>2020-10-06T08:07:47.363Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot;
        
      
    
    </summary>
    
    
      <category term="golang" scheme="https://dongxiem.github.io/categories/golang/"/>
    
    
      <category term="go" scheme="https://dongxiem.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang 基础 - go的命令源码文件</title>
    <link href="https://dongxiem.github.io/2020/05/08/golang-ji-chu-go-de-ming-ling-yuan-ma-wen-jian/"/>
    <id>https://dongxiem.github.io/2020/05/08/golang-ji-chu-go-de-ming-ling-yuan-ma-wen-jian/</id>
    <published>2020-05-08T07:48:25.000Z</published>
    <updated>2020-10-06T08:06:22.594Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-命令源码文件&quot;&gt;&lt;a href=&quot;#1-命令源码文件&quot; class=&quot;headerlink&quot; title=&quot;1.命令源码文件&quot;&gt;&lt;/a&gt;1.命令源码文件&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;命令源码文件是程序的运行入口，是每个可独立运行的程序必须拥有的&lt;/strong&gt;。我们可以通过构建或安装，生成与其对应的可执行文件，后者一般会与该命令源码文件的直接父目录同名。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果一个源码文件声明属于main包，并且包含一个无参数声明且无结果声明的main函数，那么它就是命令源码文件&lt;/strong&gt;。 就像下面这段代码：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; main&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;fmt&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fmt.Println(&lt;span class=&quot;string&quot;&gt;&quot;Hello, world!&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这其实就是就简单的可以运行go的一个文件了，刚开始搭建的时候我也是使用这么一段测试代码，随便创建了一个文件之后，然后敲上这么一段代码之后发现控制台可以打印出来“Hello World!”，瞬间感觉就学会了这门语言了，可是事情并没有那么简单，有多难？很难很难。&lt;/p&gt;
&lt;p&gt;但是这里让我挺困惑的地方就是，&lt;strong&gt;这&lt;code&gt;func main()&lt;/code&gt;，没有接收参数入口啊？？？&lt;/strong&gt;难道我就只能进行打印了？这不科学，无论在C/C++，还是Java中，main方法都不是这么写的，那么问题就来了，如果进行接收参数呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://dongxiem.github.io/categories/golang/"/>
    
    
      <category term="go" scheme="https://dongxiem.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang 基础 - go的环境变量</title>
    <link href="https://dongxiem.github.io/2020/05/08/golang-ji-chu-go-de-huan-jing-bian-liang/"/>
    <id>https://dongxiem.github.io/2020/05/08/golang-ji-chu-go-de-huan-jing-bian-liang/</id>
    <published>2020-05-08T04:11:25.000Z</published>
    <updated>2020-10-06T08:06:25.236Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-三个环境变量&quot;&gt;&lt;a href=&quot;#1-三个环境变量&quot; class=&quot;headerlink&quot; title=&quot;1.三个环境变量&quot;&gt;&lt;/a&gt;1.三个环境变量&lt;/h1&gt;&lt;p&gt;刚接触go的时候很头疼，一下子需要我配置三个环境变量，这三个环境变量看起来很让人头疼，感觉起来三个环境变量的意思大致，区分度不高，这三个环境变量也就是 &lt;code&gt;GOROOT&lt;/code&gt;、&lt;code&gt;GOPATH&lt;/code&gt; 和 &lt;code&gt;GOBIN&lt;/code&gt;。这里简单介绍一下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GOROOT：Go 语言安装根目录的路径，也就是 GO 语言的安装路径。&lt;/li&gt;
&lt;li&gt;GOPATH：若干工作区目录的路径。是我们自己定义的工作空间。&lt;/li&gt;
&lt;li&gt;GOBIN：GO 程序生成的可执行文件（executable file）的路径。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中最让人头疼的就是这个GOROOT，看起来似是而非的感觉，那么GOPATH 有什么意义吗？&lt;/p&gt;
&lt;p&gt;这里可以把 GOPATH 简单理解成 Go 语言的工作目录，它的值是一个目录的路径，也可以是多个目录路径，每个目录都代表 Go 语言的一个工作区（workspace）。&lt;/p&gt;
&lt;p&gt;我们需要利于这些工作区，去放置 Go 语言的源码文件（source file），以及安装（install）后的归档文件（archive file，也就是以“.a”为扩展名的文件）和可执行文件（executable file）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这个GOPATH 其实很重要，为什么这么说呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为Go 语言项目在其&lt;u&gt;生命周期内的所有操作（编码、依赖管理、构建、测试、安装等）&lt;/u&gt;基本上都是围绕着 GOPATH 和工作区进行的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://dongxiem.github.io/categories/golang/"/>
    
    
      <category term="go" scheme="https://dongxiem.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发 - 多线程：FutureTask源码分析</title>
    <link href="https://dongxiem.github.io/2020/04/29/java-bing-fa-duo-xian-cheng-futuretask-yuan-ma-fen-xi/"/>
    <id>https://dongxiem.github.io/2020/04/29/java-bing-fa-duo-xian-cheng-futuretask-yuan-ma-fen-xi/</id>
    <published>2020-04-29T11:18:45.000Z</published>
    <updated>2020-10-20T13:35:37.268Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-什么是FutureTask？&quot;&gt;&lt;a href=&quot;#1-什么是FutureTask？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是FutureTask？&quot;&gt;&lt;/a&gt;1. 什么是FutureTask？&lt;/h1&gt;&lt;p&gt;前面的Blog介绍了&lt;u&gt;&lt;code&gt;Future&lt;/code&gt;接口。这个接口有一个实现类叫&lt;code&gt;FutureTask&lt;/code&gt;&lt;/u&gt;。FutureTask类有什么用？为什么要有一个FutureTask类？前面说到了Future只是一个接口，而它里面的&lt;code&gt;cancel&lt;/code&gt;，&lt;code&gt;get&lt;/code&gt;，&lt;code&gt;isDone&lt;/code&gt;等方法要自己实现起来都是&lt;strong&gt;非常复杂&lt;/strong&gt;的。所以JDK提供了一个&lt;code&gt;FutureTask&lt;/code&gt;类来供我们使用。&lt;/p&gt;
&lt;p&gt;FutureTask是Future的具体实现，且实现了Runnable接口，即FutureTask满足了Task的行为，是一个可以被用来执行的Future。FutureTask是JUC提供的线程池实现用到的任务基本单元，&lt;u&gt;线程池主要接收两种对象：一个是Runnable任务，一种是Callable任务&lt;/u&gt;。按照ExecutorService接口定义的行为，可以将Runnable或Callable任务提交到线程池执行，而&lt;u&gt;被提交的Runnable或Callable任务都会被包装成FutureTask&lt;/u&gt;，由线程池的工作线程去执行。&lt;/p&gt;
&lt;p&gt;还有的就是前面的文章中所讲的FutureTask 为什么可以使用Executor 也可以使用线程直接执行？因为FutureTask是实现的&lt;code&gt;RunnableFuture&lt;/code&gt;接口的，而&lt;code&gt;RunnableFuture&lt;/code&gt;接口同时继承了&lt;code&gt;Runnable&lt;/code&gt;接口和&lt;code&gt;Future&lt;/code&gt;接口。因此，FutureTask可以交给Executor执行，也可以由调用线程直接执行（&lt;code&gt;FutureTask.run()&lt;/code&gt;）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java多线程与并发" scheme="https://dongxiem.github.io/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java" scheme="https://dongxiem.github.io/tags/Java/"/>
    
      <category term="并发" scheme="https://dongxiem.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
</feed>

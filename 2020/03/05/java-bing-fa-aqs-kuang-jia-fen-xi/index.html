<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/garmen.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/garmen.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/garmen.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dongxiem.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1.介绍AQSAbstractQueuedSynchronizer （抽象队列同步器，以下简称 AQS）出现在 JDK 1.5 中，AQS 这个东西在Java的并发中是很重要的一部分，因为他是很多同步器的基础框架，比如 ReentrantLock、CountDownLatch 和 Semaphore 等等都是基于 AQS 实现的。基于AQS来构建同步器可以带来很多好处。它不仅能够极大地减少实现工作">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 并发 - AQS：框架分析">
<meta property="og:url" content="https://dongxiem.github.io/2020/03/05/java-bing-fa-aqs-kuang-jia-fen-xi/index.html">
<meta property="og:site_name" content="桃花岛杂货铺">
<meta property="og:description" content="1.介绍AQSAbstractQueuedSynchronizer （抽象队列同步器，以下简称 AQS）出现在 JDK 1.5 中，AQS 这个东西在Java的并发中是很重要的一部分，因为他是很多同步器的基础框架，比如 ReentrantLock、CountDownLatch 和 Semaphore 等等都是基于 AQS 实现的。基于AQS来构建同步器可以带来很多好处。它不仅能够极大地减少实现工作">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/04/12/W2c1Kex85fz3Z6V.png">
<meta property="og:image" content="https://i.loli.net/2020/04/11/1k73AyCUJz9lVTd.png">
<meta property="og:image" content="https://i.loli.net/2020/04/11/9WIVEU64vpXCcP7.png">
<meta property="og:image" content="https://i.loli.net/2020/04/12/cRFCu2bP7m4a5Yt.png">
<meta property="og:image" content="https://i.loli.net/2020/04/12/qSL31JfmY86jkCF.png">
<meta property="og:image" content="https://i.loli.net/2020/04/12/xJrFBz24lspPAIw.png">
<meta property="og:image" content="https://i.loli.net/2020/04/11/TSpwJ46vCqWVF9l.png">
<meta property="og:image" content="https://i.loli.net/2020/04/12/2P9voOH3txybzYM.png">
<meta property="og:image" content="https://i.loli.net/2020/04/12/nexW1CDvzYcRPAh.png">
<meta property="og:image" content="https://i.loli.net/2020/04/12/v6EI48NwXt9Hsx3.png">
<meta property="og:image" content="https://i.loli.net/2020/04/11/LKxausrV8qbcQm6.png">
<meta property="article:published_time" content="2020-03-05T03:12:45.000Z">
<meta property="article:modified_time" content="2020-09-27T13:37:48.620Z">
<meta property="article:author" content="Garmen Lee">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="并发">
<meta property="article:tag" content="AQS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/04/12/W2c1Kex85fz3Z6V.png">

<link rel="canonical" href="https://dongxiem.github.io/2020/03/05/java-bing-fa-aqs-kuang-jia-fen-xi/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java 并发 - AQS：框架分析 | 桃花岛杂货铺</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="桃花岛杂货铺" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">桃花岛杂货铺</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dongxiem.github.io/2020/03/05/java-bing-fa-aqs-kuang-jia-fen-xi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Garmen Lee">
      <meta itemprop="description" content="杂货铺售卖知识 诸位自取">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="桃花岛杂货铺">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java 并发 - AQS：框架分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-05 11:12:45" itemprop="dateCreated datePublished" datetime="2020-03-05T11:12:45+08:00">2020-03-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-27 21:37:48" itemprop="dateModified" datetime="2020-09-27T21:37:48+08:00">2020-09-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">Java多线程与并发</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>28k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>25 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="1-介绍AQS"><a href="#1-介绍AQS" class="headerlink" title="1.介绍AQS"></a>1.介绍AQS</h1><p>AbstractQueuedSynchronizer （抽象队列同步器，以下简称 AQS）出现在 JDK 1.5 中，AQS 这个东西在Java的并发中是很重要的一部分，因为他是很多同步器的基础框架，比如 ReentrantLock、CountDownLatch 和 Semaphore 等等都是基于 AQS 实现的。基于AQS来构建同步器可以带来很多好处。它不仅能够极大地减少实现工作，而且也不必处理在多个位置上发生的竞争问题。 </p>
<p>在基于AQS构建的同步器中，<u>只能在一个时刻发生阻塞，从而降低上下文切换的开销，提高了吞吐量</u>。同时在设计AQS时充分考虑了可伸缩行，因此J.U.C中所有基于AQS构建的同步器均可以获得这个优势。 </p>
<p>AQS的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态。</p>
<p>AQS使用一个int类型的成员变量state来表示同步状态，<u>当state&gt;0时表示已经获取了锁，当state = 0时表示释放了锁</u>。它提供了三个方法（<code>getState()</code>、<code>setState(int newState)</code>、<code>compareAndSetState(int expect,int update)</code>）来对同步状态state进行操作，当然AQS可以确保对state的操作是安全的。</p>
<p>AQS通过内置的<strong>FIFO同步队列</strong>（这个会重点分析一下）来完成资源获取线程的排队工作，如果当前线程获取同步状态失败（锁）时，AQS则会将当前线程以及等待状态等信息构造成一个节点（Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，则会把节点中的线程唤醒，使其再次尝试获取同步状态。 </p>
<p>一句话：AQS使用一个Volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值的修改。</p>
<a id="more"></a>

<p>这里列出了AQS主要提供的一些方法，方便快速定位：</p>
<ul>
<li><code>getState()</code>：返回同步状态的当前值；</li>
<li><code>setState(int newState)</code>：设置当前同步状态；</li>
<li><code>compareAndSetState(int expect, int update)</code>：使用CAS设置当前状态，该方法能够保证状态设置的原子性；</li>
<li><code>tryAcquire(int arg)</code>：独占式获取同步状态，获取同步状态成功后，其他线程需要等待该线程释放同步状态才能获取同步状态；</li>
<li><code>tryRelease(int arg)</code>：独占式释放同步状态；</li>
<li><code>tryAcquireShared(int arg)</code>：共享式获取同步状态，返回值大于等于0则表示获取成功，否则获取失败；</li>
<li><code>tryReleaseShared(int arg)</code>：共享式释放同步状态；</li>
<li><code>isHeldExclusively()</code>：当前同步器是否在独占式模式下被线程占用，一般该方法表示是否被当前线程所独占；</li>
<li><code>acquire(int arg)</code>：独占式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回，否则，将会进入同步队列等待，该方法将会调用可重写的tryAcquire(int arg)方法；</li>
<li><code>acquireInterruptibly(int arg)</code>：与acquire(int arg)相同，但是该方法响应中断，当前线程为获取到同步状态而进入到同步队列中，如果当前线程被中断，则该方法会抛出InterruptedException异常并返回；</li>
<li><code>tryAcquireNanos(int arg,long nanos)</code>：超时获取同步状态，如果当前线程在nanos时间内没有获取到同步状态，那么将会返回false，已经获取则返回true；</li>
<li><code>acquireShared(int arg)</code>：共享式获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，与独占式的主要区别是在同一时刻可以有多个线程获取到同步状态；</li>
<li><code>acquireSharedInterruptibly(int arg)</code>：共享式获取同步状态，响应中断；</li>
<li><code>tryAcquireSharedNanos(int arg, long nanosTimeout)</code>：共享式获取同步状态，增加超时限制；</li>
<li><code>release(int arg)</code>：独占式释放同步状态，该方法会在释放同步状态之后，将同步队列中第一个节点包含的线程唤醒；</li>
<li><code>releaseShared(int arg)</code>：共享式释放同步状态；</li>
</ul>
<p>以上这些方法在下面的源码分析中都会有所涉及，这个AQS框架还是有些代码量挺复杂的，好好理解的话对于后面的其他的一些锁相关机制、通信工具类都是很有帮助的，内功心法都学会了，其他的就简单很多了。</p>
<p>大体整个框架图（图出自美团）：</p>
<p><img src="https://i.loli.net/2020/04/12/W2c1Kex85fz3Z6V.png" alt="AQS框架图"></p>
<hr>
<h1 id="2-AQS理论的数据结构"><a href="#2-AQS理论的数据结构" class="headerlink" title="2.AQS理论的数据结构"></a>2.AQS理论的数据结构</h1><p>AQS类中维护了一个双向链表(FIFO队列)， 这个队列也称CLH同步队列，有什么用呢？AQS就是靠这个队列来完成同步状态的管理的！</p>
<p>怎么进行管理的？这个问题问得好，大概流程就是这样：当前线程如果获取同步状态失败时，AQS则会将当前线程已经等待状态等信息构造成一个节点（Node）并将其加入到CLH同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点唤醒（公平锁），使其再次尝试获取同步状态。 </p>
<p>Node源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line">    <span class="comment">//标记一个结点（对应的线程）在共享模式下等待</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">// 标记一个结点（对应的线程）在独占模式下等待</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// waitStatus的值，表示该结点（对应的线程）已被取消</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED = <span class="number">1</span>; </span><br><span class="line">    <span class="comment">//waitStatus的值，表示后继结点（对应的线程）需要被唤醒</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//waitStatus的值，表示该结点（对应的线程）在等待某一条件</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// waitStatus的值，表示有资源可用，新head结点需要继续唤醒后继结点</span></span><br><span class="line">    <span class="comment">// （共享模式下，多线程并发释放资源，而head唤醒其后继结点后，需要把多出来的资源留给后面的结点；</span></span><br><span class="line">    <span class="comment">//  设置新的head结点时，会继续唤醒其后继结点）*/</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 等待状态，取值范围，-3，-2，-1，0，1(如上)</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">    <span class="comment">// 前驱结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev; </span><br><span class="line">    <span class="comment">// 后继结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next; </span><br><span class="line">    <span class="comment">// 结点对应的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread; </span><br><span class="line">    <span class="comment">// 等待队列里下一个等待条件的结点</span></span><br><span class="line">    Node nextWaiter; </span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>线程两种锁的模式：</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SHARED</td>
<td align="left">表示线程以共享的模式等待锁</td>
</tr>
<tr>
<td align="left">EXCLUSIVE</td>
<td align="left">表示线程正在以独占的方式等待锁</td>
</tr>
</tbody></table>
<p>waitStatus有下面几个枚举值：</p>
<table>
<thead>
<tr>
<th align="left">枚举</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">当一个Node被初始化的时候的默认值</td>
</tr>
<tr>
<td align="left">CANCELLED</td>
<td align="left">为1，表示线程获取锁的请求已经取消了</td>
</tr>
<tr>
<td align="left">CONDITION</td>
<td align="left">为-2，表示节点在等待队列中，节点线程等待唤醒</td>
</tr>
<tr>
<td align="left">PROPAGATE</td>
<td align="left">为-3，当前线程处在SHARED情况下，该字段才会使用</td>
</tr>
<tr>
<td align="left">SIGNAL</td>
<td align="left">为-1，表示线程已经准备好了，就等资源释放了</td>
</tr>
</tbody></table>
<p>Node的内部其实是这样的：</p>
<p><img src="https://i.loli.net/2020/04/11/1k73AyCUJz9lVTd.png" alt="Node结点内部"></p>
<p>如上图所示，Node 的数据结构其实也挺简单的，就是 thread + waitStatus + pre + next 四个属性而已。</p>
<p>而AQS还有哪些属性呢？如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头结点，可以理解为：当前持有锁的线程 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个链表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意区分state和waiteState！！！</span></span><br><span class="line"><span class="comment">// 这个是最重要的，代表当前锁的状态，0代表没有被占用，大于 0 代表有线程持有当前锁</span></span><br><span class="line"><span class="comment">// 这个值可以大于 1，是因为锁可以重入，每次重入都加上 1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表当前持有独占锁的线程，举个最重要的使用例子，因为锁可以重入</span></span><br><span class="line"><span class="comment">// reentrantLock.lock()可以嵌套调用多次，所以每次用这个来判断当前线程是否已经拥有了锁</span></span><br><span class="line"><span class="comment">// if (currentThread == getExclusiveOwnerThread()) {state++}</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread; <span class="comment">//继承自AbstractOwnableSynchronizer</span></span><br></pre></td></tr></tbody></table></figure>


<p>再抽象一点就是这样了，使用图示的话就如下可以很清晰的表达了（图源文末参考文章），不过需要注意的是：<u>阻塞队列不包含 head 节点。（如上图所示）</u></p>
<p>解释一下head：head是队列中标志，用于指示下一个被unpack的node，head来源于初始化的或曾取得过锁的node。</p>
<p>AbstractQueuedSynchronizer 的等待队列示意如下所示：</p>
<p><img src="https://i.loli.net/2020/04/11/9WIVEU64vpXCcP7.png" alt="CLH队列（FIFO）"></p>
<p>关于双向队列的入队操作和出队操作这些应该比较容易理解，这里就不再讲了。</p>
<hr>
<h1 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3.源码分析"></a>3.源码分析</h1><p>AQS同时提供了互斥模式（exclusive）和共享模式（shared）两种不同的同步逻辑。一般情况下，子类只需要根据需求实现其中一种模式，当然也有同时实现两种模式的同步类，如<code>ReadWriteLock</code>。接下来将详细介绍这两种模式。</p>
<h2 id="3-1-独占模式"><a href="#3-1-独占模式" class="headerlink" title="3.1 独占模式"></a>3.1 独占模式</h2><h3 id="3-1-1-独占式同步状态获取：acquire"><a href="#3-1-1-独占式同步状态获取：acquire" class="headerlink" title="3.1.1 独占式同步状态获取：acquire"></a>3.1.1 独占式同步状态获取：acquire</h3><p>独占式获取同步状态时通过 acquire 进行的，他是AQS提供的模板方法，该方法为独占式获取同步状态。但是该方法对中断不敏感，也就是说由于线程获取同步状态失败加入到CLH同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移除。</p>
<p>acquire的主要完成的事情是这样的：</p>
<ol>
<li>获取独占锁，对中断不敏感。</li>
<li>首先尝试获取一次锁，如果成功，则返回，就结束了！！！</li>
<li>否则会把当前线程包装成Node插入到队列中，在队列中会检测是否为head的直接后继，并尝试获取锁</li>
<li>如果获取失败，则会通过LockSupport阻塞当前线程，直至被释放锁的线程唤醒或者被中断，随后再次尝试获取锁，如此反复。</li>
</ol>
<p>其源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">       <span class="comment">// tryAcquire:去尝试获取锁，获取成功则设置锁状态并返回true，否则返回false。</span></span><br><span class="line">       <span class="comment">// addWaiter：如果tryAcquire返回FALSE（获取同步状态失败），则调用该方法将当前线程加入到CLH同步队列尾部。</span></span><br><span class="line">       <span class="comment">// acquireQueued：当前线程会根据公平性原则来进行阻塞等待（自旋）,直到获取锁为止；并且返回当前线程在等待过程中有没有中断过。</span></span><br><span class="line">       <span class="comment">// selfInterrupt：产生一个中断。</span></span><br><span class="line">       <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; </span><br><span class="line">           <span class="comment">// tryAcquire(arg)没有成功，这个时候需要把当前线程挂起，放到阻塞队列中。</span></span><br><span class="line">           acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">           selfInterrupt();</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>



<h4 id="tryAcquire-int"><a href="#tryAcquire-int" class="headerlink" title="tryAcquire(int)"></a>tryAcquire(int)</h4><p>上面提到的<code>tryAcquire</code>方法， tryAcquire尝试以独占的方式获取资源，如果获取成功，则直接返回true，否则直接返回false。该方法可以用于实现Lock中的tryLock()方法。而AQS中并没有实现上面的<code>tryAcquire(arg)</code>方法，当你跟进去的时候会发现，只是抛出一个异常而已，该方法自定义同步组件自己实现，该方法必须要保证线程安全的获取同步状态。AQS在这里只负责定义了一个公共的方法框架。</p>
<p>这里之所以没有定义成abstract，是因为独占模式下只用实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。</p>
<p>其代码如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 去尝试获取锁，获取成功则设置锁状态并返回true，否则返回false。</span></span><br><span class="line"><span class="comment"> * 该方法自定义同步组件自己实现，该方法必须要保证线程安全的获取同步状态。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>而具体获取锁的操作需要由其子类进行实现，比如ReentrantLock中的Sync实现，如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fair version of tryAcquire.  Don't grant access unless</span></span><br><span class="line"><span class="comment"> * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 尝试直接获取锁，返回值是boolean，代表是否获取到锁</span></span><br><span class="line"><span class="comment">// 返回true：1.没有线程在等待锁；2.重入锁，线程本来就持有锁，也就可以理所当然可以直接获取</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// state == 0 此时此刻没有线程持有锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 虽然此时此刻锁是可以用的，但是这是公平锁，既然是公平，就得讲究先来后到，</span></span><br><span class="line">        <span class="comment">// 看看有没有别人在队列中等了半天了</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            <span class="comment">// 如果没有线程在等待，那就用CAS尝试一下，成功了就获取到锁了，</span></span><br><span class="line">            <span class="comment">// 不成功的话，只能说明一个问题，就在刚刚几乎同一时刻有个线程抢先了 =_=</span></span><br><span class="line">            <span class="comment">// 因为刚刚还没人的，我判断过了</span></span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) {</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 到这里就是获取到锁了，标记一下，告诉大家，现在是我占用了锁</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 会进入这个else if分支，说明是重入了，需要操作：state=state+1</span></span><br><span class="line">    <span class="comment">// 这里不存在并发问题</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) {</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果到这里，说明前面的if和else if都没有返回true，说明没有获取到锁</span></span><br><span class="line">    <span class="comment">// 回到上面一个外层调用方法继续看:</span></span><br><span class="line">    <span class="comment">// if (!tryAcquire(arg) </span></span><br><span class="line">    <span class="comment">//        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) </span></span><br><span class="line">    <span class="comment">//     selfInterrupt();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里你会发现上面有重入锁的概念，意思就是已经获取到锁的线程还可以再次获取到同一个锁，这里多嘴一下，有哪些锁是重入锁呢？比如：syschronized、ReentrantLock都属于重入锁，而自旋锁不属于重入锁。</p>
<hr>
<h4 id="addWaiter-Node"><a href="#addWaiter-Node" class="headerlink" title="addWaiter(Node)"></a>addWaiter(Node)</h4><p>假设<code>tryAcquire(arg)</code> 返回false，那么代码将执行：<code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code>，这个方法，首先需要执行：<code>addWaiter(Node.EXCLUSIVE)</code></p>
<p>该方法用于将当前线程根据不同的模式（<code>Node.EXCLUSIVE</code>互斥模式、<code>Node.SHARED</code>共享模式）加入到等待队列的队尾，并返回当前线程所在的结点。其添加过程是一个自旋过程，会去尝试能否添加到尾结点，如果队列为空会进行同步队列的初始化。需要注意的是，这里取消了快速尝试这个方法，<code>addWaiter</code>直接就自旋了，所以在这里是没有<code>enq(node);</code>这个方法的。</p>
<p>源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>{</span><br><span class="line">    <span class="comment">// 新建Node</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(mode);</span><br><span class="line">    <span class="comment">// 通过 CAS + 自旋的方式插入节点到队尾</span></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="comment">// 如果队列不为空，则先记录当前尾结点为旧的尾结点</span></span><br><span class="line">        Node oldTail = tail;</span><br><span class="line">        <span class="comment">// 判断队列是否为空，队列为空的话就先初始化队列再重新进入for循环当中，将结点node入队！</span></span><br><span class="line">        <span class="keyword">if</span> (oldTail != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 这个操作其实就是：node.prev = pred;</span></span><br><span class="line"><span class="comment">             * AQS的精妙就是体现在很多细节的代码，比如需要用CAS往队尾里增加一个元素</span></span><br><span class="line"><span class="comment">             * 此处的else分支是先在CAS的if前设置node.prev = oldTail，而不是在CAS成功之后再设置。</span></span><br><span class="line"><span class="comment">             * 一方面是基于CAS的双向链表插入目前没有完美的解决方案，另一方面这样子做的好处是：</span></span><br><span class="line"><span class="comment">             * 保证每时每刻tail.prev都不会是一个null值，否则如果node.prev = t</span></span><br><span class="line"><span class="comment">             * 放在下面if的里面，会导致一个瞬间tail.prev = null，这样会使得队列不完整。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            node.setPrevRelaxed(oldTail);</span><br><span class="line">            <span class="comment">// CAS设置tail为node，成功后把老的tail也就是连接到node。</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(oldTail, node)) {</span><br><span class="line">                <span class="comment">// 实现了和之前的尾节点双向连接了</span></span><br><span class="line">                oldTail.next = node;</span><br><span class="line">                <span class="comment">// 线程入队了，可以返回了</span></span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 如果队列为空，则初始化该同步队列</span></span><br><span class="line">            <span class="comment">// 初始化之后，没有return，会继续for循环！！！</span></span><br><span class="line">            initializeSyncQueue();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>initializeSyncQueue就是一个初始化同步队列的方法，其源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes head and tail fields on first contention.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initializeSyncQueue</span><span class="params">()</span> </span>{</span><br><span class="line">    Node h;</span><br><span class="line">    <span class="keyword">if</span> (HEAD.compareAndSet(<span class="keyword">this</span>, <span class="keyword">null</span>, (h = <span class="keyword">new</span> Node())))</span><br><span class="line">        <span class="comment">// 这个时候有了head，但是tail还是null，设置一下， 把tail指向head</span></span><br><span class="line">        <span class="comment">//，但是很快有线程进来，tail就会重新指向</span></span><br><span class="line">        <span class="comment">// 注意：这里只是设置了tail=head，此处没有return;</span></span><br><span class="line">        <span class="comment">// 所以，设置完了以后，继续for循环</span></span><br><span class="line">        tail = h;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<hr>
<h4 id="acquireQueued-Node-int"><a href="#acquireQueued-Node-int" class="headerlink" title="acquireQueued(Node, int)"></a>acquireQueued(Node, int)</h4><p>返回<code>acquire</code>方法中，参数node，经过addWaiter(Node.EXCLUSIVE)，此时已经进入阻塞队列，注意一下：如果acquireQueued(addWaiter(Node.EXCLUSIVE), arg))返回true的话，意味着上面这段代码将进入<code>selfInterrupt()</code>，所以正常情况下，下面应该返回false。</p>
<p>这个方法非常重要，应该说真正的线程挂起，然后被唤醒后去获取锁，都在这个方法里了！！！</p>
<p><code>acquireQueued</code>方法为一个<u>自旋的过程</u>，也就是说当前线程（Node）进入同步队列后，就会进入一个自旋的过程，每个节点都会自省地观察，当条件满足，获取到同步状态后，就可以从这个自旋过程中退出，否则会一直执行下去。如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="comment">// 中断标志</span></span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 自旋的过程</span></span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="comment">// 当前线程的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 检测当前节点前驱是否head，这是试获取锁的资格</span></span><br><span class="line">            <span class="comment">// 如果是的话，则调用tryAcquire尝试获取锁</span></span><br><span class="line">            <span class="comment">// 成功，则将head置为当前节点。</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) {</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 到这里，说明上面的if分支没有成功，要么当前node本来就不是队头，要么就是tryAcquire(arg)没有抢赢别人</span></span><br><span class="line">            <span class="comment">// 如果未成功获取锁则根据前驱节点判断是否要阻塞</span></span><br><span class="line">            <span class="comment">// 注意：在获取同步状态失败后，线程并不是立马进行阻塞，需要检查该线程的状态</span></span><br><span class="line">            <span class="comment">// 如果shouldParkAfterFailedAcquire返回false，会继续上面的for循环！！！</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node))</span><br><span class="line">                <span class="comment">// 上面的判断如果返回true, 说明前驱节点的waitStatus==-1，是正常情况</span></span><br><span class="line">                <span class="comment">//    那么当前线程需要被挂起，等待以后被唤醒</span></span><br><span class="line">                <span class="comment">//    以后是被前驱节点唤醒，就等着前驱节点拿到锁，然后释放锁的时候叫你好了</span></span><br><span class="line">                <span class="comment">// 如果返回false, 说明当前不需要被挂起</span></span><br><span class="line">                <span class="comment">//    仔细看shouldParkAfterFailedAcquire(p, node)，我们可以发现，其实第一次进来的时候，一般都不会返回true的</span></span><br><span class="line">                <span class="comment">//    原因很简单，前驱节点的waitStatus=-1是依赖于后继节点设置的。</span></span><br><span class="line">                <span class="comment">//    也就是说，我都还没给前驱设置-1呢，怎么可能是true呢，但是要看到，这个方法是套在循环里的，所以第二次进来的时候状态就是-1了。</span></span><br><span class="line">                <span class="comment">//    所以：是为了应对在经过这个方法后，node已经是head的直接后继节点了</span></span><br><span class="line">                interrupted |= parkAndCheckInterrupt();</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">        <span class="comment">// 如果tryAcquire 抛出异常的话，则进行状态获取的取消</span></span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">        <span class="comment">// 如果是中断状态的话，进行一个自我中断</span></span><br><span class="line">        <span class="keyword">if</span> (interrupted)</span><br><span class="line">            selfInterrupt();</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>从上面代码中可以看到，当前线程会一直尝试获取同步状态，当然前提是只有其前驱节点为头结点才能够尝试获取同步状态，理由：</p>
<ol>
<li>保持FIFO同步队列原则。</li>
<li>头节点释放同步状态后，将会唤醒其后继节点，后继节点被唤醒后需要检查自己是否为头节点。</li>
</ol>
<p>上面还有一点，就是当获取同步状态失败后，线程并不是立马进行阻塞，需要检查该线程的状态，检查状态的方法为 <code>shouldParkAfterFailedAcquire(Node pred, Node node)</code> 方法。该方法主要用途是：当线程在获取同步状态失败时，根据前驱节点的等待状态，决定后续的动作。比如前驱节点等待状态为 SIGNAL，表明当前节点线程应该被阻塞住了。不能老是尝试，避免 CPU 忙等。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会到这里就是没有抢到锁，这个方法说的是："当前线程没有抢到锁，是否需要挂起当前线程？"</span></span><br><span class="line"><span class="comment">// 第一个参数是前驱节点，第二个参数才是代表当前线程的节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>{</span><br><span class="line">    <span class="comment">// 前驱节点</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">// 前驱节点状态为SIGNAL（-1），说明前驱节点状态正常，当前线程需要挂起，直接可以返回true</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 前驱节点 waitStatus大于0 ，之前说过，大于0 说明前驱节点取消了排队。</span></span><br><span class="line">    <span class="comment">// 这里需要知道这点：进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。</span></span><br><span class="line">    <span class="comment">// 所以下面这块代码说的是将当前节点的prev指向waitStatus&lt;=0的节点，</span></span><br><span class="line">    <span class="comment">// 简单说，就是为了找个好爹，因为你还得依赖它来唤醒呢，如果前驱节点取消了排队，</span></span><br><span class="line">    <span class="comment">// 找前驱节点的前驱节点做爹，往前遍历总能找到一个好爹的！！！</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">do</span> {</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        } <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 仔细想想，如果进入到这个分支意味着什么</span></span><br><span class="line">        <span class="comment">// 前驱节点的waitStatus不等于-1和1，那也就是只可能是0，-2，-3</span></span><br><span class="line">        <span class="comment">// 在我们前面的源码中，都没有看到有设置waitStatus的，所以每个新的node入队时，waitStatu都是0</span></span><br><span class="line">        <span class="comment">// 正常情况下，前驱节点是之前的 tail，那么它的 waitStatus 应该是 0</span></span><br><span class="line">        <span class="comment">// 用CAS将前驱节点的waitStatus设置为Node.SIGNAL(也就是-1)</span></span><br><span class="line">        pred.compareAndSetWaitStatus(ws, Node.SIGNAL);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 这个方法返回 false，那么会再走一次 for 循序，</span></span><br><span class="line">    <span class="comment">// 然后再次进来此方法，此时会从第一个分支返回 true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>这段代码主要检查当前线程是否需要被阻塞，具体规则如下：</p>
<ol>
<li>如果当前线程的前驱节点状态为SIGNAL，则表明当前线程需要被阻塞，调用unpark()方法唤醒，直接返回true，当前线程阻塞</li>
<li>如果当前线程的前驱节点状态为CANCELLED（ws &gt; 0），则表明该线程的前驱节点已经等待超时或者被中断了，则需要从CLH队列中将该前驱节点删除掉，直到回溯到前驱节点状态 &lt;= 0 ，返回false</li>
<li>如果前驱节点非SINGAL，非CANCELLED，则通过CAS的方式将其前驱节点设置为SIGNAL，返回false</li>
</ol>
<p>上面一堆看得眼花，简略来说如下：</p>
<ol>
<li>前驱节点为SIGNAL：阻塞。</li>
<li>前驱节点为CANCELLED ：向前遍历, 移除前面所有为该状态的节点。</li>
<li>前驱节点为waitStatus &lt; 0：将前驱节点状态设为 SIGNAL, 并再次尝试获取同步状态。</li>
</ol>
<p>如果<code>shouldParkAfterFailedAcquire</code>返回true，则<code>acquireQueued</code>则会接着调用<code>parkAndCheckInterrupt</code>来阻塞当前线程，该方法主要是把当前线程挂起，从而阻塞住线程的调用栈，同时返回当前线程的中断状态，其源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 调用LockSupport工具类的park()方法来阻塞该方法。</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 返回当前线程的中断状态</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>而关于<code>LockSupport</code>相关的东西，可以查看我对其分析的笔记：<a href="https://dongxiem.github.io/2020/04/11/java-bing-fa-aqs-locksupport-zu-sai-huan-xing-xian-cheng/">Java 并发 - AQS：LockSupport阻塞唤醒线程</a></p>
<p>再回到acquireQueued中，如果在获取同步状态中出现异常，<code>failed = true</code>，<code>cancelAcquire</code> 方法会被执行。因为tryAcquire 需同步组件开发者覆写，难免不了会出现异常。该方法主要的作用就是：取消获取同步状态。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>{</span><br><span class="line">       <span class="comment">// Ignore if node doesn't exist</span></span><br><span class="line">       <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">       node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 遍历并更新节点前驱，把node的prev指向前部第一个非取消节点</span></span><br><span class="line">       Node pred = node.prev;</span><br><span class="line">       <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">           node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 记录pred节点的后继为predNext，后续CAS会用到</span></span><br><span class="line">       Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 直接把当前节点的等待状态置为取消,后继节点即便也在cancel可以跨越node节点。</span></span><br><span class="line">       node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 如果CAS将tail从node置为pred节点了</span></span><br><span class="line"><span class="comment">       * 则剩下要做的事情就是尝试用CAS将pred节点的next更新为null以彻底切断pred和node的联系。</span></span><br><span class="line"><span class="comment">       * 这样一来就断开了pred与pred的所有后继节点，这些节点由于变得不可达，最终会被回收掉。</span></span><br><span class="line"><span class="comment">       * 由于node没有后继节点，所以这种情况到这里整个cancel就算是处理完毕了。</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * 这里的CAS更新pred的next即使失败了也没关系，说明有其它新入队线程或者其它取消线程更新掉了。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) {</span><br><span class="line">           <span class="comment">/* </span></span><br><span class="line"><span class="comment">            * 执行到这里，表明 pred 节点被成功设为了尾节点，这里通过 CAS 将 pred 节点的后继节点</span></span><br><span class="line"><span class="comment">            * 设为 null。注意这里的 CAS 即使失败了，也没关系。失败了，表明 pred 的后继节点更新</span></span><br><span class="line"><span class="comment">            * 了。pred 此时已经是尾节点了，若后继节点被更新，则是有新节点入队了。这种情况下，CAS </span></span><br><span class="line"><span class="comment">            * 会失败，但失败不会影响同步队列的结构。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           pred.compareAndSetNext(predNext, <span class="keyword">null</span>);</span><br><span class="line">       } <span class="keyword">else</span> {</span><br><span class="line">           <span class="comment">// 根据条件判断是唤醒后继节点，还是将前驱节点和后继节点连接到一起</span></span><br><span class="line">           <span class="keyword">int</span> ws;</span><br><span class="line">           <span class="comment">// 如果当前节点不是head的后继节点，1:判断当前节点前驱节点的是否为SIGNAL，2:如果不是，则把前驱节点设置为SINGAL看是否成功</span></span><br><span class="line">           <span class="comment">// 如果1和2中有一个为true，再判断当前节点的线程是否为null</span></span><br><span class="line">           <span class="comment">// 如果上述条件都满足，把当前节点的前驱节点的后继指针指向当前节点的后继节点    </span></span><br><span class="line">           <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">               ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">                (ws &lt;= <span class="number">0</span> &amp;&amp; pred.compareAndSetWaitStatus(ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">               pred.thread != <span class="keyword">null</span>) {</span><br><span class="line">               Node next = node.next;</span><br><span class="line">               <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                   <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    * 这里使用 CAS 设置 pred 的 next，表明多个线程同时在取消，这里存在竞争。</span></span><br><span class="line"><span class="comment">                    * 不过此处没针对 compareAndSetNext 方法失败后做一些处理，表明即使失败了也</span></span><br><span class="line"><span class="comment">                    * 没关系。实际上，多个线程同时设置 pred 的 next 引用时，只要有一个能设置成</span></span><br><span class="line"><span class="comment">                    * 功即可。</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                   pred.compareAndSetNext(predNext, next);</span><br><span class="line">           } <span class="keyword">else</span> {</span><br><span class="line">               <span class="comment">/*</span></span><br><span class="line"><span class="comment">                * 如果当前节点是head的后继节点，或者上述条件不满足，那就唤醒当前节点的后继节点</span></span><br><span class="line"><span class="comment">                * 这里简单讲一下为什么要唤醒后继线程，考虑下面一种情况：</span></span><br><span class="line"><span class="comment">                *        head          node1         node2         tail</span></span><br><span class="line"><span class="comment">                *        ws=0          ws=1          ws=-1         ws=0</span></span><br><span class="line"><span class="comment">                *      +------+  prev +-----+  prev +-----+  prev +-----+</span></span><br><span class="line"><span class="comment">                *      |      | &lt;---- |     | &lt;---- |     | &lt;---- |     |  </span></span><br><span class="line"><span class="comment">                *      |      | ----&gt; |     | ----&gt; |     | ----&gt; |     |</span></span><br><span class="line"><span class="comment">                *      +------+  next +-----+  next +-----+  next +-----+</span></span><br><span class="line"><span class="comment">                *      </span></span><br><span class="line"><span class="comment">                * 头结点初始状态为 0，node1、node2 和 tail 节点依次入队。node1 自旋过程中调用 </span></span><br><span class="line"><span class="comment">                * tryAcquire 出现异常，进入 cancelAcquire。head 节点此时等待状态仍然是 0，它</span></span><br><span class="line"><span class="comment">                * 会认为后继节点还在运行中，所它在释放同步状态后，不会去唤醒后继等待状态为非取消的</span></span><br><span class="line"><span class="comment">                * 节点 node2。如果 node1 再不唤醒 node2 的线程，该线程面临无法被唤醒的情况。此</span></span><br><span class="line"><span class="comment">                * 时，整个同步队列就回全部阻塞住。</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">               unparkSuccessor(node);</span><br><span class="line">           }</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">           * 取消节点的next之所以设置为自己本身而不是null,</span></span><br><span class="line"><span class="comment">           * 是为了方便AQS中Condition部分的isOnSyncQueue方法,</span></span><br><span class="line"><span class="comment">           * 判断一个原先属于条件队列的节点是否转移到了同步队列。</span></span><br><span class="line"><span class="comment">           *</span></span><br><span class="line"><span class="comment">           * 因为同步队列中会用到节点的next域，取消节点的next也有值的话，</span></span><br><span class="line"><span class="comment">           * 可以断言next域有值的节点一定在同步队列上。</span></span><br><span class="line"><span class="comment">           *</span></span><br><span class="line"><span class="comment">           * 在GC层面，和设置为null具有相同的效果。</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">           node.next = node; <span class="comment">// help GC</span></span><br><span class="line">       }</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line"><span class="comment">// unparkSuccessor的作用是唤醒后继节点，其源码如下：</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>{</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">        * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">        * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">// 当前节点状态</span></span><br><span class="line">       <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">       <span class="comment">// 通过 CAS 将等待状态设为 0，让后继节点线程多一次尝试获取同步状态的机会</span></span><br><span class="line">       <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">           node.compareAndSetWaitStatus(ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 当前节点的后继节点</span></span><br><span class="line">       Node s = node.next;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 这里的逻辑就是如果node.next存在并且状态不为取消，则直接唤醒s即可</span></span><br><span class="line"><span class="comment">        * 否则需要从tail开始向前找到node之后最近的非取消节点。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 这里为什么要从tail开始向前查找也是值得琢磨的:</span></span><br><span class="line"><span class="comment">        * 如果读到s == null，不代表node就为tail，参考addWaiter以及enq函数中的我的注释。</span></span><br><span class="line"><span class="comment">        * 不妨考虑到如下场景：</span></span><br><span class="line"><span class="comment">        * 1. node某时刻为tail</span></span><br><span class="line"><span class="comment">        * 2. 有新线程通过addWaiter中的if分支或者enq方法添加自己</span></span><br><span class="line"><span class="comment">        * 3. compareAndSetTail成功</span></span><br><span class="line"><span class="comment">        * 4. 此时这里的Node s = node.next读出来s == null，但事实上node已经不是tail，它有后继了!</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) {</span><br><span class="line">           s = <span class="keyword">null</span>;</span><br><span class="line">           <span class="comment">// 从tail节点开始往前遍历来找可用节点</span></span><br><span class="line">           <span class="comment">// 为何是从tail尾节点开始，而不是从node.next开始呢？</span></span><br><span class="line">           <span class="comment">// 原因在于node.next仍然可能会存在null或者取消了，所以采用tail回溯办法找第一个可用的线程。</span></span><br><span class="line">           <span class="comment">// 最后调用LockSupport的unpark(Thread thread)方法唤醒该线程。</span></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">           * 这里如果 s == null 处理，是不是表明 node 是尾节点？答案是不一定。 </span></span><br><span class="line"><span class="comment">           * 新节点入队时，队列瞬时结构可能如下：</span></span><br><span class="line"><span class="comment">           *                      node1         node2</span></span><br><span class="line"><span class="comment">           *      +------+  prev +-----+ prev  +-----+</span></span><br><span class="line"><span class="comment">           * head |      | &lt;---- |     | &lt;---- |     |  tail</span></span><br><span class="line"><span class="comment">           *      |      | ----&gt; |     |       |     |</span></span><br><span class="line"><span class="comment">           *      +------+ next  +-----+       +-----+</span></span><br><span class="line"><span class="comment">           * </span></span><br><span class="line"><span class="comment">           * node2 节点为新入队节点，此时 tail 已经指向了它，但 node1 后继引用还未设置。</span></span><br><span class="line"><span class="comment">           * 这里 node1 就是 node 参数，s = node1.next = null，但此时 node1 并不是尾</span></span><br><span class="line"><span class="comment">           * 节点。所以这里不能从前向后遍历同步队列，应该从后向前。</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">           <span class="keyword">for</span> (Node p = tail; p != node &amp;&amp; p != <span class="keyword">null</span>; p = p.prev)</span><br><span class="line">               <span class="keyword">if</span> (p.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                   s = p;</span><br><span class="line">       }</span><br><span class="line">       <span class="comment">// 唤醒后继节点</span></span><br><span class="line">       <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">           LockSupport.unpark(s.thread);</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>



<p>上面大概就是：获取当前节点的前驱节点，如果前驱节点的状态是CANCELLED，那就一直往前遍历，找到第一个waitStatus &lt;= 0的节点，将找到的Pred节点和当前Node关联，将当前Node设置为CANCELLED。</p>
<p>进行了上述的一些操作之后根据当前节点的位置，其实需要考虑以下三种情况：</p>
<ol>
<li>当前节点是尾节点。</li>
<li>当前节点是Head的后继节点。</li>
<li>当前节点不是Head的后继节点，也不是尾节点。</li>
</ol>
<p>具体分析一下一上三种情况：</p>
<p>当前节点是尾节点</p>
<p><img src="https://i.loli.net/2020/04/12/cRFCu2bP7m4a5Yt.png" alt="当前节点是尾节点"></p>
<p>当前节点是Head的后继节点：</p>
<p>取消节点的next可以设置为自己本身，不设置为null，上面的注释中有进行解释了，这里就不再解释了，如果有疑惑就往上面翻一下下。</p>
<p><img src="https://i.loli.net/2020/04/12/qSL31JfmY86jkCF.png" alt="当前节点是Head的后继节点"></p>
<p>当前节点不是Head的后继节点，也不是尾节点</p>
<p><img src="https://i.loli.net/2020/04/12/xJrFBz24lspPAIw.png" alt="当前节点不是Head的后继节点 也不是尾节点"></p>
<hr>
<h4 id="selfInterrupt"><a href="#selfInterrupt" class="headerlink" title="selfInterrupt"></a>selfInterrupt</h4><p>在上面如果acquireQueued为True，就会执行selfInterrupt方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>{</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread()) {</span><br><span class="line">        checkAccess();</span><br><span class="line">        <span class="comment">// 线程可能因为IO操作被阻塞</span></span><br><span class="line">        <span class="keyword">synchronized</span> (blockerLock) {</span><br><span class="line">            Interruptible b = blocker;</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="keyword">null</span>) {</span><br><span class="line">                interrupt0();  <span class="comment">// 设置中断状态</span></span><br><span class="line">                b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 设置中断状态</span></span><br><span class="line">    interrupt0();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>该方法其实是为了中断线程。但<u>为什么获取了锁以后还要中断线程呢</u>？这部分属于Java提供的协作式中断知识内容，这里简单介绍一下：</p>
<ol>
<li>当中断线程被唤醒时，并不知道被唤醒的原因，可能是当前线程在等待中被中断，也可能是释放了锁以后被唤醒。因此我们通过Thread.interrupted()方法检查中断标记（该方法返回了当前线程的中断状态，并将当前线程的中断标识设置为False），并记录下来，如果发现该线程被中断过，就再中断一次。</li>
<li>线程在等待资源的过程中被唤醒，唤醒后还是会不断地去尝试获取锁，直到抢到锁为止。也就是说，在整个流程中，并不响应中断，只是记录中断记录。最后抢到锁返回了，那么如果被中断过的话，就需要补充一次中断。</li>
</ol>
<p>这里的处理方式主要是运用线程池中基本运作单元Worder中的runWorker，通过Thread.interrupted()进行额外的判断处理。</p>
<p>整个流程大概就是这么一个回事了，大概的流程还是清楚的，但是个中细节还有待深挖。</p>
<hr>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>总结一下，acquire的大概流程如下：</p>
<ol>
<li>调用 tryAcquire 方法尝试获取同步状态</li>
<li>获取成功，直接返回</li>
<li>获取失败，将线程封装到节点中，并将节点入队</li>
<li>入队节点在 acquireQueued 方法中自旋获取同步状态</li>
<li>若节点的前驱节点是头节点，则再次调用 tryAcquire 尝试获取同步状态</li>
<li>获取成功，当前节点将自己设为头节点并返回</li>
<li>获取失败，可能再次尝试，也可能会被阻塞。这里简单认为会被阻塞。</li>
</ol>
<p>acquire的流程图如下（图源见文末文章出处）：</p>
<p><img src="https://i.loli.net/2020/04/11/TSpwJ46vCqWVF9l.png" alt="acquire执行过程"></p>
<h4 id="示例分析："><a href="#示例分析：" class="headerlink" title="示例分析："></a>示例分析：</h4><p>以下摘自：<a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer" target="_blank" rel="noopener">一行一行源码分析清楚AbstractQueuedSynchronizer</a>，他以<code>reentrantLock</code>进行一个简单的分析：</p>
<p>首先，第一个线程调用 reentrantLock.lock()，<code>tryAcquire(1)</code> 直接就返回 true 了，结束。只是设置了 <code>state=1</code>，连 head 都没有初始化，更谈不上什么阻塞队列了。要是线程 1 调用 unlock() 了，才有线程 2 来，完全没有交集嘛，AQS就派不上用场了。</p>
<p>于是便引出一个问题：如果线程 1 没有调用 unlock() 之前，线程 2 调用了 lock(), 想想会发生什么？</p>
<p>线程 2 会初始化 head【<code>new Node()</code>】，同时线程 2 也会插入到阻塞队列并挂起 （注意看这里是一个 for 循环，而且设置 head 和 tail 的部分是不 return 的，只有入队成功才会跳出循环）</p>
<p>首先，是线程 2 初始化 head 节点，此时 <code>head== tail</code>,  <code>waitStatus==0</code></p>
<p><img src="https://i.loli.net/2020/04/12/2P9voOH3txybzYM.png" alt="初始化head节点"></p>
<p>然后线程 2 入队：</p>
<p><img src="https://i.loli.net/2020/04/12/nexW1CDvzYcRPAh.png" alt="线程2入队"></p>
<p>同时我们也要看此时节点的 <code>waitStatus</code>，我们知道 head 节点是线程 2 初始化的，此时的 <code>waitStatus</code> 没有设置， java 默认会设置为 0，但是到 <code>shouldParkAfterFailedAcquire</code> 这个方法的时候，线程 2 会把前驱节点，也就是 head 的<code>waitStatus</code>设置为 -1。</p>
<p>那线程 2 节点此时的 <code>waitStatus</code> 是多少呢，由于没有设置，所以是 0；</p>
<p>如果线程 3 此时再进来，直接插到线程 2 的后面就可以了，此时线程 3 的 waitStatus 是 0，到 <code>shouldParkAfterFailedAcquire</code> 方法的时候把前驱节点线程 2 的 waitStatus 设置为 -1。</p>
<p><img src="https://i.loli.net/2020/04/12/v6EI48NwXt9Hsx3.png" alt="线程3入队"></p>
<p>这里可以简单说下 <code>waitStatus</code> 中 <code>SIGNAL(-1)</code> 状态的意思，Doug Lea 注释的是：<strong>代表后继节点需要被唤醒</strong>。也就是说<u>这个 waitStatus 其实代表的不是自己的状态，而是后继节点的状态</u>，我们知道，每个 node 在入队的时候，都会把前驱节点的状态改为 SIGNAL，然后阻塞，等待被前驱唤醒。这里涉及的是两个问题：有线程取消了排队、唤醒操作。其实本质是一样的，可以顺着 “waitStatus代表后继节点的状态” 这种思路去看一遍源码。</p>
<hr>
<h3 id="3-1-2-独占式获取响应中断"><a href="#3-1-2-独占式获取响应中断" class="headerlink" title="3.1.2 独占式获取响应中断"></a>3.1.2 独占式获取响应中断</h3><p>AQS提供了<code>acquire(int arg)</code>方法以供独占式获取同步状态，但是该方法对中断不响应，对线程进行中断操作后，该线程会依然位于CLH同步队列中等待着获取同步状态。为了响应中断，AQS提供了<code>acquireInterruptibly(int arg)</code>方法，<u>该方法在等待获取同步状态时，如果当前线程被中断了，会立刻响应中断抛出异常`InterruptedException</u></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>{ <span class="comment">// 这里直接抛出InterruptedException</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 还是一样自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) {</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">        <span class="comment">// 如果有异常，一样要取消申请</span></span><br><span class="line">        <span class="comment">// 然后再抛出异常，而不是使用interrupted标志</span></span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>首先校验该线程是否已经中断了，如果是则抛出<code>InterruptedException</code>，否则执行<code>tryAcquire(int arg)</code>方法获取同步状态，如果获取成功，则直接返回，否则执行<code>doAcquireInterruptibly(int arg)</code>。<code>doAcquireInterruptibly(int arg)</code>定义如下：</p>
<p>doAcquireInterruptibly(int arg)方法与acquire(int arg)方法仅有两个差别：</p>
<ol>
<li>方法声明抛出InterruptedException异常</li>
<li>在中断方法处不再是使用interrupted标志，而是直接抛出InterruptedException异常。</li>
</ol>
<hr>
<h3 id="3-1-3-独占式超时获取"><a href="#3-1-3-独占式超时获取" class="headerlink" title="3.1.3 独占式超时获取"></a>3.1.3 独占式超时获取</h3><p>AQS除了提供上面两个方法外，还提供了一个<u>增强版的方法</u>：<code>tryAcquireNanos(int arg,long nanos)</code>。该方法为<code>acquireInterruptibly</code>方法的进一步增强，它除了响应中断外，还有超时控制。即如果当前线程没有在指定时间内获取同步状态，则会返回false，否则返回true。如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">     <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">     <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">         doAcquireNanos(arg, nanosTimeout);</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">     <span class="comment">// nanosTimeout &lt;= 0</span></span><br><span class="line">     <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     <span class="comment">// 超时时间</span></span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">     <span class="comment">// 新增Node节点</span></span><br><span class="line">     <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">     <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">     <span class="keyword">try</span> {</span><br><span class="line">         <span class="comment">// 自旋</span></span><br><span class="line">         <span class="keyword">for</span> (;;) {</span><br><span class="line">             <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">             <span class="comment">// 获取同步状态成功</span></span><br><span class="line">             <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) {</span><br><span class="line">                 setHead(node);</span><br><span class="line">                 p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                 failed = <span class="keyword">false</span>;</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">             }</span><br><span class="line">             <span class="comment">/*</span></span><br><span class="line"><span class="comment">              * 获取失败，做超时、中断判断</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">             <span class="comment">// 重新计算需要休眠的时间</span></span><br><span class="line">             nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">             <span class="comment">// 已经超时，返回false</span></span><br><span class="line">             <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             <span class="comment">// 如果没有超时，则等待nanosTimeout纳秒</span></span><br><span class="line">             <span class="comment">// 注：该线程会直接从LockSupport.parkNanos中返回，</span></span><br><span class="line">             <span class="comment">// LockSupport为JUC提供的一个阻塞和唤醒的工具类，后面做详细介绍</span></span><br><span class="line">             <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                     nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                 LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">             <span class="comment">// 线程是否已经中断了</span></span><br><span class="line">             <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                 <span class="comment">// 抛出一个异常并且结束</span></span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">         }</span><br><span class="line">     } <span class="keyword">finally</span> {</span><br><span class="line">         <span class="keyword">if</span> (failed)</span><br><span class="line">             cancelAcquire(node);</span><br><span class="line">     }</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>



<p>其大概流程如下：</p>
<p><img src="https://i.loli.net/2020/04/11/LKxausrV8qbcQm6.png" alt="独占式超时获取"></p>
<hr>
<h3 id="3-1-4-独占式同步状态释放：release"><a href="#3-1-4-独占式同步状态释放：release" class="headerlink" title="3.1.4 独占式同步状态释放：release"></a>3.1.4 独占式同步状态释放：release</h3><p>释放的过程会比较简单点：</p>
<ol>
<li>调用 <code>tryRelease(arg)</code> 尝试释放同步状态</li>
<li>如果 <code>tryRelease</code> 返回true也就是独占锁被完全释放，唤醒后继线程。</li>
</ol>
<p>这里的唤醒是根据head几点来判断的，下面代码的注释中也分析了head节点的情况，只有在head存在并且等待状态小于零的情况下唤醒。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Releases in exclusive mode.  Implemented by unblocking one or</span></span><br><span class="line"><span class="comment"> * more threads if {<span class="doctag">@link</span> #tryRelease} returns true.</span></span><br><span class="line"><span class="comment"> * This method can be used to implement method {<span class="doctag">@link</span> Lock#unlock}.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment"> *        {<span class="doctag">@link</span> #tryRelease} but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment"> *        can represent anything you like.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the value returned from {<span class="doctag">@link</span> #tryRelease}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 当线程获取同步状态后，执行完相应逻辑后就需要释放同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 此时的head节点可能有3种情况:</span></span><br><span class="line"><span class="comment">     * 1. null (AQS的head延迟初始化+无竞争的情况)</span></span><br><span class="line"><span class="comment">     * 2. 当前线程在获取锁时new出来的节点通过setHead设置的</span></span><br><span class="line"><span class="comment">     * 3. 由于通过tryRelease已经完全释放掉了独占锁，有新的节点在acquireQueued中获取到了独占锁，并设置了head</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 第三种情况可以再分为两种情况：</span></span><br><span class="line"><span class="comment">     * （一）时刻1:线程A通过acquireQueued，持锁成功，set了head</span></span><br><span class="line"><span class="comment">     *          时刻2:线程B通过tryAcquire试图获取独占锁失败失败，进入acquiredQueued</span></span><br><span class="line"><span class="comment">     *          时刻3:线程A通过tryRelease释放了独占锁</span></span><br><span class="line"><span class="comment">     *          时刻4:线程B通过acquireQueued中的tryAcquire获取到了独占锁并调用setHead</span></span><br><span class="line"><span class="comment">     *          时刻5:线程A读到了此时的head实际上是线程B对应的node</span></span><br><span class="line"><span class="comment">     * （二）时刻1:线程A通过tryAcquire直接持锁成功，head为null</span></span><br><span class="line"><span class="comment">     *          时刻2:线程B通过tryAcquire试图获取独占锁失败失败，入队过程中初始化了head，进入acquiredQueued</span></span><br><span class="line"><span class="comment">     *          时刻3:线程A通过tryRelease释放了独占锁，此时线程B还未开始tryAcquire</span></span><br><span class="line"><span class="comment">     *          时刻4:线程A读到了此时的head实际上是线程B初始化出来的傀儡head</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) {</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// head节点状态不会是CANCELLED，所以这里h.waitStatus != 0相当于h.waitStatus &lt; 0</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 释放成功后，会调用unparkSuccessor(Node node)方法唤醒后继节点</span></span><br><span class="line">            <span class="comment">// 上面已经分析过了，不再叙述</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>跟tryAcquire一样，tryRelease也是由用户自己去实现了，其源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 独占式释放同步状态；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<hr>
<h2 id="3-2-共享模式"><a href="#3-2-共享模式" class="headerlink" title="3.2 共享模式"></a>3.2 共享模式</h2><p>其实如果理解了上面的独享模式之后再来理解共享模式，难度不大，主要是与共享模式下，同一时刻会有多个线程获取共享同步状态。共享模式是实现读写锁中的读锁、CountDownLatch 和 Semaphore 等同步组件的基础，这样再去理解一些共享同步组件就不难了。</p>
<h3 id="3-2-1-同步状态获取：acquireShared"><a href="#3-2-1-同步状态获取：acquireShared" class="headerlink" title="3.2.1 同步状态获取：acquireShared"></a>3.2.1 同步状态获取：acquireShared</h3><p>共享式获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，与独占式的主要区别是在同一时刻可以有多个线程获取到同步状态；</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="comment">// 尝试获取共享同步状态，tryAcquireShared 返回的是整型</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 获取失败，自旋获取同步状态</span></span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>其中<code>doAcquireShared</code>以自旋方式获取同步状态，共享式获取同步状态的标志是返回 &gt;= 0 的值表示获取成功，该方法不响应中断，与独占式相似；</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="comment">// 共享式节点</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 这里和前面一样，也是通过有限次自旋的方式获取同步状态</span></span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="comment">// 前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 前驱是头结点，其类型可能是 EXCLUSIVE，也可能是 SHARED.</span></span><br><span class="line"><span class="comment">             * 如果是 EXCLUSIVE，线程无法获取共享同步状态。</span></span><br><span class="line"><span class="comment">             * 如果是 SHARED，线程则可获取共享同步状态。</span></span><br><span class="line"><span class="comment">             * 能不能获取共享同步状态要看 tryAcquireShared 具体的实现。比如多个线程竞争读写</span></span><br><span class="line"><span class="comment">             * 锁的中的读锁时，均能成功获取读锁。但多个线程同时竞争信号量时，可能就会有一部分线</span></span><br><span class="line"><span class="comment">             * 程因无法竞争到信号量资源而阻塞。</span></span><br><span class="line"><span class="comment">             */</span> </span><br><span class="line">            <span class="keyword">if</span> (p == head) {</span><br><span class="line">                <span class="comment">// 尝试获取同步状态</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) {</span><br><span class="line">                    <span class="comment">// 设置头结点，如果后继节点是共享类型，唤醒后继节点</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node))</span><br><span class="line">                interrupted |= parkAndCheckInterrupt();</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (interrupted)</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p><code>setHeadAndPropagate</code>这个函数主要做了两件事：</p>
<ol>
<li>在获取共享锁成功后，设置head节点</li>
<li>根据调用tryAcquireShared返回的状态以及节点本身的等待状态来判断是否要需要唤醒后继线程。</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>{</span><br><span class="line">    <span class="comment">// 把当前的head封闭在方法栈上，用以下面的条件检查。</span></span><br><span class="line">    Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Try to signal next queued node if:</span></span><br><span class="line"><span class="comment">     *   Propagation was indicated by caller,</span></span><br><span class="line"><span class="comment">     *     or was recorded (as h.waitStatus either before</span></span><br><span class="line"><span class="comment">     *     or after setHead) by a previous operation</span></span><br><span class="line"><span class="comment">     *     (note: this uses sign-check of waitStatus because</span></span><br><span class="line"><span class="comment">     *      PROPAGATE status may transition to SIGNAL.)</span></span><br><span class="line"><span class="comment">     * and</span></span><br><span class="line"><span class="comment">     *   The next node is waiting in shared mode,</span></span><br><span class="line"><span class="comment">     *     or we don't know, because it appears null</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The conservatism in both of these checks may cause</span></span><br><span class="line"><span class="comment">     * unnecessary wake-ups, but only when there are multiple</span></span><br><span class="line"><span class="comment">     * racing acquires/releases, so most need signals now or soon</span></span><br><span class="line"><span class="comment">     * anyway.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// propagate是tryAcquireShared的返回值，这是决定是否传播唤醒的依据之一。</span></span><br><span class="line">    <span class="comment">// h.waitStatus为SIGNAL或者PROPAGATE时也根据node的下一个节点共享来决定是否传播唤醒</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        <span class="comment">// h.waitStatus &lt; 0 时，waitStatus = SIGNAL 或 PROPAGATE。</span></span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) {</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="comment">// 节点 s 如果是共享类型节点，则应该唤醒该节点</span></span><br><span class="line">        <span class="comment">// 至于 s == null 的情况前面分析过，这里不在赘述。</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>那继续到<code>doReleaseShared</code>里面看看做了些什么：</p>
<p><code>doReleaseShared</code>该方法用于在 acquires/releases 存在竞争的情况下，确保唤醒动作向后传播。这是共享锁中的核心唤醒函数，主要做的事情就是唤醒下一个线程或者设置传播状态。后继线程被唤醒后，会尝试获取共享锁，如果成功之后，则又会调用setHeadAndPropagate,将唤醒传播下去。</p>
<p>总的来说：<u>这个函数的作用是保障在acquire和release存在竞争的情况下，保证队列中处于等待状态的节点能够有办法被唤醒。</u></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Release action for shared mode -- signals successor and ensures</span></span><br><span class="line"><span class="comment"> * propagation. (Note: For exclusive mode, release just amounts</span></span><br><span class="line"><span class="comment"> * to calling unparkSuccessor of head if it needs signal.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 以下的循环做的事情就是，在队列存在后继线程的情况下，唤醒后继线程；</span></span><br><span class="line"><span class="comment">     * 或者由于多线程同时释放共享锁由于处在中间过程，读到head节点等待状态为0的情况下，</span></span><br><span class="line"><span class="comment">     * 虽然不能unparkSuccessor，但为了保证唤醒能够正确稳固传递下去，设置节点状态为PROPAGATE。</span></span><br><span class="line"><span class="comment">     * 这样的话获取锁的线程在执行setHeadAndPropagate时可以读到PROPAGATE，从而由获取锁的线程去释放后继等待线程。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// 如果队列中存在后继线程。</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) {</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) {</span><br><span class="line">                <span class="keyword">if</span> (!h.compareAndSetWaitStatus(Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 如果h节点的状态为0，需要设置为PROPAGATE用以保证唤醒的传播。</span></span><br><span class="line">            <span class="comment">// setHeadAndPropagate 在读到 h.waitStatus &lt; 0 时，可以继续唤醒后面的节点。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !h.compareAndSetWaitStatus(<span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 检查h是否仍然是head，如果不是的话需要再进行循环。</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>最后说一下共享模式下获取同步状态的大致流程，如下：</p>
<ol>
<li>获取共享同步状态</li>
<li>若获取失败，则生成节点，并入队</li>
<li>如果前驱为头结点，再次尝试获取共享同步状态</li>
<li>获取成功则将自己设为头结点，如果后继节点是共享类型的，则唤醒</li>
<li>若失败，将节点状态设为 SIGNAL，再次尝试。若再次失败，线程进入等待状态</li>
</ol>
<hr>
<h3 id="3-2-2-共享状态释放：releaseShared"><a href="#3-2-2-共享状态释放：releaseShared" class="headerlink" title="3.2.2 共享状态释放：releaseShared"></a>3.2.2 共享状态释放：releaseShared</h3><p>释放共享状态主要逻辑在 doReleaseShared ，而我们前面已经分析过他了，所以就不继续了。共享节点线程在获取同步状态和释放同步状态时都会调用 doReleaseShared，所以 doReleaseShared 是多线程竞争集中的地方。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) {</span><br><span class="line">        <span class="comment">// 因为可能会存在多个线程同时进行释放同步状态资源</span></span><br><span class="line">        <span class="comment">// 所以在doReleaseShared需要确保同步状态安全地成功释放，一般都是通过CAS和循环来完成的。</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<hr>
<h1 id="4-一些疑问"><a href="#4-一些疑问" class="headerlink" title="4.一些疑问"></a>4.一些疑问</h1><h2 id="4-1-插入节点时的代码顺序"><a href="#4-1-插入节点时的代码顺序" class="headerlink" title="4.1 插入节点时的代码顺序"></a>4.1 插入节点时的代码顺序</h2><p><code>addWaiter</code> 方法中新增一个节点时为什么要先将新节点的prev置为tail再尝试CAS，而不是CAS成功后来构造节点之间的双向链接？</p>
<p>这是因为，双向链表目前没有基于CAS原子插入的手段，如果我们将<code>node.prev = t</code>和<code>t.next = node</code>（t为方法执行时读到的tail，引用封闭在栈上）放到<code>compareAndSetTail(t, node)</code>成功后执行，如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (compareAndSetTail(t, node)) {</span><br><span class="line">   node.prev = t;</span><br><span class="line">   t.next = node;</span><br><span class="line">   <span class="keyword">return</span> t;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>会导致这一瞬间的tail也就是t的prev为null，这就使得这一瞬间队列处于一种不一致的中间状态。</p>
<h2 id="4-2-唤醒节点时为什么从tail向前遍历"><a href="#4-2-唤醒节点时为什么从tail向前遍历" class="headerlink" title="4.2 唤醒节点时为什么从tail向前遍历"></a>4.2 唤醒节点时为什么从tail向前遍历</h2><p>unparkSuccessor方法中为什么唤醒后继节点时要从tail向前查找最接近node的非取消节点，而不是直接从node向后找到第一个后break掉?</p>
<p>其实上面的注释中也解释得很清楚了，如果读到<code>s == null</code>，不代表node就为tail。</p>
<p>考虑如下场景：</p>
<ol>
<li>node某时刻为tail</li>
<li>有新线程通过addWaiter中的if分支或者enq方法添加自己</li>
<li>compareAndSetTail成功</li>
<li>此时这里的Node s = node.next读出来s == null，<strong>但事实上node已经不是tail，它有后继了!</strong></li>
</ol>
<h2 id="4-3-AQS如何保证队列活跃"><a href="#4-3-AQS如何保证队列活跃" class="headerlink" title="4.3 AQS如何保证队列活跃"></a>4.3 AQS如何保证队列活跃</h2><p>AQS如何保证在节点释放的同时又有新节点入队的情况下，不出现原持锁线程释放锁，后继线程被自己阻塞死的情况,保持同步队列的活跃？</p>
<p>回答这个问题，需要理解<code>shouldParkAfterFailedAcquire</code>和<code>unparkSuccessor</code>这两个方法。</p>
<ul>
<li>以独占锁为例，后继争用线程阻塞自己的情况是读到前驱节点的等待状态为SIGNAL,只要不是这种情况都会再试着去争取锁。假设后继线程读到了前驱状态为SIGNAL，说明之前在tryAcquire的时候，前驱持锁线程还没有tryRelease完全释放掉独占锁。</li>
<li>此时如果前驱线程完全释放掉了独占锁，则在<code>unparkSuccessor</code>中还没执行完置<code>waitStatus</code>为0的操作，也就是还没执行到下面唤醒后继线程的代码，否则后继线程会再去争取锁。那么就算后继争用线程此时把自己阻塞了，也一定会马上被前驱线程唤醒。</li>
<li>那么是否可能持锁线程执行唤醒后继线程的逻辑时，后继线程读到前驱等待状态为SIGNAL把自己给阻塞，再也无法苏醒呢？</li>
<li>确实可能在扫描后继需要唤醒线程时读不到新来的线程，但只要<code>tryRelease</code>语义实现正确，在true时表示完全释放独占锁，则后继线程理应能够<code>tryAcquire</code>成功，<code>shouldParkAfterFailedAcquire</code>在读到前驱状态不为<code>SIGNAL</code>会给当前线程再一次获取锁的机会的。</li>
</ul>
<h2 id="4-4-AQS如何防止内存泄露"><a href="#4-4-AQS如何防止内存泄露" class="headerlink" title="4.4 AQS如何防止内存泄露"></a>4.4 AQS如何防止内存泄露</h2><p>AQS维护了一个FIFO队列，它是如何保证在运行期间不发生内存泄露的？</p>
<p>AQS在无竞争条件下，甚至都不会new出head和tail节点。线程成功获取锁时设置head节点的方法为setHead，由于头节点的thread并不重要，此时会置node的thread和prev为null，完了之后还会置原先head也就是线程对应node的前驱的next为null，从而实现队首元素的安全移出。而在取消节点时，也会令<code>node.thread = null</code>，在node不为tail的情况下，会使<code>node.next = node</code>（之所以这样也是为了<code>isOnSyncQueue</code>实现更加简洁）</p>
<hr>
<h1 id="5小结"><a href="#5小结" class="headerlink" title="5小结"></a>5小结</h1><p>在并发环境下，加锁和解锁需要以下三个部件的协调：</p>
<ol>
<li>锁状态。我们要知道锁是不是被别的线程占有了，这个就是 state 的作用，它为 0 的时候代表没有线程占有锁，可以去争抢这个锁，用 CAS 将 state 设为 1，如果 CAS 成功，说明抢到了锁，这样其他线程就抢不到了，如果锁重入的话，state进行 +1 就可以，解锁就是减 1，直到 state 又变为 0，代表释放锁，所以 lock() 和 unlock() 必须要配对啊。然后唤醒等待队列中的第一个线程，让其来占有锁。</li>
<li>线程的阻塞和解除阻塞。AQS 中采用了 LockSupport.park(thread) 来挂起线程，用 unpark 来唤醒线程。</li>
<li>阻塞队列。因为争抢锁的线程可能很多，但是只能有一个线程拿到锁，其他的线程都必须等待，这个时候就需要一个 queue 来管理这些线程，AQS 用的是一个 FIFO 的队列，就是一个链表，每个 node 都持有后继节点的引用。AQS 采用了 CLH 锁的变体来实现。</li>
</ol>
<p>用了好几天，看了很多博客还有翻了一些书，对着JDK源码一点一点的抠了出来上面的这些阅读理解，感觉这个源码还是有些难度，还是需要时不时的回头看看，其实主要就分为独占式和共享式，然后各有没有完成的方法需要继承AQS的子类去完成，要对大致的状态获取、状态释放有所了解，这些会比较重要点，对那几个状态需要多了解了解是什么个意思，一般会出现在什么情况，感觉看了一些源码之后，发现这些源码中的状态位其实很重要，每个方法都伴随着状态位的改变，通过状态位可以了解到很多内部细节，最后还是说分析得太烂，以后又有认识之后一定要把上面这个重新整理一遍，还是不太深刻，盲人摸象，只了解到了一小部分罢了。</p>
<hr>
<p>以上参考：</p>
<ol>
<li><a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer" target="_blank" rel="noopener">一行一行源码分析清楚AbstractQueuedSynchronizer</a></li>
<li><a href="http://cmsblogs.com/?p=2174" target="_blank" rel="noopener">【死磕Java并发】—–J.U.C之AQS：AQS简介</a></li>
<li><a href="http://www.tianxiaobo.com/2018/05/01/AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-%E7%8B%AC%E5%8D%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F/#41-%E8%8A%82%E7%82%B9%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">AbstractQueuedSynchronizer 原理分析 - 独占/共享模式</a></li>
<li><a href="https://www.cnblogs.com/showing/p/6858410.html" target="_blank" rel="noopener">JDK源码之AQS源码剖析</a></li>
<li><a href="https://www.cnblogs.com/micrari/p/6937995.html" target="_blank" rel="noopener">AbstractQueuedSynchronizer源码解读</a></li>
<li><a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html" target="_blank" rel="noopener">从ReentrantLock的实现看AQS的原理及应用</a></li>
<li>书籍：Java并发编程的艺术</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag"># 并发</a>
              <a href="/tags/AQS/" rel="tag"># AQS</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2020/03/10/java-ji-he-kuang-jia-hashmap-ren-shi-yu-li-jie/" rel="next" title="Java 集合框架 - HashMap 认识与理解">
      Java 集合框架 - HashMap 认识与理解 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-介绍AQS"><span class="nav-text">1.介绍AQS</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-AQS理论的数据结构"><span class="nav-text">2.AQS理论的数据结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-源码分析"><span class="nav-text">3.源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-独占模式"><span class="nav-text">3.1 独占模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-1-独占式同步状态获取：acquire"><span class="nav-text">3.1.1 独占式同步状态获取：acquire</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#tryAcquire-int"><span class="nav-text">tryAcquire(int)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#addWaiter-Node"><span class="nav-text">addWaiter(Node)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#acquireQueued-Node-int"><span class="nav-text">acquireQueued(Node, int)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#selfInterrupt"><span class="nav-text">selfInterrupt</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小结"><span class="nav-text">小结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例分析："><span class="nav-text">示例分析：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-2-独占式获取响应中断"><span class="nav-text">3.1.2 独占式获取响应中断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-3-独占式超时获取"><span class="nav-text">3.1.3 独占式超时获取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-4-独占式同步状态释放：release"><span class="nav-text">3.1.4 独占式同步状态释放：release</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-共享模式"><span class="nav-text">3.2 共享模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-同步状态获取：acquireShared"><span class="nav-text">3.2.1 同步状态获取：acquireShared</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-共享状态释放：releaseShared"><span class="nav-text">3.2.2 共享状态释放：releaseShared</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-一些疑问"><span class="nav-text">4.一些疑问</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-插入节点时的代码顺序"><span class="nav-text">4.1 插入节点时的代码顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-唤醒节点时为什么从tail向前遍历"><span class="nav-text">4.2 唤醒节点时为什么从tail向前遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-AQS如何保证队列活跃"><span class="nav-text">4.3 AQS如何保证队列活跃</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-AQS如何防止内存泄露"><span class="nav-text">4.4 AQS如何防止内存泄露</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5小结"><span class="nav-text">5小结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Garmen Lee"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Garmen Lee</p>
  <div class="site-description" itemprop="description">杂货铺售卖知识 诸位自取</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Garmen Lee</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">230k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">3:29</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>

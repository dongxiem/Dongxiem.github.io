<!DOCTYPE html>


<html lang="en" >


<head>
  <meta charset="utf-8" />
    
  <meta name="description" content="Blog for take some note" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    Java 并发 - Synchronized 原理分析 |  桃花岛杂货铺
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/garmen.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

<link rel="alternate" href="/atom.xml" title="桃花岛杂货铺" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    <main class="content on">
      <section class="outer">
  <article id="post-Java 并发 - Synchronized 原理分析" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Java 并发 - Synchronized 原理分析
</h1>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/31/Java%20%E5%B9%B6%E5%8F%91%20-%20Synchronized%20%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2020-03-31T09:16:59.531Z" itemprop="datePublished">2020-03-31</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%B9%B6%E5%8F%91/">Java并发</a>
  </div>

      
      
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">7.2k字</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">26分钟</span>
        </span>
    </span>
</div>

      
    </div>
    

    
    
    <div class="tocbot"></div>





    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><p>JDK1.6 之后 Synchronized  的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。</p>
<p>Java中的<code>synchronized</code> 的偏向锁、轻量级锁、重量级锁三种形式，分别对应了锁只被一个线程持有、不同线程交替持有锁、多线程竞争锁三种情况。当条件不满足时，锁会按偏向锁-&gt;轻量级锁-&gt;重量级锁 的顺序升级。JVM种的锁也是能降级的，只不过条件很苛刻，可以相当于没有了，策略是为了提高获得锁和释放锁的效率。</p>
<p>所以对Synchronized 的重点分析应该是其升级流程，以前是我觉得So easy，不就这几个状态升上去而已，不过在某天看了 <a href="https://github.com/farmerjohngit/myblog/issues/12" target="_blank" rel="noopener">死磕Synchronized底层实现</a> 之后，发现我还是太嫩了，这才是真正的深入，也许对知识的求知就该如此不断的进行深入，对于Synchronized 还是有很多值得发现的知识，以下记录了学习到的一些笔记，大概对一整个锁的升级流程有了一些认识和了解。</p>
<ul>
<li>锁升级的过程可以具体看该图，大致的流程框架图很清晰（文末已注明出处）</li>
</ul>
<p><img src="https://i.loli.net/2020/03/31/nCGAmlfKqzhjdv1.png" alt="Synchronized锁升级流程图"></p>
<h1 id="2-Synchronized-锁升级流程分析"><a href="#2-Synchronized-锁升级流程分析" class="headerlink" title="2.Synchronized 锁升级流程分析"></a>2.Synchronized 锁升级流程分析</h1><h2 id="2-1-偏向锁"><a href="#2-1-偏向锁" class="headerlink" title="2.1 偏向锁"></a>2.1 <strong>偏向锁</strong></h2><ul>
<li><p><strong>目的：</strong>引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径。但是不同是：轻量级锁在无竞争的情况下使用 <code>CAS</code> 操作去代替使用互斥量，而偏向锁在无竞争的情况下会把整个同步都消除掉。那么偏向锁是如何来减少不必要的<code>CAS</code>操作呢？我们可以查看<code>Mark work</code>的结构就明白了。只需要检查是否为偏向锁、锁标识为以及<code>ThreadID</code>即可。</p>
</li>
<li><ul>
<li>注意：Java并发编程的艺术中是这么讲的：HotSpot[1]的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。</li>
</ul>
</li>
<li><p><strong>定义：</strong>偏向锁的“偏”就是偏心的偏，它的意思是会偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步！关于偏向锁的原理可以查看《深入理解Java虚拟机：JVM高级特性与最佳实践》第二版的13章第三节锁优化。当<code>JVM</code>启用了偏向锁模式（<code>JDK6</code>以上默认开启），新创建对象的Mark Word中的<code>Thread Id</code>为0，说明此时处于可偏向但未偏向任何线程，也叫<strong>做匿名偏向状态(anonymously biased)。</strong></p>
</li>
<li><p><strong>适用场合：</strong>但是对于锁竞争比较激烈的场合，偏向锁就失效了，<strong>因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失</strong>，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。</p>
</li>
<li><p><strong>关闭偏向锁：</strong>偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用<code>JVM</code>参数来关闭延迟：<code>-XX:BiasedLockingStartupDelay</code>=0。如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过<code>JVM</code>参数关闭偏向锁：<code>-XX:-UseBiasedLocking</code>=false，那么程序默认会进入轻量级锁状态。</p>
</li>
</ul>
<h3 id="2-1-1-Mark-Work-结构"><a href="#2-1-1-Mark-Work-结构" class="headerlink" title="2.1.1 Mark Work 结构"></a>2.1.1 Mark Work 结构</h3><p>关于<code>Mark work</code>结构，可以在任何一本关于Java内存结构的书中了解到很详细了，我们主要关注的是下面的几个字段：<code>thread id</code>、lock flag、biased lock flag。</p>
<p><img src="https://i.loli.net/2020/03/31/tBr7NFPumz63acj.png" alt="image.png"></p>
<h3 id="2-1-2-对象创建"><a href="#2-1-2-对象创建" class="headerlink" title="2.1.2 对象创建"></a>2.1.2 对象创建</h3><p>当 <code>JVM</code> 启用了偏向锁模式（1.6以上默认开启），当新创建一个对象的时候，如果该对象所属的class没有关闭偏向锁模式（默认所有class的偏向模式都是是开启的），那新创建对象的<code>mark word</code>将是可偏向状态，此时mark word中的thread id（参见上文偏向状态下的<code>mark word</code>格式）为0，表示未偏向任何线程，也叫做<u>匿名偏向(anonymously biased)</u>。</p>
<h3 id="2-1-3-偏向锁加锁"><a href="#2-1-3-偏向锁加锁" class="headerlink" title="2.1.3 偏向锁加锁"></a>2.1.3 偏向锁加锁</h3><p>对于偏向锁的加锁，主要分为三种不同情况来看：</p>
<ul>
<li><code>case 1</code>：当该对象第一次被线程获得锁的时候，发现是匿名偏向状态（可偏向未锁定），则会用CAS指令，将<code>mark word</code>中的<code>thread id</code>由0改成当前线程Id。如果成功，则代表获得了偏向锁，继续执行同步块中的代码。否则，即<code>CAS</code>竞争锁失败，对象锁已经被其他线程占用，证明当前存在多线程竞争情况，当到达全局安全点（即为<code>safepoint</code>，<code>safepoint</code>是什么可以具体参考这篇文章：<a href="https://blog.csdn.net/iter_zc/article/details/41847887" target="_blank" rel="noopener">聊聊JVM（六）理解JVM的safepoint</a>），将偏向锁撤销，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块；</li>
<li><code>case 2</code>：当被偏向的线程再次进入同步块时，发现锁对象偏向的就是当前线程（对象头Mark Word中Thread Id是当前线程ID），在通过一些额外的检查后（细节见后面的文章），会往当前线程的栈中添加一条Displaced Mark Word为空的Lock Record中，用来统计重入的次数（如图为当对象所处于偏向锁时，当前线程重入3次，线程栈帧中Lock Record记录）。然后继续执行同步块的代码，因为操纵的是线程私有的栈，因此不需要用到CAS指令；由此可见偏向锁模式下，当被偏向的线程再次尝试获得锁时，仅仅进行几个简单的操作就可以了，在这种情况下，synchronized关键字带来的性能开销基本可以忽略。<ul>
<li><img src="https://i.loli.net/2020/03/31/AtEPUg6GSiOurk3.png" alt="线程栈帧"></li>
</ul>
</li>
<li>case 3.当其他线程进入同步块时，发现已经有偏向的线程了，则会进入到撤销偏向锁的逻辑里，一般来说，会在<code>safepoint</code>中去查看偏向的线程是否还存活，如果存活且还在同步块中则将锁升级为轻量级锁，原偏向的线程继续拥有锁，当前线程则走入到锁升级的逻辑里；如果偏向的线程已经不存活或者不在同步块中，则将对象头的<code>mark word</code>改为无锁状态（<code>unlocked</code>），之后再升级为轻量级锁。</li>
</ul>
<p>由此可见，偏向锁升级的时机为：当锁已经发生偏向后，只要有另一个线程尝试获得偏向锁，则该偏向锁就会升级成轻量级锁。当然这个说法不绝对，因为还有批量重偏向这一机制。</p>
<h3 id="2-1-4-偏向锁解锁"><a href="#2-1-4-偏向锁解锁" class="headerlink" title="2.1.4 偏向锁解锁"></a>2.1.4 偏向锁解锁</h3><p>当有其他线程尝试获得锁时，是根据遍历偏向线程的<code>lock record</code>来确定该线程是否还在执行同步块中的代码。因此偏向锁的解锁很简单，仅仅将栈中的最近一条<code>lock record</code>的obj字段设置为null。需要注意的是，偏向锁的解锁步骤中并不会修改对象头中的<code>thread id</code>。</p>
<h3 id="2-1-5-偏向锁获取锁"><a href="#2-1-5-偏向锁获取锁" class="headerlink" title="2.1.5 偏向锁获取锁"></a>2.1.5 偏向锁获取锁</h3><p><strong>取自Java并发编程的艺术：</strong></p>
<ol>
<li>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行<code>CAS</code>操作来加锁和解锁，只需简单地测试一下对象头的<code>Mark Word</code>里是否存储着指向当前线程的偏向锁。</li>
<li>如果测试成功，表示线程已经获得了锁。</li>
<li>如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS<code>竞争</code>锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程</li>
</ol>
<p>网上参考了很多文章，发现说辞不一，十分混乱，大部分都各持己见，这让我看得很晕乎，于是还是更相信底层代码的逻辑，查看官方提供给的 JVM 底层C++代码： <a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/interpreter/bytecodeInterpreter.cpp#l1816" target="_blank" rel="noopener">bytecodeInterpreter.cpp#1816</a>，结合 <a href="https://github.com/farmerjohngit/myblog" target="_blank" rel="noopener">farmerjohngit</a> 大佬所给的一些解释，可以对整个底层实现有更加深刻的理解。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">CASE(_monitorenter): &#123;</span><br><span class="line">  <span class="comment">// lockee 就是锁对象</span></span><br><span class="line">  oop lockee = STACK_OBJECT(<span class="number">-1</span>);</span><br><span class="line">  <span class="comment">// derefing's lockee ought to provoke implicit null check</span></span><br><span class="line">  CHECK_NULL(lockee);</span><br><span class="line">  <span class="comment">// code 1：找到一个空闲的Lock Record</span></span><br><span class="line">  BasicObjectLock* limit = istate-&gt;monitor_base();</span><br><span class="line">  BasicObjectLock* most_recent = (BasicObjectLock*) istate-&gt;stack_base();</span><br><span class="line">  BasicObjectLock* entry = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">while</span> (most_recent != limit ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (most_recent-&gt;obj() == <span class="literal">NULL</span>) entry = most_recent;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (most_recent-&gt;obj() == lockee) <span class="keyword">break</span>;</span><br><span class="line">    most_recent++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//entry不为null，代表还有空闲的Lock Record</span></span><br><span class="line">  <span class="keyword">if</span> (entry != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// code 2：将Lock Record的obj指针指向锁对象</span></span><br><span class="line">    entry-&gt;set_obj(lockee);</span><br><span class="line">    <span class="keyword">int</span> success = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">uintptr_t</span> epoch_mask_in_place = (<span class="keyword">uintptr_t</span>)markOopDesc::epoch_mask_in_place;</span><br><span class="line">	<span class="comment">// markoop即对象头的mark word</span></span><br><span class="line">    markOop mark = lockee-&gt;mark();</span><br><span class="line">    <span class="keyword">intptr_t</span> hash = (<span class="keyword">intptr_t</span>) markOopDesc::no_hash;</span><br><span class="line">    <span class="comment">// code 3：如果锁对象的mark word的状态是偏向模式</span></span><br><span class="line">    <span class="keyword">if</span> (mark-&gt;has_bias_pattern()) &#123;</span><br><span class="line">      <span class="keyword">uintptr_t</span> thread_ident;</span><br><span class="line">      <span class="keyword">uintptr_t</span> anticipated_bias_locking_value;</span><br><span class="line">      thread_ident = (<span class="keyword">uintptr_t</span>)istate-&gt;thread();</span><br><span class="line">     <span class="comment">// code 4：这里有几步操作，下文分析</span></span><br><span class="line">      anticipated_bias_locking_value =</span><br><span class="line">        (((<span class="keyword">uintptr_t</span>)lockee-&gt;klass()-&gt;prototype_header() | thread_ident) ^ (<span class="keyword">uintptr_t</span>)mark) &amp;</span><br><span class="line">        ~((<span class="keyword">uintptr_t</span>) markOopDesc::age_mask_in_place);</span><br><span class="line">	 <span class="comment">// code 5：如果偏向的线程是自己且epoch等于class的epoch</span></span><br><span class="line">      <span class="keyword">if</span>  (anticipated_bias_locking_value == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// already biased towards this thread, nothing to do</span></span><br><span class="line">        <span class="keyword">if</span> (PrintBiasedLockingStatistics) &#123;</span><br><span class="line">          (* BiasedLocking::biased_lock_entry_count_addr())++;</span><br><span class="line">        &#125;</span><br><span class="line">        success = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">// code 6：如果偏向模式关闭，则尝试撤销偏向锁</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((anticipated_bias_locking_value &amp; markOopDesc::biased_lock_mask_in_place) != <span class="number">0</span>) &#123;</span><br><span class="line">        markOop header = lockee-&gt;klass()-&gt;prototype_header();</span><br><span class="line">        <span class="keyword">if</span> (hash != markOopDesc::no_hash) &#123;</span><br><span class="line">          header = header-&gt;copy_set_hash(hash);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 利用CAS操作将mark word替换为class中的mark word</span></span><br><span class="line">        <span class="keyword">if</span> (Atomic::cmpxchg_ptr(header, lockee-&gt;mark_addr(), mark) == mark) &#123;</span><br><span class="line">          <span class="keyword">if</span> (PrintBiasedLockingStatistics)</span><br><span class="line">            (*BiasedLocking::revoked_lock_entry_count_addr())++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">         <span class="comment">// code 7：如果epoch不等于class中的epoch，则尝试重偏向</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((anticipated_bias_locking_value &amp; epoch_mask_in_place) !=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 构造一个偏向当前线程的mark word</span></span><br><span class="line">        markOop new_header = (markOop) ( (<span class="keyword">intptr_t</span>) lockee-&gt;klass()-&gt;prototype_header() | thread_ident);</span><br><span class="line">        <span class="keyword">if</span> (hash != markOopDesc::no_hash) &#123;</span><br><span class="line">          new_header = new_header-&gt;copy_set_hash(hash);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// CAS替换对象头的mark word  </span></span><br><span class="line">        <span class="keyword">if</span> (Atomic::cmpxchg_ptr((<span class="keyword">void</span>*)new_header, lockee-&gt;mark_addr(), mark) == mark) &#123;</span><br><span class="line">          <span class="keyword">if</span> (PrintBiasedLockingStatistics)</span><br><span class="line">            (* BiasedLocking::rebiased_lock_entry_count_addr())++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 重偏向失败，代表存在多线程竞争，则调用monitorenter方法进行锁升级</span></span><br><span class="line">          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);</span><br><span class="line">        &#125;</span><br><span class="line">        success = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 走到这里说明当前要么偏向别的线程，要么是匿名偏向（即没有偏向任何线程）</span></span><br><span class="line">       	<span class="comment">// code 8：下面构建一个匿名偏向的mark word，尝试用CAS指令替换掉锁对象的mark word</span></span><br><span class="line">        markOop header = (markOop) ((<span class="keyword">uintptr_t</span>) mark &amp; ((<span class="keyword">uintptr_t</span>)markOopDesc::biased_lock_mask_in_place |(<span class="keyword">uintptr_t</span>)markOopDesc::age_mask_in_place |epoch_mask_in_place));</span><br><span class="line">        <span class="keyword">if</span> (hash != markOopDesc::no_hash) &#123;</span><br><span class="line">          header = header-&gt;copy_set_hash(hash);</span><br><span class="line">        &#125;</span><br><span class="line">        markOop new_header = (markOop) ((<span class="keyword">uintptr_t</span>) header | thread_ident);</span><br><span class="line">        <span class="comment">// debugging hint</span></span><br><span class="line">        DEBUG_ONLY(entry-&gt;lock()-&gt;set_displaced_header((markOop) (<span class="keyword">uintptr_t</span>) <span class="number">0xdeaddead</span>);)</span><br><span class="line">        <span class="keyword">if</span> (Atomic::cmpxchg_ptr((<span class="keyword">void</span>*)new_header, lockee-&gt;mark_addr(), header) == header) &#123;</span><br><span class="line">           <span class="comment">// CAS修改成功</span></span><br><span class="line">          <span class="keyword">if</span> (PrintBiasedLockingStatistics)</span><br><span class="line">            (* BiasedLocking::anonymously_biased_lock_entry_count_addr())++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 如果修改失败说明存在多线程竞争，所以进入monitorenter方法</span></span><br><span class="line">          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);</span><br><span class="line">        &#125;</span><br><span class="line">        success = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果偏向线程不是当前线程或没有开启偏向模式等原因都会导致success==false</span></span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">      <span class="comment">// 轻量级锁的逻辑</span></span><br><span class="line">      <span class="comment">//code 9: 构造一个无锁状态的Displaced Mark Word，并将Lock Record的lock指向它</span></span><br><span class="line">      markOop displaced = lockee-&gt;mark()-&gt;set_unlocked();</span><br><span class="line">      entry-&gt;lock()-&gt;set_displaced_header(displaced);</span><br><span class="line">      <span class="comment">//如果指定了-XX:+UseHeavyMonitors，则call_vm=true，代表禁用偏向锁和轻量级锁</span></span><br><span class="line">      <span class="keyword">bool</span> call_vm = UseHeavyMonitors;</span><br><span class="line">      <span class="comment">// 利用CAS将对象头的mark word替换为指向Lock Record的指针</span></span><br><span class="line">      <span class="keyword">if</span> (call_vm || Atomic::cmpxchg_ptr(entry, lockee-&gt;mark_addr(), displaced) != displaced) &#123;</span><br><span class="line">        <span class="comment">// 判断是不是锁重入</span></span><br><span class="line">        <span class="keyword">if</span> (!call_vm &amp;&amp; THREAD-&gt;is_lock_owned((address) displaced-&gt;clear_lock_bits())) &#123;		<span class="comment">//code 10: 如果是锁重入，则直接将Displaced Mark Word设置为null</span></span><br><span class="line">          entry-&gt;lock()-&gt;set_displaced_header(<span class="literal">NULL</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    UPDATE_PC_AND_TOS_AND_CONTINUE(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// lock record不够，重新执行</span></span><br><span class="line">    istate-&gt;set_msg(more_monitors);</span><br><span class="line">    UPDATE_PC_AND_RETURN(<span class="number">0</span>); <span class="comment">// Re-execute</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>JVM中的每个类也有一个类似mark word的prototype_header，用来标记该class的epoch和偏向开关等信息。上面的代码中<code>lockee-&gt;klass()-&gt;prototype_header()</code>即获取class的prototype_header。</p>
<p><code>code 1</code></p>
<ul>
<li>从当前线程的栈中找到一个空闲的<code>Lock Record</code>（<strong>即代码中的BasicObjectLock，下文都用Lock Record代指</strong>），判断<code>Lock Record</code>是否空闲的依据是其obj字段 是否为null。注意这里是按内存地址从低往高找到最后一个可用的<code>Lock Record</code>，换而言之，就是找到内存地址最高的可用<code>Lock Record</code>。</li>
</ul>
<p><code>code 2</code></p>
<ul>
<li>获取到<code>Lock Record</code>后，首先要做的就是为其obj字段赋值。</li>
</ul>
<p><code>code 3</code></p>
<ul>
<li>判断锁对象的<code>mark word</code>是否是偏向模式，即低3位是否为101。</li>
</ul>
<p><code>code 4</code></p>
<ul>
<li>这里有几步位运算的操作<code>anticipated_bias_locking_value = (((uintptr_t)lockee-&gt;klass()-&gt;prototype_header() | thread_ident) ^ (uintptr_t)mark) &amp;  ~((uintptr_t) markOopDesc::age_mask_in_place);</code> 这个位运算可以分为3个部分。<ul>
<li>第一部分<code>((uintptr_t)lockee-&gt;klass()-&gt;prototype_header() | thread_ident)</code> 将当前线程id和类的prototype_header相或，这样得到的值为（当前线程id + prototype_header中的（epoch + 分代年龄 + 偏向锁标志 + 锁标志位）），注意prototype_header的分代年龄那4个字节为0</li>
<li>第二部分 <code>^ (uintptr_t)mark</code> 将上面计算得到的结果与锁对象的markOop进行异或，相等的位全部被置为0，只剩下不相等的位。</li>
<li>第三部分 <code>&amp; ~((uintptr_t) markOopDesc::age_mask_in_place)</code> markOopDesc::age_mask_in_place为…0001111000,取反后，变成了…1110000111,除了分代年龄那4位，其他位全为1；将取反后的结果再与上面的结果相与，将上面异或得到的结果中分代年龄给忽略掉。</li>
</ul>
</li>
</ul>
<p><code>code 5</code></p>
<ul>
<li><code>anticipated_bias_locking_value==0</code>代表偏向的线程是当前线程且<code>mark word</code>的epoch等于class的epoch，这种情况下什么都不用做。</li>
</ul>
<p><code>code 6</code></p>
<ul>
<li><p><code>(anticipated_bias_locking_value &amp; markOopDesc::biased_lock_mask_in_place) != 0</code>代表class的prototype_header或对象的<code>mark word</code>中偏向模式是关闭的，又因为能走到这已经通过了<code>mark-&gt;has_bias_pattern()</code>判断，即对象的<code>mark word</code>中偏向模式是开启的，那也就是说class的prototype_header不是偏向模式。</p>
</li>
<li><p>然后利用<code>CAS</code>指令<code>Atomic::cmpxchg_ptr(header, lockee-&gt;mark_addr(), mark) == mark</code>撤销偏向锁，我们知道<code>CAS</code>会有几个参数，1是预期的原值，2是预期修改后的值 ，3是要修改的对象，与之对应，<code>cmpxchg_ptr</code>方法第一个参数是预期修改后的值，第2个参数是修改的对象，第3个参数是预期原值，方法返回实际原值，如果等于预期原值则说明修改成功。</p>
</li>
</ul>
<p><code>code 7</code></p>
<ul>
<li>如果epoch已过期，则需要重偏向，利用CAS指令将锁对象的<code>mark word</code>替换为一个偏向当前线程且epoch为类的epoch的新的<code>mark word</code>。</li>
</ul>
<p><code>code 8</code></p>
<ul>
<li>CAS将偏向线程改为当前线程，如果当前是匿名偏向则能修改成功，否则进入锁升级的逻辑。</li>
</ul>
<p><code>code 9</code></p>
<ul>
<li>这一步已经是轻量级锁的逻辑了。从上图的<code>mark word</code>的格式可以看到，轻量级锁中<code>mark word</code>存的是指向<code>Lock Record</code>的指针。这里构造一个无锁状态的<code>mark word</code>，然后存储到<code>Lock Record</code>（<code>Lock Record</code>的格式可以看第一篇文章）。设置<code>mark word</code>是无锁状态的原因是：轻量级锁解锁时是将对象头的<code>mark word</code>设置为<code>Lock Record</code>中的<code>Displaced Mark Word</code>，所以创建时设置为无锁状态，解锁时直接用CAS替换就好了。</li>
</ul>
<p><code>code 10</code></p>
<ul>
<li>如果是锁重入，则将<code>Lock Record</code>的<code>Displaced Mark Word</code>设置为null，起到一个锁重入计数的作用。</li>
</ul>
<p>通过这部分代码，其实可以对偏向锁加锁的流程（包括部分轻量级锁的加锁流程）有一定的认识了，如果当前锁已偏向其他线程||epoch值过期||偏向模式关闭||获取偏向锁的过程中存在并发冲突，都会进入到<code>InterpreterRuntime::monitorenter</code>方法， 在该方法中会对偏向锁撤销和升级。</p>
<h3 id="2-1-6-偏向锁释放"><a href="#2-1-6-偏向锁释放" class="headerlink" title="2.1.6 偏向锁释放"></a>2.1.6 偏向锁释放</h3><p>偏向锁的释放入口：<a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/interpreter/bytecodeInterpreter.cpp#l1923" target="_blank" rel="noopener">bytecodeInterpreter.cpp#1923</a></p>
<p>上面的代码结合注释理解起来应该不难，偏向锁的释放很简单，只要将对应Lock Record释放就好了，而轻量级锁则需要将Displaced Mark Word替换到对象头的mark word中。如果CAS失败或者是重量级锁则进入到<code>InterpreterRuntime::monitorexit</code>方法中。</p>
<ul>
<li>注意：撤销是指在获取偏向锁的过程因为不满足条件导致要将锁对象改为非偏向锁状态；释放是指退出同步块时的过程</li>
</ul>
<h3 id="2-1-7-偏向锁撤销"><a href="#2-1-7-偏向锁撤销" class="headerlink" title="2.1.7 偏向锁撤销"></a>2.1.7 偏向锁撤销</h3><p>偏向锁的撤销采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）。其步骤如下：</p>
<ol>
<li>暂停拥有偏向锁的线程，检查持有偏向锁的线程状态（遍历当前<code>JVM</code>的所有线程，如果能找到，则说明偏向的线程还存活）；<code>JVM</code>维护了一个集合存放所有存活的线程，通过遍历该集合判断某个线程是否存活。</li>
<li>如果线程还存活，则检查线程是否在执行同步代码块中的代码，如果是，则升级为轻量级锁，进行CAS竞争锁；<ul>
<li>注：每次进入同步块（即执行<code>monitorenter</code>）的时候都会以从高往低的顺序在栈中找到第一个可用的<code>Lock Record</code>，并设置偏向线程ID；每次解锁（即执行<code>monitorexit</code>）的时候都会从最低的一个<code>Lock Record</code>移除。所以如果能找到对应的Lock Record说明偏向的线程还在执行同步代码块中的代码。</li>
</ul>
</li>
<li>如果持有偏向锁的线程未存活，或者持有偏向锁的线程未在执行同步代码块中的代码，则进行校验是否允许重偏向：<ul>
<li>如果不允许重偏向，则撤销偏向锁，将<code>Mark Word</code>设置为无锁状态（未锁定不可偏向状态），然后升级为轻量级锁，进行CAS<code>竞争</code>锁；</li>
<li>如果允许重偏向，设置为匿名偏向锁状态,<code>CAS</code>将偏向锁重新指向线程A（在对象头和线程栈帧的锁记录中存储当前线程ID）；</li>
</ul>
</li>
<li>唤醒暂停的线程，从安全点继续执行代码。</li>
</ol>
<p>偏向锁撤销的具体流程如下所示：</p>
<p><img src="https://i.loli.net/2020/03/31/EUIOaiTgNluLqzw.png" alt="偏向锁撤销流程图"></p>
<p>偏向锁撤销的具体底层代码分析如下：</p>
<h3 id="2-1-8-批量重偏向与撤销"><a href="#2-1-8-批量重偏向与撤销" class="headerlink" title="2.1.8 批量重偏向与撤销"></a>2.1.8 批量重偏向与撤销</h3><p>JVM中还增加了一种批量重偏向/撤销的机制，主要是解决如下两种情况：</p>
<ol>
<li>重偏向（<code>bulk rebias</code>）机制解决的场景：一个线程创建了大量对象并执行了初始的同步操作，之后在另一个线程中将这些对象作为锁进行之后的操作。这种case下，会导致大量的偏向锁撤销操作。</li>
<li>批量撤销（<code>bulk revoke</code>）解决的场景：存在明显多线程竞争的场景下使用偏向锁是不合适的，例如生产者/消费者队列。</li>
</ol>
<h2 id="2-2-轻量级锁"><a href="#2-2-轻量级锁" class="headerlink" title="2.2 轻量级锁"></a>2.2 轻量级锁</h2><ul>
<li><strong>描述：</strong>倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)。== 轻量级锁不是为了代替重量级锁，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量。== 另外，轻量级锁的加锁和解锁都用到了CAS操作。 关于轻量级锁的加锁和解锁的原理可以查看《深入理解Java虚拟机：JVM高级特性与最佳实践》第二版的13章第三节锁优化。</li>
<li><strong>轻量级锁能够提升程序同步性能的依据：</strong>“对于绝大部分锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用 <code>CAS</code> 操作避免了使用互斥操作的开销。但如果存在锁竞争，除了互斥量开销外，还会额外发生<code>CAS</code>操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁！</li>
</ul>
<h3 id="2-2-1-轻量级锁获取锁"><a href="#2-2-1-轻量级锁获取锁" class="headerlink" title="2.2.1 轻量级锁获取锁"></a>2.2.1 轻量级锁获取锁</h3><p>其获取锁步骤如下：</p>
<ol>
<li>判断当前对象是否处于无锁状态（<code>hashcode</code>、0、01），若是，则JVM首先将在当前线程的栈帧中建立一个名为锁记录（<code>Lock Record</code>）的空间，用于存储锁对象目前的Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即<code>Displaced Mark Word</code>）；否则执行步骤（3）；</li>
<li><code>JVM</code>利用<code>CAS</code>操作尝试将对象的<code>Mark Word</code>更新为指向<code>Lock Record</code>的指正，如果成功表示竞争到锁，则将锁标志位变成00（表示此对象处于轻量级锁状态），执行同步操作；如果失败则执行步骤（3）；</li>
<li>判断当前对象的<code>Mark Word</code>是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态；</li>
</ol>
<p>栈帧 与 <code>Mark Work</code> 关系图示如下：</p>
<p><img src="https://i.loli.net/2020/03/31/pKTxoGV4clYetOL.png" alt="image.png"></p>
<p>整体流程图示如下：</p>
<p><img src="https://i.loli.net/2020/03/31/dCB5fQcuU49j3Pn.png" alt="image.png"></p>
<p>轻量级锁的锁获取源码：</p>
<h3 id="2-2-2-轻量级锁释放锁"><a href="#2-2-2-轻量级锁释放锁" class="headerlink" title="2.2.2 轻量级锁释放锁"></a>2.2.2 轻量级锁释放锁</h3><p>其释放锁步骤如下（轻量级锁的释放也是通过CAS操作来进行的）：</p>
<ol>
<li>取出在获取轻量级锁保存在<code>Displaced Mark Word</code>中的数据；</li>
<li>用<code>CAS</code>操作将取出的数据替换当前对象的<code>Mark Word</code>中，如果成功，则说明释放锁成功，否则执行（3）；</li>
<li>如果<code>CAS</code>操作替换失败，说明有其他线程尝试获取该锁，则需要在释放锁的同时需要唤醒被挂起的线程。</li>
</ol>
<p>其过程流程图如下所示：</p>
<p><img src="https://i.loli.net/2020/03/31/8WLE1HjunDXfxJO.png" alt="轻量级锁释放锁.png"></p>
<h3 id="2-2-3-轻量级锁膨胀"><a href="#2-2-3-轻量级锁膨胀" class="headerlink" title="2.2.3 轻量级锁膨胀"></a>2.2.3 轻量级锁膨胀</h3><p>其过程流程图如下所示</p>
<p><img src="https://i.loli.net/2020/03/31/QZesVDEtJqmHl9C.png" alt="轻量级锁膨胀.png"></p>
<ul>
<li><strong>一个问题：为什么在撤销轻量级锁的时候会有失败的可能？</strong><ul>
<li>假设<code>thread1</code>拥有了轻量级锁，Mark Word指向<code>thread1</code>栈帧，<code>thread2</code>请求锁的时候，就会膨胀初始化<code>ObjectMonitor</code>对象，将Mark Word更新为指向<code>ObjectMonitor</code>的指针，那么在thread1退出的时候，<code>CAS</code>操作会失败，因为Mark Word不再指向<code>thread1</code>的栈帧，这个时候<code>thread1</code>自旋等待<code>infalte</code>完毕，执行重量级锁的退出操作</li>
</ul>
</li>
</ul>
<h2 id="2-3-自旋锁和自适应自旋"><a href="#2-3-自旋锁和自适应自旋" class="headerlink" title="2.3 自旋锁和自适应自旋"></a>2.3 <strong>自旋锁和自适应自旋</strong></h2><h3 id="2-3-1-自旋锁"><a href="#2-3-1-自旋锁" class="headerlink" title="2.3.1 自旋锁"></a>2.3.1 自旋锁</h3><ul>
<li><strong>描述：</strong>一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的。 所以，虚拟机的开发团队就这样去考虑：“我们能不能让后面来的请求获取锁的线程等待一会而不被挂起呢？看看持有锁的线程是否很快就会释放锁”。为了让一个线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就叫做自旋。<ul>
<li>百度百科对自旋锁的解释：何谓自旋锁？它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。</li>
</ul>
</li>
<li><strong>使用时机：</strong>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。<ul>
<li>互斥同步对性能最大的影响就是阻塞的实现，因为挂起线程/恢复线程的操作都需要转入内核态中完成（用户态转换到内核态会耗费时间）。</li>
</ul>
</li>
<li><strong>关闭与开启：</strong>自旋锁在 <code>JDK1.6</code> 之前其实就已经引入了，不过是默认关闭的，需要通过<code>--XX:+UseSpinning</code>参数来开启。<code>JDK1.6</code>及1.6之后，就改为默认开启的了。需要注意的是：自旋等待不能完全替代阻塞，因为它还是要占用处理器时间。如果锁被占用的时间短，那么效果当然就很好了！反之，相反！自旋等待的时间必须要有限度。如果自旋超过了限定次数任然没有获得锁，就应该挂起线程。自旋次数的默认值是10次，用户可以修改-<code>-XX:PreBlockSpin</code>来更改。</li>
</ul>
<h3 id="2-3-2-自适应自旋锁："><a href="#2-3-2-自适应自旋锁：" class="headerlink" title="2.3.2 自适应自旋锁："></a>2.3.2 <strong>自适应自旋锁：</strong></h3><ul>
<li>描述：在 JDK1.6 中引入了自适应的自旋锁。自适应的自旋锁带来的改进就是：自旋的时间不再固定了，而是和前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定，虚拟机变得越来越“聪明”了。</li>
<li>实现原理：它怎么做呢？线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。 有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测会越来越准确，虚拟机会变得越来越聪明。</li>
</ul>
<h2 id="2-4-重量级锁"><a href="#2-4-重量级锁" class="headerlink" title="2.4 重量级锁"></a>2.4 重量级锁</h2><ul>
<li>描述：重量级锁通过对象内部的监视器（<code>monitor</code>）实现，其中<code>monitor</code>的本质是依赖于底层操作系统的<code>Mutex Lock</code>实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</li>
</ul>
<h1 id="3-Synchronized-的其他细节问题"><a href="#3-Synchronized-的其他细节问题" class="headerlink" title="3.Synchronized 的其他细节问题"></a>3.Synchronized 的其他细节问题</h1><h1 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h1><h2 id="4-1-总结锁的升级流程："><a href="#4-1-总结锁的升级流程：" class="headerlink" title="4.1 总结锁的升级流程："></a>4.1 总结锁的升级流程：</h2><p>每一个线程在准备获取共享资源时： </p>
<ol>
<li>第一步：检查<code>MarkWord</code>里面是不是放的自己的<code>ThreadId</code> ,如果是，表示当前线程是处于 “偏向锁” 。  </li>
<li>第二步：如果<code>MarkWord</code>不是自己的<code>ThreadId</code>，锁升级，这时候，使用<code>CAS</code>来执行切换，新的线程根据<code>MarkWord</code>里面现有的<code>ThreadId</code>，通知之前线程暂停，之前线程将<code>Markword</code>的内容置为空。</li>
<li>第三步：两个线程都把锁对象的<code>HashCode</code>复制到自己新建的用于存储锁的记录空间，接着开始通过<code>CAS</code>操作， 把锁对象的<code>MarKword</code>的内容修改为自己新建的记录空间的地址的方式竞争<code>MarkWord</code>。  </li>
<li>第四步：第三步中成功执行<code>CAS</code>的获得资源，失败的则进自旋 。</li>
<li>第五步：自旋的线程在自旋过程中，成功获得资源(即之前获的资源的线程执行完成并释放了共享资源)，则整个状态依然处于轻量级锁的状态，如果自旋失败进入第六步 。</li>
<li>第六步：进行重量级锁的状态，这个时候，自旋的线程进行阻塞，等待之前线程执行完成并唤醒自己。</li>
</ol>
<h2 id="4-2-几种锁的优缺点对比"><a href="#4-2-几种锁的优缺点对比" class="headerlink" title="4.2 几种锁的优缺点对比"></a>4.2 几种锁的优缺点对比</h2><p>下图摘自：并发编程的艺术</p>
<p><img src="https://i.loli.net/2020/03/31/8U6mNSjGLeKMrEB.png" alt="image.png"></p>
<p>以上参考文章：</p>
<ul>
<li><a href="https://blog.dreamtobe.cn/2015/11/13/java_synchronized/" target="_blank" rel="noopener">Java Synchronised机制</a></li>
<li><a href="https://github.com/farmerjohngit/myblog/issues/13" target="_blank" rel="noopener">死磕Synchronized底层实现–偏向锁</a></li>
<li><a href="https://blog.csdn.net/iter_zc/article/details/41847887" target="_blank" rel="noopener">聊聊JVM（六）理解JVM的safepoint</a></li>
<li><a href="http://cmsblogs.com/?p=2071" target="_blank" rel="noopener">【死磕Java并发】—–深入分析synchronized的实现原理</a></li>
<li>书籍：Java 并发编程的艺术</li>
<li>书籍：深入理解Java虚拟机：JVM高级特性与最佳实践</li>
<li>书籍：深入浅出Java 多线程</li>
</ul>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
        <div class="declare">
          <ul class="post-copyright">
            <li>
              <i class="ri-copyright-line"></i>
              <strong>版权声明： </strong s>
              本博客所有文章除特别声明外，均采用 <a href="https://www.apache.org/licenses/LICENSE-2.0.html" rel="external nofollow"
                target="_blank">Apache License 2.0</a> 许可协议。转载请注明出处！
            </li>
          </ul>
        </div>
        
    <footer class="article-footer">
      
          
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://dongxiem.github.io/2020/03/31/Java%20%E5%B9%B6%E5%8F%91%20-%20Synchronized%20%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li></ul>


    </footer>

  </div>

  
  
  <nav class="article-nav">
    
      <a href="/2020/03/31/Java%20%E5%B9%B6%E5%8F%91%20-%20Synchronized%20%E5%87%A0%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            Java 并发 - Synchronized 几种使用方式
          
        </div>
      </a>
    
    
      <a href="/2020/03/31/Java%20%E5%9F%BA%E7%A1%80%20-%20Static%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%A4%E8%AF%86/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Java 基础 - Static关键字的一些认识</div>
      </a>
    
  </nav>


  

  
  
<!-- valine评论 -->
<div id="vcomments-box">
    <div id="vcomments">
    </div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#vcomments',
        app_id: '',
        app_key: '',
        path: window.location.pathname,
        notify: 'false',
        verify: 'false',
        avatar: 'mp',
        placeholder: '给我的文章加点评论吧~',
        recordIP: true
    });
    const infoEle = document.querySelector('#vcomments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
        infoEle.childNodes.forEach(function (item) {
            item.parentNode.removeChild(item);
        });
    }
</script>
<style>
    #vcomments-box {
        padding: 5px 30px;
    }

    @media screen and (max-width: 800px) {
        #vcomments-box {
            padding: 5px 0px;
        }
    }

    #vcomments-box #vcomments {
        background-color: #fff;
    }

    .v .vlist .vcard .vh {
        padding-right: 20px;
    }

    .v .vlist .vcard {
        padding-left: 10px;
    }
</style>

  

  
  
  

</article>
</section>
      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2019-2020
        Garmen Lee
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/garmen.jpeg" alt="桃花岛杂货铺"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/WTIM">WTIM</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/About">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>





<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>



<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>



<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>

    
  </div>
</body>

</html>
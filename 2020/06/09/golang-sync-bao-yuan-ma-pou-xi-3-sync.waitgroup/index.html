<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/garmen.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/garmen.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/garmen.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dongxiem.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1.sync.WaitGroup 介绍sync.WaitGroup 按照官方注释给的解释，它可以等待一组 Goroutine 集合的结束，主 goroutine 通过调用 Add() 函数来设置一定数量进行等待的 goroutines ，然后其余的一些 goroutines 则进行各自的运行结束之后再调用 Done()，这样一来，等待的主 goroutine 会阻塞知道其余所有 goroutine">
<meta property="og:type" content="article">
<meta property="og:title" content="golang Sync包源码剖析(3) - sync.WaitGroup">
<meta property="og:url" content="https://dongxiem.github.io/2020/06/09/golang-sync-bao-yuan-ma-pou-xi-3-sync.waitgroup/index.html">
<meta property="og:site_name" content="桃花岛杂货铺">
<meta property="og:description" content="1.sync.WaitGroup 介绍sync.WaitGroup 按照官方注释给的解释，它可以等待一组 Goroutine 集合的结束，主 goroutine 通过调用 Add() 函数来设置一定数量进行等待的 goroutines ，然后其余的一些 goroutines 则进行各自的运行结束之后再调用 Done()，这样一来，等待的主 goroutine 会阻塞知道其余所有 goroutine">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20201006140734.png">
<meta property="og:image" content="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20201006140833.png">
<meta property="article:published_time" content="2020-06-09T04:25:21.000Z">
<meta property="article:modified_time" content="2020-10-06T07:35:24.578Z">
<meta property="article:author" content="Garmen Lee">
<meta property="article:tag" content="go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20201006140734.png">

<link rel="canonical" href="https://dongxiem.github.io/2020/06/09/golang-sync-bao-yuan-ma-pou-xi-3-sync.waitgroup/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>golang Sync包源码剖析(3) - sync.WaitGroup | 桃花岛杂货铺</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="桃花岛杂货铺" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">桃花岛杂货铺</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dongxiem.github.io/2020/06/09/golang-sync-bao-yuan-ma-pou-xi-3-sync.waitgroup/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Garmen Lee">
      <meta itemprop="description" content="杂货铺售卖知识 诸位自取">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="桃花岛杂货铺">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          golang Sync包源码剖析(3) - sync.WaitGroup
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-09 12:25:21" itemprop="dateCreated datePublished" datetime="2020-06-09T12:25:21+08:00">2020-06-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="1-sync-WaitGroup-介绍"><a href="#1-sync-WaitGroup-介绍" class="headerlink" title="1.sync.WaitGroup 介绍"></a>1.sync.WaitGroup 介绍</h1><p><a href="https://sourcegraph.com/github.com/golang/go@master/-/blob/src/sync/waitgroup.go#L21:2" target="_blank" rel="noopener">sync.WaitGroup</a> 按照官方注释给的解释，它可以等待一组 Goroutine 集合的结束，主 <code>goroutine</code> 通过调用 <code>Add()</code> 函数来设置一定数量进行等待的 <code>goroutines</code> ，然后其余的一些 <code>goroutines</code> 则进行各自的运行结束之后再调用 <code>Done()</code>，这样一来，等待的主 <code>goroutine</code> 会阻塞知道其余所有 <code>goroutines</code>都结束。</p>
<blockquote>
<p>A WaitGroup waits for a collection of goroutines to finish.The main goroutine calls Add to set the number of goroutines to wait for. Then each of the goroutines runs and calls Done when finished. At the same time, Wait can be used to block until all goroutines have finished.</p>
</blockquote>
<a id="more"></a>

<p>注：以下<code>golang</code>源码版本为：1.15</p>
<h1 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2.源码解析"></a>2.源码解析</h1><h2 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h2><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A WaitGroup must not be copied after first use.</span></span><br><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> {</span><br><span class="line">    <span class="comment">// 保证 sync.WaitGroup 不会被开发者通过再赋值的方式拷贝；</span></span><br><span class="line">	noCopy noCopy</span><br><span class="line">    <span class="comment">// 存储着状态和信号量；</span></span><br><span class="line">	state1 [<span class="number">3</span>]<span class="keyword">uint32</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p><strong>第一个参数：noCopy</strong></p>
<p>noCopy：它是 sync 包下的一个特殊标记，可以嵌入到结构中，<strong><u>在第一次使用后不可复制</u></strong>，使用<code>go vet</code>作为检测使用，并因此<strong><u>只能进行指针传递，从而保证全局唯一</u></strong>；</p>
<p>比如下面的演示代码中：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> {</span><br><span class="line">    wg := sync.WaitGroup {}</span><br><span class="line">    w := wg</span><br><span class="line">    fmt.Println (w, wg)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>run 的时候没问题，但是如果你使用 go vet 做个检查就有警告了：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> vet proc.<span class="keyword">go</span></span><br><span class="line">./prog.<span class="keyword">go</span>:<span class="number">10</span>:<span class="number">10</span>: assignment copies lock value to yawg: sync.WaitGroup</span><br><span class="line">./prog.<span class="keyword">go</span>:<span class="number">11</span>:<span class="number">14</span>: call of fmt.Println copies lock value: sync.WaitGroup</span><br><span class="line">./prog.<span class="keyword">go</span>:<span class="number">11</span>:<span class="number">18</span>: call of fmt.Println copies lock value: sync.WaitGroup</span><br></pre></td></tr></tbody></table></figure>

<p>所以<strong><u>它能够保证 sync.WaitGroup 不会被开发者通过再赋值的方式拷贝</u></strong>；</p>
<p><strong>第二个参数：state1</strong></p>
<p>state1：是用来存放任务计数器和等待者计数器，应该会涉及到一些位操作相关的内容，估计还是挺棘手的，需要注意的是：<strong>WaitGroup 在 64 位和 32 位机器是持有不同的状态</strong>，其相对应的具体内容如下：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">state [0]</th>
<th align="left">state [1]</th>
<th align="left">state [2]</th>
</tr>
</thead>
<tbody><tr>
<td align="left">64 位</td>
<td align="left">waiter</td>
<td align="left">counter</td>
<td align="left">sema</td>
</tr>
<tr>
<td align="left">32 位</td>
<td align="left">sema</td>
<td align="left">waiter</td>
<td align="left">counter</td>
</tr>
</tbody></table>
<p>注意其中 <code>waiter</code> 是等待者计数，<code>counter</code> 是任务计数，<code>sema</code> 是信号量。具体可以看看注释（不过这是之前版本的注释，官方并未修改）：</p>
<blockquote>
<p>64-bit value: high 32 bits are counter, low 32 bits are waiter count.<br>64-bit atomic operations require 64-bit alignment, but 32-bit compilers do not ensure it. </p>
<p>So we allocate 12 bytes and then use the aligned 8 bytes in them as state, and the other 4 as storage for the sema.</p>
</blockquote>
<p>其实如果看其他书籍或者博客，会发现之前版本的 <code>WaitGroup</code> 结构体定义并非如此：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> {</span><br><span class="line">    noCopy noCopy  <span class="comment">//该WaitGroup对象不允许拷贝使用,只能用指针传递</span></span><br><span class="line"></span><br><span class="line">    state1 [<span class="number">12</span>]<span class="keyword">byte</span></span><br><span class="line">    sema   <span class="keyword">uint32</span>  <span class="comment">//信号量</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>关于新版本的 <code>go</code> 为什么重新设计可以看看注释，我认为应该是为了操作的便利性。</p>
<p>同时<code>sync.WaitGroup</code> 提供的私有方法 <code>sync.WaitGroup.state</code> 能够帮我们从 <code>state1</code> 字段中取出它的状态（<code>statep = waiter + counter</code>）和信号量（<code>semap</code>）。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取statep、semap的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">state</span><span class="params">()</span> <span class="params">(statep *<span class="keyword">uint64</span>, semap *<span class="keyword">uint32</span>)</span></span> {</span><br><span class="line">    <span class="comment">// 根据state1的起始地址分析，判断是否为8字节对齐的（64位）</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;wg.state1))%<span class="number">8</span> == <span class="number">0</span> {</span><br><span class="line">        <span class="keyword">return</span> (*<span class="keyword">uint64</span>)(unsafe.Pointer(&amp;wg.state1)), &amp;wg.state1[<span class="number">2</span>]</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> (*<span class="keyword">uint64</span>)(unsafe.Pointer(&amp;wg.state1[<span class="number">1</span>])), &amp;wg.state1[<span class="number">0</span>]</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<h2 id="Add"><a href="#Add" class="headerlink" title="Add()"></a>Add()</h2><p><code>sync.WaitGroup</code> 对外暴露了三个方法分别是 <code>sync.WaitGroup.Add</code>、<code>sync.WaitGroup.Wait</code> 和 <code>sync.WaitGroup.Done</code>，而有意思的是<code>sync.WaitGroup.Done</code>向 <code>sync.WaitGroup.Add</code> 方法传入了 -1（没错，就是这么简单，也说明了这个 <code>delta</code> 可以为负数），接下来先从<code>sync.WaitGroup.Add</code> 开始分析起。</p>
<p>通过 <code>Add()</code> 函数我们传进了 <code>delta</code> 这么一个值，它要加到 <code>WaitGroup</code> 的计数器当中，它可以是负数；如果计数器变为零时，所有被阻塞的 <code>goroutines</code> 都会被释放，如果计数器变为负数时，则会报 <code>panic</code>（意思就是，计数器不能为负）。</p>
<p>其源码具体如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Add</span><span class="params">(delta <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="comment">// 首先获得 statep（waiter + counter） 和 semap</span></span><br><span class="line">    statep, semap := wg.state()</span><br><span class="line">    <span class="comment">// 竞态检测</span></span><br><span class="line">    <span class="keyword">if</span> race.Enabled {</span><br><span class="line">        _ = *statep <span class="comment">// trigger nil deref early</span></span><br><span class="line">        <span class="keyword">if</span> delta &lt; <span class="number">0</span> {</span><br><span class="line">            <span class="comment">// Synchronize decrements with Wait.</span></span><br><span class="line">            race.ReleaseMerge(unsafe.Pointer(wg))</span><br><span class="line">        }</span><br><span class="line">        race.Disable()</span><br><span class="line">        <span class="keyword">defer</span> race.Enable()</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 首先将 delta 左移32位，再加到 statep 中，此时是叠加到 staep 中的 counter计数器</span></span><br><span class="line">    state := atomic.AddUint64(statep, <span class="keyword">uint64</span>(delta)&lt;&lt;<span class="number">32</span>)</span><br><span class="line">    <span class="comment">// 将 counter 和 waiter 进行抽离，分别封装为 v、w</span></span><br><span class="line">    v := <span class="keyword">int32</span>(state &gt;&gt; <span class="number">32</span>)</span><br><span class="line">    w := <span class="keyword">uint32</span>(state)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> race.Enabled &amp;&amp; delta &gt; <span class="number">0</span> &amp;&amp; v == <span class="keyword">int32</span>(delta) {</span><br><span class="line">        race.Read(unsafe.Pointer(semap))</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果计数器 counter 为负，则panic</span></span><br><span class="line">    <span class="keyword">if</span> v &lt; <span class="number">0</span> {</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"sync: negative WaitGroup counter"</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// waiter值不为0，delta大于零且累加后的counter值和delta相等，</span></span><br><span class="line">    <span class="comment">// 说明Wait()方法没有在Add()方法之后调用，触发panic，因为正确的做法是先Add()后Wait()</span></span><br><span class="line">    <span class="keyword">if</span> w != <span class="number">0</span> &amp;&amp; delta &gt; <span class="number">0</span> &amp;&amp; v == <span class="keyword">int32</span>(delta) {</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"sync: WaitGroup misuse: Add called concurrently with Wait"</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// Add()添加正常返回</span></span><br><span class="line">    <span class="comment">// 1.counter &gt; 0，说明还不需要释放信号量，可以直接返回；</span></span><br><span class="line">    <span class="comment">// 2.waiter = 0，说明没有等待的goroutine，也不需要释放信号量，可以直接返回；</span></span><br><span class="line">    <span class="keyword">if</span> v &gt; <span class="number">0</span> || w == <span class="number">0</span> {</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 下面是 counter == 0 并且 waiter &gt; 0的情况</span></span><br><span class="line">    <span class="comment">// 现在若原state和新的state不等，则有以下两种可能：</span></span><br><span class="line">    <span class="comment">// 	- Add 与 Wait 同时调用；</span></span><br><span class="line">    <span class="comment">// 	- 如果counter已经0，但Wait 继续增加等待计数器 waiters，这种情况永远不会触发信号量；</span></span><br><span class="line">    <span class="comment">// 以上两种情况都是错误的，所以触发异常。</span></span><br><span class="line">    <span class="comment">// 注：state := atomic.AddUint64(statep, uint64(delta)&lt;&lt;32)  这一步调用之后，state和*statep的值应该是相等的，除非有以上两种情况发生。</span></span><br><span class="line">    <span class="keyword">if</span> *statep != state {</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"sync: WaitGroup misuse: Add called concurrently with Wait"</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 将 waiter 和 counter都置为0</span></span><br><span class="line">    *statep = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 当调用计数器归零，也就是所有任务都执行完成时，就会通过 sync.runtime_Semrelease 唤醒处于等待状态的所有 Goroutine</span></span><br><span class="line">    <span class="keyword">for</span> ; w != <span class="number">0</span>; w-- {</span><br><span class="line">        runtime_Semrelease(semap, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>捋一捋，以上的 <code>Add()</code> 函数主要完成的以下内容：</p>
<ol>
<li>首先通过 <code>wg.state()</code> 得到  <code>statep</code>（<code>waiter + counter</code>） 和 <code>semap</code>，然后将 <code>Add()</code> 传进的参数 <code>delta</code> 添加至 <code>counter</code>，再将<code>statep</code> 中的 <code>waiter</code> 和 <code>coutner</code> 分别抽离出来并封装成为 <code>v</code> 和 <code>w</code>，然后对 <code>v</code> 和 <code>w</code>做一些校验，比如<ol>
<li>计数器 <code>counter</code> 为负，则触发<code>panic</code>；</li>
<li>还有 <code>Wait()</code> 方法没有在 <code>Add()</code> 方法之后调用，则触发panic；</li>
</ol>
</li>
<li>如果 <code>Add()</code> 添加正常则返回。</li>
<li>再对原<code>state</code>和新的<code>state</code>不等的两种情况进行判断是否出错，出错则报panic，具体的两种情况为：<ol>
<li>Add 与 Wait 同时调用；</li>
<li>如果counter已经0，但Wait 继续增加等待计数器 waiters，这种情况永远不会触发信号量；</li>
</ol>
</li>
<li>最后对于 <code>w &gt; 0</code> 的情况，会进行 for 循环直到调用计数器归零，也就是所有任务都执行完成时，就会通过 <code>sync.runtime_Semrelease</code> 唤醒处于等待状态的所有 <code>Goroutine</code>。</li>
</ol>
<h2 id="Done"><a href="#Done" class="headerlink" title="Done()"></a>Done()</h2><p><code>Done()</code> 就简单将<code>counter</code>值减1，这里就能够理解为什么上面说 <code>delta</code> 可以为负数了。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Done decrements the WaitGroup counter by one.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Done</span><span class="params">()</span></span> {</span><br><span class="line">	wg.Add(<span class="number">-1</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="Wait"><a href="#Wait" class="headerlink" title="Wait()"></a>Wait()</h2><p><code>Wait()</code> 会在计数器 <code>counter</code> 大于 0 并且不存在等待的 <code>Goroutine</code> 时，调用 <code>sync.runtime_Semacquire</code> 陷入睡眠状态，直到 <code>couner</code> 的值为0时进行唤醒。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Wait</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">// 同样得到 statep（waiter + counter） 和 semap</span></span><br><span class="line">    statep, semap := wg.state()</span><br><span class="line">    <span class="comment">// 竞态检测</span></span><br><span class="line">    <span class="keyword">if</span> race.Enabled {</span><br><span class="line">        _ = *statep <span class="comment">// trigger nil deref early</span></span><br><span class="line">        race.Disable()</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 进行一个死循环判断</span></span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        state := atomic.LoadUint64(statep)</span><br><span class="line">        v := <span class="keyword">int32</span>(state &gt;&gt; <span class="number">32</span>)</span><br><span class="line">        w := <span class="keyword">uint32</span>(state)</span><br><span class="line">        <span class="comment">// 如果 counter 为0，则停止死循环，进行 return 跳出</span></span><br><span class="line">        <span class="keyword">if</span> v == <span class="number">0</span> {</span><br><span class="line">            <span class="keyword">if</span> race.Enabled {</span><br><span class="line">                race.Enable()</span><br><span class="line">                race.Acquire(unsafe.Pointer(wg))</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 通过CAS方法进行原子地增加 waiter的值，并且for循环会一直尝试，保证多个goroutine同时调用Wait()也能正确累加waiter；</span></span><br><span class="line">        <span class="comment">// 注意等待者计数在低32位，可以直接加，不需要移位操作</span></span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapUint64(statep, state, state+<span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">if</span> race.Enabled &amp;&amp; w == <span class="number">0</span> {</span><br><span class="line">                race.Write(unsafe.Pointer(semap))</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 同步原语，进行信号量的等待</span></span><br><span class="line">            runtime_Semacquire(semap)</span><br><span class="line">            <span class="comment">// 之前的Add()函数中，触发信号量前会先将counter和waiter置0，所以此时*statep必定为0</span></span><br><span class="line">            <span class="comment">// 若不为0，说明WaitGroup此时又被执行Add()或者Wait()操作了，应panic</span></span><br><span class="line">            <span class="keyword">if</span> *statep != <span class="number">0</span> {</span><br><span class="line">                <span class="built_in">panic</span>(<span class="string">"sync: WaitGroup is reused before previous Wait has returned"</span>)</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> race.Enabled {</span><br><span class="line">                race.Enable()</span><br><span class="line">                race.Acquire(unsafe.Pointer(wg))</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到当 <code>sync.WaitGroup</code> 的计数器 <code>Counter</code> 归零时，陷入睡眠状态的 Goroutine 就被唤醒，上述方法会立刻返回。</p>
<h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h1><p>通过源码的解析，可以得到以下的一些认识：</p>
<ul>
<li><code>WaitGroup</code> 利用信号量来实现任务结束的通知；</li>
<li><code>Wait()</code> 可以被调用多次，也即可以同时有多个 Goroutine 等待当前 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="noopener"><code>sync.WaitGroup</code></a> 计数器的归零，并且每个都会收到完成的通知；</li>
<li><code>sync.WaitGroup.Done</code> 只是对 <code>sync.WaitGroup.Add</code> 方法的简单封装，我们可以向 <code>sync.WaitGroup.Add</code> 方法传入任意负数（需要保证计数器非负）快速将计数器归零以唤醒其他等待的 Goroutine；</li>
<li><code>WaitGroup</code>作为参数传递的时候需要注意传递指针，或者尽量避免传递；</li>
<li><code>WaitGroup</code>不能保证多个 <code>goroutine</code> 执行次序</li>
</ul>
<p>但是使用的时候需要注意以下几点：</p>
<ul>
<li><code>Add()</code>操作必须早于<code>Wait()</code>，否则会<code>panic</code>；</li>
<li><code>Add()</code>设置的值必须与实际等待的<code>goroutine</code>个数一致，否则会<code>panic</code>；</li>
<li><code>WaitGroup</code> 必须在 <code>Wait()</code> 方法返回之后才能被重新使用；</li>
<li><code>WaitGroup</code>只可保持一份，不可拷贝给其他变量，否则会造成意想不到的BUG；</li>
</ul>
<p>最后：实在忍不了吐槽一下，虽然很多地方我分析得不是很好，但是 <code>go夜读</code> 的一些源码解析也太烂了，直接将注解扔进谷歌翻译/百度翻译，最后也都不审核一下，简直就是不能入眼。</p>
<p><img src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20201006140734.png" alt="image-20201006140734579"></p>
<p><img src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20201006140833.png" alt="image-20201006140833507"></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/go/" rel="tag"># go</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/06/07/golang-sync-bao-yuan-ma-pou-xi-2-sync.rwmutex/" rel="prev" title="golang Sync包源码剖析(2) - sync.RWMutex">
      <i class="fa fa-chevron-left"></i> golang Sync包源码剖析(2) - sync.RWMutex
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/06/12/golang-sync-bao-yuan-ma-pou-xi-4-sync.map/" rel="next" title="golang Sync包源码剖析(4) - sync.Map">
      golang Sync包源码剖析(4) - sync.Map <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-sync-WaitGroup-介绍"><span class="nav-text">1.sync.WaitGroup 介绍</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-源码解析"><span class="nav-text">2.源码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#结构体定义"><span class="nav-text">结构体定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Add"><span class="nav-text">Add()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Done"><span class="nav-text">Done()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Wait"><span class="nav-text">Wait()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-小结"><span class="nav-text">3.小结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Garmen Lee"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Garmen Lee</p>
  <div class="site-description" itemprop="description">杂货铺售卖知识 诸位自取</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">36</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Garmen Lee</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">256k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">3:53</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>

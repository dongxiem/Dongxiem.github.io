<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java 基础 - 面试题集上  | 桃花岛杂货铺</title><meta name="description" content="Java 基础 - 面试题集上 "><meta name="keywords" content="Java,导页"><meta name="author" content="Garmen Lee"><meta name="copyright" content="Garmen Lee"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/garmen.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Java 基础 - 面试题集上 "><meta name="twitter:description" content="Java 基础 - 面试题集上 "><meta name="twitter:image" content="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511205145.png"><meta property="og:type" content="article"><meta property="og:title" content="Java 基础 - 面试题集上 "><meta property="og:url" content="https://dongxiem.github.io/2020/05/11/java-ji-chu-mian-shi-ti-ji-shang/"><meta property="og:site_name" content="桃花岛杂货铺"><meta property="og:description" content="Java 基础 - 面试题集上 "><meta property="og:image" content="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511205145.png"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="https://dongxiem.github.io/2020/05/11/java-ji-chu-mian-shi-ti-ji-shang/"><link rel="prev" title="Java 基础 - 面试题集下" href="https://dongxiem.github.io/2020/05/11/java-ji-chu-mian-shi-ti-ji-xia/"><link rel="next" title="Java 并发 - 多线程：线程间通信交替打印" href="https://dongxiem.github.io/2020/04/16/java-bing-fa-duo-xian-cheng-xian-cheng-jian-tong-xin-jiao-ti-da-yin/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://dongxiem.github.io/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: true
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="桃花岛杂货铺" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">137</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">17</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 標籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分類</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 快速導航</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/2020/03/20/java-ji-chu-dao-ye/"><i class="fa-fw fa fa-link"></i><span> Java基礎</span></a></li><li><a class="site-page" href="/2020/03/20/java-ji-he-kuang-jia-dao-ye/"><i class="fa-fw fa fa-link"></i><span> Java集合框架</span></a></li><li><a class="site-page" href="/2020/03/20/java-bing-fa-dao-ye/"><i class="fa-fw fa fa-link"></i><span> Java多線程與並發</span></a></li><li><a class="site-page" href="/2020/04/01/mybatis-kuang-jia-fen-xi-1-zong-ti-gai-shu/"><i class="fa-fw fa fa-link"></i><span> MyBatis</span></a></li><li><a class="site-page" href="/2020/03/29/spring-kuang-jia-fen-xi-dao-ye/"><i class="fa-fw fa fa-link"></i><span> Spring</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 算法</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/leetcode/"><i class="fa-fw fa fa-link"></i><span> LeetCode</span></a></li><li><a class="site-page" href="/JZoffer/"><i class="fa-fw fa fa-link"></i><span> 劍指OFFER</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友鏈</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 關於</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-概述"><span class="toc-number">1.</span> <span class="toc-text">Java 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java是解析运行吗？"><span class="toc-number">1.1.</span> <span class="toc-text">Java是解析运行吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解释一下Java程序执行？"><span class="toc-number">1.2.</span> <span class="toc-text">解释一下Java程序执行？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#几种编译语言的区别？"><span class="toc-number">1.3.</span> <span class="toc-text">几种编译语言的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-与-C-的区别"><span class="toc-number">1.4.</span> <span class="toc-text">Java 与 C++ 的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#基础语言"><span class="toc-number">2.</span> <span class="toc-text">基础语言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#用最有效率的方法计算2乘以8？"><span class="toc-number">2.1.</span> <span class="toc-text">用最有效率的方法计算2乘以8？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#amp-和-amp-amp-的区别？"><span class="toc-number">2.2.</span> <span class="toc-text">&amp; 和 &amp;&amp;的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#foreach-与正常-for-循环效率对比"><span class="toc-number">2.3.</span> <span class="toc-text">foreach 与正常 for 循环效率对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#float-f-3-4-是否正确？"><span class="toc-number">2.4.</span> <span class="toc-text">float f&#x3D;3.4;是否正确？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗？"><span class="toc-number">2.5.</span> <span class="toc-text">short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?  short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#switch-是否能作用在byte-上，是否能作用在long-上，是否能作用在String上？"><span class="toc-number">2.6.</span> <span class="toc-text">switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#编码"><span class="toc-number">3.</span> <span class="toc-text">编码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#char-型变量中能不能存贮一个中文汉字，为什么？"><span class="toc-number">3.1.</span> <span class="toc-text">char 型变量中能不能存贮一个中文汉字，为什么？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数据类型"><span class="toc-number">4.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java有哪些数据类型"><span class="toc-number">4.1.</span> <span class="toc-text">Java有哪些数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用基本类型的时候有什么注意事项吗？"><span class="toc-number">4.2.</span> <span class="toc-text">使用基本类型的时候有什么注意事项吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java中基础数据类型是在栈上分配还是在堆上分配？"><span class="toc-number">4.3.</span> <span class="toc-text">Java中基础数据类型是在栈上分配还是在堆上分配？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-两个整型相加怎么知道有没有溢出"><span class="toc-number">4.4.</span> <span class="toc-text">Java 两个整型相加怎么知道有没有溢出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java中包装类的常见误区"><span class="toc-number">4.5.</span> <span class="toc-text">Java中包装类的常见误区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#隐式类型转换和显示类型转换"><span class="toc-number">4.6.</span> <span class="toc-text">隐式类型转换和显示类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#拆箱与装箱"><span class="toc-number">4.7.</span> <span class="toc-text">拆箱与装箱</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本类型和包装类型的区别，涉及自动装箱和拆箱，怎么做的，原理？"><span class="toc-number">4.7.1.</span> <span class="toc-text">基本类型和包装类型的区别，涉及自动装箱和拆箱，怎么做的，原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#integer和int的自动装箱和拆箱以及为什么要用integer类"><span class="toc-number">4.7.2.</span> <span class="toc-text">integer和int的自动装箱和拆箱以及为什么要用integer类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自动装箱与拆箱：引入内存池"><span class="toc-number">4.7.3.</span> <span class="toc-text">自动装箱与拆箱：引入内存池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本数据类型与字符串"><span class="toc-number">4.8.</span> <span class="toc-text">基本数据类型与字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#如何将字符串转换为基本数据类型？"><span class="toc-number">4.8.1.</span> <span class="toc-text">如何将字符串转换为基本数据类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何将基本数据类型转换为字符串？"><span class="toc-number">4.8.2.</span> <span class="toc-text">如何将基本数据类型转换为字符串？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#你知道对象的内存结构是什么样的吗？比如，对象头的结构。如何计算或者获取某个-Java-对象的大小"><span class="toc-number">4.9.</span> <span class="toc-text">你知道对象的内存结构是什么样的吗？比如，对象头的结构。如何计算或者获取某个 Java 对象的大小?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#那么Integer对象占用内存大小多少？"><span class="toc-number">4.10.</span> <span class="toc-text">那么Integer对象占用内存大小多少？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Object类"><span class="toc-number">5.</span> <span class="toc-text">Object类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Equals"><span class="toc-number">5.1.</span> <span class="toc-text">Equals</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#讲讲Equals？"><span class="toc-number">5.1.1.</span> <span class="toc-text">讲讲Equals？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashCode"><span class="toc-number">5.2.</span> <span class="toc-text">HashCode</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要有-hashCode"><span class="toc-number">5.2.1.</span> <span class="toc-text">为什么要有 hashCode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#object类equals和hash关系？"><span class="toc-number">5.2.2.</span> <span class="toc-text">object类equals和hash关系？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义了一个类，需要在Map、Set中使用，需要注意什么？"><span class="toc-number">5.2.3.</span> <span class="toc-text">自定义了一个类，需要在Map、Set中使用，需要注意什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？"><span class="toc-number">5.2.4.</span> <span class="toc-text">两个对象值相同(x.equals(y) &#x3D;&#x3D; true)，但却可有不同的hash code，这句话对不对？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#toString-NaN"><span class="toc-number">5.3.</span> <span class="toc-text">toString</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#关于toString的认识"><span class="toc-number">5.3.1.</span> <span class="toc-text">关于toString的认识</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#clone"><span class="toc-number">5.4.</span> <span class="toc-text">clone</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#四种拷贝方案"><span class="toc-number">5.4.1.</span> <span class="toc-text">四种拷贝方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cloneable"><span class="toc-number">5.4.1.1.</span> <span class="toc-text">cloneable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#浅拷贝"><span class="toc-number">5.4.1.2.</span> <span class="toc-text">浅拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#深拷贝"><span class="toc-number">5.4.1.3.</span> <span class="toc-text">深拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#clone-的替代方案"><span class="toc-number">5.4.1.4.</span> <span class="toc-text">clone() 的替代方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#讲讲浅拷贝和深拷贝？？？"><span class="toc-number">5.4.2.</span> <span class="toc-text">讲讲浅拷贝和深拷贝？？？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组的复制方法"><span class="toc-number">5.4.3.</span> <span class="toc-text">数组的复制方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何实现对象克隆？"><span class="toc-number">5.4.4.</span> <span class="toc-text">如何实现对象克隆？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#comparable-和-Comparator的区别"><span class="toc-number">5.5.</span> <span class="toc-text">comparable 和 Comparator的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#String类"><span class="toc-number">6.</span> <span class="toc-text">String类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#概述"><span class="toc-number">6.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JAVA-String对象是如何实现的？（摘自极客时间）"><span class="toc-number">6.2.</span> <span class="toc-text">JAVA String对象是如何实现的？（摘自极客时间）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符型常量和字符串常量的区别"><span class="toc-number">6.3.</span> <span class="toc-text">字符型常量和字符串常量的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#是否可以继承String类？"><span class="toc-number">6.4.</span> <span class="toc-text">是否可以继承String类？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sring-不可变"><span class="toc-number">6.5.</span> <span class="toc-text">Sring 不可变</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#String不可变性带来的好处"><span class="toc-number">6.5.1.</span> <span class="toc-text">String不可变性带来的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sring-不可变问题一"><span class="toc-number">6.5.2.</span> <span class="toc-text">Sring 不可变问题一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String真的是不可变的吗？"><span class="toc-number">6.5.3.</span> <span class="toc-text">String真的是不可变的吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-intern问题"><span class="toc-number">6.6.</span> <span class="toc-text">String.intern问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#如何使用-String-intern-节省内存？"><span class="toc-number">6.6.1.</span> <span class="toc-text">如何使用 String.intern 节省内存？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String的创建"><span class="toc-number">6.7.</span> <span class="toc-text">String的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#说说new-String-“-“-的方式？"><span class="toc-number">6.7.1.</span> <span class="toc-text">说说new String(“ “)的方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String到底创建几个对象？"><span class="toc-number">6.7.2.</span> <span class="toc-text">String到底创建几个对象？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-s-new-String-“xyz”-创建了几个字符串对象"><span class="toc-number">6.7.3.</span> <span class="toc-text">String s &#x3D; new String(“xyz”);创建了几个字符串对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不同创建方式对比问题一"><span class="toc-number">6.7.4.</span> <span class="toc-text">不同创建方式对比问题一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不同创建方式对比问题二"><span class="toc-number">6.7.5.</span> <span class="toc-text">不同创建方式对比问题二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不同创建方式对比问题三"><span class="toc-number">6.7.6.</span> <span class="toc-text">不同创建方式对比问题三</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不同创建方式对比问题四"><span class="toc-number">6.7.7.</span> <span class="toc-text">不同创建方式对比问题四</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String中equals方法"><span class="toc-number">6.8.</span> <span class="toc-text">String中equals方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String的compareTo方法"><span class="toc-number">6.9.</span> <span class="toc-text">String的compareTo方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String、StringBuilder、StringBuffer"><span class="toc-number">6.10.</span> <span class="toc-text">String、StringBuilder、StringBuffer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关于-“-”-运算符问题"><span class="toc-number">6.11.</span> <span class="toc-text">关于 “+” 运算符问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是String-Pool？"><span class="toc-number">6.12.</span> <span class="toc-text">什么是String Pool？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-API"><span class="toc-number">6.13.</span> <span class="toc-text">String API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#String-类的常用方法都有那些？"><span class="toc-number">6.13.1.</span> <span class="toc-text">String 类的常用方法都有那些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#共享char数组可能导致内存泄露问题？"><span class="toc-number">6.13.2.</span> <span class="toc-text">共享char数组可能导致内存泄露问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何将字符串反转？"><span class="toc-number">6.13.3.</span> <span class="toc-text">如何将字符串反转？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组有没有-length-方法？String-有没有-length-方法"><span class="toc-number">6.13.4.</span> <span class="toc-text">数组有没有 length()方法？String 有没有 length()方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-字符串编码"><span class="toc-number">6.14.</span> <span class="toc-text">String 字符串编码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？"><span class="toc-number">6.14.1.</span> <span class="toc-text">怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#关键字"><span class="toc-number">7.</span> <span class="toc-text">关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Static-关键字"><span class="toc-number">7.1.</span> <span class="toc-text">Static 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同？"><span class="toc-number">7.1.1.</span> <span class="toc-text">静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#下面的代码哪些地方会产生编译错误？"><span class="toc-number">7.1.2.</span> <span class="toc-text">下面的代码哪些地方会产生编译错误？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static修饰的特点？java的static讲下，然后有6种用法，我说了4种，后来网上搜也只有五种呀"><span class="toc-number">7.1.3.</span> <span class="toc-text">static修饰的特点？java的static讲下，然后有6种用法，我说了4种，后来网上搜也只有五种呀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Static-初始化顺序"><span class="toc-number">7.1.4.</span> <span class="toc-text">Static 初始化顺序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Final关键字"><span class="toc-number">7.2.</span> <span class="toc-text">Final关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Final修饰的特点，基本类型和类类型"><span class="toc-number">7.2.1.</span> <span class="toc-text">Final修饰的特点，基本类型和类类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#阐述final、finally、finalize的区别。"><span class="toc-number">7.2.2.</span> <span class="toc-text">阐述final、finally、finalize的区别。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#几个-fanlly-不会被执行的情况"><span class="toc-number">7.2.3.</span> <span class="toc-text">几个 fanlly 不会被执行的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#匿名内部类，访问局部变量时，局部变量为啥要用fnal来修饰吗？"><span class="toc-number">7.2.4.</span> <span class="toc-text">匿名内部类，访问局部变量时，局部变量为啥要用fnal来修饰吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final不是immutable"><span class="toc-number">7.2.5.</span> <span class="toc-text">final不是immutable?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static与final修饰变量所处JVM中的位置"><span class="toc-number">7.2.6.</span> <span class="toc-text">static与final修饰变量所处JVM中的位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fnalize真的那么不堪？"><span class="toc-number">7.2.7.</span> <span class="toc-text">fnalize真的那么不堪？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有什么机制可以替换fnalize吗？"><span class="toc-number">7.2.8.</span> <span class="toc-text">有什么机制可以替换fnalize吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#super关键字"><span class="toc-number">7.3.</span> <span class="toc-text">super关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#解释一下super？"><span class="toc-number">7.3.1.</span> <span class="toc-text">解释一下super？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super-与-this-的区别"><span class="toc-number">7.3.2.</span> <span class="toc-text">super 与 this 的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#instanceof关键字"><span class="toc-number">7.4.</span> <span class="toc-text">instanceof关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#流程控制语句"><span class="toc-number">7.5.</span> <span class="toc-text">流程控制语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#break-continue-return-的区别及作用"><span class="toc-number">7.5.1.</span> <span class="toc-text">break ,continue ,return 的区别及作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在-Java-中，如何跳出当前的多重嵌套循环"><span class="toc-number">7.5.2.</span> <span class="toc-text">在 Java 中，如何跳出当前的多重嵌套循环</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#面对对象"><span class="toc-number">8.</span> <span class="toc-text">面对对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象和面向过程的区别"><span class="toc-number">8.1.</span> <span class="toc-text">面向对象和面向过程的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面对对象三大特性"><span class="toc-number">8.2.</span> <span class="toc-text">面对对象三大特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是多态机制？Java语言是如何实现多态的？"><span class="toc-number">8.2.1.</span> <span class="toc-text">什么是多态机制？Java语言是如何实现多态的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多态的原理是什么，多态的含义？多态是如何实现的？"><span class="toc-number">8.2.2.</span> <span class="toc-text">多态的原理是什么，多态的含义？多态是如何实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面向对象五大基本原则是什么？"><span class="toc-number">8.2.3.</span> <span class="toc-text">面向对象五大基本原则是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#访问修饰符public-private-protected-以及不写（默认）时的区别？"><span class="toc-number">8.2.4.</span> <span class="toc-text">访问修饰符public,private,protected,以及不写（默认）时的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类ExampleA继承Exception，类ExampleB继承ExampleA。请问执行此段代码的输出是什么？"><span class="toc-number">8.2.5.</span> <span class="toc-text">类ExampleA继承Exception，类ExampleB继承ExampleA。请问执行此段代码的输出是什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重写与重载"><span class="toc-number">8.3.</span> <span class="toc-text">重写与重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#重写重载的联系与区别"><span class="toc-number">8.3.1.</span> <span class="toc-text">重写重载的联系与区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#讲讲方法调用的优先级？"><span class="toc-number">8.3.2.</span> <span class="toc-text">讲讲方法调用的优先级？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造器（constructor）是否可被重写（override）？"><span class="toc-number">8.3.3.</span> <span class="toc-text">构造器（constructor）是否可被重写（override）？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么不能根据返回类型来区分重载"><span class="toc-number">8.3.4.</span> <span class="toc-text">为什么不能根据返回类型来区分重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类与接口"><span class="toc-number">8.4.</span> <span class="toc-text">类与接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#讲讲借口与抽象类？"><span class="toc-number">8.4.1.</span> <span class="toc-text">讲讲借口与抽象类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象类的相关特性"><span class="toc-number">8.4.2.</span> <span class="toc-text">抽象类的相关特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口的相关特性"><span class="toc-number">8.4.3.</span> <span class="toc-text">接口的相关特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象类与接口的对比"><span class="toc-number">8.4.4.</span> <span class="toc-text">抽象类与接口的对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么时候用抽象类什么时候用接口？"><span class="toc-number">8.4.5.</span> <span class="toc-text">什么时候用抽象类什么时候用接口？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口与抽象类在不同版本中的变化"><span class="toc-number">8.4.6.</span> <span class="toc-text">接口与抽象类在不同版本中的变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过实例对象-方法名这种调用过程的流程"><span class="toc-number">8.4.7.</span> <span class="toc-text">通过实例对象.方法名这种调用过程的流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被synchronized修饰？"><span class="toc-number">8.4.8.</span> <span class="toc-text">抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#普通类与抽象类的区别"><span class="toc-number">8.4.9.</span> <span class="toc-text">普通类与抽象类的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象类能够使用final修饰？"><span class="toc-number">8.4.10.</span> <span class="toc-text">抽象类能够使用final修饰？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建一个对象用什么关键字？对象实例与对象引用有何不同？"><span class="toc-number">8.4.11.</span> <span class="toc-text">创建一个对象用什么关键字？对象实例与对象引用有何不同？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变量与方法"><span class="toc-number">8.5.</span> <span class="toc-text">变量与方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简述静态类和单例的区别"><span class="toc-number">8.5.1.</span> <span class="toc-text">简述静态类和单例的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#成员变量与局部变量的区别有哪些"><span class="toc-number">8.5.2.</span> <span class="toc-text">成员变量与局部变量的区别有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么在父类中要定义一个没有参数的空构造函数"><span class="toc-number">8.5.3.</span> <span class="toc-text">为什么在父类中要定义一个没有参数的空构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？"><span class="toc-number">8.5.4.</span> <span class="toc-text">在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？"><span class="toc-number">8.5.5.</span> <span class="toc-text">一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造方法有哪些特性？"><span class="toc-number">8.5.6.</span> <span class="toc-text">构造方法有哪些特性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态变量和实例变量区别"><span class="toc-number">8.5.7.</span> <span class="toc-text">静态变量和实例变量区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态变量与普通变量区别"><span class="toc-number">8.5.8.</span> <span class="toc-text">静态变量与普通变量区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态方法和实例方法有何不同？"><span class="toc-number">8.5.9.</span> <span class="toc-text">静态方法和实例方法有何不同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#成员变量与局部变量"><span class="toc-number">8.5.10.</span> <span class="toc-text">成员变量与局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态方法和实例方法的区别"><span class="toc-number">8.5.11.</span> <span class="toc-text">静态方法和实例方法的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"><span class="toc-number">8.5.12.</span> <span class="toc-text">是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#值传递"><span class="toc-number">8.6.</span> <span class="toc-text">值传递</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么Java中只有值传递"><span class="toc-number">8.6.1.</span> <span class="toc-text">为什么Java中只有值传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-的参数是值传递？还是引用传递？"><span class="toc-number">8.6.2.</span> <span class="toc-text">Java 的参数是值传递？还是引用传递？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？"><span class="toc-number">8.6.3.</span> <span class="toc-text">当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内部类"><span class="toc-number">8.7.</span> <span class="toc-text">内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是内部类？"><span class="toc-number">8.7.1.</span> <span class="toc-text">什么是内部类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内部类的分类？"><span class="toc-number">8.7.2.</span> <span class="toc-text">内部类的分类？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#静态内部类"><span class="toc-number">8.7.2.0.1.</span> <span class="toc-text">静态内部类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#成员内部类"><span class="toc-number">8.7.2.0.2.</span> <span class="toc-text">成员内部类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#局部内部类"><span class="toc-number">8.7.2.0.3.</span> <span class="toc-text">局部内部类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#匿名内部类"><span class="toc-number">8.7.2.0.4.</span> <span class="toc-text">匿名内部类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内部类的优点"><span class="toc-number">8.7.3.</span> <span class="toc-text">内部类的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内部类的应用场景"><span class="toc-number">8.7.4.</span> <span class="toc-text">内部类的应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？"><span class="toc-number">8.7.5.</span> <span class="toc-text">局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#局部内部类与匿名内部类"><span class="toc-number">8.7.6.</span> <span class="toc-text">局部内部类与匿名内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Anonymous-Inner-Class-匿名内部类-是否可以继承其它类？是否可以实现接口？"><span class="toc-number">8.7.7.</span> <span class="toc-text">Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内部类相关，看程序说出运行结果"><span class="toc-number">8.7.8.</span> <span class="toc-text">内部类相关，看程序说出运行结果</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div class="post-bg" id="nav" style="background-image: url(https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511205145.png)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">桃花岛杂货铺</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 標籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分類</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 快速導航</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/2020/03/20/java-ji-chu-dao-ye/"><i class="fa-fw fa fa-link"></i><span> Java基礎</span></a></li><li><a class="site-page" href="/2020/03/20/java-ji-he-kuang-jia-dao-ye/"><i class="fa-fw fa fa-link"></i><span> Java集合框架</span></a></li><li><a class="site-page" href="/2020/03/20/java-bing-fa-dao-ye/"><i class="fa-fw fa fa-link"></i><span> Java多線程與並發</span></a></li><li><a class="site-page" href="/2020/04/01/mybatis-kuang-jia-fen-xi-1-zong-ti-gai-shu/"><i class="fa-fw fa fa-link"></i><span> MyBatis</span></a></li><li><a class="site-page" href="/2020/03/29/spring-kuang-jia-fen-xi-dao-ye/"><i class="fa-fw fa fa-link"></i><span> Spring</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 算法</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/leetcode/"><i class="fa-fw fa fa-link"></i><span> LeetCode</span></a></li><li><a class="site-page" href="/JZoffer/"><i class="fa-fw fa fa-link"></i><span> 劍指OFFER</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友鏈</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 關於</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Java 基础 - 面试题集上 </div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-05-11 16:58:50"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-05-11</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-05-11 22:48:53"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-05-11</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">Java基础知识</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">33.3k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 107 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2020/05/11/java-ji-chu-mian-shi-ti-ji-shang/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2020/05/11/java-ji-chu-mian-shi-ti-ji-shang/" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h1 id="Java-概述"><a href="#Java-概述" class="headerlink" title="Java 概述"></a>Java 概述</h1><h2 id="Java是解析运行吗？"><a href="#Java是解析运行吗？" class="headerlink" title="Java是解析运行吗？"></a>Java是解析运行吗？</h2><p>不正确！</p>
<p>Java源代码经过Javac编译成.class文件，class文件经JVM解析或编译运行。</p>
<ul>
<li>解析: .class文件经过JVM内嵌的解析器解析执行。</li>
<li>编译:存在JIT编译器（Just In Time Compile 即时编译器）把经常运行的代码作为”热点代码”编译与本地平台相关的机器码，并进行各种层次的优化。</li>
<li>AOT编译器: Java 9提供的直接将所有代码编译成机器码执行。</li>
</ul>
<p>写个程序直接执行字节码就是解释执行。写个程序运行时把字节码动态翻译成机器码就是jit。写个程序把java源代码直接翻译为机器码就是aot。造个CPU直接执行字节码，字节码就是机器码。</p>
<p>因为如果虚拟机加载字节码后，完全进行解释执行，这势必会影响执行效率。所以，对于这个运行环节，虚拟机会进行一些优化处理，例如JIT技术，会将某些运行特别频繁的代码编译成机器码。而AOT技术，是在运行前，通过工具直接将字节码转换为机器码。</p>
<h2 id="解释一下Java程序执行？"><a href="#解释一下Java程序执行？" class="headerlink" title="解释一下Java程序执行？"></a>解释一下Java程序执行？</h2><p>我理解的java程序执行步骤：首先javac编译器将源代码编译成字节码。然后jvm类加载器加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度相对会比较慢。有些方法和代码块是高频率调用的，也就是所谓的热点代码，所以引进jit技术，提前将这类字节码直接编译成本地机器码。这样类似于缓存技术，运行时再遇到这类代码直接可以执行，而不是先解释后执行。</p>
<p>JIT是运行时编译</p>
<h2 id="几种编译语言的区别？"><a href="#几种编译语言的区别？" class="headerlink" title="几种编译语言的区别？"></a>几种编译语言的区别？</h2><ul>
<li><strong>编译型语言</strong>： C/C++、 Pascal（Delphi）<ul>
<li>编译就是把源代码（高级语言，人类容易读，容易理解）转换成机器码（CPU能理解，能高效的执行）</li>
</ul>
</li>
<li><strong>解释型语言</strong>： JavaScript、 Perl、 Python、 Ruby<ul>
<li>解释就简单多了，解析源代码，并且直接执行，没有编译过程</li>
</ul>
</li>
<li>编译程序是整体编译完了，再一次性执行。 而解释程序是一边解释，一边执行</li>
<li><strong>编译型-解释型语言</strong>：JAVA语言是一种<strong>编译型-解释型语言</strong>，同时具备编译特性和解释特性<ul>
<li>其所谓的编译过程只是将.java文件编程成平台无关的字节码.class文件，并不是向C一样编译成可执行的机器语言，在此请读者注意Java中所谓的“编译”和传统的“编译”的区别。</li>
<li>作为编译型语言， JAVA程序要被统一编译成字节码文件——文件后缀是class。此种文件在java中又称为类文件。</li>
<li>java类文件不能再计算机上直接执行，它需要被java虚拟机翻译成本地的机器码后才能执行，而java虚拟机的翻译过程则是解释性的。</li>
<li>java字节码文件首先被加载到计算机内存中，然后读出一条指令，翻译一条指令，执行一条指令，该过程被称为java语言的解释执行，是由java虚拟机完成的。</li>
<li>以上说的是Java的解释执行，但是比如我们大多数情况使用的Hotspot JVM，都提供了动态编译器编译器JIT，能够追踪热点代码， 然后变成机器指令，这种情况下部分热点代码就属于编译执行，而不是解释执行了</li>
</ul>
</li>
</ul>
<h2 id="Java-与-C-的区别"><a href="#Java-与-C-的区别" class="headerlink" title="Java 与 C++ 的区别"></a>Java 与 C++ 的区别</h2><ul>
<li>Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。</li>
<li>Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。</li>
<li>Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。</li>
<li>Java 支持自动垃圾回收，而 C++ 需要手动回收。</li>
<li>Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。</li>
<li>Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。</li>
<li>Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。</li>
</ul>
<hr>
<h1 id="基础语言"><a href="#基础语言" class="headerlink" title="基础语言"></a>基础语言</h1><h2 id="用最有效率的方法计算2乘以8？"><a href="#用最有效率的方法计算2乘以8？" class="headerlink" title="用最有效率的方法计算2乘以8？"></a>用最有效率的方法计算2乘以8？</h2><p>2 &lt;&lt; 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）。</p>
<h2 id="amp-和-amp-amp-的区别？"><a href="#amp-和-amp-amp-的区别？" class="headerlink" title="&amp; 和 &amp;&amp;的区别？"></a>&amp; 和 &amp;&amp;的区别？</h2><p>&amp;运算符有两种用法：</p>
<ol>
<li>按位与</li>
<li>逻辑与</li>
</ol>
<p>&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。</p>
<ul>
<li>&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。</li>
</ul>
<p>很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username != null &amp;&amp;!username.equals(“”)，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。</p>
<p>注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</p>
<h2 id="foreach-与正常-for-循环效率对比"><a href="#foreach-与正常-for-循环效率对比" class="headerlink" title="foreach 与正常 for 循环效率对比"></a>foreach 与正常 for 循环效率对比</h2><p>先表明结果：由于for循环的特性，每次循环都会进行比较，所以效率上不如foreach</p>
<p>for需要获取容器大小，如果计算大小比较耗时，那么for循环效率会很低。它是<strong>根据容器大小防止越界</strong>，因此每次循环需要进行一次比较。</p>
<p>ForEach 编译成字节码之后，使用的是迭代器实现的，所以本质上是通过迭代器遍历的</p>
<h2 id="float-f-3-4-是否正确？"><a href="#float-f-3-4-是否正确？" class="headerlink" title="float f=3.4;是否正确？"></a>float f=3.4;是否正确？</h2><p>不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换<code>float f =(float)3.4;</code> 或者写成<code>float f =3.4F;</code>。</p>
<p>Java 不能隐式执行向下转型，因为这会使得精度降低。</p>
<p>1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。<code>// float f = 1.1;</code></p>
<p>1.1f 字面量才是 float 类型。<code>float f = 1.1f;</code></p>
<h2 id="short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗？"><a href="#short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗？" class="headerlink" title="short s1 = 1; s1 = s1 + 1;有错吗?  short s1 = 1; s1 += 1;有错吗？"></a>short s1 = 1; s1 = s1 + 1;有错吗?  short s1 = 1; s1 += 1;有错吗？</h2><p>对于<code>short s1 = 1;</code> <code>s1 = s1 + 1;</code></p>
<p>因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型向下转型为 short 类型。由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型。</p>
<p>而<code>short s1 = 1;</code> <code>s1 += 1;</code>可以正确编译，因为<code>s1+= 1;</code>相当于<code>s1 = (short)(s1 + 1);</code> 其中有<strong>隐含的强制类型转换</strong>。使用 += 或者 ++ 运算符会执行隐式类型转换。</p>
<h2 id="switch-是否能作用在byte-上，是否能作用在long-上，是否能作用在String上？"><a href="#switch-是否能作用在byte-上，是否能作用在long-上，是否能作用在String上？" class="headerlink" title="switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？"></a>switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？</h2><p>在Java 5以前，switch(expr)中，expr只能是byte、short、char、int。</p>
<p>从Java 5开始，Java中引入了枚举类型，expr也可以是enum类型</p>
<p>从Java 7开始，expr还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。</p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511172947.png"  alt="Sring类型的switch"></p>
<p>switch 不支持 long，是因为 switch 的设计初衷是对那些只有少数几个值的类型进行等值判断，如果值过于复杂，那么还是用 if 比较合适。</p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511173015.png"  alt="Sring对于long不支持"></p>
<hr>
<h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><h2 id="char-型变量中能不能存贮一个中文汉字，为什么？"><a href="#char-型变量中能不能存贮一个中文汉字，为什么？" class="headerlink" title="char 型变量中能不能存贮一个中文汉字，为什么？"></a>char 型变量中能不能存贮一个中文汉字，为什么？</h2><p>char类型可以存储一个中文汉字</p>
<p>因为<u>Java中使用的编码是Unicode</u>（不选择任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一个char类型占2个字节（16比特），所以放一个中文是没问题的。</p>
<p>补充：使用Unicode意味着字符在JVM内部和外部有不同的表现形式，在JVM内部都是Unicode，当这个字符被从JVM内部转移到外部时（例如存入文件系统中），需要进行编码转换。所以Java中有字节流和字符流，以及在字符流和字节流之间进行转换的转换流，如InputStreamReader和OutputStreamReader，这两个类是字节流和字符流之间的适配器类，承担了编码转换的任务；对于C程序员来说，要完成这样的编码转换恐怕要依赖于union（联合体/共用体）共享内存的特征来实现了。</p>
<hr>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="Java有哪些数据类型"><a href="#Java有哪些数据类型" class="headerlink" title="Java有哪些数据类型"></a>Java有哪些数据类型</h2><p><strong>定义</strong>：Java语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。</p>
<p><strong>分类</strong></p>
<ul>
<li>基本数据类型<ul>
<li>数值型<ul>
<li>整数类型(byte,short,int,long)</li>
<li>浮点类型(float,double)</li>
</ul>
</li>
<li>字符型(char)</li>
<li>布尔型(boolean)</li>
</ul>
</li>
<li>引用数据类型<ul>
<li>类(class)</li>
<li>接口(interface)</li>
<li>数组([])</li>
</ul>
</li>
</ul>
<p><strong>Java基本数据类型图</strong></p>
<p><img src="/" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL0phdmElRTUlOUYlQkElRTclQTElODAlRTglQUYlQUQlRTYlQjMlOTUvSmF2YSVFNSU5RiVCQSVFNiU5QyVBQyVFNiU5NSVCMCVFNiU4RCVBRSVFNyVCMSVCQiVFNSU5RSU4Qi5wbmc?x-oss-process=image/format,png"  alt="基本数据类型图"></p>
<h2 id="使用基本类型的时候有什么注意事项吗？"><a href="#使用基本类型的时候有什么注意事项吗？" class="headerlink" title="使用基本类型的时候有什么注意事项吗？"></a>使用基本类型的时候有什么注意事项吗？</h2><ol>
<li>基本类型均具有取值范围，在大数*大数的时候，有可能会出现越界的情况。</li>
<li>基本类型转换时，使用声明的方式。例：long result= 1234567890 * 24 * 365；结果值一定不会是你所期望的那个值，因为1234567890 * 24已经超过了int的范围，如果修改为：long result= 1234567890L * 24 * 365；就正常了。</li>
<li>慎用基本类型处理货币存储。如采用double常会带来差距，常采用BigDecimal、整型（如果要精确表示分，可将值扩大100倍转化为整型）解决该问题。</li>
<li>优先使用基本类型。原则上，建议避免无意中的装箱、拆箱行为，尤其是在性能敏感的场合</li>
<li>如果有线程安全的计算需要，建议考虑使用类型AtomicInteger、AtomicLong 这样的线程安全类。部分比较宽的基本数据类型，比如 float、double，甚至不能保证更新操作的原子性，可能出现程序读取到只更新了一半数据位的数值。</li>
</ol>
<h2 id="Java中基础数据类型是在栈上分配还是在堆上分配？"><a href="#Java中基础数据类型是在栈上分配还是在堆上分配？" class="headerlink" title="Java中基础数据类型是在栈上分配还是在堆上分配？"></a>Java中基础数据类型是在栈上分配还是在堆上分配？</h2><p>要解答这个问题，首先要看这个数据类型在哪里定义的，有以下三种情况。</p>
<ul>
<li>如果在方法体内定义的，这时候就是在栈上分配的</li>
<li>如果是类的成员变量，这时候就是在堆上分配的</li>
<li>如果是类的静态成员变量，在方法区上分配的</li>
</ul>
<h2 id="Java-两个整型相加怎么知道有没有溢出"><a href="#Java-两个整型相加怎么知道有没有溢出" class="headerlink" title="Java 两个整型相加怎么知道有没有溢出"></a>Java 两个整型相加怎么知道有没有溢出</h2><p>正数相加溢出会变成负数</p>
<h2 id="Java中包装类的常见误区"><a href="#Java中包装类的常见误区" class="headerlink" title="Java中包装类的常见误区"></a>Java中包装类的常见误区</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testEquals</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> int1 = <span class="number">12</span>;</span><br><span class="line">        <span class="keyword">int</span> int2 = <span class="number">12</span>;</span><br><span class="line">        Integer integer1 = <span class="keyword">new</span> Integer(<span class="number">12</span>);</span><br><span class="line">        Integer integer2 = <span class="keyword">new</span> Integer(<span class="number">12</span>);</span><br><span class="line">        Integer integer3 = <span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line">        Integer a1 = <span class="number">127</span>;</span><br><span class="line">        Integer a2 = <span class="number">127</span>;</span><br><span class="line">        Integer a = <span class="number">128</span>;</span><br><span class="line">        Integer b = <span class="number">128</span>;</span><br><span class="line">        System.out.println(<span class="string">"int1 == int2 -&gt; "</span> + (int1 == int2));    <span class="comment">// true       </span></span><br><span class="line">        System.out.println(<span class="string">"int1 == integer1 -&gt; "</span> + (int1 == integer1));    <span class="comment">// true       </span></span><br><span class="line">        System.out.println(<span class="string">"integer1 == integer2 -&gt; "</span> + (integer1 == integer2));        <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">"integer3 == a1 -&gt; "</span> + (integer3 == a1));  <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">"a1 == a2 -&gt; "</span> + (a1 == a2));       <span class="comment">// true       </span></span><br><span class="line">        System.out.println(<span class="string">"a == b -&gt; "</span> + (a == b));        <span class="comment">// false                           </span></span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>1.略</li>
<li>2.Integer是int的封装类，当Integer与int进行==比较时，Integer就会拆箱成一个int类型，所以还是相当于两个int类型进行比较</li>
<li>3.两个都是对象类型，而且不会进行拆箱比较</li>
<li>4.integer3是一个对象类型，而a1是一个常量它们存放内存的位置不一样，所以也不等</li>
<li>5.128不在缓存范围内，所以会new出两个不同的对象</li>
</ul>
<h2 id="隐式类型转换和显示类型转换"><a href="#隐式类型转换和显示类型转换" class="headerlink" title="隐式类型转换和显示类型转换"></a>隐式类型转换和显示类型转换</h2><ul>
<li>当将占位数少的类型赋值给占位数多的类型时，java自动使用隐式类型转换（如int型转为long型）</li>
<li>当把在级别高的变量的值赋给级别低变量时，必须使用显式类型转换运算（如double型转为float型）</li>
</ul>
<h2 id="拆箱与装箱"><a href="#拆箱与装箱" class="headerlink" title="拆箱与装箱"></a>拆箱与装箱</h2><h3 id="基本类型和包装类型的区别，涉及自动装箱和拆箱，怎么做的，原理？"><a href="#基本类型和包装类型的区别，涉及自动装箱和拆箱，怎么做的，原理？" class="headerlink" title="基本类型和包装类型的区别，涉及自动装箱和拆箱，怎么做的，原理？"></a>基本类型和包装类型的区别，涉及自动装箱和拆箱，怎么做的，原理？</h3><p>拆箱与装箱示例代码如下：</p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511154345.png"  alt="拆箱与装箱"></p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511154403.png"  alt="测试"></p>
<p>自动装箱实际上算是一种语法糖。什么是语法糖？可以简单理解为 Java 平台为我们自动进行了一些转换，保证不同的写法在运行时等价，它们发生在编译阶段，也就是生成的字节码是一致的。</p>
<p>最常用的是通过new方法构建Integer对象。但是，基于大部分数据操作都是集中在有限的、较小的数值范围，在JDK1.5 中新增了静态工厂方法 valueOf，其背后实现是将int值为-128 到 127 之间的Integer对象进行缓存，在调用时候直接从缓存中获取，进而提升构建对象的性能，也就是说使用该方法后，如果两个对象的int值相同且落在缓存值范围内，那么这个两个对象就是同一个对象；当值较小且频繁使用时，推荐优先使用整型池方法（时间与空间性能俱佳）</p>
<h3 id="integer和int的自动装箱和拆箱以及为什么要用integer类"><a href="#integer和int的自动装箱和拆箱以及为什么要用integer类" class="headerlink" title="integer和int的自动装箱和拆箱以及为什么要用integer类"></a>integer和int的自动装箱和拆箱以及为什么要用integer类</h3><p>Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，是为了能够将这些基本数据类型当成对象操作！</p>
<p>Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。</p>
<h3 id="自动装箱与拆箱：引入内存池"><a href="#自动装箱与拆箱：引入内存池" class="headerlink" title="自动装箱与拆箱：引入内存池"></a>自动装箱与拆箱：引入内存池</h3><p><strong>示例代码如下</strong></p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511155601.png"  alt="示例代码"></p>
<p>如果不明就里很容易认为两个输出要么都是true要么都是false。首先需要注意的是f1、f2、f3、f4四个变量都是Integer对象引用，所以下面的==运算比较的不是值而是引用。</p>
<p>装箱的本质是什么呢？当我们给一个Integer对象赋一个int值的时候，会调用Integer类的静态方法valueOf，如果看看valueOf的源代码就知道发生了什么。</p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511155624.png"  alt="valueOf源码"></p>
<p>简单的说，如果整型字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象，所以上面的面试题中<code>f1 == f2</code> 的结果是true，而<code>f3 == f4</code>的结果是false。</p>
<p>深入解析如下：<strong>引入一个缓存池的概念</strong></p>
<p><code>new Integer(123)</code> 与 <code>Integer.valueOf(123)</code> 的区别在于：</p>
<ul>
<li>new Integer(123) 每次都会新建一个对象；</li>
<li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511155739.png"  alt="两种创建方式的测试"></p>
<p>编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。</p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511155809.png"  alt="测试用例"></p>
<p>基本类型对应的缓冲池如下：</p>
<ul>
<li>boolean values true and false</li>
<li>all byte values</li>
<li>short values between -128 and 127</li>
<li>int values between -128 and 127</li>
<li>char in the range \u0000 to \u007F</li>
<li>注：在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。</li>
</ul>
<p>在 jdk 1.8 所有的数值类缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的，在启动 jvm 的时候，通过 <code>-XX:AutoBoxCacheMax=&lt;size&gt;</code> 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 <code>java.lang.IntegerCache.high</code> 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界。</p>
<p>IntegerCache是Integer的内部类，其代码如下所示：</p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511155923.png"  alt="IntegerCache源码"></p>
<h2 id="基本数据类型与字符串"><a href="#基本数据类型与字符串" class="headerlink" title="基本数据类型与字符串"></a>基本数据类型与字符串</h2><h3 id="如何将字符串转换为基本数据类型？"><a href="#如何将字符串转换为基本数据类型？" class="headerlink" title="如何将字符串转换为基本数据类型？"></a>如何将字符串转换为基本数据类型？</h3><p>调用基本数据类型对应的包装类中的方法parseXXX(String)或valueOf(String)即可返回相应基本类型；</p>
<h3 id="如何将基本数据类型转换为字符串？"><a href="#如何将基本数据类型转换为字符串？" class="headerlink" title="如何将基本数据类型转换为字符串？"></a>如何将基本数据类型转换为字符串？</h3><p>一种方法是将基本数据类型与空字符串（””）连接（+）即可获得其所对应的字符串；</p>
<p>另一种方法是调用String 类中的valueOf()方法返回相应字符串；</p>
<h2 id="你知道对象的内存结构是什么样的吗？比如，对象头的结构。如何计算或者获取某个-Java-对象的大小"><a href="#你知道对象的内存结构是什么样的吗？比如，对象头的结构。如何计算或者获取某个-Java-对象的大小" class="headerlink" title="你知道对象的内存结构是什么样的吗？比如，对象头的结构。如何计算或者获取某个 Java 对象的大小?"></a>你知道对象的内存结构是什么样的吗？比如，对象头的结构。如何计算或者获取某个 Java 对象的大小?</h2><blockquote>
<p>节选自《深入理解JAVA虚拟机》</p>
</blockquote>
<p>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：<u>对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）</u>。</p>
<ol>
<li>HotSpot虚拟机的对象头包括两部分信息<ul>
<li>第一部分用于<u>存储对象自身的运行时数据</u>，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，官方称它为<strong>“Mark Word”</strong>。<ul>
<li>Hotspot虚拟机文档 “oops/oop.hp”有对Markword字段的定义：<ul>
<li><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511160525.png"  alt="MarkWord定义"></li>
<li>normal object，初始new出来的对象都是这种状态</li>
<li>biased object，当某个对象被作为同步锁对象时，会有一个偏向锁，其实就是存储了持有该同步锁的线程id，关于偏向锁的知识这里就不再赘述了，大家可以自行查阅相关资料。</li>
<li>CMS promoted object 和 CMS free block 我也不清楚到底是啥，但是看名字似乎跟CMS 垃圾回收器有关，这里我们也可以暂时忽略它们</li>
</ul>
</li>
</ul>
</li>
<li>对象头的另外一部分是<u>类型指针</u>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身。另外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中却无法确定数组的大小。</li>
</ul>
</li>
<li>接下来的实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。</li>
<li>第三部分对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。</li>
</ol>
<p>计算对象大小可通过dump内存之后用memory analyze分析，也可以利用：jol，jmap，或者instrument api（Java agent）等等</p>
<h2 id="那么Integer对象占用内存大小多少？"><a href="#那么Integer对象占用内存大小多少？" class="headerlink" title="那么Integer对象占用内存大小多少？"></a>那么Integer对象占用内存大小多少？</h2><p>基于64的虚拟机：</p>
<ol>
<li>Mark Word（对象头）：标记位 8字节，类似轻量级锁标记位，偏向锁标记位等。</li>
<li>Class对象指针：如果是32G内存以下的，默认开启对象指针压缩，4个字节，指向对象对应class对象的内存地址。</li>
<li>对象实际数据：对象所有成员变量。</li>
<li>对齐：对齐填充字节，按照8个字节填充。</li>
</ol>
<p>故：8+4+4=16 字节；</p>
<p>或者用以下代码方法：获取一个JAVA对象的大小，可以将一个对象进行序列化为二进制的Byte，便可以查看大小。</p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511160734.png"  alt="Integer大小查看"></p>
<p>有一个Fruit类继承了Object类，我们分别新建一个object和fruit，那他们分别占用多大的内存呢？</p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511160800.png"  alt="Fruit类"></p>
<p>先来看object对象，通过上面的知识，它的Markword是8个字节，kclass是4个字节， 加起来是12个字节，加上4个字节的对齐填充，所以它占用的空间是16个字节。</p>
<p>再来看fruit对象，同样的，它的Markword是8个字节，kclass是4个字节，但是它还有个size成员变量，int类型占4个字节，加起来刚好是16个字节，所以不需要对齐填充。</p>
<p>详细见：</p>
<p><a href="https://cloud.tencent.com/developer/article/1450250" target="_blank" rel="noopener">重学Java-一个对象到底占多少内存？</a></p>
<p><a href="https://juejin.im/post/5e538d8d6fb9a07ccf303aca" target="_blank" rel="noopener">你写的Java对象究竟占多少内存？</a></p>
<hr>
<h1 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h1><p>方法概览如下：</p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511173152.png"  alt="Object方法概览"></p>
<h2 id="Equals"><a href="#Equals" class="headerlink" title="Equals"></a>Equals</h2><h3 id="讲讲Equals？"><a href="#讲讲Equals？" class="headerlink" title="讲讲Equals？"></a>讲讲Equals？</h3><p>等价关系：两个对象具有等价关系，需要满足以下五个条件：</p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511205914.png"  alt="五个条件"></p>
<p>等价与相等（顺便回答了这个问题：<strong>==和equals的区别？</strong>）</p>
<ul>
<li>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。</li>
<li>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</li>
</ul>
<p>实现（也即是重写equals，分为四步进行）</p>
<ol>
<li>检查是否为同一个对象的引用，如果是直接返回 true；</li>
<li>检查是否是同一个类型，如果不是，直接返回 false；</li>
<li>将 Object 对象进行转型；</li>
<li>判断每个关键域是否相等。</li>
</ol>
<p>具体实现如下：</p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511210059.png"  alt="重写equals的实现"></p>
<p>实现高质量的equals方法的诀窍包括：</p>
<ol>
<li>使用==操作符检查”参数是否为这个对象的引用”；</li>
<li>使用instanceof操作符检查”参数是否为正确的类型”；</li>
<li>对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；</li>
<li>编写完equals方法后，问自己它是否满足对称性、传递性、一致性；</li>
<li>重写equals时总是要重写hashCode；</li>
<li>不要将equals方法参数中的Object对象替换为其他的类型，在重写时不要忘掉@Override注解。</li>
</ol>
<h2 id="HashCode"><a href="#HashCode" class="headerlink" title="HashCode"></a>HashCode</h2><h3 id="为什么要有-hashCode"><a href="#为什么要有-hashCode" class="headerlink" title="为什么要有 hashCode"></a>为什么要有 hashCode</h3><p>我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p>
<p>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</p>
<h3 id="object类equals和hash关系？"><a href="#object类equals和hash关系？" class="headerlink" title="object类equals和hash关系？"></a>object类equals和hash关系？</h3><ol>
<li>hashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价。</li>
<li>等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价，这是因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。</li>
<li>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象哈希值也相等。</li>
<li>HashSet 和 HashMap 等集合类使用了 hashCode() 方法来计算对象应该存储的位置，因此要将对象添加到这些集合类中，需要让对应的类实现 hashCode() 方法。</li>
<li>下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象。但是 EqualExample 没有实现 hashCode() 方法，因此这两个对象的哈希值是不同的，最终导致集合添加了两个等价的对象。<ul>
<li><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511173327.png"  alt="hashCode示例"></li>
</ul>
</li>
<li>由此进行引申出：理想的哈希函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的哈希值上。这就要求了哈希函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。<ul>
<li>R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位，最左边的位丢失。</li>
<li>并且一个数与 31 相乘可以转换成移位和减法：31*x == (x&lt;&lt;5)-x，编译器会自动进行这个优化。（容器那里有详细解释）</li>
</ul>
</li>
</ol>
<h3 id="自定义了一个类，需要在Map、Set中使用，需要注意什么？"><a href="#自定义了一个类，需要在Map、Set中使用，需要注意什么？" class="headerlink" title="自定义了一个类，需要在Map、Set中使用，需要注意什么？"></a>自定义了一个类，需要在Map、Set中使用，需要注意什么？</h3><p>重写hashcode，重写equals方法。</p>
<h3 id="两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？"><a href="#两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？" class="headerlink" title="两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？"></a>两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？</h3><p>不对，如果两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。</p>
<p>Java对于eqauls方法和hashCode方法是这样规定的：</p>
<ol>
<li>如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；</li>
<li>如果两个对象的hashCode相同，它们并不一定相同。</li>
</ol>
<p>当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。</p>
<h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h2><h3 id="关于toString的认识"><a href="#关于toString的认识" class="headerlink" title="关于toString的认识"></a>关于toString的认识</h3><p>返回的数据：默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。</p>
<p><strong>编写toSring代码如下</strong></p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511173533.png"  alt="编写ToString相关类"></p>
<p><strong>测试代码如下</strong></p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511173559.png"  alt="ToString测试方法"></p>
<p><strong>结果如下</strong></p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511173612.png"  alt="结果打印"></p>
<h2 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h2><h3 id="四种拷贝方案"><a href="#四种拷贝方案" class="headerlink" title="四种拷贝方案"></a>四种拷贝方案</h3><p>以下分为四点简述一下clone相关知识点：</p>
<ol>
<li>cloneable</li>
<li>浅拷贝</li>
<li>深拷贝</li>
<li>clone() 的替代方案</li>
</ol>
<h4 id="cloneable"><a href="#cloneable" class="headerlink" title="cloneable"></a>cloneable</h4><p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p>
<p><strong>示例代码如下</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CloneExample e1 = <span class="keyword">new</span> CloneExample();</span><br><span class="line"><span class="comment">// CloneExample e2 = e1.clone(); // 'clone()' has protected access in 'java.lang.Object' 行不通，因为是protected</span></span><br></pre></td></tr></tbody></table></figure>

<p>重写 clone() 得到以下实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> </span>{    <span class="comment">// 此处没有实现Cloneable接口！！！</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CloneExample <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>{</span><br><span class="line">        <span class="keyword">return</span> (CloneExample)<span class="keyword">super</span>.clone();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CloneExample e1 = <span class="keyword">new</span> CloneExample();</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    CloneExample e2 = e1.clone();</span><br><span class="line">} <span class="keyword">catch</span> (CloneNotSupportedException e) {</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>打印如下</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.CloneNotSupportedException: CloneExample</span><br></pre></td></tr></tbody></table></figure>

<p>以上抛出了 <code>CloneNotSupportedException</code>，这是因为 CloneExample 没有实现 Cloneable 接口。</p>
<p>应该注意的是，<code>clone()</code> 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 <code>clone()</code> 方法，就会抛出 <code>CloneNotSupportedException</code>。</p>
<p>所以应该加上：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>记住最重要一条：拷贝对象和原始对象的引用类型引用同一个对象。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShallowCloneExample</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShallowCloneExample</span><span class="params">()</span> </span>{</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ShallowCloneExample <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>{</span><br><span class="line">        <span class="keyword">return</span> (ShallowCloneExample) <span class="keyword">super</span>.clone();    <span class="comment">// 直接进行super.clone对象的转换而已</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ShallowCloneExample e1 = <span class="keyword">new</span> ShallowCloneExample();</span><br><span class="line">ShallowCloneExample e2 = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    e2 = e1.clone();</span><br><span class="line">} <span class="keyword">catch</span> (CloneNotSupportedException e) {</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">}</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 222</span></span><br></pre></td></tr></tbody></table></figure>





<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>记住最重要的一条：拷贝对象和原始对象的引用类型引用不同对象。</p>
<p>示例代码如下</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepCloneExample</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeepCloneExample</span><span class="params">()</span> </span>{</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DeepCloneExample <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>{    <span class="comment">// 重写了clone方法</span></span><br><span class="line">        DeepCloneExample result = (DeepCloneExample) <span class="keyword">super</span>.clone();    <span class="comment">// 创建了一个super.clone对象转换之后的新对象result</span></span><br><span class="line">        result.arr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];    <span class="comment">// 进行数组的申请并且将所有元素进行拷贝</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">            result.arr[i] = arr[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;    <span class="comment">// 最后返回该新对象</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DeepCloneExample e1 = <span class="keyword">new</span> DeepCloneExample();</span><br><span class="line">DeepCloneExample e2 = <span class="keyword">null</span>;    <span class="comment">// 先置为null</span></span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    e2 = e1.clone();</span><br><span class="line">} <span class="keyword">catch</span> (CloneNotSupportedException e) {</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">}</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 222</span></span><br></pre></td></tr></tbody></table></figure>



<h4 id="clone-的替代方案"><a href="#clone-的替代方案" class="headerlink" title="clone() 的替代方案"></a>clone() 的替代方案</h4><p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p>
<p>实现代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneConstructorExample</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CloneConstructorExample</span><span class="params">()</span> </span>{</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CloneConstructorExample</span><span class="params">(CloneConstructorExample original)</span> </span>{    <span class="comment">// 拷贝构造函数，传入一个本身对象</span></span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[original.arr.length];    <span class="comment">// 获取原对象original的数组长度，初始化本地对象的数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; original.arr.length; i++) {    <span class="comment">// 将original对象的所有所有元素进行拷贝</span></span><br><span class="line">            arr[i] = original.arr[i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CloneConstructorExample e1 = <span class="keyword">new</span> CloneConstructorExample();</span><br><span class="line">CloneConstructorExample e2 = <span class="keyword">new</span> CloneConstructorExample(e1);</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 222</span></span><br></pre></td></tr></tbody></table></figure>











<h3 id="讲讲浅拷贝和深拷贝？？？"><a href="#讲讲浅拷贝和深拷贝？？？" class="headerlink" title="讲讲浅拷贝和深拷贝？？？"></a>讲讲浅拷贝和深拷贝？？？</h3><ul>
<li>浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</li>
<li>深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511175037.png"  alt="深拷贝与浅拷贝"></p>
<p>浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型，数组或引用），拷贝的就是内存地址。因此如果其中一个对象改变了这个地址，就会影响到另一个对象。Object 的 clone() 方法，提供的是一种浅克隆的机制。而拷贝构造方法指的是该类的构造方法参数为该类的对象。浅拷贝的实现方式如下：</p>
<ol>
<li>对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。因为是两份不同的数据，所以对其中一个对象的该成员变量值进行修改，不会影响另一个对象拷贝得到的数据</li>
<li>对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值</li>
</ol>
<p>深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。如果想要实现对对象的深克隆，在不引入第三方jar包的情况下，可以使用如下办法：</p>
<ol>
<li>先对对象进行序列化，紧接着马上反序列化出</li>
<li>重写 clone 方法。与通过重写 clone 方法实现浅拷贝的基本思路一样，只需要为对象图的每一层的每一个对象都实现 Cloneable 接口并重写 clone 方法。最后在最顶层的类的重写的 clone 方法中调用所有的 clone 方法即可实现深拷贝。简单的说就是：每一层的每个对象都进行浅拷贝=深拷贝</li>
<li>拷贝构造函数</li>
</ol>
<h3 id="数组的复制方法"><a href="#数组的复制方法" class="headerlink" title="数组的复制方法"></a>数组的复制方法</h3><ol>
<li>for循环</li>
<li><code>Arrays.copyOf</code> 本质上是调用 <code>System.arraycopy</code> 。之所以时间差距比较大，是因为很大一部分开销全花在了 Math.min 函数上了。所以，相比之下，<code>System.arraycopy</code> 效率要高一些。</li>
<li><code>clone()</code> 比较特殊，对于对象而言，它是深拷贝，但是对于数组而言，它是浅拷贝。</li>
<li>对于基本数据类型来说 <code>System.arraycopy()</code> 方法是深拷贝；对于引用数据类型来说 <code>System.arraycopy()</code> 方法是浅拷贝。System.arraycopy线程不安全！！！</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] copyOf(<span class="keyword">byte</span>[] original, <span class="keyword">int</span> newLength){</span><br><span class="line">    <span class="keyword">byte</span>[] copy = <span class="keyword">new</span> <span class="keyword">byte</span>[newLength];</span><br><span class="line">    <span class="comment">// 这里调用了System.arraycopy</span></span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>, Math.min(original.length, newLength));</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Object src,  //源数组</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> srcPos,  //源数组的起始位置</span></span></span><br><span class="line"><span class="function"><span class="params">            Object dest, //目标数组</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> destPos, //目标数组的起始位置</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> length   //复制长度</span></span></span><br><span class="line"><span class="function"><span class="params">        )</span></span></span><br></pre></td></tr></tbody></table></figure>



<h3 id="如何实现对象克隆？"><a href="#如何实现对象克隆？" class="headerlink" title="如何实现对象克隆？"></a>如何实现对象克隆？</h3><p>有三种方式：</p>
<ol>
<li>实现Cloneable接口并重写Object类中的clone()方法；</li>
<li>使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</li>
<li>实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下。</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUtil</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyUtil</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Serializable&gt; <span class="function">T <span class="title">clone</span><span class="params">(T obj)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化：通过对象输出流进而转成字符输出流，结合writeObject方法</span></span><br><span class="line">        ByteArrayOutputStream bout = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bout);</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反序列化：再通过字数输入流进而转成对象输入流，结合readObject方法</span></span><br><span class="line">        ByteArrayInputStream bin = <span class="keyword">new</span> ByteArrayInputStream(bout.toByteArray());</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bin);</span><br><span class="line">        <span class="keyword">return</span> (T) ois.readObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 说明：调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义</span></span><br><span class="line">        <span class="comment">// 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，这一点不同于对外部资源（如文件流）的释放</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 人类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">9102017020286042305L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;        <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">private</span> Car car;        <span class="comment">// 座驾</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, Car car)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.car = car;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 隐藏get 和 set 及 toString方法；</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 小汽车类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5713945027627603702L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String brand;       <span class="comment">// 品牌</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSpeed;       <span class="comment">// 最高时速</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String brand, <span class="keyword">int</span> maxSpeed)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.brand = brand;</span><br><span class="line">        <span class="keyword">this</span>.maxSpeed = maxSpeed;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 隐藏get 和 set 及 toString方法；</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloneTest</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Person p1 = <span class="keyword">new</span> Person(<span class="string">"Hao LUO"</span>, <span class="number">33</span>, <span class="keyword">new</span> Car(<span class="string">"Benz"</span>, <span class="number">300</span>));</span><br><span class="line">            Person p2 = MyUtil.clone(p1);   <span class="comment">// 深度克隆</span></span><br><span class="line">            p2.getCar().setBrand(<span class="string">"BYD"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 修改克隆的Person对象p2关联的汽车对象的品牌属性</span></span><br><span class="line">            <span class="comment">// 原来的Person对象p1关联的汽车不会受到任何影响</span></span><br><span class="line">            <span class="comment">// 因为在克隆Person对象时其关联的汽车对象也被克隆了</span></span><br><span class="line">            System.out.println(p1);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="comparable-和-Comparator的区别"><a href="#comparable-和-Comparator的区别" class="headerlink" title="comparable 和 Comparator的区别"></a>comparable 和 Comparator的区别</h2><p>主要联系如下</p>
<ol>
<li>comparable接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li>
<li>comparator接口实际上是出自 <code>java.util</code> 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li>
</ol>
<p>一般我们需要对一个集合使用自定义排序时，我们就要重写<code>compareTo()</code>方法或<code>compare()</code>方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写<code>compareTo()</code>方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 <code>Collections.sort()</code>.</p>
<p>Comparator定制排序</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    arrayList.add(-<span class="number">1</span>);</span><br><span class="line">    arrayList.add(<span class="number">3</span>);</span><br><span class="line">    arrayList.add(<span class="number">3</span>);</span><br><span class="line">    arrayList.add(-<span class="number">5</span>);</span><br><span class="line">    arrayList.add(<span class="number">7</span>);</span><br><span class="line">    arrayList.add(<span class="number">4</span>);</span><br><span class="line">    arrayList.add(-<span class="number">9</span>);</span><br><span class="line">    arrayList.add(-<span class="number">7</span>);</span><br><span class="line">    System.out.println(<span class="string">"原始数组:"</span>);</span><br><span class="line">    System.out.println(arrayList);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// void reverse(List list)：反转</span></span><br><span class="line">    Collections.reverse(arrayList);</span><br><span class="line">    System.out.println(<span class="string">"Collections.reverse(arrayList):"</span>);</span><br><span class="line">    System.out.println(arrayList);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// void sort(List list),按自然排序的升序排序</span></span><br><span class="line">    Collections.sort(arrayList);</span><br><span class="line">    System.out.println(<span class="string">"Collections.sort(arrayList):"</span>);</span><br><span class="line">    System.out.println(arrayList);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定制排序的用法</span></span><br><span class="line">    Collections.sort(arrayList, <span class="keyword">new</span> Comparator&lt;Integer&gt;() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"定制排序后："</span>);</span><br><span class="line">    System.out.println(arrayList);</span><br></pre></td></tr></tbody></table></figure>

<p>Output</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">原始数组:</span><br><span class="line">[-<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, -<span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>, -<span class="number">9</span>, -<span class="number">7</span>]</span><br><span class="line">Collections.reverse(arrayList):</span><br><span class="line">[-<span class="number">7</span>, -<span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, -<span class="number">5</span>, <span class="number">3</span>, <span class="number">3</span>, -<span class="number">1</span>]</span><br><span class="line">Collections.sort(arrayList):</span><br><span class="line">[-<span class="number">9</span>, -<span class="number">7</span>, -<span class="number">5</span>, -<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">定制排序后：</span><br><span class="line">[<span class="number">7</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, -<span class="number">1</span>, -<span class="number">5</span>, -<span class="number">7</span>, -<span class="number">9</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>重写compareTo方法实现按年龄来排序</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列</span></span><br><span class="line"><span class="comment">// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他</span></span><br><span class="line"><span class="comment">// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>{</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 隐藏geter和seter;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**     </span></span><br><span class="line"><span class="comment">      * TODO重写compareTo方法实现按年龄来排序     </span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>{</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.age &gt; o.getAge()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.age &lt; o.getAge()) {</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    TreeMap&lt;Person, String&gt; pdata = <span class="keyword">new</span> TreeMap&lt;Person, String&gt;();</span><br><span class="line">    pdata.put(<span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">30</span>), <span class="string">"zhangsan"</span>);</span><br><span class="line">    pdata.put(<span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">20</span>), <span class="string">"lisi"</span>);</span><br><span class="line">    pdata.put(<span class="keyword">new</span> Person(<span class="string">"王五"</span>, <span class="number">10</span>), <span class="string">"wangwu"</span>);</span><br><span class="line">    pdata.put(<span class="keyword">new</span> Person(<span class="string">"小红"</span>, <span class="number">5</span>), <span class="string">"xiaohong"</span>);</span><br><span class="line">    <span class="comment">// 得到key的值的同时得到key所对应的值</span></span><br><span class="line">    Set&lt;Person&gt; keys = pdata.keySet();</span><br><span class="line">    <span class="keyword">for</span> (Person key : keys) {</span><br><span class="line">        System.out.println(key.getAge() + <span class="string">"-"</span> + key.getName());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Output</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>-小红</span><br><span class="line"><span class="number">10</span>-王五</span><br><span class="line"><span class="number">20</span>-李四</span><br><span class="line"><span class="number">30</span>-张三</span><br></pre></td></tr></tbody></table></figure>









<hr>
<h1 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在 JDK8 中，String 类使用 char[] 数组保存值。这个 char 数组使用 final 修饰符修饰，意味着一旦确定就引用即不可修改；此外，String 类中也没有提供修改数组修改值的方法。上述两种方式保证了 String 值的不可变性。此外 String 类只用 final 修饰，表明其不可继承。</p>
<p>版本的变化区别：</p>
<p>在 Java 8 中，String 内部使用 char 数组存储数据。</p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511121122.png"  alt="Java 8中的String"></p>
<p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。</p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511121144.png"  alt="Java 9中的String"></p>
<h2 id="JAVA-String对象是如何实现的？（摘自极客时间）"><a href="#JAVA-String对象是如何实现的？（摘自极客时间）" class="headerlink" title="JAVA String对象是如何实现的？（摘自极客时间）"></a>JAVA String对象是如何实现的？（摘自极客时间）</h2><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/05/10/CVFcWBQpaKlzNqJ.png"  alt="String 对象变化"></p>
<p><strong>在 Java6 以及之前的版本中</strong>，String 对象是对 char 数组进行了封装实现的对象，主要有四个成员变量：char 数组、偏移量 offset、字符数量 count、哈希值 hash。String 对象是通过 offset 和 count 两个属性来定位 char[]数组，获取字符串。这么做可以高效、快速地共享数组对象，同时节省内存空间，但这种方式很有可能会导致内存泄漏。</p>
<p><strong>从 Java7 版本开始到 Java8 版本</strong>，Java 对 String 类做了一些改变。String 类中不再有 offset 和 count 两个变量了。这样的好处是 String 对象占用的内存稍微少了些，同时，String.substring 方法也不再共享 char[]，从而解决了使用该方法可能导致的内存泄漏问题。</p>
<p><strong>从 Java9 版本开始</strong>，工程师将 char[]字段改为了 byte[]字段，又维护了一个新的属性 coder，它是一个编码格式的标识。</p>
<ul>
<li>为什么要这么做呢？</li>
<li>我们知道一个 char 字符占 16 位，2 个字节。这个情况下，存储单字节编码内的字符（占一个字节的字符）就显得非常浪费。JDK1.9 的 String 类为了节约内存空间，于是使用了占 8 位，1 个字节的 byte 数组来存放字符串。而新属性 coder 的作用是，在计算字符串长度或者使用 indexOf（）函数时，我们需要根据这个字段，判断如何计算字符串长度。coder 属性默认有 0 和 1 两个值，0 代表 Latin-1（单字节编码），1 代表 UTF-16。如果 String 判断字符串只包含了 Latin-1，则 coder 属性值为 0，反之则为 1。</li>
</ul>
<h2 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别"></a>字符型常量和字符串常量的区别</h2><ol>
<li>形式上: 字符常量是单引号引起的一个字符 字符串常量是双引号引起的若干个字符</li>
<li>含义上: 字符常量相当于一个整形值(ASCII值),可以参加表达式运算 字符串常量代表一个地址值(该字符串在内存中存放位置)</li>
<li>占内存大小 字符常量只占一个字节 字符串常量占若干个字节(至少一个字符结束标志)</li>
</ol>
<h2 id="是否可以继承String类？"><a href="#是否可以继承String类？" class="headerlink" title="是否可以继承String类？"></a>是否可以继承String类？</h2><p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p>
<p>补充：继承String本身就是一个错误的行为，对String类型最好的重用方式是关联关系（Has-A）和依赖关系（Use-A）而不是继承关系（Is-A）。</p>
<h2 id="Sring-不可变"><a href="#Sring-不可变" class="headerlink" title="Sring 不可变"></a>Sring 不可变</h2><h3 id="String不可变性带来的好处"><a href="#String不可变性带来的好处" class="headerlink" title="String不可变性带来的好处"></a>String不可变性带来的好处</h3><ol>
<li><strong>可以缓存 hash 值</strong>：因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</li>
<li><strong>String Pool 的需要</strong>：如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。<ul>
<li>在 Java 中，通常有两种创建字符串对象的方式，一种是通过字符串常量的方式创建，如 <code>String str=“abc”</code>；另一种是字符串变量通过 new 形式的创建，如 <code>String str = new String(“abc”)</code>。</li>
<li>当代码中使用第一种方式创建字符串对象时，JVM 首先会检查该对象是否在字符串常量池中，如果在，就返回该对象引用，否则新的字符串将在常量池中被创建。这种方式可以减少同一个值的字符串对象的重复创建，节约内存。</li>
<li><code>String str = new String(“abc”)</code> 这种方式，首先在编译类文件时，”abc”常量字符串将会放入到常量结构中，在类加载时，“abc”将会在常量池中创建；其次，在调用 new 时，JVM 命令将会调用 String 的构造函数，同时引用常量池中的”abc” 字符串，在堆内存中创建一个 String 对象；最后，str 将引用 String 对象。</li>
</ul>
</li>
<li><strong>安全性</strong>：String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。</li>
<li><strong>线程安全</strong>：String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</li>
</ol>
<h3 id="Sring-不可变问题一"><a href="#Sring-不可变问题一" class="headerlink" title="Sring 不可变问题一"></a>Sring 不可变问题一</h3><p><strong>问题如下：</strong></p>
<p>对一个 String 对象 str 赋值“hello”，然后又让 str 值为“world”，这个时候 str 的值变成了“world”。那么 str 值确实改变了，为什么我还说 String 对象不可变呢？</p>
<p><strong>回答如下：</strong></p>
<p>首先，我来解释下什么是对象和对象引用。在 Java 中要比较两个对象是否相等，往往是用 ==，而要判断两个对象的值是否相等，则需要用 equals 方法来判断。</p>
<p>这是因为 str 只是 String 对象的引用，并不是对象本身。对象在内存中是一块内存地址，str 则是一个指向该内存地址的引用。所以在刚刚我们说的这个例子中，第一次赋值的时候，创建了一个“hello”对象，str 引用指向“hello”地址；第二次赋值的时候，又重新创建了一个对象“world”，str 引用指向了“world”，但“hello”对象依然存在于内存中。</p>
<p>也就是说 str 并不是对象，而只是一个对象引用。真正的对象依然还在内存中，没有被改变。</p>
<h3 id="String真的是不可变的吗？"><a href="#String真的是不可变的吗？" class="headerlink" title="String真的是不可变的吗？"></a>String真的是不可变的吗？</h3><p>我觉得如果别人问这个问题的话，回答不可变就可以了。 下面只是给大家看两个有代表性的例子：</p>
<p><strong>1) String不可变但不代表引用不可以变</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"Hello"</span>;</span><br><span class="line">str = str + <span class="string">" World"</span>;</span><br><span class="line">System.out.println(<span class="string">"str="</span> + str);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>结果：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str=Hello World</span><br></pre></td></tr></tbody></table></figure>

<p><strong>解析：</strong></p>
<p>实际上，原来String的内容是不变的，只是str由原来指向”Hello”的内存地址转为指向”Hello World”的内存地址而已，也就是说多开辟了一块内存区域给”Hello World”字符串。</p>
<p><strong>2) 通过反射是可以修改所谓的“不可变”对象</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建字符串"Hello World"， 并赋给引用s</span></span><br><span class="line">String s = <span class="string">"Hello World"</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"s = "</span> + s); <span class="comment">// Hello World</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取String类中的value字段</span></span><br><span class="line">Field valueFieldOfString = String.class.getDeclaredField("value");</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变value属性的访问权限</span></span><br><span class="line">valueFieldOfString.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取s对象上的value属性的值</span></span><br><span class="line"><span class="keyword">char</span>[] value = (<span class="keyword">char</span>[]) valueFieldOfString.get(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变value所引用的数组中的第5个字符</span></span><br><span class="line">value[<span class="number">5</span>] = <span class="string">'_'</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"s = "</span> + s); <span class="comment">// Hello_World</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>结果：</strong></p>
<figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">s</span> = Hello World</span><br><span class="line"><span class="attr">s</span> = Hello_World</span><br></pre></td></tr></tbody></table></figure>

<p><strong>解析：</strong></p>
<p>用反射可以访问私有成员， 然后反射出String对象中的value属性， 进而改变通过获得的value引用改变数组的结构。但是一般我们不会这么做，这里只是简单提一下有这个东西。</p>
<h2 id="String-intern问题"><a href="#String-intern问题" class="headerlink" title="String.intern问题"></a>String.intern问题</h2><h3 id="如何使用-String-intern-节省内存？"><a href="#如何使用-String-intern-节省内存？" class="headerlink" title="如何使用 String.intern 节省内存？"></a>如何使用 String.intern 节省内存？</h3><blockquote>
<p>摘自极客时间：如果能结合案例说出来就更好了！</p>
</blockquote>
<p>案例：</p>
<p>Twitter 每次发布消息状态的时候，都会产生一个地址信息，以当时 Twitter 用户的规模预估，服务器需要 32G 的内存来存储地址信息。</p>
<p>Twitter 每次发布消息状态的时候，都会产生一个地址信息，以当时 Twitter 用户的规模预估，服务器需要 32G 的内存来存储地址信息。</p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511112241.png"  alt="Location创建"></p>
<p>考虑到其中有很多用户在地址信息上是有重合的，比如，国家、省份、城市等，这时就可以将这部分信息单独列出一个类，以减少重复，代码如下：</p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511112301.png"  alt="重新创建"></p>
<p><strong>问题如下</strong></p>
<p>通过优化，数据存储大小减到了 20G 左右。但对于内存存储这个数据来说，依然很大，怎么办呢？</p>
<p>这个案例来自一位 Twitter 工程师在 QCon 全球软件开发大会上的演讲，他们想到的解决方法，就是使用 String.intern 来节省内存空间，从而优化 String 对象的存储。</p>
<p>具体做法就是，在每次赋值的时候使用 String 的 intern 方法，如果常量池中有相同值，就会重复使用该对象，返回对象引用，这样一开始的对象就可以被回收掉。这种方式可以使重复性非常高的地址信息存储大小从 20G 降到几百兆。</p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511112403.png"  alt="使用intern方法"></p>
<p>总结就是：运行时创建的字符串对象只会在堆中创建一个对象。在这个前提下，如果有相同值的对象创建，使用intern可以减少重复字符串的创建。例如，有广东省/深圳市/南山区，如果有千万个人发布消息，创建了地址对象，这样导致千万个“广东省”对象在堆内存中创建，如果长时间引用，这些对象都没法释放，使用intern将“广东省”放到常量池中，其他对象引用常量池中的同一个“广东省”字符串，而堆中的千万个对象将被回收。</p>
<p>追问：<code>String s1="123"</code>;字符串”123”已经被放入常量池，那要定义一个和s1一样的，用<code>String s2=s1;</code>不就好了，为什么还要用intern方法。推特的那个优化也一样，<code>setCity(messageInfo.getCity())</code>就好了，为什么要用intern呢？</p>
<p>回答：我们在类对象中的String属性是在堆内存中开辟的地址空间，所以如果不用intern方法，新生产的对象中的String字段的属性是引用堆内存的地址，而堆内存中创建的字段即使value值一样也会开辟新地址空间。如果使用intern方法，则会引用常量池中的引用，而如果常量池中如果存在字符串对象，则复用，不会再创建了。</p>
<h2 id="String的创建"><a href="#String的创建" class="headerlink" title="String的创建"></a>String的创建</h2><h3 id="说说new-String-“-“-的方式？"><a href="#说说new-String-“-“-的方式？" class="headerlink" title="说说new String(“ “)的方式？"></a>说说new String(“ “)的方式？</h3><p>new String(“abc”)，使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 “abc” 字符串对象）。</p>
<ul>
<li>“abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 “abc” 字符串字面量；</li>
<li>而使用 new 的方式会在堆中创建一个字符串对象。</li>
</ul>
<p>创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。</p>
<ul>
<li><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/Image.png"  alt="String 测试类"></li>
</ul>
<p>使用 javap -verbose 进行反编译，得到以下内容：</p>
<ul>
<li><p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511000516.png"  alt="反编译结果"></p>
</li>
<li><p>在 Constant Pool 中，#19 存储这字符串字面量 “abc”，#3 是 String Pool 的字符串对象，它指向 #19 这个字符串字面量。</p>
</li>
<li><p>在 main 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。</p>
</li>
</ul>
<p>以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。</p>
<ul>
<li><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511000556.png"  alt="Sring 构造函数"></li>
</ul>
<h3 id="String到底创建几个对象？"><a href="#String到底创建几个对象？" class="headerlink" title="String到底创建几个对象？"></a>String到底创建几个对象？</h3><p><code>String s1=new String("11");</code> //在堆中创建对象，并且新建一个”11”对象放入常量池；</p>
<p>即创建了两个对象，一个是静态区的”11”，一个是用new创建在堆上的对象。</p>
<p>对比声明式拼接<code>String s1=new String("11")+new String("111");</code>//创建5个，分别是堆中的3个：”11” “111” “11111”，常量池2个： “11” “111”；</p>
<p>看到不同了么，很多人认为，new出来的只在堆里，这就是最大的错误</p>
<h3 id="String-s-new-String-“xyz”-创建了几个字符串对象"><a href="#String-s-new-String-“xyz”-创建了几个字符串对象" class="headerlink" title="String s = new String(“xyz”);创建了几个字符串对象"></a>String s = new String(“xyz”);创建了几个字符串对象</h3><p>两个对象，一个是静态区的”xyz”，一个是用new创建在堆上的对象。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"hello"</span>; <span class="comment">//str1指向静态区</span></span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);  <span class="comment">//str2指向堆上的对象</span></span><br><span class="line">String str3 = <span class="string">"hello"</span>;</span><br><span class="line">String str4 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">System.out.println(str1.equals(str2)); <span class="comment">//true</span></span><br><span class="line">System.out.println(str2.equals(str4)); <span class="comment">//true</span></span><br><span class="line">System.out.println(str1 == str3); <span class="comment">//true</span></span><br><span class="line">System.out.println(str1 == str2); <span class="comment">//false</span></span><br><span class="line">System.out.println(str2 == str4); <span class="comment">//false</span></span><br><span class="line">System.out.println(str2 == <span class="string">"hello"</span>); <span class="comment">//false</span></span><br><span class="line">str2 = str1;</span><br><span class="line">System.out.println(str2 == <span class="string">"hello"</span>); <span class="comment">//true</span></span><br></pre></td></tr></tbody></table></figure>



<h3 id="不同创建方式对比问题一"><a href="#不同创建方式对比问题一" class="headerlink" title="不同创建方式对比问题一"></a>不同创建方式对比问题一</h3><p>通过三种不同的方式创建了三个对象，再依次两两匹配，每组被匹配的两个对象是否相等？</p>
<p><strong>创建如下</strong></p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511002015.png"  alt="三种String的创建方式"></p>
<p><strong>输出如下</strong></p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511002116.png"  alt="输出结果"></p>
<p><strong>原因</strong></p>
<ol>
<li><code>String str1 = "abc";</code>通过字面量的方式创建，abc存储于字符串常量池中；</li>
<li><code>String str2 = new String("abc");</code>通过new对象的方式创建字符串对象，引用地址存放在堆内存中，abc则存放在字符串常量池中；所以str1 == str2?显然是false</li>
<li><code>String str3 = str2.intern();</code>由于str2调用了intern()方法，会返回常量池中的数据，地址直接指向常量池，所以str1 == str3；</li>
<li>而str2和str3地址值不等所以也是false（str2指向堆空间，str3直接指向字符串常量池）。</li>
</ol>
<h3 id="不同创建方式对比问题二"><a href="#不同创建方式对比问题二" class="headerlink" title="不同创建方式对比问题二"></a>不同创建方式对比问题二</h3><p><strong>创建如下</strong></p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511002327.png"  alt="String创建代码"></p>
<p><strong>输出结果</strong></p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511002408.png"  alt="输出结果"></p>
<p><strong>原因</strong></p>
<ol>
<li>第一个通过加动态生成的“11”字符串由于在运行时常量中没有该字符串的引用，所以会在调用<code>s1.intern</code>时，在运行时常量池中生成一个s1的引用，当s2再次引用该字符串时，发现运行时常量池中存在相同值的字符串的引用，就直接返回s1的引用。所以<code>s1==s2</code>是返回的true。这也仅限于JDK1.7之后的版本。在JDK1.6版本运行的结果却为false：</li>
<li>第二种，用于”11”在类加载时，已经存在静态常量池中，在<code>new string(“11”)</code>时，会在运行时常量池中创建一个“11”字符串的直接引用。而s3指向的并不是该引用，而是<code>new string</code>这个对象的引用。此时s3.intern()返回的是常量池字符串常量”11”的引用，而非堆中的。当<code>s4=“11”</code>时，返回的是运行时常量池中的引用。所以<code>s3==s4</code>返回false。</li>
<li>意思就是：<code>s3.intern()==s4</code>是true，<code>s3==s4</code>是 false</li>
</ol>
<p>深入点，再看看JVM的编译是如何？</p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511003139.png"  alt="Jvm编译结果"></p>
<p>我们可以看到 0 new，即是生成了一个对象，这个对象是在堆内存用创建的，之后4 Idc则是将常量池中创建的字符串abc压入栈中，invokespecial调用构造方法复制abc字符串到对象中，invokevirtual调用intern本地方法，返回常量池中的对象引用给s1。</p>
<p><code>new String("abc")</code> 是会创建两个对象的，一个是堆对象，一个是常量池中的对象，intern会去判断常量池中是否有，这个时候是有的，所以不会创建，而是改变s1的引用。</p>
<h3 id="不同创建方式对比问题三"><a href="#不同创建方式对比问题三" class="headerlink" title="不同创建方式对比问题三"></a>不同创建方式对比问题三</h3><p><strong>问题如下</strong></p>
<p>为什么下面代码输出的是True？</p>
<p>为什么在第二段比较中会返回true,从字节码看s3应该就是生成了一个stringbuilder对象完成连接操作后执行了toString, s3不是应该仍然是堆内的对象地址吗?为什么会和常量池中的地址相等?</p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511112617.png"  alt="问题代码"></p>
<p><strong>回答如下</strong></p>
<p>查了下资料，说是在jdk1.7之后，如果字符串在堆中有实例，那intern方法就会把这个字符串的引用放在字符串常量池里，所以，<code>String s3 = new String("12") + new String("34");</code>这里在字符串常量池里放了一个字符串“12”，一个字符串“34”，在堆里存放他们的运算结果“1234”，然后把“1234”的引用返回给s3，</p>
<p><code>s3.intern()</code>这段代码运行时，jvm在堆里先到了字符串“1234”，所以就会把他的引用放到字符串常量池里，这个引用和s3相等，</p>
<p><code>String s4 = "1234"</code>;这个代码时，因此会直接去常量池中创建，创建的时候发现已经有这个对象了，此时也就是指向 s3 引用对象的一个引用。所以 s4 引用就指向和 s3 一样了。因此最后的比较 <code>s3 == s4</code> 是 true。</p>
<h3 id="不同创建方式对比问题四"><a href="#不同创建方式对比问题四" class="headerlink" title="不同创建方式对比问题四"></a>不同创建方式对比问题四</h3><p>创建如下：</p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511003224.png"  alt="两种String创建方式"></p>
<p>输出结果：</p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511003251.png"  alt="输出结果"></p>
<p>原理：</p>
<ol>
<li>在字符串常量中，默认会将对象放入常量池；在字符串变量中，对象是会创建在堆内存中，同时也会在常量池中创建一个字符串对象，String 对象中的 char 数组将会引用常量池中的 char 数组，并返回堆内存对象引用。</li>
<li>如果调用 intern 方法，会去查看字符串常量池中是否有等于该对象的字符串的引用，如果没有，在 JDK1.6 版本中会复制堆中的字符串到常量池中，并返回该字符串引用，堆内存中原有的字符串由于没有引用指向它，将会通过垃圾回收器回收。</li>
<li>在 JDK1.7 版本以后，由于常量池已经合并到了堆中，所以不会再复制具体字符串了，只是会把首次遇到的字符串的引用添加到常量池中；如果有，就返回常量池中的字符串引用。</li>
</ol>
<p><strong>那么实际情况呢？</strong></p>
<ol>
<li>在一开始字符串<code>"abc"</code>会在加载类时，在常量池中创建一个字符串对象。</li>
<li>创建 a 变量时/创建 b 变量时，调用 <code>new Sting()</code> 会在堆内存中创建一个 String 对象，String 对象中的 char 数组将会引用常量池中字符串。在调用 intern 方法之后，会去常量池中查找是否有等于该字符串对象的引用，有就返回引用。</li>
<li>而在堆内存中的两个对象，由于没有引用指向它，将会被垃圾回收。所以 a 和 b 引用的是同一个对象。</li>
<li>如果在运行时，创建字符串对象，将会直接在堆内存中创建，不会在常量池中创建。所以动态创建的字符串对象，调用 intern 方法，在 JDK1.6 版本中会去常量池中创建运行时常量以及返回字符串引用，在 JDK1.7 版本之后，会将堆中的字符串常量的引用放入到常量池中，当其它堆中的字符串对象通过 intern 方法获取字符串对象引用时，则会去常量池中判断是否有相同值的字符串的引用，此时有，则返回该常量池中字符串引用，跟之前的字符串指向同一地址的字符串对象。</li>
</ol>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511003406.png"  alt="创建String方法图示"></p>
<ul>
<li>注：<code>String str = new String("abc");</code>这个语句会在字符串常量池中和堆中都生成变量，但str指向堆中的变量；如果调用intern方法，则str指向字符串常量池中的变量，此时堆中的变量会被垃圾回收。</li>
</ul>
<h2 id="String中equals方法"><a href="#String中equals方法" class="headerlink" title="String中equals方法"></a>String中equals方法</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>{</span><br><span class="line">    <span class="comment">// 首先使用==判断二者内存是否指向同一个地方</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 再判断类型是否都为String</span></span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) {</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="comment">// 如果类型相等再根据长度逐一对比</span></span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) {</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 最后逐一对比字符是否相等</span></span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<h2 id="String的compareTo方法"><a href="#String的compareTo方法" class="headerlink" title="String的compareTo方法"></a>String的compareTo方法</h2><ul>
<li><p>compareTo()的返回值是整型，它是先比较对应字符的大小（ASCII码顺序），</p>
</li>
<li><ul>
<li>如果第一个字符和参数的第一个字符不等，结束比较，返回他们之间的差值。</li>
<li>如果第一个字符和参数的第一个字符相等，则以第二个字符和参数的第二个字符作比较，</li>
<li>以此类推，直至比较的字符或被比较的字符有一方全比较完，这时就比较字符的长度。</li>
</ul>
</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/05/10/Om3W2vC4iSgFYN9.png"  alt="compareTo方法示例"></p>
<h2 id="String、StringBuilder、StringBuffer"><a href="#String、StringBuilder、StringBuffer" class="headerlink" title="String、StringBuilder、StringBuffer"></a>String、StringBuilder、StringBuffer</h2><p><strong>String</strong> 是 Java 语言非常基础和重要的类，提供了构造和管理字符串的各种基本逻辑。它是典型的 Immutable 类，被声明成为 final class，所有属性也都是 final 的。也由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的 String 对象。由于字符串操作的普遍性，所以相关操作的效率往往对应用性能有明显影响。</p>
<ul>
<li>通过字面量赋值创建字符串（如：<code>String str=”twm”</code>）时，会先在常量池中查找是否存在相同的字符串，若存在，则将栈中的引用直接指向该字符串；若不存在，则在常量池中生成一个字符串，再将栈中的引用指向该字符串。</li>
<li>JDK 1.7后，intern方法还是会先去查询常量池中是否有已经存在，如果存在，则返回常量池中的引用，这一点与1.7之前没有区别，区别在于，如果在常量池找不到对应的字符串，则不会再将字符串拷贝到常量池，而只是在常量池中生成一个对原字符串的引用。简单的说，就是往常量池放的东西变了：原来在常量池中找不到时，复制一个副本放到常量池，1.7后则是将在堆上的地址引用复制到常量池。jdk1.7之后，常量池不仅仅可以存储对象，还可以存储对象的引用。</li>
<li>在jdk1.7之前，字符串常量存储在方法区的PermGen Space（永久代）。在jdk1.7之后，字符串常量重新被移到了堆中。</li>
</ul>
<p><strong>StringBuffer</strong> 是为解决上面提到拼接产生太多中间对象的问题而提供的一个类，我们可以用 append 或者 add 方法，把字符串添加到已有序列的末尾或者指定位置。StringBuffer 本质是一个线程安全的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销，所以除非有线程安全的需要，不然还是推荐使用它的后继者，也就是 StringBuilder。</p>
<p><strong>StringBuilder</strong> 是 Java 1.5 中新增的，在能力上和 StringBuffer 没有本质区别，但是它去掉了线程安全的部分，有效减小了开销，是绝大部分情况下进行字符串拼接的首选。</p>
<ul>
<li>注意：StringBuffer/StringBuilder对象的值是可以改变的，并且值改变以后，对象引用不会发生改变；两者对象在构造过程中，首先按照默认大小申请一个字符数组，由于会不断加入新数据，当超过默认大小后，会创建一个更大的数组，并将原先的数组内容复制过来，再丢弃旧的数组。因此，对于较大对象的扩容会涉及大量的内存复制操作，如果能够预先评估大小，可提升性能。</li>
</ul>
<p><strong>详细区分如下：</strong></p>
<ol>
<li>可变不可变<ul>
<li>String：字符串常量,在修改时不会改变自身;若修改,等于重新生成新的字符串对象。String 是只读字符串，String类是 final 类,不可以被继承。</li>
<li>StringBuffer：在修改时会改变对象自身,每次操作都是对 StringBuffer 对象本身进行修改,不是生成新的对象;使用场景:对字符串经常改变情况下,主要方法:<code>append()</code>,<code>insert()</code>等。</li>
<li>StringBuilder：可变</li>
</ul>
</li>
<li>线程是否安全<ul>
<li>String：对象定义后不可变,线程安全。</li>
<li>StringBuffer：是线程安全的(对调用方法加入同步锁),执行效率较慢,适用于多线程下操作字符串缓冲区大量数据。</li>
<li>StringBuilder：是线程不安全的,适用于单线程下操作字符串缓冲区大量数据。</li>
</ul>
</li>
<li>共同点<ul>
<li>StringBuffer、StringBuilder其底层在内存中的存储方式与String相同，都是以一个有序的字符序列（char类型的数组）进行存储</li>
<li>StringBuilder 与 StringBuffer 有公共父类 AbstractStringBuilder(抽象类)。</li>
<li>StringBuilder、 StringBuffer 的方法都会调用 AbstractStringBuilder 中的公共方法,如 <code>super.append(...)</code>。只是 StringBuffer 会在方法上加 synchronized 关键字,进行同步。</li>
<li>最后,如果程序不是多线程的,那么使用StringBuilder 效率高于 StringBuffer。因此,StringBuilder 的效率会更高。</li>
</ul>
</li>
<li>应用场景<ul>
<li>在字符串内容不经常发生变化的业务场景优先使用String类。例如：常量声明、少量的字符串拼接操作等。如果有大量的字符串内容拼接，避免使用String与String之间的“+”操作，因为这样会产生大量无用的中间对象，耗费空间且执行效率低下（新建对象、回收对象花费大量时间）。</li>
<li>在频繁进行字符串的运算（如拼接、替换、删除等），并且运行在多线程环境下，建议使用StringBuffer，例如XML解析、HTTP参数解析与封装。</li>
<li>在频繁进行字符串的运算（如拼接、替换、删除等），并且运行在单线程环境下，建议使用StringBuilder，例如SQL语句拼装、JSON封装等。</li>
</ul>
</li>
</ol>
<p><strong>知识拓展</strong>：</p>
<ol>
<li>字符串设计与实现考量<ul>
<li>String 是 Immutable 类的典型实现，原生的保证了基础线程安全，因为你无法对它内部数据进行任何修改，这种便利甚至体现在拷贝构造函数中，由于不可变，Immutable 对象在拷贝时不需要额外复制数据。</li>
<li>StringBuffer 实现的一些细节，它的线程安全是通过把各种修改数据的方法都加上 synchronized 关键字实现的，非常直白。其实，这种简单粗暴的实现方式，非常适合我们常见的线程安全类实现，不必纠结于 synchronized 性能之类的，有人说“过早优化是万恶之源”，考虑可靠性、正确性和代码可读性才是大多数应用开发最重要的因素。</li>
<li>为了实现修改字符序列的目的，StringBuffer 和 StringBuilder 底层都是利用可修改的（char，JDK 9 以后是 byte）数组，二者都继承了 AbstractStringBuilder，里面包含了基本操作，区别仅在于最终的方法是否加了 synchronized。</li>
<li><strong>另外，这个内部数组应该创建成多大的呢？</strong>如果太小，拼接的时候可能要重新创建足够大的数组；如果太大，又会浪费空间。目前的实现是，构建时初始字符串长度加 <u>16</u>（这意味着，如果没有构建对象时输入最初的字符串，那么初始值就是 16）。我们如果确定拼接会发生非常多次，而且大概是可预计的，那么就可以指定合适的大小，避免很多次扩容的开销。扩容会产生多重开销，因为要抛弃原有数组，创建新的（可以简单认为是倍数）数组，还要进行 arraycopy。</li>
<li><strong>在没有线程安全问题的情况下，全部拼接操作是应该都用 StringBuilder 实现吗？</strong>我们在JDK8和JDK9分别进行反编译之后发现：非静态的拼接逻辑在 JDK 8 中会自动被 javac 转换为 StringBuilder 操作；而在 JDK 9 里面，则是体现了思路的变化。Java 9 利用 InvokeDynamic，将字符串拼接的优化与 javac 生成的字节码解耦，假设未来 JVM 增强相关运行时实现，将不需要依赖 javac 的任何修改</li>
</ul>
</li>
<li>字符串缓存（关于Intern 与 String Pool相关）<ul>
<li>String 在 Java 6 以后提供了 <code>intern() 方</code>法，目的是提示 JVM 把相应字符串缓存起来，以备重复使用。在我们创建字符串对象并调用 <code>intern()</code> 方法的时候，如果已经有缓存的字符串，就会返回缓存里的实例，否则将其缓存起来。一般来说，JVM 会将所有的类似“abc”这样的文本字符串，或者字符串常量之类缓存起来。看起来很不错是吧？但实际情况估计会让你大跌眼镜。一般使用 Java 6 这种历史版本，并不推荐大量使用 intern，为什么呢？魔鬼存在于细节中，被缓存的字符串是存在所谓 PermGen 里的，也就是臭名昭著的“永久代”，这个空间是很有限的，也基本不会被 FullGC 之外的垃圾收集照顾到。所以，如果使用不当，OOM 就会光顾。在后续版本中，这个缓存被放置在堆中，这样就极大避免了永久代占满的问题，甚至永久代在 JDK 8 中被 MetaSpace（元数据区）替代了。而且，默认缓存大小也在不断地扩大中，从最初的 1009，到 7u40 以后被修改为 60013。</li>
<li><strong>Intern 是一种显式地排重机制</strong>，但是它也有一定的副作用，因为需要开发者写代码时明确调用，一是不方便，每一个都显式调用是非常麻烦的；另外就是我们很难保证效率，应用开发阶段很难清楚地预计字符串的重复情况，有人认为这是一种污染代码的实践。幸好在 Oracle JDK 8u20 之后，推出了一个新的特性，也就是 G1 GC 下的字符串排重。它是通过将相同数据的字符串指向同一份数据来做到的，是 JVM 底层的改变，并不需要 Java 类库做什么修改。注意这个功能目前是默认关闭的，你需要使用下面参数开启，并且记得指定使用 G1 GC：<ul>
<li><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511120803.png"  alt="参数命令"></li>
</ul>
</li>
<li>更多关于Intern，查看美团技术的文章： <a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html" target="_blank" rel="noopener">https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html</a></li>
<li>关于Intren我只说两句话：<ol>
<li>直接使用双引号声明出来的String对象会直接存储在常量池中。</li>
<li>如果不是用双引号声明的String对象，可以使用String提供的intern方法。intern 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。</li>
</ol>
</li>
<li>Intern的大体实现结构就是：<u>JAVA 使用 jni 调用c++实现的StringTable的intern方法, StringTable的intern方法跟Java中的HashMap的实现是差不多的, 只是不能自动扩容</u>。默认大小是1009。要注意的是，String的String Pool是一个固定大小的Hashtable，默认值大小长度是1009，如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern时性能会大幅下降（因为要一个一个找）。在 jdk6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。在jdk7中，StringTable的长度可以通过一个参数指定：<ul>
<li><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511120924.png"  alt="StringTalbe参数"></li>
</ul>
</li>
</ul>
</li>
<li>String 自身的演化<ul>
<li>在历史版本中，它是使用 char 数组来存数据的，这样非常直接。但是 Java 中的 char 是两个 bytes 大小，拉丁语系语言的字符，根本就不需要太宽的 char，这样无区别的实现就造成了一定的浪费。在 Java 9 中，我们引入了 Compact Strings 的设计，对字符串进行了大刀阔斧的改进。<u>将数据存储方式从 char 数组，改变为一个 byte 数组加上一个标识编码的所谓 coder，并且将相关字符串操作类都进行了修改</u>。另外，所有相关的 Intrinsic 之类也都进行了重写，以保证没有任何性能损失。</li>
<li>在极端情况下，字符串也出现了一些能力退化，比如最大字符串的大小。你可以思考下，原来 char 数组的实现，字符串的最大长度就是数组本身的长度限制，但是替换成 byte 数组，同样数组长度下，存储能力是退化了一倍的！还好这是存在于理论中的极限，还没有发现现实应用受此影响。</li>
<li>在通用的性能测试和产品实验中，我们能非常明显地看到紧凑字符串带来的优势，即更小的内存占用、更快的操作速度。</li>
</ul>
</li>
</ol>
<h2 id="关于-“-”-运算符问题"><a href="#关于-“-”-运算符问题" class="headerlink" title="关于 “+” 运算符问题"></a>关于 “+” 运算符问题</h2><p>什么情况下用+运算符进行字符串连接比调用StringBuffer/StringBuilder对象的append方法连接字符串性能更好？</p>
<p>回答如下：</p>
<p>String一旦赋值或实例化后就不可更改，如果赋予新值将会重新开辟内存地址进行存储。而StringBuffer类使用append和insert等方法改变字符串值时只是在原有对象存储的内存地址上进行连续操作，减少了资源的开销。</p>
<p>如果有大量需要进行字符串拼接的操作，最好还是使用StringBuffer或StringBuilder进行。是少量的字符串可以使用+。</p>
<p>字符串的+操作其本质是创建了StringBuilder对象进行append操作，然后将拼接后的StringBuilder对象用toString方法处理成String对象，这一点可以用javap -c StringEqualTest.class命令获得class文件对应的JVM字节码指令就可以看出来。</p>
<p>注意：下面代码编译后，你可以看到编译器同样对这段代码进行了优化。不难发现，Java 在进行字符串的拼接时，偏向使用 StringBuilder，这样可以提高程序的效率。</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/05/10/DRwQZ3CyHkpEWjT.png"  alt="“+&quot;运算"></p>
<ul>
<li>即使使用 + 号作为字符串的拼接，也一样可以被编译器优化成 StringBuilder 的方式。但再细致些，你会发现在编译器优化的代码中，每次循环都会生成一个新的 StringBuilder 实例，同样也会降低系统的性能。</li>
<li>所以平时做字符串拼接的时候，我建议你还是要显示地使用 String Builder 来提升系统性能。</li>
<li>如果在多线程编程中，String 对象的拼接涉及到线程安全，你可以使用 StringBuffer。但是要注意，由于 StringBuffer 是线程安全的，涉及到锁竞争，所以从性能上来说，要比 StringBuilder 差一些。</li>
</ul>
<h2 id="什么是String-Pool？"><a href="#什么是String-Pool？" class="headerlink" title="什么是String Pool？"></a>什么是String Pool？</h2><p>字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中。当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。常量池里不止是字面量常量，还有引用型常量。</p>
<p>下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得同一个字符串引用。</p>
<p>intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/05/10/NRDjYsTemdoL6X9.png"  alt="intern 示例1"></p>
<p>如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/05/10/6ctILFp8UbKXWOe.png"  alt="intern 示例2"></p>
<p>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p>
<h2 id="String-API"><a href="#String-API" class="headerlink" title="String API"></a>String API</h2><h3 id="String-类的常用方法都有那些？"><a href="#String-类的常用方法都有那些？" class="headerlink" title="String 类的常用方法都有那些？"></a>String 类的常用方法都有那些？</h3><ul>
<li>indexOf()：返回指定字符的索引。</li>
<li>charAt()：返回指定索引处的字符。</li>
<li>replace()：字符串替换。</li>
<li>trim()：去除字符串两端空白。</li>
<li>split()：分割字符串，返回一个分割后的字符串数组。</li>
<li>getBytes()：返回字符串的 byte 类型数组。</li>
<li>length()：返回字符串长度。</li>
<li>toLowerCase()：将字符串转成小写字母。</li>
<li>toUpperCase()：将字符串转成大写字符。</li>
<li>substring()：截取字符串。</li>
<li>equals()：字符串比较。</li>
</ul>
<h3 id="共享char数组可能导致内存泄露问题？"><a href="#共享char数组可能导致内存泄露问题？" class="headerlink" title="共享char数组可能导致内存泄露问题？"></a>共享char数组可能导致内存泄露问题？</h3><p>String.substring 方法也不再共享 char[]，从而解决了使用该方法可能导致的内存泄漏问题。</p>
<p>在Java6中substring方法会调用<code>new string</code>构造函数，此时会复用原来的char数组，而如果我们仅仅是用substring获取一小段字符，而原本string字符串非常大的情况下，substring的对象如果一直被引用，由于substring的里面的char数组仍然指向原字符串，此时string字符串也无法回收，从而导致内存泄露。</p>
<p>试想下，如果有大量这种通过substring获取超大字符串中一小段字符串的操作，会因为内存泄露而导致内存溢出。</p>
<h3 id="如何将字符串反转？"><a href="#如何将字符串反转？" class="headerlink" title="如何将字符串反转？"></a>如何将字符串反转？</h3><p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StringBuffer reverse</span></span><br><span class="line">StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">stringBuffer. append(<span class="string">"abcdefg"</span>);</span><br><span class="line">System. out. println(stringBuffer. reverse()); <span class="comment">// gfedcba</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// StringBuilder reverse</span></span><br><span class="line">StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">stringBuilder. append(<span class="string">"abcdefg"</span>);</span><br><span class="line">System. out. println(stringBuilder. reverse()); <span class="comment">// gfedcba</span></span><br></pre></td></tr></tbody></table></figure>



<h3 id="数组有没有-length-方法？String-有没有-length-方法"><a href="#数组有没有-length-方法？String-有没有-length-方法" class="headerlink" title="数组有没有 length()方法？String 有没有 length()方法"></a>数组有没有 length()方法？String 有没有 length()方法</h3><p>数组没有 length()方法 ，有 length 的属性。String 有 length()方法。JavaScript中，获得字符串的长度是通过 length 属性得到的，这一点容易和 Java 混淆。</p>
<h2 id="String-字符串编码"><a href="#String-字符串编码" class="headerlink" title="String 字符串编码"></a>String 字符串编码</h2><h3 id="怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？"><a href="#怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？" class="headerlink" title="怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？"></a>怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？</h3><p>代码如下所示：</p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511113653.png"  alt="Sring字符串编码转换代码"></p>
<hr>
<h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h2 id="Static-关键字"><a href="#Static-关键字" class="headerlink" title="Static 关键字"></a>Static 关键字</h2><h3 id="静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同？"><a href="#静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同？" class="headerlink" title="静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？"></a>静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？</h3><p>Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化，其语法看起来挺诡异的</p>
<h3 id="下面的代码哪些地方会产生编译错误？"><a href="#下面的代码哪些地方会产生编译错误？" class="headerlink" title="下面的代码哪些地方会产生编译错误？"></a>下面的代码哪些地方会产生编译错误？</h3><p>示例代码</p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511180449.png"  alt="static示例代码"></p>
<p>注意：Java中非静态内部类对象的创建要依赖其外部类对象，上面的面试题中foo和main方法都是静态方法，静态方法中没有this，也就是说没有所谓的外部类对象因此无法创建内部类对象，如果要在静态方法中创建内部类对象，可以这样做：</p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511180502.png"  alt="正确做法"></p>
<h3 id="static修饰的特点？java的static讲下，然后有6种用法，我说了4种，后来网上搜也只有五种呀"><a href="#static修饰的特点？java的static讲下，然后有6种用法，我说了4种，后来网上搜也只有五种呀" class="headerlink" title="static修饰的特点？java的static讲下，然后有6种用法，我说了4种，后来网上搜也只有五种呀"></a>static修饰的特点？java的static讲下，然后有6种用法，我说了4种，后来网上搜也只有五种呀</h3><p>1）<strong>静态变量</strong></p>
<p>静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。</p>
<p>实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。</p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511180734.png"  alt="静态变量与实例变量"></p>
<p>2）<strong>静态方法</strong></p>
<p>静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。</p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511180830.png"  alt="静态方法创建"></p>
<p>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字，因此这两个关键字与具体对象关联。</p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511180852.png"  alt="静态方法错误示例"></p>
<p>3）<strong>静态语句块</strong></p>
<p>静态语句块在类初始化时运行一次。</p>
<p>示例代码如下：</p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511180932.png"  alt="静态语句块示例"></p>
<p>4）<strong>静态内部类</strong></p>
<p>非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。</p>
<p>静态内部类不能访问外部类的非静态的变量和方法。</p>
<p>示例代码如下：</p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511181003.png"  alt="静态内部类示例代码"></p>
<p>5）<strong>静态导包</strong></p>
<p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。</p>
<p>示例代码如下：</p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511181033.png"  alt="静态导包示例代码"></p>
<h3 id="Static-初始化顺序"><a href="#Static-初始化顺序" class="headerlink" title="Static 初始化顺序"></a>Static 初始化顺序</h3><p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序</p>
<p>存在继承的情况下，初始化顺序为：</p>
<ol>
<li>父类（静态变量、静态语句块）</li>
<li>子类（静态变量、静态语句块）</li>
<li>父类（实例变量、普通语句块）</li>
<li>父类（构造函数）</li>
<li>子类（实例变量、普通语句块）</li>
<li>子类（构造函数）</li>
</ol>
<h2 id="Final关键字"><a href="#Final关键字" class="headerlink" title="Final关键字"></a>Final关键字</h2><h3 id="Final修饰的特点，基本类型和类类型"><a href="#Final修饰的特点，基本类型和类类型" class="headerlink" title="Final修饰的特点，基本类型和类类型"></a>Final修饰的特点，基本类型和类类型</h3><ul>
<li>修饰类：表示该类不能被继承；</li>
<li>修饰方法：表示方法不能被重写；</li>
<li>修饰变量：表示变量只能一次赋值以后值不能被修改（常量）。使用 final 关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。</li>
</ul>
<h3 id="阐述final、finally、finalize的区别。"><a href="#阐述final、finally、finalize的区别。" class="headerlink" title="阐述final、finally、finalize的区别。"></a>阐述final、finally、finalize的区别。</h3><ol>
<li>final可以用来修饰类、方法、变量，分别有不同的意义， final修饰的class代表不可以继承扩展， final的变量是不可以修改的，而final的方法也是不可以重写的（override）。<ul>
<li>推荐使用final关键字来明确表示我们代码的语义、逻辑意图，这已经被证明在很多场景下是非常好的实践，比如：<ul>
<li>我们可以将方法或者类声明为fnal，这样就可以明确告知别人，这些行为是不许修改的</li>
<li>使用final修饰参数或者变量，也可以清楚地避免意外赋值导致的编程错误，甚至，有人明确推荐将所有方法参数、本地变量、成员变量声明成final。</li>
<li>final变量产生了某种程度的不可变（immutable）的效果，所以，可以用于保护只读数据，尤其是在并发编程中，因为明确地不能再赋值final变量，有利于减少额外的同步开销，也可以省去一些防御性拷贝的必要。</li>
</ul>
</li>
</ul>
</li>
<li>finally则是Java保证重点代码一定要被执行的一种机制。我们可以使用try-finally或者try-catch-finally来进行类似关闭JDBC连接、保证unlock锁等动作。</li>
<li>finalize是基础类java.lang.Object的一个方法，它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。 finalize机制现在已经不推荐使用，并且在JDK 9开始被标记为deprecated。<ul>
<li>为什么呢？简单说，你无法保证fnalize什么时候执行，执行的是否符合预期。使用不当会影响性能，导致程序死锁、挂起等。</li>
<li>注意： 这个方法一个对象只能执行一次，只能在第一次进入被回收的队列，而且对象所属于的类重写了finalize方法才会被执行。第二次进入回收队列的时候，不会再执行其finalize方法，而是直接被二次标记，在下一次GC的时候被GC。</li>
<li><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511181715.png"  alt="GC过程"></li>
<li>注意：fnalize还有有一种用途：在 Java 中调用非 Java 代码，在非 Java 代码中若调用了C的 malloc 来分配内存，如果不调用 C 的free 函数，会导致内存泄露。所以需要在 fnalize 中调用它。换句话说：fnalize本身就是为了提供类似c或c++析构函数产生的</li>
</ul>
</li>
</ol>
<h3 id="几个-fanlly-不会被执行的情况"><a href="#几个-fanlly-不会被执行的情况" class="headerlink" title="几个 fanlly 不会被执行的情况"></a>几个 fanlly 不会被执行的情况</h3><ol>
<li>try-cach 异常退出。</li>
<li>无限循环</li>
<li>线程被杀死<ul>
<li>当执行 try， fnally 的线程被杀死时。 fnally 也无法执行。</li>
</ul>
</li>
</ol>
<p>总结：</p>
<ul>
<li>不要在 fnally 中使用 return 语句。</li>
<li>fnally 总是执行，除非程序或者线程被中断</li>
</ul>
<h3 id="匿名内部类，访问局部变量时，局部变量为啥要用fnal来修饰吗？"><a href="#匿名内部类，访问局部变量时，局部变量为啥要用fnal来修饰吗？" class="headerlink" title="匿名内部类，访问局部变量时，局部变量为啥要用fnal来修饰吗？"></a>匿名内部类，访问局部变量时，局部变量为啥要用fnal来修饰吗？</h3><p>因为Java inner class实际会copy一份，不是去直接使用局部变量， fnal可以防止出现数据一致性问题</p>
<h3 id="final不是immutable"><a href="#final不是immutable" class="headerlink" title="final不是immutable?"></a>final不是immutable?</h3><p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511182254.png"  alt="讲解用例"></p>
<p>final只能约束strList这个引用不可以被赋值，但是strList对象行为不被fnal影响，添加元素等操作是完全正常的。如果我们真的希望对象本身是不可变的，那么需要相应的类支持不可变的行为。在上面这个例子中， List.of方法创建的本身就是不可变List，最后那句add是会在运行时抛出异常的。</p>
<p>Immutable在很多场景是非常棒的选择，某种意义上说， Java语言目前并没有原生的不可变支持，如果要实现immutable的类，我们需要做到：</p>
<ol>
<li><p>将class自身声明为final，这样别人就不能扩展来绕过限制了。</p>
</li>
<li><p>将所有成员变量定义为private和final，并且不要实现setter方法。</p>
</li>
<li><p>通常构造对象时，成员变量使用深度拷贝来初始化，而不是直接赋值，这是一种防御措施，因为你无法确定输入对象不被其他人修改。</p>
</li>
<li><p>如果确实需要实现getter方法，或者其他可能会返回内部状态的方法，使用copy-on-write原则，创建私有的copy。</p>
</li>
</ol>
<h3 id="static与final修饰变量所处JVM中的位置"><a href="#static与final修饰变量所处JVM中的位置" class="headerlink" title="static与final修饰变量所处JVM中的位置"></a>static与final修饰变量所处JVM中的位置</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">10</span>;    <span class="comment">// static int x 在方法区</span></span><br><span class="line">    <span class="keyword">static</span> BigWaterMelon bigWaterMelon_1 = <span class="keyword">new</span> BigWaterMelon(x);    <span class="comment">// static BigWaterMelon bigWaterMelon_1在方法区，而new BigWaterMelon(x)在堆上</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">20</span>;        <span class="comment">// int y=20 在堆上</span></span><br><span class="line">    BigWaterMelon bigWaterMelon_2 = <span class="keyword">new</span> BigWaterMelon(y);    <span class="comment">// BigWaterMelon bigWaterMelon_2 与 new BigWaterMelon(y) 都在堆上</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{    <span class="comment">// String[] args 在vm栈上</span></span><br><span class="line">        <span class="keyword">final</span> Fruit fruit = <span class="keyword">new</span> Fruit();        <span class="comment">// Fruit fruit 在vm栈上，而 new Fruit() 在堆上</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> z = <span class="number">30</span>;    <span class="comment">// int z = 30 在vm栈上</span></span><br><span class="line">        BigWaterMelon bigWaterMelon_3 = <span class="keyword">new</span> BigWaterMelon(z);    <span class="comment">// BigWaterMelon bigWaterMelon_3 在vm栈上，而new BigWaterMelon(z)在堆上</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{  </span><br><span class="line">                <span class="keyword">int</span> k = <span class="number">100</span>;    <span class="comment">// int k=100 在栈帧上</span></span><br><span class="line">                setWeight(k);</span><br><span class="line">            }</span><br><span class="line"> </span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">int</span> waterMelonWeight)</span> </span>{    <span class="comment">// int waterMelonWeight 在栈帧上</span></span><br><span class="line">                fruit.bigWaterMelon_2.weight = waterMelonWeight;</span><br><span class="line">            }</span><br><span class="line">        }.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BigWaterMelon</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BigWaterMelon</span><span class="params">(<span class="keyword">int</span> weight)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> weight;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/" class="lazyload" data-src="https://img-blog.csdn.net/20180606191239192"  alt="内存分配图"></p>
<p>由于方法区和堆内存的数据都是线程间共享的，所以线程Main Thread，New Thread和Another Thread都可以访问方法区中的静态变量以及访问这个变量所引用的对象的实例变量。</p>
<p>栈内存中每个线程都有自己的虚拟机栈，每一个栈帧之间的数据就是线程独有的了，也就是说线程New Thread中setWeight方法是不能访问线程Main Thread中的局部变量bigWaterMelon_3，但是我们发现setWeight却访问了同为Main Thread局部变量的“fruit”，这是为什么呢？因为“fruit”被声明为final了。</p>
<p>当“fruit”被声明为final后，“fruit”会作为New Thread的构造函数的一个参数传入New Thread，也就是堆内存中Fruit$1对象中的实例变量val$fruit会引用“fruit”引用的对象，从而New Thread可以访问到Main Thread的局部变量“fruit”。</p>
<h3 id="fnalize真的那么不堪？"><a href="#fnalize真的那么不堪？" class="headerlink" title="fnalize真的那么不堪？"></a>fnalize真的那么不堪？</h3><p>Finalize是一种已经被业界证明了的非常不好的实践，那么为什么会导致那些问题呢？</p>
<ol>
<li>fnalize的执行是和垃圾收集关联在一起的，一旦实现了非空的fnalize方法，就会导致相应对象回收呈现数量级上的变慢，有人专门做过benchmark，大概是40~50倍的下降。</li>
<li>因为， finalize被设计成在对象被垃圾收集前调用，这就意味着实现了fnalize方法的对象是个“特殊公民”， JVM要对它进行额外处理。 finalize本质上成为了快速回收的阻碍者，可能导致你的对象经过多个垃圾收集周期才能被回收。</li>
<li>实践中，因为finalize拖慢垃圾收集，导致大量对象堆积，也是一种典型的导致OOM的原因。</li>
<li>从另一个角度，我们要确保回收资源就是因为资源都是有限的，垃圾收集时间的不可预测，可能会极大加剧资源占用。这意味着对于消耗非常高频的资源，千万不要指望fnalize去承担资源释放的主要职责，最多让fnalize作为最后的“守门员”，况且它已经暴露了如此多的问题。这也是为什么我推荐， 资源用完即显式释放，或者利用资源池来尽量重用。</li>
<li>fnalize还会掩盖资源回收时的出错信息</li>
</ol>
<h3 id="有什么机制可以替换fnalize吗？"><a href="#有什么机制可以替换fnalize吗？" class="headerlink" title="有什么机制可以替换fnalize吗？"></a>有什么机制可以替换fnalize吗？</h3><p>Java平台目前在逐步使用java.lang.ref.Cleaner来替换掉原有的fnalize实现。 Cleaner的实现利用了幻象引用（PhantomReference），这是一种常见的所谓post-mortem清理机制。</p>
<p>利用幻象引用和引用队列，我们可以保证对象被彻底销毁前做一些类似资源回收的工作，比如关闭文件描述符（操作系统有限的资源），它比fnalize更加轻量、更加可靠。</p>
<p>注意，从可预测性的角度来判断， Cleaner或者幻象引用改善的程度仍然是有限的，如果由于种种原因导致幻象引用堆积，同样会出现问题。所以， Cleaner适合作为一种最后的保证手段，而不是完全依赖Cleaner进行资源回收，不然我们就要再做一遍fnalize的噩梦了。</p>
<h2 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h2><h3 id="解释一下super？"><a href="#解释一下super？" class="headerlink" title="解释一下super？"></a>解释一下super？</h3><p>访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。应该注意到，子类一定会调用父类的构造函数来完成初始化工作，一般是调用父类的默认构造函数，如果子类需要调用父类其它构造函数，那么就可以使用 super() 函数。</p>
<p>访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。</p>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperExample</span> </span>{</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperExample</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"SuperExample.func()"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperExtendExample</span> <span class="keyword">extends</span> <span class="title">SuperExample</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperExtendExample</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>(x, y);</span><br><span class="line">        <span class="keyword">this</span>.z = z;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>.func();</span><br><span class="line">        System.out.println(<span class="string">"SuperExtendExample.func()"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>测试如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SuperExample e = <span class="keyword">new</span> SuperExtendExample(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">e.func();</span><br></pre></td></tr></tbody></table></figure>

<p>结果如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SuperExample.func()</span><br><span class="line">SuperExtendExample.func()</span><br></pre></td></tr></tbody></table></figure>



<h3 id="super-与-this-的区别"><a href="#super-与-this-的区别" class="headerlink" title="super 与 this 的区别"></a>super 与 this 的区别</h3><ul>
<li>super（参数）：调用基类中的某一个构造函数（应该为构造函数中的第一条语句）；this（参数）：调用本类中另一种形成的构造函数（应该为构造函数中的第一条语句）</li>
<li>super 引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 或 super.成员函数名()；this 代表当前对象名（在程序中易产生二义性之处，应使用 this 来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用 this 来指明成员变量名）</li>
<li>调用 super() 必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用 super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。</li>
<li>super() 和 this()类似,区别在于 super() 从子类中调用父类的构造方法，this() 在同一类内调用其它方法。</li>
<li>super() 和 this()均需放在构造方法内第一行。</li>
<li>尽管可以用 this调用一个构造器，但却不能调用两个。</li>
<li>this 和 super 不能同时出现在一个构造函数里面，因为 this 必然会调用其它的构造函数，其它的构造函数必然也会有 super 语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</li>
<li>this() 和 super() 都指的是对象，所以，均不可以在 static 环境中使用。包括：static 变量,static 方法，static 语句块。</li>
<li>从本质上讲，this 是一个指向本对象的指针, 然而 super 是一个Java关键字。</li>
</ul>
<h2 id="instanceof关键字"><a href="#instanceof关键字" class="headerlink" title="instanceof关键字"></a>instanceof关键字</h2><p>instanceof 严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例，用法为：boolean result = obj instanceof Class;其中 obj 为一个对象，Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果 result 都返回 true ，否则返回 false 。编译器会检查 obj 是否能转换成右边的 class 类型，如果不能转换则直接报错；如果不能确定类型，则通过编译，具体看运行时定。注意：编译器会检查 obj 是否能转换成右边的class 类型，如果不能转换则直接报错，如果不能确定类型，则通过编译，具体看运行时定。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="keyword">null</span> <span class="keyword">instanceof</span> Object);       <span class="comment">// 输出false</span></span><br><span class="line"> </span><br><span class="line">ArrayList arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">System.out.println(arrayList <span class="keyword">instanceof</span> List);    <span class="comment">// 输出true</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) {</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) {</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><h3 id="break-continue-return-的区别及作用"><a href="#break-continue-return-的区别及作用" class="headerlink" title="break ,continue ,return 的区别及作用"></a>break ,continue ,return 的区别及作用</h3><ul>
<li>break 跳出总上一层循环，不再执行循环(结束当前的循环体)</li>
<li>continue 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)</li>
<li>return 程序返回，不再执行下面的代码(结束当前的方法 直接返回)</li>
</ul>
<h3 id="在-Java-中，如何跳出当前的多重嵌套循环"><a href="#在-Java-中，如何跳出当前的多重嵌套循环" class="headerlink" title="在 Java 中，如何跳出当前的多重嵌套循环"></a>在 Java 中，如何跳出当前的多重嵌套循环</h3><p>在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。例如：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    ok:</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) {</span><br><span class="line">            System.out.println(<span class="string">"i="</span> + i + <span class="string">",j="</span> + j);</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">5</span>) {</span><br><span class="line">                <span class="keyword">break</span> ok;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<hr>
<h1 id="面对对象"><a href="#面对对象" class="headerlink" title="面对对象"></a>面对对象</h1><h2 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h2><p>面向过程：</p>
<ul>
<li>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。</li>
</ul>
<ul>
<li>缺点：没有面向对象易维护、易复用、易扩展</li>
</ul>
<p>面向对象：</p>
<ul>
<li>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</li>
</ul>
<ul>
<li>缺点：性能比面向过程低</li>
</ul>
<p>面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。</p>
<p>面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，关我们什么事？我们会用就可以了。</p>
<p>面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装，方便我们使用的就是面向对象了。</p>
<h2 id="面对对象三大特性"><a href="#面对对象三大特性" class="headerlink" title="面对对象三大特性"></a>面对对象三大特性</h2><ol>
<li>封装：封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</li>
<li>继承：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。<ul>
<li>关于继承如下 3 点请记住：<ol>
<li>子类拥有父类非 private 的属性和方法。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。</li>
</ol>
</li>
</ul>
</li>
<li>多态：所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</li>
</ol>
<p>在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p>
<p>方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。</p>
<p>一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：</p>
<ul>
<li>方法重写（子类继承父类并重写父类中已有的或抽象的方法）；</li>
<li>对象造型（用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。</li>
</ul>
<h3 id="什么是多态机制？Java语言是如何实现多态的？"><a href="#什么是多态机制？Java语言是如何实现多态的？" class="headerlink" title="什么是多态机制？Java语言是如何实现多态的？"></a>什么是多态机制？Java语言是如何实现多态的？</h3><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</p>
<p>多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。</p>
<p><strong>多态的实现</strong></p>
<p>Java实现多态有三个必要条件：继承、重写、向上转型。</p>
<ol>
<li>继承：在多态中必须存在有继承关系的子类和父类。</li>
<li>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</li>
<li>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</li>
</ol>
<p>只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。</p>
<p>对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。</p>
<h3 id="多态的原理是什么，多态的含义？多态是如何实现的？"><a href="#多态的原理是什么，多态的含义？多态是如何实现的？" class="headerlink" title="多态的原理是什么，多态的含义？多态是如何实现的？"></a>多态的原理是什么，多态的含义？多态是如何实现的？</h3><p><strong>多态的实现原理</strong>：在加载时<strong>invoke virtual多态查找</strong>实现了多态</p>
<ol>
<li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记做C</li>
<li>如果在类型C中找到与常量中描述符和简单名称都相符的方法，则进行<strong>访问权限校验（可见性声明）</strong>，如果通过则返回这个方法的直接引用，查找过程结束；不通过则返回<code>java.lang.IllegalAccessErro</code>r异常。</li>
<li>否则，按照<strong>继承关系</strong>从下往上依次对C的各个父类进行第 2 步的搜索和验证过程。</li>
<li>如果始终没有找到合适的方法，就抛出java.lang.AbstractMethodError异常。</li>
</ol>
<p><strong>多态的含义</strong>：多态是指父对象中同一个行为能在其多个子对象中有不同的表现。</p>
<p><strong>多态的作用</strong>：消除类型之间的耦合关系</p>
<p><strong>多态存在的三个必要条件</strong>：要有继承、要有重写、父类引用指向子类对象</p>
<p><strong>多态的实现</strong>：父类或者接口定义的引用变量可以指向子类或者具体实现类的实例对象，由于程序调用方法是在运行期才动态绑定的，那么引用变量所指向的具体实例对象在运行期才确定。所以这个对象的方法是运行期正在内存运行的这个对象的方法而不是引用变量的类型中定义的方法。</p>
<h3 id="面向对象五大基本原则是什么？"><a href="#面向对象五大基本原则是什么？" class="headerlink" title="面向对象五大基本原则是什么？"></a>面向对象五大基本原则是什么？</h3><ul>
<li>单一职责原则SRP(Single Responsibility Principle)：类的功能要单一，不能包罗万象，跟杂货铺似的。</li>
<li>开放封闭原则OCP(Open－Close Principle)：一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意。</li>
<li>里式替换原则LSP(the Liskov Substitution Principle LSP)：子类可以替换父类出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活。哈哈~~</li>
<li>依赖倒置原则DIP(the Dependency Inversion Principle DIP)：高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的抽象是中国人，而不是你是xx村的。</li>
<li>接口分离原则ISP(the Interface Segregation Principle ISP)：设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多。</li>
</ul>
<h3 id="访问修饰符public-private-protected-以及不写（默认）时的区别？"><a href="#访问修饰符public-private-protected-以及不写（默认）时的区别？" class="headerlink" title="访问修饰符public,private,protected,以及不写（默认）时的区别？"></a>访问修饰符public,private,protected,以及不写（默认）时的区别？</h3><p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511171536.png"  alt="几种访问修饰符"></p>
<h3 id="类ExampleA继承Exception，类ExampleB继承ExampleA。请问执行此段代码的输出是什么？"><a href="#类ExampleA继承Exception，类ExampleB继承ExampleA。请问执行此段代码的输出是什么？" class="headerlink" title="类ExampleA继承Exception，类ExampleB继承ExampleA。请问执行此段代码的输出是什么？"></a>类ExampleA继承Exception，类ExampleB继承ExampleA。请问执行此段代码的输出是什么？</h3><p>有如下代码片断：</p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511171622.png"  alt="示例代码"></p>
<p>输出：ExampleA。（根据里氏代换原则[能使用父类型的地方一定能使用子类型]，抓取ExampleA类型异常的catch块能够抓住try块中抛出的ExampleB类型的异常）</p>
<hr>
<h2 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h2><h3 id="重写重载的联系与区别"><a href="#重写重载的联系与区别" class="headerlink" title="重写重载的联系与区别"></a>重写重载的联系与区别</h3><p>方法的重载和重写都是实现多态的方式，区别在于前者重载实现的是编译时的多态性，而后者重写实现的是运行时的多态性。</p>
<ul>
<li>方法重载：同一个类中的多个方法有相同的名字，但这些方法的参数列表不同，参数的数量或参数类型不能完全相同。</li>
<li>方法重写：存在子父类之间的,子类定义的方法与父类中的方法具有相同的方法名字，以及相同的参数表和相同的返回类型。</li>
</ul>
<p>为了满足里式替换原则，重写有以下三个限制：</p>
<ol>
<li>子类方法的访问权限必须大于等于父类方法；</li>
<li>子类方法的返回类型必须是父类方法返回类型或为其子类型。</li>
<li>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。</li>
</ol>
<p>下面的示例中，SubClass 为 SuperClass 的子类，SubClass 重写了 SuperClass 的 func() 方法。其中：</p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511171857.png"  alt="重写示例"></p>
<ol>
<li>子类方法访问权限为 public，大于父类的 protected。</li>
<li>子类的返回类型为 ArrayList，是父类返回类型 List 的子类。</li>
<li>子类抛出的异常类型为 Exception，是父类抛出异常 Throwable 的子类。</li>
<li>子类重写方法使用 @Override 注解，从而让编译器自动检查是否满足限制条件。</li>
</ol>
<h3 id="讲讲方法调用的优先级？"><a href="#讲讲方法调用的优先级？" class="headerlink" title="讲讲方法调用的优先级？"></a>讲讲方法调用的优先级？</h3><p>在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有再到父类中查看，看是否从父类继承来。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为：</p>
<ol>
<li>this.func(this)</li>
<li>super.func(this)</li>
<li>this.func(super)</li>
<li>super.func(super)</li>
</ol>
<p>示例代码如下：</p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511172150.png"  alt="方法调用优先级示例代码"></p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511172206.png"  alt="方法调用优先级验证代码"></p>
<h3 id="构造器（constructor）是否可被重写（override）？"><a href="#构造器（constructor）是否可被重写（override）？" class="headerlink" title="构造器（constructor）是否可被重写（override）？"></a>构造器（constructor）是否可被重写（override）？</h3><p>构造器不能被继承，因此不能被重写，但可以被重载。</p>
<p>构造器不能被重写，不能用static修饰构造器，只能用public private protected这三个权限修饰符，且不能有返回语句。</p>
<h3 id="为什么不能根据返回类型来区分重载"><a href="#为什么不能根据返回类型来区分重载" class="headerlink" title="为什么不能根据返回类型来区分重载"></a>为什么不能根据返回类型来区分重载</h3><p>因为调用时不能指定类信息，编译器不知道你要调用哪个类。</p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511172235.png"  alt="示例代码"></p>
<p>当调用max(1, 2)时无法确定调用的是哪个，单从这一点上来说，仅返回值类型不同的重载是不应该允许的。</p>
<p>函数的返回值只是作为函数运行之后的一个“状态”他是保持方法的调用者与被调用者进行通信的关键。并不能作为某个方法的“标识”</p>
<hr>
<h2 id="类与接口"><a href="#类与接口" class="headerlink" title="类与接口"></a>类与接口</h2><h3 id="讲讲借口与抽象类？"><a href="#讲讲借口与抽象类？" class="headerlink" title="讲讲借口与抽象类？"></a>讲讲借口与抽象类？</h3><p>抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。抽象类和普通类最大的区别是，抽象类<strong>不能被实例化，只能被继承</strong>。</p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511153452.png"  alt="抽象类"></p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511153531.png"  alt="实现抽象类"></p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511153544.png"  alt="抽象类的使用"></p>
<p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。</p>
<ul>
<li>从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。</li>
<li>在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类，让它们都实现新增的方法。</li>
<li>接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。接口的字段默认都是 static 和 final 的。</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511153730.png"  alt="接口的实现"></p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511153743.png"  alt="继承接口"></p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511153751.png"  alt="接口的实现"></p>
<h3 id="抽象类的相关特性"><a href="#抽象类的相关特性" class="headerlink" title="抽象类的相关特性"></a>抽象类的相关特性</h3><ul>
<li>被 Abstract 关键字修饰</li>
<li>含有抽象方法的类一定是抽象类，但是抽象类不一定含有抽象方法；且抽象方法必须是 public 或protected，否则不能被子类继承。默认修饰符根据 Java 版本而定</li>
<li>抽象方法可以有具体数据和具体实现！</li>
<li>抽象类中可以定义自己的成员变量权限没要求，private，protected，public(亲测通过)</li>
<li>抽象类中的抽象方法要被实现，所以不能用 static 和 private 修饰。</li>
<li>子类继承抽象类时，必须实现抽象类中的所有抽象方法，否则该子类也要被定义为抽象类</li>
<li>抽象类不能被实例化，只能引用其非抽象子类的对象</li>
<li>可以有构造器，初始化块，内部类</li>
<li>Abstract 不能修饰成员，局部变量</li>
</ul>
<h3 id="接口的相关特性"><a href="#接口的相关特性" class="headerlink" title="接口的相关特性"></a>接口的相关特性</h3><ul>
<li>接口中变量类型默认且只能是 public staic final</li>
<li>接口中声明抽象方法，且只能是默认的public abstract，没有具体的实现。默认的方法没有方法体，但JDK1.8之后有默认方法，静态方法是要有方法体。</li>
<li>子类必须实现所有接口函数</li>
<li>不能定义构造器和初始化块</li>
<li>接口可多继承</li>
<li>接口的实现类必须全部实现接口中的方法，如果不实现，可以将子类变成一个抽象类</li>
</ul>
<h3 id="抽象类与接口的对比"><a href="#抽象类与接口的对比" class="headerlink" title="抽象类与接口的对比"></a>抽象类与接口的对比</h3><p>抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。</p>
<p>从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</p>
<p>总的来说：</p>
<ol>
<li>从设计层面上看，抽象类提供了一种 IS-A 关系，需要满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。</li>
<li>从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。</li>
<li>接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。</li>
<li>接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。</li>
<li>接口使用implements，抽象使用extends。</li>
</ol>
<p><strong>相同点</strong></p>
<ul>
<li>接口和抽象类都不能实例化</li>
<li>都位于继承的顶端，用于被其他实现或继承</li>
<li>都包含抽象方法，其子类都必须覆写这些抽象方法</li>
</ul>
<p><strong>不同点</strong></p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511142749.png"  alt="抽象类与接口的不同点"></p>
<p><strong>备注</strong>：Java8中接口中引入默认方法和静态方法，以此来减少抽象类和接口之间的差异。</p>
<p>现在，我们可以为接口提供默认实现的方法了，并且不用强制子类来实现它。</p>
<p>接口和抽象类各有优缺点，在接口和抽象类的选择上，必须遵守这样一个原则：</p>
<ul>
<li>行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量少用抽象类。</li>
<li>选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用的功能。</li>
</ul>
<h3 id="什么时候用抽象类什么时候用接口？"><a href="#什么时候用抽象类什么时候用接口？" class="headerlink" title="什么时候用抽象类什么时候用接口？"></a>什么时候用抽象类什么时候用接口？</h3><ol>
<li>使用接口：<ul>
<li>需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 <code>compareTo()</code> 方法；</li>
<li>需要使用多重继承。</li>
</ul>
</li>
<li>使用抽象类：<ul>
<li>需要在几个相关的类中共享代码。</li>
<li>需要能控制继承来的成员的访问权限，而不是都为 public。</li>
<li>需要继承非静态和非常量字段。</li>
</ul>
</li>
<li>在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。</li>
</ol>
<h3 id="接口与抽象类在不同版本中的变化"><a href="#接口与抽象类在不同版本中的变化" class="headerlink" title="接口与抽象类在不同版本中的变化"></a>接口与抽象类在不同版本中的变化</h3><ul>
<li>抽象类在1.8以前，其方法的默认访问权限为protected；1.8后改为default</li>
<li>接口在1.8以前，方法必须是public；1.8时可以使用default；1.9时可以是private</li>
</ul>
<h3 id="通过实例对象-方法名这种调用过程的流程"><a href="#通过实例对象-方法名这种调用过程的流程" class="headerlink" title="通过实例对象.方法名这种调用过程的流程"></a>通过实例对象.方法名这种调用过程的流程</h3><ul>
<li>编译器查看对象的声明类型和方法名；如果有多个同名但参数类型不同的函数，那么编译器将一一列举所有该类中同名的方法和超类中同名的方法</li>
<li>编译器查看调用方法时提供的参数类型。如果存在一个参数匹配的方法，那么就使用这个方法，这个过程称之为重载解析；如果未找到一个匹配的参数，那么就会报错</li>
<li>如果该方法是 private 方法、 static 方法、 final 方法或者构造器，则编译器可以准确地知道应该调用哪种方法，被称之为静态绑定。与之对应的是，调用方法依赖于隐式参数的实际类型，并在运行时实现动态绑定</li>
<li>当程序运行时并采用动态绑定调用方法时，虚拟机一定会调用最合适的那个类方法，否则层层向超类上搜索</li>
</ul>
<p>值得注意的是，在调用方法搜索时，时间开销相当大。<u>因此 ，虚拟机为每个类预先创建了一个方法表，其中列出了所有方法的签名和实际调用的方法。通过查表节省时间</u></p>
<h3 id="抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被synchronized修饰？"><a href="#抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被synchronized修饰？" class="headerlink" title="抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰？"></a>抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰？</h3><p>都不能，主要原因如下：</p>
<ol>
<li>抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。</li>
<li>本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。</li>
<li>synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。</li>
</ol>
<h3 id="普通类与抽象类的区别"><a href="#普通类与抽象类的区别" class="headerlink" title="普通类与抽象类的区别"></a>普通类与抽象类的区别</h3><ol>
<li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li>
<li>抽象类不能直接实例化，普通类可以直接实例化。</li>
</ol>
<h3 id="抽象类能够使用final修饰？"><a href="#抽象类能够使用final修饰？" class="headerlink" title="抽象类能够使用final修饰？"></a>抽象类能够使用final修饰？</h3><p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类</p>
<h3 id="创建一个对象用什么关键字？对象实例与对象引用有何不同？"><a href="#创建一个对象用什么关键字？对象实例与对象引用有何不同？" class="headerlink" title="创建一个对象用什么关键字？对象实例与对象引用有何不同？"></a>创建一个对象用什么关键字？对象实例与对象引用有何不同？</h3><p>new关键字，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有n个引用指向它（可以用n条绳子系住一个气球）</p>
<hr>
<h2 id="变量与方法"><a href="#变量与方法" class="headerlink" title="变量与方法"></a>变量与方法</h2><h3 id="简述静态类和单例的区别"><a href="#简述静态类和单例的区别" class="headerlink" title="简述静态类和单例的区别"></a>简述静态类和单例的区别</h3><ul>
<li>单例可以继承类，实现接口，而静态类不能（可以集成类，但不能集成实例成员）</li>
<li>单例可以被延迟初始化，静态类一般在第一次加载是初始化</li>
<li>单例类可以被集成，他的方法可以被覆写</li>
<li>单例类可以被用于多态而无需强迫用户只假定唯一的实例</li>
<li>（静态方法）静态方法中产生的对象，会随着静态方法执行完毕而释放掉，而且执行类中的静态方法时，不会实例化静态方法所在的类。如果是用singleton，产生的那一个唯一的实例，会一直在内存中，不会被GC清除的(原因是静态的属性变量不会被GC清除)，除非整个JVM退出</li>
</ul>
<h3 id="成员变量与局部变量的区别有哪些"><a href="#成员变量与局部变量的区别有哪些" class="headerlink" title="成员变量与局部变量的区别有哪些"></a>成员变量与局部变量的区别有哪些</h3><ul>
<li>变量：在程序执行的过程中，在某个范围内其值可以发生改变的量。从本质上讲，变量其实是内存中的一小块区域</li>
<li>成员变量：方法外部，类内部定义的变量</li>
<li>局部变量：类的方法中的变量。</li>
</ul>
<p><strong>成员变量和局部变量的区别</strong></p>
<ol>
<li>作用域<ul>
<li>成员变量：针对整个类有效。</li>
<li>局部变量：只在某个范围内有效。(一般指的就是方法,语句体内)</li>
</ul>
</li>
<li>存储位置<ul>
<li>成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。</li>
<li>局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中。当方法调用完，或者语句结束后，就自动释放。</li>
</ul>
</li>
<li>生命周期<ul>
<li>成员变量：随着对象的创建而存在，随着对象的消失而消失</li>
<li>局部变量：当方法调用完，或者语句结束后，就自动释放。</li>
</ul>
</li>
<li>初始值<ul>
<li>成员变量：有默认初始值。</li>
<li>局部变量：没有默认初始值，使用前必须赋值。</li>
</ul>
</li>
<li>使用原则<ul>
<li>在使用变量时需要遵循的原则为：就近原则</li>
<li>首先在局部范围找，有就使用；接着在成员位置找。</li>
</ul>
</li>
</ol>
<h3 id="为什么在父类中要定义一个没有参数的空构造函数"><a href="#为什么在父类中要定义一个没有参数的空构造函数" class="headerlink" title="为什么在父类中要定义一个没有参数的空构造函数"></a>为什么在父类中要定义一个没有参数的空构造函数</h3><p>Java 程序在执行子类的构造方法之前，如果没有用 super() 来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Parent dp = <span class="keyword">new</span> Son(<span class="number">12</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 注释无参构造函数，无法通过编译</span></span><br><span class="line">    Parent() {}</span><br><span class="line">    Parent(<span class="keyword">int</span> age) {</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    Son(<span class="keyword">int</span> height) {</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.height = height;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？"><a href="#在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？" class="headerlink" title="在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？"></a>在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？</h3><p>帮助子类做初始化工作。</p>
<h3 id="一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？"><a href="#一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？" class="headerlink" title="一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？"></a>一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？</h3><p>主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</p>
<h3 id="构造方法有哪些特性？"><a href="#构造方法有哪些特性？" class="headerlink" title="构造方法有哪些特性？"></a>构造方法有哪些特性？</h3><ol>
<li>名字与类名相同；</li>
<li>没有返回值，但不能用void声明构造函数；</li>
<li>生成类的对象时自动执行，无需调用。</li>
</ol>
<h3 id="静态变量和实例变量区别"><a href="#静态变量和实例变量区别" class="headerlink" title="静态变量和实例变量区别"></a>静态变量和实例变量区别</h3><p>静态变量： 静态变量由于不属于任何实例对象，属于类的，所以在内存中只会有一份，在类的加载过程中，JVM只为静态变量分配一次内存空间。一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；</p>
<p>实例变量： 每次创建对象，都会为每个对象分配成员变量内存空间，实例变量是属于实例对象的，在内存中，创建几次对象，就有几份成员变量。</p>
<p>补充：在Java开发中，上下文类和工具类中通常会有大量的静态成员。</p>
<h3 id="静态变量与普通变量区别"><a href="#静态变量与普通变量区别" class="headerlink" title="静态变量与普通变量区别"></a>静态变量与普通变量区别</h3><p>static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。</p>
<p>还有一点就是static成员变量的初始化顺序按照定义的顺序进行初始化。</p>
<h3 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a>静态方法和实例方法有何不同？</h3><p>静态方法和实例方法的区别主要体现在两个方面：</p>
<p>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。<br>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制</p>
<h3 id="成员变量与局部变量"><a href="#成员变量与局部变量" class="headerlink" title="成员变量与局部变量"></a>成员变量与局部变量</h3><ul>
<li>成员变量可以使用 public，private，static等修饰符修饰；而局部变量不能被访问修饰符以及static 修饰。二者均可被final修饰</li>
<li>成员变量在堆中，而局部变量在栈中</li>
<li>成员变量如果未被赋初值，则会自动以默认值赋值，final修饰则需要显式地手动赋值；而局部变量不会被自动赋初值，直接拿来用会抛异常</li>
</ul>
<h3 id="静态方法和实例方法的区别"><a href="#静态方法和实例方法的区别" class="headerlink" title="静态方法和实例方法的区别"></a>静态方法和实例方法的区别</h3><ul>
<li>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象</li>
<li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制</li>
</ul>
<h3 id="是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"><a href="#是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？" class="headerlink" title="是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"></a>是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？</h3><p>不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，在调用静态方法时可能对象并没有被初始化。</p>
<h2 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h2><h3 id="为什么Java中只有值传递"><a href="#为什么Java中只有值传递" class="headerlink" title="为什么Java中只有值传递"></a>为什么Java中只有值传递</h3><p>在程序设计语言中存在两种传递方式，分别是传值调用和传址调用。传值调用指的是方法接收的是调用者提供的值，而传址调用指的是调用者提供变量的地址。一个方法可以修改传址调用所对应的变量值，而不能修改传值调用所对应的变量值。</p>
<p>Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。所以得到如下结论：</p>
<ul>
<li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）</li>
<li>一个方法可以改变一个对象参数的状态</li>
<li>一个方法不能让对象参数引用一个新的对象</li>
</ul>
<p>首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。 它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。</p>
<p>Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</p>
<p>下面通过 3 个例子来给大家说明</p>
<p>example 1</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    swap(num1, num2);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"num1 = "</span> + num1);</span><br><span class="line">    System.out.println(<span class="string">"num2 = "</span> + num2);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"a = "</span> + a);</span><br><span class="line">    System.out.println(<span class="string">"b = "</span> + b);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>结果</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">20</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line">num1 = <span class="number">10</span></span><br><span class="line">num2 = <span class="number">20</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>解析</strong></p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511214635.png"  alt="example1解析"></p>
<p>在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p>
<p><strong>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2.</strong></p>
<p>example 2</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span>[] arr = { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> };</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    change(arr);</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>{</span><br><span class="line">    <span class="comment">// 将数组的第一个元素变为0</span></span><br><span class="line">    array[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>结果</strong>：</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>解析</strong>：</p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511214829.png"  alt="example2解析"></p>
<p>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</p>
<p><strong>通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。</strong></p>
<p><strong>很多程序设计语言（特别是，C++和Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。</strong></p>
<p>example 3</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student(<span class="string">"小张"</span>);</span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student(<span class="string">"小李"</span>);</span><br><span class="line">        Test.swap(s1, s2);</span><br><span class="line">        System.out.println(<span class="string">"s1:"</span> + s1.getName());</span><br><span class="line">        System.out.println(<span class="string">"s2:"</span> + s2.getName());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Student x, Student y)</span> </span>{</span><br><span class="line">        Student temp = x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = temp;</span><br><span class="line">        System.out.println(<span class="string">"x:"</span> + x.getName());</span><br><span class="line">        System.out.println(<span class="string">"y:"</span> + y.getName());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>结果</strong>：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x:小李</span><br><span class="line">y:小张</span><br><span class="line">s1:小张</span><br><span class="line">s2:小李</span><br></pre></td></tr></tbody></table></figure>

<p><strong>解析</strong>：</p>
<p>交换之前：</p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511215005.png"  alt="example3解析：交换之前"></p>
<p>交换之后：</p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511215042.png"  alt="example3解析：交换之后"></p>
<p>通过上面两张图可以很清晰的看出： <strong>方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</strong></p>
<p><strong>总结</strong></p>
<p>Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。</p>
<p>下面再总结一下Java中方法参数的使用情况：</p>
<ol>
<li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）</li>
<li>一个方法可以改变一个对象参数的状态。</li>
<li>一个方法不能让对象参数引用一个新的对象。</li>
</ol>
<h3 id="Java-的参数是值传递？还是引用传递？"><a href="#Java-的参数是值传递？还是引用传递？" class="headerlink" title="Java 的参数是值传递？还是引用传递？"></a>Java 的参数是值传递？还是引用传递？</h3><p>Java 的参数是以值传递的形式传入方法中，而不是引用传递。</p>
<p>以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。</p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511155154.png"  alt="Dog类创建"></p>
<p>在方法中改变对象的字段值会改变原对象该字段值，因为引用的是同一个对象。</p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511155250.png"  alt="修改方法1"></p>
<p>重点：但是在方法中将指针引用了其它对象，那么此时方法里和方法外的两个指针指向了不同的对象，在一个指针改变其所指向对象的内容对另一个指针所指向的对象没有影响。</p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511155310.png"  alt="修改方法2"></p>
<h3 id="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？"><a href="#当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？" class="headerlink" title="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？"></a>当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？</h3><p>是值传递。Java语言的方法调用只支持参数的值传递。</p>
<p>当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的。</p>
<p>C++和C#中可以通过传引用或传输出参数来改变传入的参数的值。在C#中可以编写如下所示的代码，但是在Java中却做不到。</p>
<p><img src="/" class="lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511155414.png"  alt="C++示例代码"></p>
<p>说明：Java中没有传引用实在是非常的不方便，这一点在Java 8中仍然没有得到改进</p>
<p>正是如此在Java编写的代码中才会出现大量的Wrapper类（将需要通过方法调用修改的引用置于一个Wrapper类中，再将Wrapper对象传入方法），这样的做法只会让代码变得臃肿，尤其是让从C和C++转型为Java程序员的开发者无法容忍。</p>
<hr>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="什么是内部类？"><a href="#什么是内部类？" class="headerlink" title="什么是内部类？"></a>什么是内部类？</h3><p>在Java中，可以将一个类的定义放在另外一个类的定义内部，这就是<strong>内部类</strong>。内部类本身就是类的一个属性，与其他属性定义方式一致。</p>
<h3 id="内部类的分类？"><a href="#内部类的分类？" class="headerlink" title="内部类的分类？"></a>内部类的分类？</h3><p>内部类可以分为四种：<strong>成员内部类、局部内部类、匿名内部类和静态内部类</strong>。</p>
<h5 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h5><p>定义在类内部的静态类，就是静态内部类。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> radius = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInner</span> </span>{</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span> </span>{</span><br><span class="line">            System.out.println(<span class="string">"visit outer static  variable:"</span> + radius);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量；静态内部类的创建方式，<code>new 外部类.静态内部类()</code>，如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Outer.StaticInner inner = <span class="keyword">new</span> Outer.StaticInner();</span><br><span class="line">inner.visit();</span><br></pre></td></tr></tbody></table></figure>

<h5 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h5><p>定义在类内部，成员位置上的非静态类，就是成员内部类。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">int</span> radius = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count =<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">     <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>{	<span class="comment">// 成员内部类</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span> </span>{</span><br><span class="line">            System.out.println(<span class="string">"visit outer static  variable:"</span> + radius);</span><br><span class="line">            System.out.println(<span class="string">"visit outer   variable:"</span> + count);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。成员内部类依赖于外部类的实例，它的创建方式<code>外部类实例.new 内部类()</code>，如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">Outer.Inner inner = outer.<span class="keyword">new</span> Inner();</span><br><span class="line">inner.visit();</span><br></pre></td></tr></tbody></table></figure>

<h5 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h5><p>定义在方法中的内部类，就是局部内部类。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> out_a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> STATIC_b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFunctionClass</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">int</span> inner_c =<span class="number">3</span>;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>{	<span class="comment">// 局部内部类</span></span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>{</span><br><span class="line">                System.out.println(out_a);</span><br><span class="line">                System.out.println(STATIC_b);</span><br><span class="line">                System.out.println(inner_c);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        Inner  inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        inner.fun();</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStaticFunctionClass</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">int</span> d =<span class="number">3</span>;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>{</span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>{</span><br><span class="line">                <span class="comment">// System.out.println(out_a); 编译错误，定义在静态方法中的局部类不可以访问外部类的实例变量</span></span><br><span class="line">                System.out.println(STATIC_b);</span><br><span class="line">                System.out.println(d);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        Inner  inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        inner.fun();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。局部内部类的创建方式，在对应方法内，<code>new 内部类()</code>，如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStaticFunctionClass</span><span class="params">()</span></span>{</span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>{</span><br><span class="line">   }</span><br><span class="line">   Inner  inner = <span class="keyword">new</span> Inner();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h5><p>匿名内部类就是没有名字的内部类，日常开发中使用的比较多。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> i)</span> </span>{</span><br><span class="line">        <span class="keyword">new</span> Service() {</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) {</span><br><span class="line">                    System.out.println(<span class="string">"匿名内部类"</span> );</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }.method();</span><br><span class="line">    }</span><br><span class="line"> }</span><br><span class="line"> <span class="comment">//匿名内部类必须继承或实现一个已有的接口 </span></span><br><span class="line"> <span class="class"><span class="keyword">interface</span> <span class="title">Service</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>除了没有名字，匿名内部类还有以下特点：</p>
<ul>
<li>匿名内部类必须继承一个抽象类或者实现一个接口。</li>
<li>匿名内部类不能定义任何静态成员和静态方法。</li>
<li>当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。</li>
<li>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</li>
</ul>
<p>匿名内部类创建方式：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类/接口{ </span><br><span class="line">  <span class="comment">//匿名内部类实现部分</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="内部类的优点"><a href="#内部类的优点" class="headerlink" title="内部类的优点"></a>内部类的优点</h3><p>我们为什么要使用内部类呢？因为它有以下优点：</p>
<ul>
<li>一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！</li>
<li>内部类不为同一包的其他类所见，具有很好的封装性；</li>
<li>内部类有效实现了“多重继承”，优化 java 单继承的缺陷。</li>
<li>匿名内部类可以很方便的定义回调。</li>
</ul>
<h3 id="内部类的应用场景"><a href="#内部类的应用场景" class="headerlink" title="内部类的应用场景"></a>内部类的应用场景</h3><ol>
<li>一些多算法场合</li>
<li>解决一些非面向对象的语句块。</li>
<li>适当使用内部类，使得代码更加灵活和富有扩展性。</li>
<li>当某个类除了它的外部类，不再被其他的类使用时。</li>
</ol>
<h3 id="局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？"><a href="#局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？" class="headerlink" title="局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？"></a>局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？</h3><p>局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final呢？它内部原理是什么呢？</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">outMethod</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> a =<span class="number">10</span>;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>{</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">innerMethod</span><span class="params">()</span></span>{</span><br><span class="line">                System.out.println(a);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上例子，为什么要加final呢？是<u>因为生命周期不一致</u>， 局部变量直接存储在栈中，当方法执行结束后，非final的局部变量就被销毁。而局部内部类对局部变量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。加了final，可以确保局部内部类使用的变量与外层的局部变量区分开，解决了这个问题。</p>
<h3 id="局部内部类与匿名内部类"><a href="#局部内部类与匿名内部类" class="headerlink" title="局部内部类与匿名内部类"></a>局部内部类与匿名内部类</h3><h3 id="Anonymous-Inner-Class-匿名内部类-是否可以继承其它类？是否可以实现接口？"><a href="#Anonymous-Inner-Class-匿名内部类-是否可以继承其它类？是否可以实现接口？" class="headerlink" title="Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？"></a>Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？</h3><p>可以继承其他类或实现其他接口，在Swing编程和Android开发中常用此方式来实现事件监听和回调。</p>
<h3 id="内部类相关，看程序说出运行结果"><a href="#内部类相关，看程序说出运行结果" class="headerlink" title="内部类相关，看程序说出运行结果"></a>内部类相关，看程序说出运行结果</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">13</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">int</span> age = <span class="number">14</span>;</span><br><span class="line">            System.out.println(<span class="string">"局部变量："</span> + age);</span><br><span class="line">            System.out.println(<span class="string">"内部类变量："</span> + <span class="keyword">this</span>.age);</span><br><span class="line">            System.out.println(<span class="string">"外部类变量："</span> + Outer.<span class="keyword">this</span>.age);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Outer.Inner in = <span class="keyword">new</span> Outer().<span class="keyword">new</span> Inner();</span><br><span class="line">        in.print();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">局部变量：<span class="number">14</span></span><br><span class="line">内部类变量：<span class="number">13</span></span><br><span class="line">外部类变量：<span class="number">12</span></span><br></pre></td></tr></tbody></table></figure>



<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Garmen Lee</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://dongxiem.github.io/2020/05/11/java-ji-chu-mian-shi-ti-ji-shang/">https://dongxiem.github.io/2020/05/11/java-ji-chu-mian-shi-ti-ji-shang/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://dongxiem.github.io" target="_blank">桃花岛杂货铺</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E5%AF%BC%E9%A1%B5/">导页</a></div><div class="post_share"><div class="social-share" data-image="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511205145.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/05/11/java-ji-chu-mian-shi-ti-ji-xia/"><img class="prev_cover lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511205145.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java 基础 - 面试题集下</div></div></a></div><div class="next-post pull_right"><a href="/2020/04/16/java-bing-fa-duo-xian-cheng-xian-cheng-jian-tong-xin-jiao-ti-da-yin/"><img class="next_cover lazyload" data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511205031.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java 并发 - 多线程：线程间通信交替打印</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/05/11/java-ji-chu-mian-shi-ti-ji-xia/" title="Java 基础 - 面试题集下"><img class="relatedPosts_cover lazyload"data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511205145.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-11</div><div class="relatedPosts_title">Java 基础 - 面试题集下</div></div></a></div><div class="relatedPosts_item"><a href="/2020/03/29/spring-kuang-jia-fen-xi-dao-ye/" title="Spring 框架分析 - 导页"><img class="relatedPosts_cover lazyload"data-src="https://i.loli.net/2020/04/07/4AiURNT3WyfXGlr.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-29</div><div class="relatedPosts_title">Spring 框架分析 - 导页</div></div></a></div><div class="relatedPosts_item"><a href="/2020/03/20/java-ji-he-kuang-jia-dao-ye/" title="Java 集合框架 - 导页"><img class="relatedPosts_cover lazyload"data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511203825.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-20</div><div class="relatedPosts_title">Java 集合框架 - 导页</div></div></a></div><div class="relatedPosts_item"><a href="/2020/03/20/java-bing-fa-dao-ye/" title="Java 并发 - 导页"><img class="relatedPosts_cover lazyload"data-src="https://i.loli.net/2020/04/13/m3CZySzpGY2DPuo.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-20</div><div class="relatedPosts_title">Java 并发 - 导页</div></div></a></div><div class="relatedPosts_item"><a href="/2020/04/16/java-bing-fa-duo-xian-cheng-xian-cheng-jian-tong-xin-jiao-ti-da-yin/" title="Java 并发 - 多线程：线程间通信交替打印"><img class="relatedPosts_cover lazyload"data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511205031.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-16</div><div class="relatedPosts_title">Java 并发 - 多线程：线程间通信交替打印</div></div></a></div><div class="relatedPosts_item"><a href="/2020/04/16/java-bing-fa-cas-fen-xi/" title="Java 并发 - CAS 分析"><img class="relatedPosts_cover lazyload"data-src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511205031.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-16</div><div class="relatedPosts_title">Java 并发 - CAS 分析</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify: false,
  verify: false,
  appId: 'LJP263NIvTFr34gesCv9qoCh-gzGzoHsz',
  appKey: 'satF6eG2kFuCICaRaJCieaux',
  placeholder: 'Please leave your footprints',
  avatar: 'monsterid',
  meta: guest_info,
  pageSize: '10',
  lang: 'en',
  recordIP: false,
  serverURLs: ''
});</script></div></article></main><footer id="footer" style="background-image: url(https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200511205145.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By Garmen Lee</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/third-party/click_heart.js"></script><script src="/js/search/local-search.js"></script></body></html>
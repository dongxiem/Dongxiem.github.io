<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/garmen.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/garmen.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/garmen.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dongxiem.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1.Channels是什么？这里又可以搬出知乎名言了，在认识一件事物之前，先问问是什么，再回答为什么！直接来说，一个Channel 是一个通信机制，它可以让一个Goroutine 通过它给另一个Goroutine 发送值信息。每个Channel 都有一个特殊的类型，也就是Channels可发送数据的类型（例如：一个可以发送int类型数据的Channel 一般写为chan int）。 在我们常见的一">
<meta property="og:type" content="article">
<meta property="og:title" content="golang 并发 - Channel的深入了解">
<meta property="og:url" content="https://dongxiem.github.io/2020/05/25/golang-bing-fa-channel-de-shen-ru-liao-jie/index.html">
<meta property="og:site_name" content="桃花岛杂货铺">
<meta property="og:description" content="1.Channels是什么？这里又可以搬出知乎名言了，在认识一件事物之前，先问问是什么，再回答为什么！直接来说，一个Channel 是一个通信机制，它可以让一个Goroutine 通过它给另一个Goroutine 发送值信息。每个Channel 都有一个特殊的类型，也就是Channels可发送数据的类型（例如：一个可以发送int类型数据的Channel 一般写为chan int）。 在我们常见的一">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200822142805.png">
<meta property="og:image" content="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200822000155.png">
<meta property="og:image" content="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200822000228.png">
<meta property="article:published_time" content="2020-05-25T03:41:15.000Z">
<meta property="article:modified_time" content="2020-09-28T03:32:28.328Z">
<meta property="article:author" content="Garmen Lee">
<meta property="article:tag" content="go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200822142805.png">

<link rel="canonical" href="https://dongxiem.github.io/2020/05/25/golang-bing-fa-channel-de-shen-ru-liao-jie/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>golang 并发 - Channel的深入了解 | 桃花岛杂货铺</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="桃花岛杂货铺" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">桃花岛杂货铺</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dongxiem.github.io/2020/05/25/golang-bing-fa-channel-de-shen-ru-liao-jie/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Garmen Lee">
      <meta itemprop="description" content="杂货铺售卖知识 诸位自取">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="桃花岛杂货铺">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          golang 并发 - Channel的深入了解
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-25 11:41:15" itemprop="dateCreated datePublished" datetime="2020-05-25T11:41:15+08:00">2020-05-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="1-Channels是什么？"><a href="#1-Channels是什么？" class="headerlink" title="1.Channels是什么？"></a>1.Channels是什么？</h1><p>这里又可以搬出知乎名言了，在认识一件事物之前，先问问是什么，再回答为什么！直接来说，一个Channel 是一个通信机制，它<strong>可以让一个Goroutine 通过它给另一个Goroutine 发送值信息</strong>。每个Channel 都有一个特殊的类型，也就是Channels可发送数据的类型（例如：一个可以发送int类型数据的Channel 一般写为chan int）。</p>
<p>在我们常见的一些语言中，多个线程传递数据的方式一般都是共享内存，<u>为了解决线程冲突的问题，我们需要限制同一时间能够读写这些变量的线程数量</u>。而Golang 语言提供了一种不同与使用使用共享内存加互斥锁也能进行通信的并发模型，也就是<strong>通信顺序进程（Communicating sequential processes，CSP）</strong>。其中Goroutine 和 Channel 分别对应 CSP 中的实体和传递信息的媒介，Go 语言中的 Goroutine 会通过 Channel 传递数据。这也是Golang一直提倡的<strong>不要通过共享内存的方式进行通信，而是应该通过通信的方式共享内存</strong>。</p>
<p>目前的 Channel 收发操作均遵循了先入先出（FIFO）的设计，而且<strong>带缓存区和不带缓存区的 Channel 都会遵循先入先出对数据进行接收和发送</strong>（关于带缓存区与不带缓存区在下面会提及），具体规则如下：</p>
<ul>
<li>先从 Channel 读取数据的 Goroutine 会先接收到数据； </li>
<li>先向 Channel 发送数据的 Goroutine 会得到先发送数据的权利；</li>
</ul>
<p>通过源码查看我们可知，Channel 在运行时使用 <a href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L32" target="_blank" rel="noopener">runtime.hchan</a> 结构体进行表示，而这玩意最后包含这一个互斥锁用于保护成员变量，所以从某种程度上说，Channel 是一个<u>用于同步和通信的有锁队列</u>。具体数据结构如下所示：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> {</span><br><span class="line">    qcount   <span class="keyword">uint</span>           <span class="comment">// total data in the queue</span></span><br><span class="line">    dataqsiz <span class="keyword">uint</span>           <span class="comment">// size of the circular queue</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements</span></span><br><span class="line">    elemsize <span class="keyword">uint16</span></span><br><span class="line">    closed   <span class="keyword">uint32</span></span><br><span class="line">    elemtype *_type <span class="comment">// element type</span></span><br><span class="line">    sendx    <span class="keyword">uint</span>   <span class="comment">// send index</span></span><br><span class="line">    recvx    <span class="keyword">uint</span>   <span class="comment">// receive index</span></span><br><span class="line">    recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">    sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">    <span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Do not change another G's status while holding this lock</span></span><br><span class="line">    <span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">    <span class="comment">// with stack shrinking.</span></span><br><span class="line">    lock mutex</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<a id="more"></a>



<p>上面提到了CSP，这里进行一些补充：CSP 是 <strong>Communicating Sequential Process</strong> 的简称，中文可以叫做<strong>通信顺序进程</strong>，是一种并发编程模型，由 <a href="https://en.wikipedia.org/wiki/Tony_Hoare" target="_blank" rel="noopener">Tony Hoare</a> 于 1977 年提出。简单来说，<strong>CSP 模型由并发执行的实体（线程或者进程）所组成，实体之间通过发送消息进行通信</strong>，这里发送消息时使用的就是通道，或者叫 channel。CSP 模型的关键是关注 channel，而不关注发送消息的实体。Go 语言实现了 CSP 部分理论，goroutine 对应 CSP 中并发执行的实体，channel 也就对应着 CSP 中的 channel。</p>
<hr>
<h1 id="2-如何实现Channels？"><a href="#2-如何实现Channels？" class="headerlink" title="2.如何实现Channels？"></a>2.如何实现Channels？</h1><h2 id="2-1-基本实现及操作"><a href="#2-1-基本实现及操作" class="headerlink" title="2.1 基本实现及操作"></a>2.1 基本实现及操作</h2><p>详细来说，Channel 类型的格式如下：<code>var 变量 chan 元素类型</code>，具体举例如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch1 <span class="keyword">chan</span> <span class="keyword">int</span>   <span class="comment">// 声明一个传递整型的通道</span></span><br><span class="line"><span class="keyword">var</span> ch2 <span class="keyword">chan</span> <span class="keyword">bool</span>  <span class="comment">// 声明一个传递布尔型的通道</span></span><br><span class="line"><span class="keyword">var</span> ch3 <span class="keyword">chan</span> []<span class="keyword">int</span> <span class="comment">// 声明一个传递int切片的通道</span></span><br></pre></td></tr></tbody></table></figure>
<p>如果仅仅进行Channel 创建：<code>var ch chan int</code>，而没有进行使用make函数初始化，打印输出会发现为nil：<code>fmt.Println(ch) // &lt;nil&gt;</code>，而且！<strong>在一个<code>nil</code>的channel上发送和接收操作会被永久阻塞</strong>，可以看看下面的代码结果会怎样？</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {  </span><br><span class="line">    <span class="comment">// 没有进行make函数初始化，该ch为nil</span></span><br><span class="line">    <span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ {</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="keyword">int</span>)</span></span> {</span><br><span class="line">            ch &lt;- (idx + <span class="number">1</span>) * <span class="number">2</span></span><br><span class="line">        }(i)</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 得到第一个结果</span></span><br><span class="line">    fmt.Println(<span class="string">"result:"</span>,&lt;-ch)</span><br><span class="line">    <span class="comment">// 休眠</span></span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>面这段代码能够通过编译，但是执行的时候会发现runtime错误：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br></pre></td></tr></tbody></table></figure>

<p>我们可以通过使用内置的make函数创建一个Channel ：<code>ch := make(chan int)</code>，创建Channel 的格式：<code>make(chan 元素类型, [缓存大小])</code>，具体举例如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch4 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">ch5 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">ch6 := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="keyword">int</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>很简单就可以实现一个Channel，需要注意的是经过上面的make创建了之后的Channel对应的<u>是make底层数据结构的一个引用</u>，意思就是当复制一个Channel 或者 将Channel 用于参数传递的时候，仅仅只是复制了一个Channel 的引用而已！此时调用者何被调用者将引用同一个Channel 对象。</p>
<p>既然是对象，那么Channel 也是可以使用<code>==</code>运算符进行比较了，但是注意的是<u>相同类型才可以进行比较</u>，简单验证如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"></span><br><span class="line">    ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="comment">//ch3 := make(chan string)</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(ch1 == ch2)	<span class="comment">// 可以比较，但是比较结果为false</span></span><br><span class="line">    <span class="comment">//fmt.Println(ch1 == ch3) // 不可以比较，错误为：invalid operation: ch1 == ch3 (mismatched types chan int and chan string)</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>一个Channel 有发送、接收及关闭等简单操作，如果浏览源码，时不时的会发现这么一个符号：<code>&lt;-</code>，简直不要太有代表性，这玩意就是Channel 的使用！而且发送和接收两个操作都是用<code>&lt;-</code>运算符。具体如下：</p>
<p><u>在发送语句中，<code>&lt;-</code>运算符分割channel和要发送的值</u>。比如：<code>ch &lt;- x</code>，我们将x发送到通道ch之中。</p>
<p><u>在接收语句中，<code>&lt;-</code>运算符写在channel对象之前</u>。比如：<code>x = &lt;-ch</code> </p>
<ul>
<li>当然一个不使用接收结果的接收操作也是合法的。比如：<code>&lt;-ch</code></li>
</ul>
<p><u>当然我们可以关闭一个通道，使用close就可以了</u>：<code>close(ch)</code></p>
<ul>
<li><p>需要注意的是，我们要对close的使用进行比较好的处理，如果还有数据没发送完或者没有数据没有接收完，我们直接close，是不是不是很妥？而且Golang并没有办法直接测试一个Channels是否被关闭，但是接收操作有一个<strong>变体形式</strong>：它多接收一个结果，多接收的第二个结果是一个布尔值ok，<u>ture表示成功从channels接收到值，false表示channels已经被关闭并且里面没有值可接收</u>。</p>
</li>
<li><p>示例如下：</p>
<ul>
<li><pre class=" language-go">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number"><code class="language-go">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)
<span class="comment">// ok-idiom </span>
val, ok := <-ch
<span class="keyword">if</span> ok == <span class="literal">false</span> {
   <span class="comment">// channel closed</span>
   <span class="built_in">close</span>(ch)
}
<!--￼<span class="number">6</span>-->
</code></pre>
</li>
</ul>
</li>
</ul>
<p>结果如下：</p>
<p><img src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200822142805.png" alt="向已经关闭的Channel继续发送数据"></p>
<p>这里给出一个简单的解决方案，我们需要确保应用不会向关闭的channel中发送数据：通过使用一个特殊的废弃的channel来向剩余的worker发送不再需要它们的结果的信号来修复。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{})</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ {</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="keyword">int</span>)</span></span> {</span><br><span class="line">            <span class="keyword">select</span> {</span><br><span class="line">                <span class="keyword">case</span> ch &lt;- (idx + <span class="number">1</span>) * <span class="number">2</span>:</span><br><span class="line">                fmt.Println(idx,<span class="string">"sent result"</span>)</span><br><span class="line">                <span class="keyword">case</span> &lt;- done:</span><br><span class="line">                fmt.Println(idx,<span class="string">"exiting"</span>)</span><br><span class="line">            }</span><br><span class="line">        }(i)</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 取得通道Channels的首个结果</span></span><br><span class="line">    fmt.Println(<span class="string">"result:"</span>,&lt;-ch)</span><br><span class="line">    <span class="comment">// 关闭特殊Channel通道done</span></span><br><span class="line">    <span class="built_in">close</span>(done)</span><br><span class="line">    <span class="comment">// 等待三秒</span></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>于是我们便掌握了简单的发送、接受及关闭，难道Channel 就这？这么简单就都搞定了？其实不然，还挺复杂，继续往下。</p>
<h2 id="2-2-不带缓存的Channels"><a href="#2-2-不带缓存的Channels" class="headerlink" title="2.2 不带缓存的Channels"></a>2.2 不带缓存的Channels</h2><p>无缓存的通道又称为<strong>阻塞的通道</strong>，通常我们使用不带缓存的Channels来做同步操作，所以无缓存Channels有时候也被称为<strong>同步Channels。</strong></p>
<p>其中同步Channel 不需要携带额外的信息，它仅仅是用作两个goroutine之间的同步，我们还可以使用<code>struct{}</code>空结构体作为channels元素的类型（这里也是为什么之前看到很多<code>struct{}</code>懵逼的原因了），虽然也可以使用bool或int类型实现同样的功能，<code>done &lt;- 1</code>语句也比<code>done &lt;- struct{}{}</code>更短。</p>
<p>具体如何进行阻塞呢？</p>
<ul>
<li>一个基于无缓存Channels的发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相同的Channels上执行接收操作，当发送的值通过Channels成功传输之后，两个goroutine可以继续执行后面的语句。</li>
<li>如果接收操作先发生，那么接收者goroutine也将阻塞，直到有另一个goroutine在相同的Channels上执行发送操作。</li>
</ul>
<p>这里的同步操作则引出了一个Golang并发内存模型的关键术语：Happens Before！具体如何体现？</p>
<p>比如<strong>无缓存的Channel上的发送操作总在对应的接收操作完成前 发生。</strong></p>
<p>具体案例如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"><span class="keyword">var</span> msg <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">// 对msg进行写入</span></span><br><span class="line">    msg = <span class="string">"Hello World！"</span></span><br><span class="line">    <span class="comment">// 发送同步信号</span></span><br><span class="line">    done &lt;- <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">go</span> send()</span><br><span class="line">    <span class="comment">// 接收同步信号</span></span><br><span class="line">    &lt;-done</span><br><span class="line">    <span class="built_in">println</span>(msg)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>怎么体现？体现在：<u>可保证打印出”Hello World！”</u>，原因记载上面了！结合例子思考一下。</p>
<p>具体流程为：该程序首先对<code>msg</code>进行写入，然后在<code>done</code>管道上发送同步信号，随后从<code>done</code>接收对应的同步信号，最后执行<code>println</code>函数。</p>
<p>还有<strong>对于从无缓存Channel进行的接收，发生在对该Channel进行的发送<u>完成</u> 之前。</strong></p>
<p>具体案例如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"><span class="keyword">var</span> msg <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">// 对msg进行写入</span></span><br><span class="line">    msg = <span class="string">"Hello World！"</span></span><br><span class="line">    <span class="comment">// 接收同步信号</span></span><br><span class="line">    &lt;-done</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">go</span> recv()</span><br><span class="line">    <span class="comment">// 发送同步信号</span></span><br><span class="line">    done &lt;- <span class="literal">true</span></span><br><span class="line">    <span class="built_in">println</span>(msg)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>怎么体现？体现在：<u>也可保证打印出”Hello World！”</u>。因为<code>main</code>线程中<code>done &lt;- true</code>发送完成前，后台线程<code>&lt;-done</code>接收已经开始，这保证<code>msg = "Hello World！</code>被执行了，所以之后<code>println(msg)</code>的msg已经被赋值过了。具体流程为：后台线程首先对<code>msg</code>进行写入，然后从<code>done</code>中接收信号，随后<code>main</code>线程向<code>done</code>发送对应的信号，最后执行<code>println</code>函数完成。</p>
<p>对于带缓冲的Channel也自然有Happens Before：<strong>对于Channel的第<code>K</code>个接收完成操作发生在第<code>K+C</code>个发送操作完成之前，其中<code>C</code>是Channel的缓存大小。</strong> 如果将<code>C</code>设置为0自然就对应无缓存的Channel，也即使第K个接收完成在第K个发送完成之前。因为无缓存的Channel只能同步发1个，也就简化为前面无缓存Channel的规则：<strong>对于从无缓冲Channel进行的接收，发生在对该Channel进行的发送完成之前。</strong></p>
<p>如果用反向思维来辩证一下的话，要是没有这条Happens Before的话，是不是<code>done &lt;- true</code>发送了之后就瞬间直接打印”Hello World！了，而运行的结果并不是，我们在接收同步信号之前进行一个睡眠延时，发现打印”Hello World！也需要等待这个睡眠延时的时间，原因就是对无缓存Channel的接收发生在对该Chennel进行的发送完成之前：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"><span class="keyword">var</span> msg <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">// 对msg进行写入</span></span><br><span class="line">    msg = <span class="string">"Hello World！"</span></span><br><span class="line">    <span class="comment">// 等待三秒</span></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">// 接收同步信号</span></span><br><span class="line">    &lt;-done</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">go</span> recv()</span><br><span class="line">    <span class="comment">// 发送同步信号</span></span><br><span class="line">    done &lt;- <span class="literal">true</span></span><br><span class="line">    <span class="built_in">println</span>(msg)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里看到了一幅很具体的图展示了什么叫无缓存的Channel：</p>
<p><img src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200822000155.png" alt="不带缓存的Channels"></p>
<p>需要注意的是<u>无缓存的Channel 必须再有人接收值的时候才能发送值，否则会产生deallock</u>，代码如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="comment">// 只有发送，并没有接收！</span></span><br><span class="line">    ch &lt;- <span class="number">10</span></span><br><span class="line">    fmt.Println(<span class="string">"发送成功"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行之后发生错误：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br></pre></td></tr></tbody></table></figure>

<p>上面的代码会阻塞在ch &lt;- 10这一行代码形成死锁，那如何解决这个问题呢？</p>
<p>可以启用一个goroutine去接收值，例如：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    ret := &lt;-c</span><br><span class="line">    fmt.Println(<span class="string">"接收成功"</span>, ret)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> recv(ch) <span class="comment">// 启用goroutine从通道接收值</span></span><br><span class="line">    ch &lt;- <span class="number">10</span></span><br><span class="line">    fmt.Println(<span class="string">"发送成功"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>还有一个需要注意的地方，也是我一直在怀疑的地方，<u>如果我同时向通道进行数据发送和数据接收，会不会速度太快导致接收方不够时间在发送者继续执行发送前处理数据</u>？进行验证一下：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        <span class="keyword">for</span> m := <span class="keyword">range</span> ch {</span><br><span class="line">            fmt.Println(<span class="string">"processed:"</span>,m)</span><br><span class="line">        }</span><br><span class="line">    }()</span><br><span class="line">    ch &lt;- <span class="string">"First"</span></span><br><span class="line">    ch &lt;- <span class="string">"Second"</span> <span class="comment">// 这段有可能不被处理</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>进行了多次的测试之后发现有时候”Second”会被处理到，有时候并不会！所以对这里数据处理要注意一下，主要原因是<u>上述代码处理过程中发送方不会被阻塞，除非发送的消息正在被接收方处理这样才会进行阻塞</u>，所以我们的同步操作不可像上面那样编写！</p>
<h2 id="2-3-带缓存的Channels"><a href="#2-3-带缓存的Channels" class="headerlink" title="2.3 带缓存的Channels"></a>2.3 带缓存的Channels</h2><p>我们可以在使用make函数初始化通道的时候为其指定通道的容量，带缓存的Channel内部持有一个元素队列。队列的最大容量是在调用make函数创建channel时通过第二个参数指定的。例如：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">3</span>) <span class="comment">// 创建一个容量为3的有缓冲区通道</span></span><br><span class="line">    ch &lt;- <span class="string">"A"</span></span><br><span class="line">    fmt.Println(<span class="string">"发送成功"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>向缓存Channel的发送操作就是向内部缓存队列的尾部插入元素，接收操作则是从队列的头部删除元素。</p>
<p>而带缓存的Channels 与阻塞的联系则如下：</p>
<ul>
<li>如果内部缓存队列是满的，那么发送操作将阻塞直到因另一个goroutine执行接收操作而释放了新的队列空间。</li>
<li>相反，如果channel是空的，接收操作将阻塞直到有另一个goroutine执行发送操作而向队列插入元素。</li>
<li>那么channel的缓存队列将不是满的也不是空的，因此对该channel执行的发送或接收操作都不会发送阻塞。通过这种方式，channel的缓存队列解耦了接收和发送的goroutine。</li>
</ul>
<p>细心的你想必发现了，为啥上面的代码不像前面的不带缓存的Channel一样报错deadlock？这里联系上下文讲一下我个人的理解，在不带缓存的Channels中就好比快递员送快递，而你的小区没有快递柜和菜鸟驿站啥的，那么他就必须要把这个快递直接送到你手中了，但是根本都没有这个收货人则怎么发出去货物呢？所以则报错了！而在带缓存的Channels中，你有很多个快递柜，你可以将货物暂存在这里，别人拿不拿是别人的事，反正有目的地即可（如果理解错误请纠正我）。</p>
<p>在某些特殊情况下，程序可能需要知道channel内部缓存的容量，可以用内置的cap函数获取：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    ch &lt;- <span class="string">"A"</span></span><br><span class="line">    ch &lt;- <span class="string">"B"</span></span><br><span class="line">    ch &lt;- <span class="string">"C"</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="built_in">cap</span>(ch)) <span class="comment">// "3"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>同样，对于内置的len函数，如果传入的是channel，那么将返回channel内部缓存队列中有效元素的个数。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="built_in">len</span>(ch)) <span class="comment">// "3"</span></span><br></pre></td></tr></tbody></table></figure>

<p>还有一点需要注意的是，如果Channel为带缓存的，即使我们将其缓存设置为1，也不会进行像前面无缓存那样的阻塞，<code>main</code>线程的<code>done &lt;- true</code>接收操作将不会被后台线程的<code>&lt;-done</code>接收操作阻塞，该程序将无法保证打印出”Hello World！”。如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将其变为有缓存的Chan</span></span><br><span class="line"><span class="keyword">var</span> done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">var</span> msg <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">// 对msg进行写入</span></span><br><span class="line">    msg = <span class="string">"Hello World！"</span></span><br><span class="line">    <span class="comment">// 等待三秒</span></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">// 接收同步信号</span></span><br><span class="line">    &lt;-done</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">go</span> recv()</span><br><span class="line">    <span class="comment">// 发送同步信号</span></span><br><span class="line">    done &lt;- <span class="literal">true</span></span><br><span class="line">    <span class="built_in">println</span>(msg)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>你会发现，这个 “Hello World！”永远也打印不出来！</p>
<p>同样参考如下图所示：</p>
<p><img src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200822000228.png" alt="带缓存的Channels"></p>
<h2 id="2-4-单向的Channels"><a href="#2-4-单向的Channels" class="headerlink" title="2.4 单向的Channels"></a>2.4 单向的Channels</h2><p>单向 Channel，既只能读或者只能进行写的Channel。对比普通的Channel：<code>chan int</code>，其详细类型如下：</p>
<ul>
<li><u><code>chan&lt;- int</code>表示一个只发送int的channel</u>，只能发送不能接收。</li>
<li><u><code>&lt;-chan int</code>表示一个只接收int的channel</u>，只能接收不能发送。</li>
</ul>
<blockquote>
<p>注意：箭头<code>&lt;-</code>和关键字chan的相对位置表明了channel的方向。这种限制将在编译期检测。</p>
</blockquote>
<p><strong>任何双向channel向单向channel变量的赋值操作都将导致该channel进行隐式转换</strong>。这里并没有反向转换的语法：也就是不能一个将类似<code>chan&lt;- int</code>类型的单向型的channel转换为<code>chan int</code>类型的双向型的channel。案例如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// counter ：进行计数，传入一个只读的chan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> x := <span class="number">0</span>; x &lt; <span class="number">100</span>; x++ {</span><br><span class="line">        out &lt;- x</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">close</span>(out)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// squarer ：进行平方计算,out是只写chan，in是只读chan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squarer</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> in {</span><br><span class="line">        out &lt;- v * v</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">close</span>(out)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// printer ：进行打印输出，in是只读chan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> in {</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    naturals := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    squares := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> counter(naturals)</span><br><span class="line">    <span class="keyword">go</span> squarer(squares, naturals)</span><br><span class="line">    printer(squares)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>调用counter(naturals)将导致将<code>chan int</code>类型的naturals隐式地转换为<code>chan&lt;- int</code>类型只发送型的channel。调用printer(squares)也会导致相似的隐式转换，这一次是转换为<code>&lt;-chan int</code>类型只接收型的channel。</p>
<p>总的来说，单向 channel 主要用在<u>函数声明</u>中，有的时候我们会将通道作为参数在多个任务函数间传递，很多时候我们在不同的任务函数中使用通道都会对其进行限制，比如限制通道在函数中只能发送或只能接收。比如：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> {...}</span><br></pre></td></tr></tbody></table></figure>

<p><u>foo 的形参是一个只能写的 channel</u>，那么就表示函数 foo 只会对 ch 进行写，当然你传入的参数可以是个普通 channel。<u>foo 的返回值是一个只能读的 channel</u>，那么表示 foo 的返回值规范用法就是只能读取。</p>
<p>使用单向 channel 编程体现了一种非常优秀的编程范式：<strong>convention over configuration</strong>，中文一般叫做 <strong>约定优于配置</strong>。</p>
<p>还有需要注意的一点是因为关闭操作只用于断言不再向channel发送新的数据，所以只有在发送者所在的goroutine才会调用close函数，<strong>因此对一个只接收的channel调用close将是一个编译错误</strong>。</p>
<hr>
<h1 id="3-Channels有缓存和无缓存的区别是什么？"><a href="#3-Channels有缓存和无缓存的区别是什么？" class="headerlink" title="3.Channels有缓存和无缓存的区别是什么？"></a>3.Channels有缓存和无缓存的区别是什么？</h1><p>简单来说：</p>
<ul>
<li>无缓存的管道，<strong>只要没有协程写入就读出阻塞，没有协程读出，就造成写入阻塞</strong>；</li>
<li>有缓存的管道，即使没人写入，也能读出若干默认值，即使没人读出，也能写入若干值；</li>
</ul>
<p><strong>关于无缓存或带缓存channels之间的选择</strong></p>
<ul>
<li><strong>关于无缓存或带缓存channels之间的选择，或者是带缓存channels的容量大小的选择，都可能影响程序的正确性</strong>。<ul>
<li>无缓存channel更强地保证了每个发送操作与相应的同步接收操作；</li>
<li>但是对于带缓存channel，这些操作是解耦的。</li>
</ul>
</li>
<li>即使我们知道将要发送到一个channel的信息的数量上限，创建一个对应容量大小的带缓存channel也是不现实的，因为<u>这要求在执行任何接收操作之前缓存所有已经发送的值</u>。如果未能分配足够的缓存将导致程序死锁。</li>
<li><strong>Channel的缓存也可能影响程序的性能</strong>。想象一家蛋糕店有三个厨师，一个烘焙，一个上糖衣，还有一个将每个蛋糕传递到它下一个厨师的生产线。在狭小的厨房空间环境，每个厨师在完成蛋糕后必须等待下一个厨师已经准备好接受它；这类似于在一个无缓存的channel上进行沟通。</li>
<li>如果在每个厨师之间有一个放置一个蛋糕的额外空间，那么每个厨师就可以将一个完成的蛋糕临时放在那里而马上进入下一个蛋糕的制作中；这类似于将channel的缓存队列的容量设置为1。只要每个厨师的平均工作效率相近，那么其中大部分的传输工作将是迅速的，个体之间细小的效率差异将在交接过程中弥补。如果厨师之间有更大的额外空间——也是就更大容量的缓存队列——将可以在不停止生产线的前提下消除更大的效率波动，例如一个厨师可以短暂地休息，然后再加快赶上进度而不影响其他人。</li>
<li>另一方面，如果生产线的前期阶段一直快于后续阶段，那么它们之间的缓存在大部分时间都将是满的。<u>相反，如果后续阶段比前期阶段更快，那么它们之间的缓存在大部分时间都将是空的。对于这类场景，额外的缓存并没有带来任何好处</u>。</li>
<li>生产线的隐喻对于理解channels和goroutines的工作机制是很有帮助的。例如，如果第二阶段是需要精心制作的复杂操作，一个厨师可能无法跟上第一个厨师的进度，或者是无法满足第三阶段厨师的需求。要解决这个问题，我们可以再雇佣另一个厨师来帮助完成第二阶段的工作，他执行相同的任务但是独立工作。这类似于基于相同的channels创建另一个独立的goroutine。</li>
</ul>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="http://topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/channel.html" target="_blank" rel="noopener">Go语言中文文档-Channel</a></li>
<li><a href="http://legendtkl.com/2017/07/30/understanding-golang-channel/" target="_blank" rel="noopener">深入理解 Go Channel</a></li>
<li><a href="https://www.kancloud.cn/lbb4511/gopl/1107899" target="_blank" rel="noopener">第八章 Goroutines和Channels</a></li>
<li><a href="https://colobu.com/2015/09/07/gotchas-and-common-mistakes-in-go-golang/#%E5%90%91%E6%97%A0%E7%BC%93%E5%AD%98%E7%9A%84Channel%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%EF%BC%8C%E5%8F%AA%E8%A6%81%E7%9B%AE%E6%A0%87%E6%8E%A5%E6%94%B6%E8%80%85%E5%87%86%E5%A4%87%E5%A5%BD%E5%B0%B1%E4%BC%9A%E7%AB%8B%E5%8D%B3%E8%BF%94%E5%9B%9E" target="_blank" rel="noopener">Go的50度灰：Golang新开发者要注意的陷阱和常见错误</a></li>
<li><a href="https://chai2010.cn/advanced-go-programming-book/ch1-basic/ch1-05-mem.html" target="_blank" rel="noopener">面向并发的内存模型</a></li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/go/" rel="tag"># go</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/05/18/golang-yuan-ma-pou-xi-map-ying-she/" rel="prev" title="golang 源码剖析 - Map映射">
      <i class="fa fa-chevron-left"></i> golang 源码剖析 - Map映射
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/05/29/golang-bing-fa-channel-de-yi-xie-shi-xian/" rel="next" title="golang 并发 - Channel的一些实现">
      golang 并发 - Channel的一些实现 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-Channels是什么？"><span class="nav-text">1.Channels是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-如何实现Channels？"><span class="nav-text">2.如何实现Channels？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-基本实现及操作"><span class="nav-text">2.1 基本实现及操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-不带缓存的Channels"><span class="nav-text">2.2 不带缓存的Channels</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-带缓存的Channels"><span class="nav-text">2.3 带缓存的Channels</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-单向的Channels"><span class="nav-text">2.4 单向的Channels</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-Channels有缓存和无缓存的区别是什么？"><span class="nav-text">3.Channels有缓存和无缓存的区别是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考文章"><span class="nav-text">参考文章</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Garmen Lee"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Garmen Lee</p>
  <div class="site-description" itemprop="description">杂货铺售卖知识 诸位自取</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">36</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Garmen Lee</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">256k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">3:53</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>

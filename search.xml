<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>golang 基础 - Slice的几个疑惑</title>
    <url>/2020/08/29/golang-ji-chu-slice-de-ji-ge-yi-huo/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>golang 基础 - 数组与切片的一些认识</title>
    <url>/2020/08/29/golang-ji-chu-shu-zu-yu-qie-pian-de-yi-xie-ren-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>golang 并发 - 深入Channel源码解析</title>
    <url>/2020/08/21/golang-bing-fa-shen-ru-channel-yuan-ma-jie-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Channel有锁还是无锁？</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>golang 基础 - 关于使用Type定义类型的几个问题</title>
    <url>/2020/06/04/golang-ji-chu-guan-yu-shi-yong-type-ding-yi-lei-xing-de-ji-ge-wen-ti/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>从一道题目开始入手Type的一些具体知识，可以想想打印结果是什么？</p>
<p>这里涉及到的是一些golang语言中的Type的一些基础知识，不要再犯迷糊了，好好地加深一下认识~</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 1--</span></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">interface</span>{}</span><br><span class="line"><span class="comment">// 2--</span></span><br><span class="line"><span class="keyword">type</span> X <span class="keyword">string</span></span><br><span class="line"><span class="comment">// 3--</span></span><br><span class="line"><span class="keyword">type</span> Y = <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> t T = <span class="string">"abc"</span></span><br><span class="line">    <span class="keyword">var</span> x X = <span class="string">"abc"</span></span><br><span class="line">    <span class="keyword">var</span> y Y = <span class="string">"abc"</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(t == x)</span><br><span class="line">    fmt.Println(t == <span class="keyword">string</span>(x))</span><br><span class="line"></span><br><span class="line">    fmt.Println(t == y)</span><br><span class="line">    fmt.Println(t == <span class="keyword">string</span>(y))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<a id="more"></a>

<p>输出结果如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure>

<p>不知道你是不是跟我一样错了两个，上面涉及的知识点接下来一一展开~</p>
<p>在第7、9、11行中：</p>
<ol>
<li>第7行, 使用type<u>定义</u>自定义类型T, <u><strong>底层为interface接口类型</strong></u></li>
<li>第9行, 使用type<strong><u>定义</u></strong>自定义类型X, <u><strong>底层为string</strong></u>，X 和 string 是不同的类型！</li>
<li>第11行, 使用type<strong><u>申明</u></strong>类型别名Y, 为string类型的<u><strong>别名</strong></u>，Y和 string 是一样的！</li>
</ol>
<p>通过上面的Type我们可以了解到，<u><strong>Type有两种格式：申明别名 和 定义类型</strong></u></p>
<p>需要注意的是使用type定义的所有类型(非类型别名)都是不同的, 如：</p>
<ul>
<li>type A string</li>
<li>type B string</li>
<li>type C string</li>
</ul>
<p>那么A, B, C 的类型是不同的！</p>
<p>在第14、15、16行中：申明特定类型的变量, 并使用各类型的字面值进行赋值(不同类型的字面值可能不一样)，但是T、X 和 Y 虽然都赋值为字符串 abc，但含义不一样：</p>
<ol>
<li><p><u><strong>T 是空接口</strong></u>，可以存放任意类型值；</p>
</li>
<li><p><strong><u>X 的底层类型是 string</u></strong>，因此字符串字面量 abc 可以直接赋值给 x</p>
<ul>
<li><p>但下面的情况是不允许的：</p>
<ul>
<li><pre class=" language-go"><span class="keyword">var</span> s <span class="keyword">string</span> = <span class="string"><code class="language-go"><span class="keyword">var</span> s <span class="keyword">string</span> = <span class="string">"abc"</span>
<span class="keyword">var</span> x X = s
<!--￼<span class="number">2</span>--></code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p><u><strong>Y 是 string 的别名，自然可以直接赋值</strong></u>；</p>
</li>
</ol>
<p>接下来涉及到了比较了，先说明接口类型值和非接口类型值比较的一些问题：</p>
<p>Go 语言规范里有这样的说明：</p>
<blockquote>
<p>A value x of non-interface type X and a value t of interface type T are comparable when values of type X are comparable and X implements T. They are equal if t’s dynamic type is identical to X and t’s dynamic value is equal to x.</p>
</blockquote>
<p>翻译如下：</p>
<blockquote>
<p>当非接口类型 <code>X</code> 的值是可比较的且 <code>X</code> 实现了接口类型 <code>T</code> ，那么 <code>X</code> 的值 <code>x</code> 和 <code>T</code> 的值 <code>t</code> 是可比较的。如果 <code>t</code>的动态类型和 <code>X</code> 一致并且 <code>t</code> 的动态值等于 <code>x</code> 的话，那么它们相等。</p>
</blockquote>
<p>那么再对题目进行细细解剖：</p>
<p>第18行为什么输出false？</p>
<ul>
<li>这一行中, 接口值t的动态类型为string, 动态值为”abc”(第12行), <strong>而非接口值x的类型为X, 类型都不相同, 动态值就不用比较了</strong></li>
</ul>
<p>第19行为什么输出true?</p>
<ul>
<li>把==号后面的值转换为string类型, 再与接口值t的动态类型和动态值比较, <strong>类型相同, 值相等</strong>, 返回true</li>
</ul>
<p>第21行为什么输出true？</p>
<ul>
<li><strong>接口值t的动态类型和非接口值y的类型比较, 相同, 动态值与非接口值y的值比较, 相等</strong>, 返回true</li>
</ul>
<p>第22行为什么输出true?</p>
<ul>
<li><strong>Y是string类型的别名, 所以string(y)和第19行的y一样, 都是string类型, 此行中的string()没有必要</strong></li>
</ul>
<p>至此，关于Type关键字的几个知识点应该可以了解到一些，还有对于接口类型值和非接口类型值比较应该也比较清晰了！</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>golang 并发 - Channel的一些实现</title>
    <url>/2020/05/29/golang-bing-fa-channel-de-yi-xie-shi-xian/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-使用无缓存Channel进行goroutine通信"><a href="#1-使用无缓存Channel进行goroutine通信" class="headerlink" title="1.使用无缓存Channel进行goroutine通信"></a>1.使用无缓存Channel进行goroutine通信</h1><p>在前面的关于Channel的一些认识当中，我们了解基于无缓存Channels的发送和接收操作将导致两个goroutine做一次同步操作，故无缓存Channels有时候也被称为同步Channels，那么我们就可以使用无缓存的Channel进行简单的goroutine通信了，代码如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">// make一个无缓存channel</span></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        fmt.Println(<span class="string">"三秒之后开始启动！"</span>)</span><br><span class="line">        <span class="comment">// 等待三秒</span></span><br><span class="line">        time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">        ch &lt;- <span class="number">1</span> <span class="comment">// 信号发送</span></span><br><span class="line">    }()</span><br><span class="line">    &lt;- ch <span class="comment">// 信号接收</span></span><br><span class="line">    <span class="built_in">close</span>(ch) <span class="comment">// 关闭通道</span></span><br><span class="line">    fmt.Println(<span class="string">"收到通知！"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<a id="more"></a>

<p>当然对于如何使用<code>stuct{}</code>空结构体进行同步Channels的操作我是一直耿耿于怀，将上面的代码改一改，加深一下认识：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">// 使用strcu{}创建一个无缓存channel</span></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{})</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        fmt.Println(<span class="string">"三秒之后开始启动！"</span>)</span><br><span class="line">        <span class="comment">// 等待三秒</span></span><br><span class="line">        time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">        ch &lt;- <span class="keyword">struct</span>{}{} <span class="comment">// 发送信号</span></span><br><span class="line">    }()</span><br><span class="line">    &lt;- ch <span class="comment">// 接收信号</span></span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">    fmt.Println(<span class="string">"收到通知！"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<hr>
<h1 id="2-结合Select多路复用"><a href="#2-结合Select多路复用" class="headerlink" title="2.结合Select多路复用"></a>2.结合Select多路复用</h1><p>一言以蔽之：<strong>Golang 中的 select 提供了对多个 channel 的统一管理</strong>。这个就是最简洁的答案，如果我们想要在程序中对多个Channel的管理，我们可以选择使用select，select语句的一般形式的代码如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> {</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch1:</span><br><span class="line">        <span class="comment">// 如果chan1成功读到数据，则进行该case处理语句</span></span><br><span class="line">    <span class="keyword">case</span> x := &lt;-ch2:</span><br><span class="line">        <span class="comment">// 如果chan2成功读到数据并将该数据赋值给x，则进行该case处理语句</span></span><br><span class="line">    <span class="keyword">case</span> ch3 &lt;- y:</span><br><span class="line">        <span class="comment">// 如果成功向chan2写入数据，则进行该case处理语句</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>select和switch语句稍微有点相似，有case也有最后的default默认分支来设置当其它的操作都不能够马上被处理时程序需要执行哪些逻辑。每一个case代表一个通信操作(在某个channel上进行发送或者接收)并且会包含一些语句组成的一个语句块。</p>
<p><u>select会等待case中有能够执行的case时去执行</u>。当条件满足时，select才会去通信并执行case之后的语句；这时候其它通信是不会执行的。<u>一个没有任何case的select语句写作select{}，会永远地等待下去</u>。</p>
<h2 id="2-1-监听一个或者多个Channel"><a href="#2-1-监听一个或者多个Channel" class="headerlink" title="2.1 监听一个或者多个Channel"></a>2.1 监听一个或者多个Channel</h2><p>关于select结合channel还是有几种情况出现的，比如我们的select可以<strong><u>监听一个或者多个channel</u></strong>，只要有一个channel做好准备进行数据发送，则select则会马上进行处理，代码如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> {</span><br><span class="line">	time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">	ch &lt;- <span class="string">"test1"</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test2</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> {</span><br><span class="line">	time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">	ch &lt;- <span class="string">"test2"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">// 2个管道</span></span><br><span class="line">	chan1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	chan2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	<span class="comment">// 跑2个子协程，写数据</span></span><br><span class="line">	<span class="keyword">go</span> test1(output1)</span><br><span class="line">	<span class="keyword">go</span> test2(output2)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用select监控</span></span><br><span class="line">	<span class="keyword">select</span> {</span><br><span class="line">	<span class="keyword">case</span> s1 := &lt;-chan1:</span><br><span class="line">		fmt.Println(<span class="string">"chan1:"</span>, s1)</span><br><span class="line">	<span class="keyword">case</span> s2 := &lt;-chan2:</span><br><span class="line">		fmt.Println(<span class="string">"chan2:"</span>, s2)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-2-多个Case随机处理"><a href="#2-2-多个Case随机处理" class="headerlink" title="2.2 多个Case随机处理"></a>2.2 多个Case随机处理</h2><p>那肯定有些情况我们不知道那么些个channel哪个先准备好，哪个后准备好，在这种个case同时就绪时的情况下，select会<u><strong>随机处理</strong></u>，即随机地选择一个执行，这样来保证每一个channel都有平等的被select的机会。比如下面的代码中，有时候会打印 <code>ch1:1</code>，有时候则打印 <code>ch2:"hello"</code>，这是一个随机处理的过程！代码如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">// 创建2个管道</span></span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">	ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">		ch1 &lt;- <span class="number">1</span></span><br><span class="line">	}()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">		ch2 &lt;- <span class="string">"hello"</span></span><br><span class="line">	}()</span><br><span class="line">	<span class="keyword">select</span> {</span><br><span class="line">	<span class="keyword">case</span> value := &lt;-ch1:</span><br><span class="line">		fmt.Println(<span class="string">"ch1:"</span>, value)</span><br><span class="line">	<span class="keyword">case</span> value := &lt;-ch2:</span><br><span class="line">		fmt.Println(<span class="string">"ch2:"</span>, value)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-3-充分利用Default"><a href="#2-3-充分利用Default" class="headerlink" title="2.3 充分利用Default"></a>2.3 充分利用Default</h2><p>我们还可以<u><strong>利用default</strong></u>这个巧妙的设定来进行一些判断，比如判断channel是否已经写满，下面的代码会在ch channel中有值时，从其中接收值；无值时什么都不做。这是一个非阻塞的接收操作；反复地做这样的操作叫做“轮询channel”。代码如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断管道有没有存满</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">// 创建容量为10的chan</span></span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="comment">// 开启goroutine写数据</span></span><br><span class="line">	<span class="keyword">go</span> write(ch)</span><br><span class="line">	<span class="comment">// 消耗数据</span></span><br><span class="line">	<span class="keyword">for</span> s := <span class="keyword">range</span> ch {</span><br><span class="line">		fmt.Println(<span class="string">"res:"</span>, s)</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> {</span><br><span class="line">	<span class="keyword">for</span> {</span><br><span class="line">		<span class="keyword">select</span> {</span><br><span class="line">		<span class="comment">// 写数据</span></span><br><span class="line">		<span class="keyword">case</span> ch &lt;- <span class="string">"hello"</span>:</span><br><span class="line">			fmt.Println(<span class="string">"write hello"</span>)</span><br><span class="line">		<span class="comment">// 如果ch通道已满，数据则写不进了，于是走default</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(<span class="string">"channel full"</span>)</span><br><span class="line">		}</span><br><span class="line">		time.Sleep(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-4-超时控制"><a href="#2-4-超时控制" class="headerlink" title="2.4 超时控制"></a>2.4 超时控制</h2><p>还有其他很多很简单的一些实现，比如可以使用<code>select+channel</code>做超时控制，在很多操作情况下都需要超时控制，利用 select 实现超时控制，代码如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">		<span class="comment">// 休眠两秒</span></span><br><span class="line">		time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">		<span class="comment">// 往通道ch写入数据</span></span><br><span class="line">		ch &lt;- <span class="string">"result"</span></span><br><span class="line">	}()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> {</span><br><span class="line">	<span class="keyword">case</span> res := &lt;-ch:</span><br><span class="line">		fmt.Println(res)</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">1</span>): </span><br><span class="line">		<span class="comment">// 休眠时间设定为1秒，超过1秒没有得到ch数据则判定为超时</span></span><br><span class="line">		fmt.Println(<span class="string">"timeout"</span>)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面的代码中，<code>select</code>语句会阻塞等待最先返回数据的<code>channel</code>，当先接收到<code>time.After</code>的通道数据时，<code>select</code>则会停止阻塞并执行该<code>case</code>的代码。此时就已经实现了对业务代码的超时处理。</p>
<hr>
<h1 id="3-并发协程的安全退出"><a href="#3-并发协程的安全退出" class="headerlink" title="3.并发协程的安全退出"></a>3.并发协程的安全退出</h1><p>有时候我们需要通知goroutine停止它正在干的事情，比如一个正在执行计算的web服务，然而它的客户端已经断开了和服务端的连接。Golang 没有提供这么一个goroutine中终止另一个goroutine的方法，为啥不直接提供一个goroutine直接终止另外一个goroutine的方法呢？因为这样会<strong>导致goroutine之间的共享变量落在未定义的状态上</strong>。</p>
<p>通常我们可以使用<code>select</code>和<code>default</code>分支可以很容易实现一个Goroutine的退出控制：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(cancel <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> {</span><br><span class="line">	<span class="keyword">for</span> {</span><br><span class="line">		<span class="keyword">select</span> {</span><br><span class="line">		<span class="keyword">case</span> &lt;-cancel:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">			<span class="comment">// 退出</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">			<span class="comment">// 正常工作</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	cancel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">	<span class="keyword">go</span> worker(cancel)</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">	cancel &lt;- <span class="literal">true</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>假如我们不是使用<code>cancel &lt;- true</code>这种传值的方式，而是想通过<code>close()</code>方法关闭一个通道进而关闭相对于的协程呢？这就要使用到<code>ok-idiom</code>了！</p>
<p><strong>关于使用<code>ok-idiom</code>我们可以结合select进行</strong>，往往我们需要结合<code>for-select</code>这种结构来实现，因为select提供了多路复用的能力，所以<u><code>for-select</code>可以让函数具有持续多路处理多个Channel的能力</u>。</p>
<p>需要注意的是在使用ok-idiom过程中进行退出的时候，<strong>select没有感知channel的关闭</strong>，这引出了2个问题：</p>
<ol>
<li>继续在关闭的通道上读，会读到通道传输数据类型的零值，如果是指针类型，读到nil，继续处理还会产生nil。</li>
<li>继续在关闭的通道上写，将会panic。</li>
</ol>
<p>问题2可以这样解决，<u>通道只由发送方关闭，接收方不可关闭</u>，即某个写通道只由使用该select的协程关闭，select中就不存在继续在关闭的通道上写数据的问题。关于这点，官方<code>close()</code>的注释中也明确讲了：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// The close built-in function closes a channel, which must be either</span></span><br><span class="line"><span class="comment">// bidirectional or send-only. It should be executed only by the sender,</span></span><br><span class="line"><span class="comment">// never the receiver, and has the effect of shutting down the channel after</span></span><br><span class="line"><span class="comment">// the last sent value is received. After the last value has been received</span></span><br><span class="line"><span class="comment">// from a closed channel c, any receive from c will succeed without</span></span><br><span class="line"><span class="comment">// blocking, returning the zero value for the channel element. The form</span></span><br><span class="line"><span class="comment">// x, ok := &lt;-c</span></span><br><span class="line"><span class="comment">// will also set ok to false for a closed channel.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">close</span><span class="params">(c <span class="keyword">chan</span>&lt;- Type)</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>问题1可以使用<code>,ok</code>来检测通道的关闭，使用情况有2种。</p>
<p>使用<code>ok-idiom</code>结合<code>for-select</code>结构第一种情况：<strong>如果某个通道关闭后，需要退出协程，直接return即可</strong>。例代码中，该协程需要从in通道读数据，还需要定时打印已经处理的数量，有2件事要做，所以不能使用for-range，需要使用for-select，当in关闭时，<code>ok=false</code>，我们直接返回。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(cancel <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> {</span><br><span class="line">	<span class="keyword">for</span> {</span><br><span class="line">		<span class="keyword">select</span> {</span><br><span class="line">		<span class="keyword">case</span> _, ok := &lt;-cancel:</span><br><span class="line">			<span class="comment">// 如果ok为false，则直接返回退出</span></span><br><span class="line">			<span class="keyword">if</span> !ok {</span><br><span class="line">				fmt.Println(<span class="string">"I am out!"</span>)</span><br><span class="line">				<span class="comment">// 退出</span></span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			}</span><br><span class="line">			<span class="comment">// 接收其他值时候进行正常工作</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">			<span class="comment">// 正常工作</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	cancel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">	<span class="keyword">go</span> worker(cancel)</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">	<span class="built_in">close</span>(cancel)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>使用<code>ok-idiom</code>结合<code>for-select</code>结构第二种情况：如果<strong>某个通道关闭了，不再处理该通道，而是继续处理其他case，退出是等待所有的通道关闭。</strong></p>
<p>我们需要<strong>使用select的一个特征：select不会在nil的通道上进行等待</strong>。这种情况，把只读通道设置为nil即可解决。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ch1, ch2 <span class="keyword">chan</span> <span class="keyword">int</span>,)</span></span> {</span><br><span class="line">	<span class="keyword">for</span> {</span><br><span class="line">		<span class="keyword">select</span> {</span><br><span class="line">		<span class="keyword">case</span> _, ok := &lt;-ch1:</span><br><span class="line">			<span class="comment">// 如果ok为false，置ch1位nil</span></span><br><span class="line">			<span class="comment">// 再往后的循环中，select不会再处理这个nil的case了</span></span><br><span class="line">			<span class="keyword">if</span> !ok {</span><br><span class="line">				fmt.Println(<span class="string">"ch1 is over!"</span>)</span><br><span class="line">				ch1 = <span class="literal">nil</span></span><br><span class="line">			}</span><br><span class="line">			<span class="comment">// 正常处理</span></span><br><span class="line">		<span class="keyword">case</span> _, ok := &lt;-ch2:</span><br><span class="line">			<span class="comment">// 同上</span></span><br><span class="line">			<span class="keyword">if</span> !ok {</span><br><span class="line">				fmt.Println(<span class="string">"ch2 is over!"</span>)</span><br><span class="line">				ch2 = <span class="literal">nil</span></span><br><span class="line">			}</span><br><span class="line">			<span class="comment">// 接收其他值时候进行正常工作</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">			fmt.Println(<span class="string">"I am doing other work!"</span>)</span><br><span class="line">			<span class="comment">// 正常处理</span></span><br><span class="line">		}</span><br><span class="line">		<span class="comment">// 如果ch1 和 ch2通道都被关闭了，才进行goroutine的退出</span></span><br><span class="line">		<span class="keyword">if</span> ch1 == <span class="literal">nil</span> &amp;&amp; ch2 == <span class="literal">nil</span> {</span><br><span class="line">			fmt.Println(<span class="string">"worker is done!"</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> worker(ch1, ch2)</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">	<span class="comment">// 先关闭ch1</span></span><br><span class="line">	<span class="built_in">close</span>(ch1)</span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">	<span class="comment">// 再关闭ch2</span></span><br><span class="line">	<span class="built_in">close</span>(ch2)</span><br><span class="line">	<span class="comment">// 延时一下再结束主协程</span></span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>打印结果如下：</p>
<p><img src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200823234824.png" alt="image-20200823234824352"></p>
<p>但问题是<strong>如果我们想要退出两个或者任意多个Goroutine怎么办呢？</strong>这里大概有两种办法：</p>
<p><u>一种是向所有的goroutine发送同样数量的信号给对应的同步Channel来进行退出提示（上面的示例就是一个例子了！）</u>。但是这样并不是保险的，想想如果在发出发出信号的时候有些goroutine自动退出了，那么是不是<u>Channel中的事件数比需要关闭的goroutine还多</u>？这样一来，我们的发送就直接被阻塞了！除了发送到Channel的事件数目过多的情况，<u>过少的情况也可能出现</u>，比如待关闭的goroutine又生成了其他的goroutine，那样一来就会产生有些需要关闭的goroutine却没有收到退出的消息</p>
<blockquote>
<p>最重要的一点在于Go的并发十分强大，我们很难知道某一个时刻具体运行着的goroutine数目，所以采用这种方法精确的去关闭多个goroutine是很困难的。</p>
</blockquote>
<p>管道的发送操作和接收操作是一一对应的，如果要停止多个Goroutine那么可能需要创建同样数量的管道，这个代价太大了！</p>
<p>而另外一种则是通过Channel进行消息广播，<strong>使用一个专门的通道，发送退出的信号</strong>，我们看看如何进行一步步改进。</p>
<p><strong>首先我们可以通过不向Channel发送值而是使用<code>close</code>关闭一个Channel，从而实现广播的效果！</strong>为什么不使用发送值而是使用close呢？因为当一个goroutine从一个channel中接收到一个值的时候，他会消费掉这个值，这样其它的goroutine就没法看到这条信息了。</p>
<p>比如说，我们启动了10个worker时，只要<code>main()</code>执行关闭cancel通道，每一个worker都会都到信号，进而关闭。示例代码如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(cancel <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> {</span><br><span class="line">	<span class="keyword">for</span> {</span><br><span class="line">		<span class="keyword">select</span> {</span><br><span class="line">		<span class="keyword">case</span> &lt;-cancel:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">			<span class="comment">// 退出</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">			<span class="comment">// 正常工作</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">// 建立一个通知退出的同步Channel</span></span><br><span class="line">	cancel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">	<span class="comment">// 创建10个goroutine</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">		<span class="keyword">go</span> worker(cancel)</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// 休眠一段时间</span></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	<span class="comment">// 发送终止信号</span></span><br><span class="line">	<span class="built_in">close</span>(cancel)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里存在的问题就是：当每个Goroutine收到退出指令退出时一般会进行一定的清理工作，但是退出的清理工作并不能保证被完成，因为<strong><code>main</code>线程并没有等待各个工作Goroutine退出工作完成的机制</strong>。我们可以结合<code>sync.WaitGroup</code>来改进:</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(wg *sync.WaitGroup, cannel <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> {</span><br><span class="line">	<span class="comment">// 在程序处理完所有之后进行减一</span></span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> {</span><br><span class="line">		<span class="keyword">select</span> {</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">		<span class="keyword">case</span> &lt;-cannel:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	cancel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">		<span class="comment">// 每开始创建一个woker之前将计数加一</span></span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> worker(&amp;wg, cancel)</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	<span class="built_in">close</span>(cancel)</span><br><span class="line">	<span class="comment">// 等待所有计数为0时才关闭主线程</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在每个工作者并发体的创建、运行、暂停和退出都是在<code>main</code>函数的安全控制之下了。</p>
<p>小结一下处理并发协程的安全退出的几种方法：</p>
<ol>
<li>使用<code>ok-idiom</code>处理一个或者多个goroutine的关闭，但是多个goroutine的关闭并不推荐使用这种方式进行。</li>
<li>通过Channel进行消息广播，<strong>使用一个专门的Channel，通过<code>close()</code>发送退出的信号</strong>。</li>
<li>在第二点的基础上结合<code>sync.WaitGroup</code>来改进，完善为<strong><code>main</code>线程等待各个工作Goroutine退出工作完成的机制</strong></li>
</ol>
<hr>
<h1 id="4-使用管道（Pipeline）优雅的从Channel循环取值"><a href="#4-使用管道（Pipeline）优雅的从Channel循环取值" class="headerlink" title="4.使用管道（Pipeline）优雅的从Channel循环取值"></a>4.使用管道（Pipeline）优雅的从Channel循环取值</h1><p>当通过Channel发送有限的数据时，我们可以通过<code>close()</code>函数关闭Channel来告知从该Channel接收值的goroutine停止等待。当Channel被关闭时，再继续往该Channel发送值则会引发panic，如果从该Channel里接收的值一直都是类型零值。<strong>那如何判断一个通道是否被关闭了呢？</strong>在前面的关于Channel的认识中我们了解到，可以使用ok-idiom 进行判断，接收操作有一个<strong>变体形式</strong>：它多接收一个结果，多接收的第二个结果是一个布尔值ok，ture表示成功从channels接收到值，false表示channels已经被关闭并且里面没有值可接收。</p>
<p>在下面的代码中，第一个goroutine是一个计数器，用于生成0、1、2、……形式的整数序列，然后通过channel将该整数序列发送给第二个goroutine；第二个goroutine是一个求平方的程序，对收到的每个整数求平方，然后将平方后的结果通过第二个channel发送给第三个goroutine；第三个goroutine是一个打印程序，打印收到的每个整数。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 开启goroutine将0~100的数发送到ch1中</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ {</span><br><span class="line">			ch1 &lt;- i</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">close</span>(ch1)</span><br><span class="line">	}()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 开启goroutine从ch1中接收值，并将该值的平方发送到ch2中</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">		<span class="keyword">for</span> {</span><br><span class="line">			i, ok := &lt;-ch1 <span class="comment">// 通道关闭后再取值，此时ok=false</span></span><br><span class="line">			<span class="keyword">if</span> !ok { <span class="comment">// 如果ok为false，证明通道已经关闭了，则break，然后执行close</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			}</span><br><span class="line">			ch2 &lt;- i * i</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">close</span>(ch2)</span><br><span class="line">	}()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在主goroutine中从ch2中接收值打印</span></span><br><span class="line">	<span class="comment">// 通道关闭后会退出for range循环</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> ch2 {</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>从上面的例子中我们看到有两种方式在接收值的时候判断通道是否被关闭：</p>
<ul>
<li>一种是使用<code>ok-idiom</code></li>
<li>另外一种就是使用<code>for range</code>了，而我们通常使用的是<code>for range</code>的方式。</li>
</ul>
<p>为什么for range能够起到作用呢？因为range channel 可以直接取到 channel 中的值。当我们使用 range 来操作 channel 的时候，它<strong>依次从channel接收数据，当channel被关闭并且没有值可接收时跳出循环</strong>。这应该和<code>for range</code>的语法糖相关，后续了解到<code>for range</code>的语法糖的时候，再返回来解决详细的解决这个疑惑！</p>
<hr>
<h1 id="5-实现生产者消费者模型"><a href="#5-实现生产者消费者模型" class="headerlink" title="5.实现生产者消费者模型"></a>5.实现生产者消费者模型</h1><p>生产者消费者模型是很常见的了，在操作系统看见的次数可不少，这是并发编程中最常见的例子了，该模式主要通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。简单地说，就是生产者生产一些数据，然后放到成果队列中，同时消费者从成果队列中来取这些数据。这样就让生产消费变成了异步的两个过程。当成果队列中没有数据时，消费者就进入饥饿的等待中；而当成果队列中数据已满时，生产者则面临因产品挤压导致CPU被剥夺的下岗问题。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Producer ： 生产者，生成 factor 整数倍的序列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Producer</span><span class="params">(factor <span class="keyword">int</span>, out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> {</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++ {</span><br><span class="line">		fmt.Println(<span class="string">"生产了："</span>, i*factor)</span><br><span class="line">		out &lt;- i*factor</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Consumer ：消费者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Consumer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> in {</span><br><span class="line">		fmt.Println(<span class="string">"消费了："</span>,v)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">64</span>) <span class="comment">// 成果队列</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> Producer(<span class="number">2</span>, ch) <span class="comment">// 生成 2 的倍数的序列</span></span><br><span class="line">	<span class="keyword">go</span> Consumer(ch)    <span class="comment">// 消费 生成的队列</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 运行一定时间后退出</span></span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>还可以进行改进，我们让<code>main</code>函数保存阻塞状态不退出，只有当用户输入<code>Ctrl-C</code>时才真正退出程序：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"os/signal"</span></span><br><span class="line">	<span class="string">"syscall"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Producer ： 生产者，生成 factor 整数倍的序列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Producer</span><span class="params">(factor <span class="keyword">int</span>, out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> {</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++ {</span><br><span class="line">		fmt.Println(<span class="string">"生产了："</span>, i*factor)</span><br><span class="line">		out &lt;- i*factor</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Consumer ：消费者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Consumer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> in {</span><br><span class="line">		fmt.Println(<span class="string">"消费了："</span>,v)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">64</span>) <span class="comment">// 成果队列</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> Producer(<span class="number">2</span>, ch) <span class="comment">// 生成 3 的倍数的序列</span></span><br><span class="line">	<span class="keyword">go</span> Consumer(ch)    <span class="comment">// 消费 生成的队列</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Ctrl+C 退出</span></span><br><span class="line">	sig := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">	signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">	fmt.Printf(<span class="string">"quit (%v)\n"</span>, &lt;-sig)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<hr>
<h1 id="6-实现循环队列"><a href="#6-实现循环队列" class="headerlink" title="6.实现循环队列"></a>6.实现循环队列</h1><h1 id="7-控制并发数"><a href="#7-控制并发数" class="headerlink" title="7.控制并发数"></a>7.控制并发数</h1><h1 id="8-发布订阅模型"><a href="#8-发布订阅模型" class="headerlink" title="8.发布订阅模型"></a>8.发布订阅模型</h1><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="http://topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/channel.html" target="_blank" rel="noopener">Go语言中文文档-Channel</a></li>
<li><a href="http://legendtkl.com/2017/07/30/understanding-golang-channel/" target="_blank" rel="noopener">深入理解 Go Channel</a></li>
<li><a href="https://www.kancloud.cn/lbb4511/gopl/1107899" target="_blank" rel="noopener">第八章 Goroutines和Channels</a></li>
<li><a href="https://colobu.com/2015/09/07/gotchas-and-common-mistakes-in-go-golang/#%E5%90%91%E6%97%A0%E7%BC%93%E5%AD%98%E7%9A%84Channel%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%EF%BC%8C%E5%8F%AA%E8%A6%81%E7%9B%AE%E6%A0%87%E6%8E%A5%E6%94%B6%E8%80%85%E5%87%86%E5%A4%87%E5%A5%BD%E5%B0%B1%E4%BC%9A%E7%AB%8B%E5%8D%B3%E8%BF%94%E5%9B%9E" target="_blank" rel="noopener">Go的50度灰：Golang新开发者要注意的陷阱和常见错误</a></li>
<li><a href="https://chai2010.cn/advanced-go-programming-book/ch1-basic/ch1-05-mem.html" target="_blank" rel="noopener">面向并发的内存模型</a></li>
<li><a href="https://lessisbetter.site/2018/12/02/golang-exit-goroutine-in-3-ways/" target="_blank" rel="noopener">Golang并发模型：并发协程的优雅退出</a></li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>golang 并发 - Channel的深入了解</title>
    <url>/2020/05/25/golang-bing-fa-channel-de-shen-ru-liao-jie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-Channels是什么？"><a href="#1-Channels是什么？" class="headerlink" title="1.Channels是什么？"></a>1.Channels是什么？</h1><p>这里又可以搬出知乎名言了，在认识一件事物之前，先问问是什么，再回答为什么！直接来说，一个Channel 是一个通信机制，它<strong>可以让一个Goroutine 通过它给另一个Goroutine 发送值信息</strong>。每个Channel 都有一个特殊的类型，也就是Channels可发送数据的类型（例如：一个可以发送int类型数据的Channel 一般写为chan int）。</p>
<p>在我们常见的一些语言中，多个线程传递数据的方式一般都是共享内存，<u>为了解决线程冲突的问题，我们需要限制同一时间能够读写这些变量的线程数量</u>。而Golang 语言提供了一种不同与使用使用共享内存加互斥锁也能进行通信的并发模型，也就是<strong>通信顺序进程（Communicating sequential processes，CSP）</strong>。其中Goroutine 和 Channel 分别对应 CSP 中的实体和传递信息的媒介，Go 语言中的 Goroutine 会通过 Channel 传递数据。这也是Golang一直提倡的<strong>不要通过共享内存的方式进行通信，而是应该通过通信的方式共享内存</strong>。</p>
<p>目前的 Channel 收发操作均遵循了先入先出（FIFO）的设计，而且<strong>带缓存区和不带缓存区的 Channel 都会遵循先入先出对数据进行接收和发送</strong>（关于带缓存区与不带缓存区在下面会提及），具体规则如下：</p>
<ul>
<li>先从 Channel 读取数据的 Goroutine 会先接收到数据； </li>
<li>先向 Channel 发送数据的 Goroutine 会得到先发送数据的权利；</li>
</ul>
<p>通过源码查看我们可知，Channel 在运行时使用 <a href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L32" target="_blank" rel="noopener">runtime.hchan</a> 结构体进行表示，而这玩意最后包含这一个互斥锁用于保护成员变量，所以从某种程度上说，Channel 是一个<u>用于同步和通信的有锁队列</u>。具体数据结构如下所示：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> {</span><br><span class="line">	qcount   <span class="keyword">uint</span>           <span class="comment">// total data in the queue</span></span><br><span class="line">	dataqsiz <span class="keyword">uint</span>           <span class="comment">// size of the circular queue</span></span><br><span class="line">	buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements</span></span><br><span class="line">	elemsize <span class="keyword">uint16</span></span><br><span class="line">	closed   <span class="keyword">uint32</span></span><br><span class="line">	elemtype *_type <span class="comment">// element type</span></span><br><span class="line">	sendx    <span class="keyword">uint</span>   <span class="comment">// send index</span></span><br><span class="line">	recvx    <span class="keyword">uint</span>   <span class="comment">// receive index</span></span><br><span class="line">	recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">	sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">	<span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Do not change another G's status while holding this lock</span></span><br><span class="line">	<span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">	<span class="comment">// with stack shrinking.</span></span><br><span class="line">	lock mutex</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<a id="more"></a>



<p>上面提到了CSP，这里进行一些补充：CSP 是 <strong>Communicating Sequential Process</strong> 的简称，中文可以叫做<strong>通信顺序进程</strong>，是一种并发编程模型，由 <a href="https://en.wikipedia.org/wiki/Tony_Hoare" target="_blank" rel="noopener">Tony Hoare</a> 于 1977 年提出。简单来说，<strong>CSP 模型由并发执行的实体（线程或者进程）所组成，实体之间通过发送消息进行通信</strong>，这里发送消息时使用的就是通道，或者叫 channel。CSP 模型的关键是关注 channel，而不关注发送消息的实体。Go 语言实现了 CSP 部分理论，goroutine 对应 CSP 中并发执行的实体，channel 也就对应着 CSP 中的 channel。</p>
<hr>
<h1 id="2-如何实现Channels？"><a href="#2-如何实现Channels？" class="headerlink" title="2.如何实现Channels？"></a>2.如何实现Channels？</h1><h2 id="2-1-基本实现及操作"><a href="#2-1-基本实现及操作" class="headerlink" title="2.1 基本实现及操作"></a>2.1 基本实现及操作</h2><p>详细来说，Channel 类型的格式如下：<code>var 变量 chan 元素类型</code>，具体举例如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ch1 <span class="keyword">chan</span> <span class="keyword">int</span>   <span class="comment">// 声明一个传递整型的通道</span></span><br><span class="line"><span class="keyword">var</span> ch2 <span class="keyword">chan</span> <span class="keyword">bool</span>  <span class="comment">// 声明一个传递布尔型的通道</span></span><br><span class="line"><span class="keyword">var</span> ch3 <span class="keyword">chan</span> []<span class="keyword">int</span> <span class="comment">// 声明一个传递int切片的通道</span></span><br></pre></td></tr></tbody></table></figure>
<p>如果仅仅进行Channel 创建：<code>var ch chan int</code>，而没有进行使用make函数初始化，打印输出会发现为nil：<code>fmt.Println(ch) // &lt;nil&gt;</code>，而且！<strong>在一个<code>nil</code>的channel上发送和接收操作会被永久阻塞</strong>，可以看看下面的代码结果会怎样？</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {  </span><br><span class="line">    <span class="comment">// 没有进行make函数初始化，该ch为nil</span></span><br><span class="line">    <span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ {</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="keyword">int</span>)</span></span> {</span><br><span class="line">            ch &lt;- (idx + <span class="number">1</span>) * <span class="number">2</span></span><br><span class="line">        }(i)</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 得到第一个结果</span></span><br><span class="line">    fmt.Println(<span class="string">"result:"</span>,&lt;-ch)</span><br><span class="line">    <span class="comment">// 休眠</span></span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>面这段代码能够通过编译，但是执行的时候会发现runtime错误：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br></pre></td></tr></tbody></table></figure>

<p>我们可以通过使用内置的make函数创建一个Channel ：<code>ch := make(chan int)</code>，创建Channel 的格式：<code>make(chan 元素类型, [缓存大小])</code>，具体举例如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">ch4 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">ch5 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">ch6 := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="keyword">int</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>很简单就可以实现一个Channel，需要注意的是经过上面的make创建了之后的Channel对应的<u>是make底层数据结构的一个引用</u>，意思就是当复制一个Channel 或者 将Channel 用于参数传递的时候，仅仅只是复制了一个Channel 的引用而已！此时调用者何被调用者将引用同一个Channel 对象。</p>
<p>既然是对象，那么Channel 也是可以使用<code>==</code>运算符进行比较了，但是注意的是<u>相同类型才可以进行比较</u>，简单验证如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"></span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="comment">//ch3 := make(chan string)</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(ch1 == ch2)	<span class="comment">// 可以比较，但是比较结果为false</span></span><br><span class="line">	<span class="comment">//fmt.Println(ch1 == ch3) // 不可以比较，错误为：invalid operation: ch1 == ch3 (mismatched types chan int and chan string)</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>一个Channel 有发送、接收及关闭等简单操作，如果浏览源码，时不时的会发现这么一个符号：<code>&lt;-</code>，简直不要太有代表性，这玩意就是Channel 的使用！而且发送和接收两个操作都是用<code>&lt;-</code>运算符。具体如下：</p>
<p><u>在发送语句中，<code>&lt;-</code>运算符分割channel和要发送的值</u>。比如：<code>ch &lt;- x</code>，我们将x发送到通道ch之中。</p>
<p><u>在接收语句中，<code>&lt;-</code>运算符写在channel对象之前</u>。比如：<code>x = &lt;-ch</code> </p>
<ul>
<li>当然一个不使用接收结果的接收操作也是合法的。比如：<code>&lt;-ch</code></li>
</ul>
<p><u>当然我们可以关闭一个通道，使用close就可以了</u>：<code>close(ch)</code></p>
<ul>
<li><p>需要注意的是，我们要对close的使用进行比较好的处理，如果还有数据没发送完或者没有数据没有接收完，我们直接close，是不是不是很妥？而且Golang并没有办法直接测试一个Channels是否被关闭，但是接收操作有一个<strong>变体形式</strong>：它多接收一个结果，多接收的第二个结果是一个布尔值ok，<u>ture表示成功从channels接收到值，false表示channels已经被关闭并且里面没有值可接收</u>。</p>
</li>
<li><p>示例如下：</p>
<ul>
<li><pre class=" language-go">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number"><code class="language-go">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)
<span class="comment">// ok-idiom </span>
val, ok := <-ch
<span class="keyword">if</span> ok == <span class="literal">false</span> {
   <span class="comment">// channel closed</span>
   <span class="built_in">close</span>(ch)
}
<!--￼<span class="number">6</span>-->
</code></pre>
</li>
</ul>
</li>
</ul>
<p>结果如下：</p>
<p><img src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200822142805.png" alt="向已经关闭的Channel继续发送数据"></p>
<p>这里给出一个简单的解决方案，我们需要确保应用不会向关闭的channel中发送数据：通过使用一个特殊的废弃的channel来向剩余的worker发送不再需要它们的结果的信号来修复。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{})</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ {</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="keyword">int</span>)</span></span> {</span><br><span class="line">			<span class="keyword">select</span> {</span><br><span class="line">			<span class="keyword">case</span> ch &lt;- (idx + <span class="number">1</span>) * <span class="number">2</span>:</span><br><span class="line">				fmt.Println(idx,<span class="string">"sent result"</span>)</span><br><span class="line">			<span class="keyword">case</span> &lt;- done:</span><br><span class="line">				fmt.Println(idx,<span class="string">"exiting"</span>)</span><br><span class="line">			}</span><br><span class="line">		}(i)</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// 取得通道Channels的首个结果</span></span><br><span class="line">	fmt.Println(<span class="string">"result:"</span>,&lt;-ch)</span><br><span class="line">	<span class="comment">// 关闭特殊Channel通道done</span></span><br><span class="line">	<span class="built_in">close</span>(done)</span><br><span class="line">	<span class="comment">// 等待三秒</span></span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>于是我们便掌握了简单的发送、接受及关闭，难道Channel 就这？这么简单就都搞定了？其实不然，还挺复杂，继续往下。</p>
<h2 id="2-2-不带缓存的Channels"><a href="#2-2-不带缓存的Channels" class="headerlink" title="2.2 不带缓存的Channels"></a>2.2 不带缓存的Channels</h2><p>无缓存的通道又称为<strong>阻塞的通道</strong>，通常我们使用不带缓存的Channels来做同步操作，所以无缓存Channels有时候也被称为<strong>同步Channels。</strong></p>
<p>其中同步Channel 不需要携带额外的信息，它仅仅是用作两个goroutine之间的同步，我们还可以使用<code>struct{}</code>空结构体作为channels元素的类型（这里也是为什么之前看到很多<code>struct{}</code>懵逼的原因了），虽然也可以使用bool或int类型实现同样的功能，<code>done &lt;- 1</code>语句也比<code>done &lt;- struct{}{}</code>更短。</p>
<p>具体如何进行阻塞呢？</p>
<ul>
<li>一个基于无缓存Channels的发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相同的Channels上执行接收操作，当发送的值通过Channels成功传输之后，两个goroutine可以继续执行后面的语句。</li>
<li>如果接收操作先发生，那么接收者goroutine也将阻塞，直到有另一个goroutine在相同的Channels上执行发送操作。</li>
</ul>
<p>这里的同步操作则引出了一个Golang并发内存模型的关键术语：Happens Before！具体如何体现？</p>
<p>比如<strong>无缓存的Channel上的发送操作总在对应的接收操作完成前 发生。</strong></p>
<p>具体案例如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"><span class="keyword">var</span> msg <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">// 对msg进行写入</span></span><br><span class="line">	msg = <span class="string">"Hello World！"</span></span><br><span class="line">	<span class="comment">// 发送同步信号</span></span><br><span class="line">	done &lt;- <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">go</span> send()</span><br><span class="line">	<span class="comment">// 接收同步信号</span></span><br><span class="line">	&lt;-done</span><br><span class="line">	<span class="built_in">println</span>(msg)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>怎么体现？体现在：<u>可保证打印出”Hello World！”</u>，原因记载上面了！结合例子思考一下。</p>
<p>具体流程为：该程序首先对<code>msg</code>进行写入，然后在<code>done</code>管道上发送同步信号，随后从<code>done</code>接收对应的同步信号，最后执行<code>println</code>函数。</p>
<p>还有<strong>对于从无缓存Channel进行的接收，发生在对该Channel进行的发送<u>完成</u> 之前。</strong></p>
<p>具体案例如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"><span class="keyword">var</span> msg <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">// 对msg进行写入</span></span><br><span class="line">	msg = <span class="string">"Hello World！"</span></span><br><span class="line">	<span class="comment">// 接收同步信号</span></span><br><span class="line">	&lt;-done</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">go</span> recv()</span><br><span class="line">	<span class="comment">// 发送同步信号</span></span><br><span class="line">	done &lt;- <span class="literal">true</span></span><br><span class="line">	<span class="built_in">println</span>(msg)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>怎么体现？体现在：<u>也可保证打印出”Hello World！”</u>。因为<code>main</code>线程中<code>done &lt;- true</code>发送完成前，后台线程<code>&lt;-done</code>接收已经开始，这保证<code>msg = "Hello World！</code>被执行了，所以之后<code>println(msg)</code>的msg已经被赋值过了。具体流程为：后台线程首先对<code>msg</code>进行写入，然后从<code>done</code>中接收信号，随后<code>main</code>线程向<code>done</code>发送对应的信号，最后执行<code>println</code>函数完成。</p>
<p>对于带缓冲的Channel也自然有Happens Before：<strong>对于Channel的第<code>K</code>个接收完成操作发生在第<code>K+C</code>个发送操作完成之前，其中<code>C</code>是Channel的缓存大小。</strong> 如果将<code>C</code>设置为0自然就对应无缓存的Channel，也即使第K个接收完成在第K个发送完成之前。因为无缓存的Channel只能同步发1个，也就简化为前面无缓存Channel的规则：<strong>对于从无缓冲Channel进行的接收，发生在对该Channel进行的发送完成之前。</strong></p>
<p>如果用反向思维来辩证一下的话，要是没有这条Happens Before的话，是不是<code>done &lt;- true</code>发送了之后就瞬间直接打印”Hello World！了，而运行的结果并不是，我们在接收同步信号之前进行一个睡眠延时，发现打印”Hello World！也需要等待这个睡眠延时的时间，原因就是对无缓存Channel的接收发生在对该Chennel进行的发送完成之前：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"><span class="keyword">var</span> msg <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">// 对msg进行写入</span></span><br><span class="line">	msg = <span class="string">"Hello World！"</span></span><br><span class="line">	<span class="comment">// 等待三秒</span></span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">	<span class="comment">// 接收同步信号</span></span><br><span class="line">	&lt;-done</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">go</span> recv()</span><br><span class="line">	<span class="comment">// 发送同步信号</span></span><br><span class="line">	done &lt;- <span class="literal">true</span></span><br><span class="line">	<span class="built_in">println</span>(msg)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里看到了一幅很具体的图展示了什么叫无缓存的Channel：</p>
<p><img src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200822000155.png" alt="不带缓存的Channels"></p>
<p>需要注意的是<u>无缓存的Channel 必须再有人接收值的时候才能发送值，否则会产生deallock</u>，代码如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="comment">// 只有发送，并没有接收！</span></span><br><span class="line">    ch &lt;- <span class="number">10</span></span><br><span class="line">    fmt.Println(<span class="string">"发送成功"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行之后发生错误：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br></pre></td></tr></tbody></table></figure>

<p>上面的代码会阻塞在ch &lt;- 10这一行代码形成死锁，那如何解决这个问题呢？</p>
<p>可以启用一个goroutine去接收值，例如：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">	ret := &lt;-c</span><br><span class="line">	fmt.Println(<span class="string">"接收成功"</span>, ret)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> recv(ch) <span class="comment">// 启用goroutine从通道接收值</span></span><br><span class="line">	ch &lt;- <span class="number">10</span></span><br><span class="line">	fmt.Println(<span class="string">"发送成功"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>还有一个需要注意的地方，也是我一直在怀疑的地方，<u>如果我同时向通道进行数据发送和数据接收，会不会速度太快导致接收方不够时间在发送者继续执行发送前处理数据</u>？进行验证一下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">		<span class="keyword">for</span> m := <span class="keyword">range</span> ch {</span><br><span class="line">			fmt.Println(<span class="string">"processed:"</span>,m)</span><br><span class="line">		}</span><br><span class="line">	}()</span><br><span class="line">	ch &lt;- <span class="string">"First"</span></span><br><span class="line">	ch &lt;- <span class="string">"Second"</span> <span class="comment">// 这段有可能不被处理</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>进行了多次的测试之后发现有时候”Second”会被处理到，有时候并不会！所以对这里数据处理要注意一下，主要原因是<u>上述代码处理过程中发送方不会被阻塞，除非发送的消息正在被接收方处理这样才会进行阻塞</u>，所以我们的同步操作不可像上面那样编写！</p>
<h2 id="2-3-带缓存的Channels"><a href="#2-3-带缓存的Channels" class="headerlink" title="2.3 带缓存的Channels"></a>2.3 带缓存的Channels</h2><p>我们可以在使用make函数初始化通道的时候为其指定通道的容量，带缓存的Channel内部持有一个元素队列。队列的最大容量是在调用make函数创建channel时通过第二个参数指定的。例如：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">3</span>) <span class="comment">// 创建一个容量为3的有缓冲区通道</span></span><br><span class="line">	ch &lt;- <span class="string">"A"</span></span><br><span class="line">	fmt.Println(<span class="string">"发送成功"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>向缓存Channel的发送操作就是向内部缓存队列的尾部插入元素，接收操作则是从队列的头部删除元素。</p>
<p>而带缓存的Channels 与阻塞的联系则如下：</p>
<ul>
<li>如果内部缓存队列是满的，那么发送操作将阻塞直到因另一个goroutine执行接收操作而释放了新的队列空间。</li>
<li>相反，如果channel是空的，接收操作将阻塞直到有另一个goroutine执行发送操作而向队列插入元素。</li>
<li>那么channel的缓存队列将不是满的也不是空的，因此对该channel执行的发送或接收操作都不会发送阻塞。通过这种方式，channel的缓存队列解耦了接收和发送的goroutine。</li>
</ul>
<p>细心的你想必发现了，为啥上面的代码不像前面的不带缓存的Channel一样报错deadlock？这里联系上下文讲一下我个人的理解，在不带缓存的Channels中就好比快递员送快递，而你的小区没有快递柜和菜鸟驿站啥的，那么他就必须要把这个快递直接送到你手中了，但是根本都没有这个收货人则怎么发出去货物呢？所以则报错了！而在带缓存的Channels中，你有很多个快递柜，你可以将货物暂存在这里，别人拿不拿是别人的事，反正有目的地即可（如果理解错误请纠正我）。</p>
<p>在某些特殊情况下，程序可能需要知道channel内部缓存的容量，可以用内置的cap函数获取：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    ch &lt;- <span class="string">"A"</span></span><br><span class="line">    ch &lt;- <span class="string">"B"</span></span><br><span class="line">    ch &lt;- <span class="string">"C"</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="built_in">cap</span>(ch)) <span class="comment">// "3"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>同样，对于内置的len函数，如果传入的是channel，那么将返回channel内部缓存队列中有效元素的个数。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">fmt.Println(<span class="built_in">len</span>(ch)) <span class="comment">// "3"</span></span><br></pre></td></tr></tbody></table></figure>

<p>还有一点需要注意的是，如果Channel为带缓存的，即使我们将其缓存设置为1，也不会进行像前面无缓存那样的阻塞，<code>main</code>线程的<code>done &lt;- true</code>接收操作将不会被后台线程的<code>&lt;-done</code>接收操作阻塞，该程序将无法保证打印出”Hello World！”。如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将其变为有缓存的Chan</span></span><br><span class="line"><span class="keyword">var</span> done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">var</span> msg <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">// 对msg进行写入</span></span><br><span class="line">	msg = <span class="string">"Hello World！"</span></span><br><span class="line">	<span class="comment">// 等待三秒</span></span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">	<span class="comment">// 接收同步信号</span></span><br><span class="line">	&lt;-done</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">go</span> recv()</span><br><span class="line">	<span class="comment">// 发送同步信号</span></span><br><span class="line">	done &lt;- <span class="literal">true</span></span><br><span class="line">	<span class="built_in">println</span>(msg)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>你会发现，这个 “Hello World！”永远也打印不出来！</p>
<p>同样参考如下图所示：</p>
<p><img src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200822000228.png" alt="带缓存的Channels"></p>
<h2 id="2-4-单向的Channels"><a href="#2-4-单向的Channels" class="headerlink" title="2.4 单向的Channels"></a>2.4 单向的Channels</h2><p>单向 Channel，既只能读或者只能进行写的Channel。对比普通的Channel：<code>chan int</code>，其详细类型如下：</p>
<ul>
<li><u><code>chan&lt;- int</code>表示一个只发送int的channel</u>，只能发送不能接收。</li>
<li><u><code>&lt;-chan int</code>表示一个只接收int的channel</u>，只能接收不能发送。</li>
</ul>
<blockquote>
<p>注意：箭头<code>&lt;-</code>和关键字chan的相对位置表明了channel的方向。这种限制将在编译期检测。</p>
</blockquote>
<p><strong>任何双向channel向单向channel变量的赋值操作都将导致该channel进行隐式转换</strong>。这里并没有反向转换的语法：也就是不能一个将类似<code>chan&lt;- int</code>类型的单向型的channel转换为<code>chan int</code>类型的双向型的channel。案例如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// counter ：进行计数，传入一个只读的chan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> {</span><br><span class="line">	<span class="keyword">for</span> x := <span class="number">0</span>; x &lt; <span class="number">100</span>; x++ {</span><br><span class="line">		out &lt;- x</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">close</span>(out)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// squarer ：进行平方计算,out是只写chan，in是只读chan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squarer</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> in {</span><br><span class="line">		out &lt;- v * v</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">close</span>(out)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// printer ：进行打印输出，in是只读chan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> in {</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	naturals := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	squares := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> counter(naturals)</span><br><span class="line">	<span class="keyword">go</span> squarer(squares, naturals)</span><br><span class="line">	printer(squares)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>调用counter(naturals)将导致将<code>chan int</code>类型的naturals隐式地转换为<code>chan&lt;- int</code>类型只发送型的channel。调用printer(squares)也会导致相似的隐式转换，这一次是转换为<code>&lt;-chan int</code>类型只接收型的channel。</p>
<p>总的来说，单向 channel 主要用在<u>函数声明</u>中，有的时候我们会将通道作为参数在多个任务函数间传递，很多时候我们在不同的任务函数中使用通道都会对其进行限制，比如限制通道在函数中只能发送或只能接收。比如：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> {...}</span><br></pre></td></tr></tbody></table></figure>

<p><u>foo 的形参是一个只能写的 channel</u>，那么就表示函数 foo 只会对 ch 进行写，当然你传入的参数可以是个普通 channel。<u>foo 的返回值是一个只能读的 channel</u>，那么表示 foo 的返回值规范用法就是只能读取。</p>
<p>使用单向 channel 编程体现了一种非常优秀的编程范式：<strong>convention over configuration</strong>，中文一般叫做 <strong>约定优于配置</strong>。</p>
<p>还有需要注意的一点是因为关闭操作只用于断言不再向channel发送新的数据，所以只有在发送者所在的goroutine才会调用close函数，<strong>因此对一个只接收的channel调用close将是一个编译错误</strong>。</p>
<hr>
<h1 id="3-Channels有缓存和无缓存的区别是什么？"><a href="#3-Channels有缓存和无缓存的区别是什么？" class="headerlink" title="3.Channels有缓存和无缓存的区别是什么？"></a>3.Channels有缓存和无缓存的区别是什么？</h1><p>简单来说：</p>
<ul>
<li>无缓存的管道，<strong>只要没有协程写入就读出阻塞，没有协程读出，就造成写入阻塞</strong>；</li>
<li>有缓存的管道，即使没人写入，也能读出若干默认值，即使没人读出，也能写入若干值；</li>
</ul>
<p><strong>关于无缓存或带缓存channels之间的选择</strong></p>
<ul>
<li><strong>关于无缓存或带缓存channels之间的选择，或者是带缓存channels的容量大小的选择，都可能影响程序的正确性</strong>。<ul>
<li>无缓存channel更强地保证了每个发送操作与相应的同步接收操作；</li>
<li>但是对于带缓存channel，这些操作是解耦的。</li>
</ul>
</li>
<li>即使我们知道将要发送到一个channel的信息的数量上限，创建一个对应容量大小的带缓存channel也是不现实的，因为<u>这要求在执行任何接收操作之前缓存所有已经发送的值</u>。如果未能分配足够的缓存将导致程序死锁。</li>
<li><strong>Channel的缓存也可能影响程序的性能</strong>。想象一家蛋糕店有三个厨师，一个烘焙，一个上糖衣，还有一个将每个蛋糕传递到它下一个厨师的生产线。在狭小的厨房空间环境，每个厨师在完成蛋糕后必须等待下一个厨师已经准备好接受它；这类似于在一个无缓存的channel上进行沟通。</li>
<li>如果在每个厨师之间有一个放置一个蛋糕的额外空间，那么每个厨师就可以将一个完成的蛋糕临时放在那里而马上进入下一个蛋糕的制作中；这类似于将channel的缓存队列的容量设置为1。只要每个厨师的平均工作效率相近，那么其中大部分的传输工作将是迅速的，个体之间细小的效率差异将在交接过程中弥补。如果厨师之间有更大的额外空间——也是就更大容量的缓存队列——将可以在不停止生产线的前提下消除更大的效率波动，例如一个厨师可以短暂地休息，然后再加快赶上进度而不影响其他人。</li>
<li>另一方面，如果生产线的前期阶段一直快于后续阶段，那么它们之间的缓存在大部分时间都将是满的。<u>相反，如果后续阶段比前期阶段更快，那么它们之间的缓存在大部分时间都将是空的。对于这类场景，额外的缓存并没有带来任何好处</u>。</li>
<li>生产线的隐喻对于理解channels和goroutines的工作机制是很有帮助的。例如，如果第二阶段是需要精心制作的复杂操作，一个厨师可能无法跟上第一个厨师的进度，或者是无法满足第三阶段厨师的需求。要解决这个问题，我们可以再雇佣另一个厨师来帮助完成第二阶段的工作，他执行相同的任务但是独立工作。这类似于基于相同的channels创建另一个独立的goroutine。</li>
</ul>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="http://topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/channel.html" target="_blank" rel="noopener">Go语言中文文档-Channel</a></li>
<li><a href="http://legendtkl.com/2017/07/30/understanding-golang-channel/" target="_blank" rel="noopener">深入理解 Go Channel</a></li>
<li><a href="https://www.kancloud.cn/lbb4511/gopl/1107899" target="_blank" rel="noopener">第八章 Goroutines和Channels</a></li>
<li><a href="https://colobu.com/2015/09/07/gotchas-and-common-mistakes-in-go-golang/#%E5%90%91%E6%97%A0%E7%BC%93%E5%AD%98%E7%9A%84Channel%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%EF%BC%8C%E5%8F%AA%E8%A6%81%E7%9B%AE%E6%A0%87%E6%8E%A5%E6%94%B6%E8%80%85%E5%87%86%E5%A4%87%E5%A5%BD%E5%B0%B1%E4%BC%9A%E7%AB%8B%E5%8D%B3%E8%BF%94%E5%9B%9E" target="_blank" rel="noopener">Go的50度灰：Golang新开发者要注意的陷阱和常见错误</a></li>
<li><a href="https://chai2010.cn/advanced-go-programming-book/ch1-basic/ch1-05-mem.html" target="_blank" rel="noopener">面向并发的内存模型</a></li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>golang 基础 - go的命令源码文件</title>
    <url>/2020/05/15/golang-ji-chu-go-de-ming-ling-yuan-ma-wen-jian/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-命令源码文件"><a href="#1-命令源码文件" class="headerlink" title="1.命令源码文件"></a>1.命令源码文件</h1><p><strong>命令源码文件是程序的运行入口，是每个可独立运行的程序必须拥有的</strong>。我们可以通过构建或安装，生成与其对应的可执行文件，后者一般会与该命令源码文件的直接父目录同名。</p>
<p><strong>如果一个源码文件声明属于main包，并且包含一个无参数声明且无结果声明的main函数，那么它就是命令源码文件</strong>。 就像下面这段代码：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">  fmt.Println(<span class="string">"Hello, world!"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这其实就是就简单的可以运行go的一个文件了，刚开始搭建的时候我也是使用这么一段测试代码，随便创建了一个文件之后，然后敲上这么一段代码之后发现控制台可以打印出来“Hello World!”，瞬间感觉就学会了这门语言了，可是事情并没有那么简单，有多难？很难很难。</p>
<p>但是这里让我挺困惑的地方就是，<strong>这<code>func main()</code>，没有接收参数入口啊？？？</strong>难道我就只能进行打印了？这不科学，无论在C/C++，还是Java中，main方法都不是这么写的，那么问题就来了，如果进行接收参数呢？</p>
<a id="more"></a>



<h2 id="1-1-命令源码文件进行传参"><a href="#1-1-命令源码文件进行传参" class="headerlink" title="1.1 命令源码文件进行传参"></a>1.1 命令源码文件进行传参</h2><p>于是我们这一部分的主角就要登场了，没错，他就是：<code>flag</code></p>
<p><strong><code>flag</code> 是一个包，是Go 语言标准库中有一个代码包专门用于接收和解析命令参数。</strong></p>
<blockquote>
<p>对于flag包，详细可以查看官方文档：<a href="https://golang.google.cn/pkg/flag/" target="_blank" rel="noopener">Package flag</a></p>
</blockquote>
<p>首先要使用一个包，必须先要导入这个包，当然是用我们的import 方法了，而且fmt这个包我们是必须要import的，这样一来我们需要import两个包了：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"flag"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>

<p>那我们我们需要传入一串字符串，比如我们想要拿某样东西，<code>I want to take “xxx”</code>，我们可以定义一个Sring类型的变量name：<code>var name string</code>来表示我们需要拿到的东西，这样的话，我想传入一个字符串，那么我该如何才能达到目的呢？通过查阅文档，我们发现flag提供了一个绝妙的方法，就是<code>flag.StringVar</code></p>
<p>他是这么定义的：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StringVar</span><span class="params">(p *<span class="keyword">string</span>, name <span class="keyword">string</span>, value <span class="keyword">string</span>, usage <span class="keyword">string</span>)</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>StringVar定义了一个有指定名字，默认值，和用法说明的string标签。 参数p指向一个存储标签解析值的string变量。</p>
<p>这四个参数的详解如下：</p>
<ol>
<li>参数1：是用于<u>存储该命令参数值的地址</u></li>
<li>参数2：是为了指定该命令参数的名称</li>
<li>参数3：是为了指定在未追加该命令参数时的默认值</li>
<li>函数参数4：即是该命令参数的简短说明了</li>
</ol>
<p>那我们就可以这么写了：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">flag.StringVar(&amp;name, <span class="string">"name"</span>, <span class="string">"momey"</span>, <span class="string">"The greeting object."</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>大概意思就是去取name这个变量，传入我们需要的参数”momey”，就可以达到我们传参的目的了。</p>
<p>我们发现还有一个类似<code>flag.StringVar</code>的函数：<code>flag.String</code>，这两个函数的区别是，<strong>后者会直接返回一个已经分配好的用于存储命令参数值的地址。</strong>这里暂不展开讲解，记住我们的任务，传参传参传参！</p>
<p>那么经过使用上面的<code>flag.StringVal()</code>，我们就可以达到目的了吗？</p>
<p>当然还没有，我们这里还需要一个解析函数，<strong>函数<code>flag.Parse</code>用于真正解析命令参数，并把它们的值赋给相应的变量</strong>。</p>
<p>对该函数<code>flag.Parse()</code>的调用必须<u>在所有命令参数存储载体的声明（对变量name的声明）和设置（对flag.StringVar函数的调用）之后，并且在读取任何命令参数值之前进行</u>。</p>
<p>所以我们最好就将<code>flag.Parse()</code>放在main函数的函数体的第一行。</p>
<p>则我们需要完成的代码框架如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"flag"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> {</span><br><span class="line">    flag.StringVar(&amp;name, <span class="string">"name"</span>, <span class="string">"momey"</span>, <span class="string">"The greeting object."</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    flag.Parse()</span><br><span class="line">    fmt.Printf(<span class="string">"I want to take %s! \n"</span>, name) <span class="comment">// 有没有发现跟SQL传参有些类似</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出如下：</p>
<p><img src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200515164632.png" alt="使用StringVar输出"></p>
<p>总的来说我们的小目标算是完成了！</p>
<hr>
<h2 id="1-2-如何查看参数说明"><a href="#1-2-如何查看参数说明" class="headerlink" title="1.2 如何查看参数说明"></a>1.2 如何查看参数说明</h2><p>我们使用Cmder工具进行命令行处理上面编写的demo，看能否得到详细的命令源码文件参数说明</p>
<p>我们运行demo：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> run demo2.<span class="keyword">go</span> -name=<span class="string">"some money"</span></span><br></pre></td></tr></tbody></table></figure>

<p>发现能够打印输出，完成了传参功能，这并没有什么问题。</p>
<p><img src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200515173222.png" alt="运行命令输出如上"></p>
<p>但是我们想看更加详细的内容呢？可以使用如下命令：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> run demo2.<span class="keyword">go</span> --help</span><br></pre></td></tr></tbody></table></figure>

<p>发现这次有所不一样了，我们发现了挺多细节，比如：<code>"-name string"</code>，这个name是string类型的，其默认是：”money”</p>
<p><img src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200515173129.png" alt="可以查看到详细参数"></p>
<p>这里可能会发现：<code>Usage of C:\Users\dongxiem\AppData\Local\Temp\go-build807196986\b001\exe\demo2.exe:</code>这么长一串？其实这个只是<code>go run</code>命令构建上述命令源码文件时临时生成的可执行文件的完整路径。</p>
<hr>
<h2 id="1-3-自定义命令源码文件的参数使用说明"><a href="#1-3-自定义命令源码文件的参数使用说明" class="headerlink" title="1.3 自定义命令源码文件的参数使用说明"></a>1.3 自定义命令源码文件的参数使用说明</h2><p>这个里面的内容还有些复杂，上面我们得到这么一串<code>Usage of C:\Users\dongxiem\AppData\Local\Temp\go-build807196986\b001\exe\demo2.exe:</code>的打印输出，看起来还挺复杂的，那么如果我不想要这么复杂可以吗？我只想简简单单，让我能够了解内容就行了。那当然是可以的，而且办法还不只有一种。</p>
<h3 id="第一种方法：重新赋值变量flag-Usage"><a href="#第一种方法：重新赋值变量flag-Usage" class="headerlink" title="第一种方法：重新赋值变量flag.Usage"></a>第一种方法：重新赋值变量flag.Usage</h3><p><code>flag.Usage</code>的类型是<code>func()</code>，即一种无参数声明且无结果声明的函数类型。</p>
<blockquote>
<p>注意，对flag.Usage的赋值必须在调用flag.Parse函数之前！</p>
</blockquote>
<p>我们修改Demo代码为：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"flag"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> {</span><br><span class="line">    flag.StringVar(&amp;name, <span class="string">"name"</span>, <span class="string">"momey"</span>, <span class="string">"The greeting object."</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    flag.Usage = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        fmt.Fprintf(os.Stderr, <span class="string">"Usage of %s : \n"</span>, <span class="string">"Dongxiem"</span>)</span><br><span class="line">        flag.PrintDefaults()</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    flag.Parse()</span><br><span class="line">    fmt.Printf(<span class="string">"I want to take %s! \n"</span>, name)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行之后查看输出如下：</p>
<p><img src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200515173012.png" alt="修改之后运行如上"></p>
<h3 id="第二种方式：调用flag-CommandLine变量"><a href="#第二种方式：调用flag-CommandLine变量" class="headerlink" title="第二种方式：调用flag.CommandLine变量"></a>第二种方式：调用flag.CommandLine变量</h3><p>其实我们在调用flag包中的一些函数（比如StringVar、Parse等等）的时候，实际上是在调用<code>flag.CommandLine</code>变量的对应方法。所以我们也可以直接对<code>flag.CommandLine</code>进行操作，这也不是不可以的！</p>
<blockquote>
<p><code>flag.CommandLine</code>相当于默认情况下的命令参数容器。所以，通过对<code>flag.CommandLine</code>重新赋值，我们可以更深层次地定制当前命令源码文件的参数使用说明。</p>
</blockquote>
<p>于是我们继续修改测试代码：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"flag"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">// 使用flag.CommandLine 修改go run demo.go --help 打印输出</span></span><br><span class="line">    flag.CommandLine = flag.NewFlagSet(<span class="string">""</span>, flag.ExitOnError)</span><br><span class="line">    flag.CommandLine.Usage = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        fmt.Fprintf(os.Stderr, <span class="string">"Usage of %s:\n"</span>, <span class="string">"Dongxiem"</span>)</span><br><span class="line">        flag.PrintDefaults()</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    flag.StringVar(&amp;name, <span class="string">"name"</span>, <span class="string">"momey"</span>, <span class="string">"The greeting object."</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    flag.Parse()</span><br><span class="line">    fmt.Printf(<span class="string">"I want to take %s! \n"</span>, name) </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行以上Demo，打印输出如下：</p>
<p><img src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200515174542.png" alt="使用flag.CommandLine进行修改"></p>
<p>发现和第一种方法打印输出的东西是一样的，看起来起到了同样的效果了！</p>
<p>但是，如果我们使用<code>flag.CommandLine = flag.NewFlagSet("", flag.PanicOnError)</code>替换上面Demo中的<code>flag.CommandLine = flag.NewFlagSet("", flag.ExitOnError)</code>，我们会发现，似乎有了一些不一样的东西了，这是怎么回事？</p>
<p><img src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200515175003.png" alt="替换之后进行运行"></p>
<p>首先，<code>flag.PanicOnError</code>和<code>flag.ExitOnError</code>都是预定义在flag包中的常量。</p>
<ul>
<li><code>flag.ExitOnError</code>的含义是，告诉命令参数容器，当命令后跟–help或者参数设置的不正确的时候，在打印命令参数使用说明后以状态码2结束当前程序。状态码2代表用户错误地使用了命令</li>
<li><code>flag.PanicOnError</code>与之的区别是在最后抛出“运行时恐慌（panic）”。</li>
</ul>
<p>上述两种情况都会在我们调用<code>flag.Parse</code>函数时被触发。顺便提一句，“运行时恐慌”是 Go 程序错误处理方面的概念。</p>
<h3 id="第三种-创建一个私有的命令参数容器"><a href="#第三种-创建一个私有的命令参数容器" class="headerlink" title="第三种 创建一个私有的命令参数容器"></a>第三种 创建一个私有的命令参数容器</h3><p>我们可以不用全局的<code>flag.CommandLine</code>变量，转而自己创建一个私有的命令参数容器。我们在函数外再添加一个变量声明：<code>var cmdLine = flag.NewFlagSet("Dongxiem", flag.ExitOnError)</code></p>
<p>然后，我们把对<code>flag.StringVar</code>的调用替换为对<code>cmdLine.StringVar</code>调用，再把<code>flag.Parse()</code>替换为<code>cmdLine.Parse(os.Args[1:])</code></p>
<blockquote>
<p><code>os.Args[1:]</code>指的就是我们给定的那些命令参数。这样做就完全脱离了<code>flag.CommandLine</code>。</p>
</blockquote>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"flag"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cmdLine = flag.NewFlagSet(<span class="string">"Dongxiem"</span>, flag.ExitOnError)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> {</span><br><span class="line"></span><br><span class="line">    cmdLine.StringVar(&amp;name, <span class="string">"name"</span>, <span class="string">"some money"</span>, <span class="string">"The greeting object."</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    cmdLine.Parse(os.Args[<span class="number">1</span>:])</span><br><span class="line">    fmt.Printf(<span class="string">"I want to take %s! \n"</span>, name)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后我们发现运行之后的打印如下：</p>
<p><img src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200515180815.png" alt="还是一样起到作用"></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>golang 基础 - go的环境变量</title>
    <url>/2020/05/15/golang-ji-chu-go-de-huan-jing-bian-liang/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-三个环境变量"><a href="#1-三个环境变量" class="headerlink" title="1.三个环境变量"></a>1.三个环境变量</h1><p>刚接触go的时候很头疼，一下子需要我配置三个环境变量，这三个环境变量看起来很让人头疼，感觉起来三个环境变量的意思大致，区分度不高，这三个环境变量也就是 <code>GOROOT</code>、<code>GOPATH</code> 和 <code>GOBIN</code>。这里简单介绍一下。</p>
<ul>
<li>GOROOT：Go 语言安装根目录的路径，也就是 GO 语言的安装路径。</li>
<li>GOPATH：若干工作区目录的路径。是我们自己定义的工作空间。</li>
<li>GOBIN：GO 程序生成的可执行文件（executable file）的路径。</li>
</ul>
<p>其中最让人头疼的就是这个GOROOT，看起来似是而非的感觉，那么GOPATH 有什么意义吗？</p>
<p>这里可以把 GOPATH 简单理解成 Go 语言的工作目录，它的值是一个目录的路径，也可以是多个目录路径，每个目录都代表 Go 语言的一个工作区（workspace）。</p>
<p>我们需要利于这些工作区，去放置 Go 语言的源码文件（source file），以及安装（install）后的归档文件（archive file，也就是以“.a”为扩展名的文件）和可执行文件（executable file）。</p>
<p><strong>这个GOPATH 其实很重要，为什么这么说呢？</strong></p>
<p>因为Go 语言项目在其<u>生命周期内的所有操作（编码、依赖管理、构建、测试、安装等）</u>基本上都是围绕着 GOPATH 和工作区进行的。</p>
<a id="more"></a>



<hr>
<h1 id="2-拓展GOPATH"><a href="#2-拓展GOPATH" class="headerlink" title="2.拓展GOPATH"></a>2.拓展GOPATH</h1><h2 id="2-1-Go如何组织源码"><a href="#2-1-Go如何组织源码" class="headerlink" title="2.1 Go如何组织源码"></a>2.1 Go如何组织源码</h2><p>在编写代码的过程中，我们肯定的是不只有一两个文件，随着项目的不过扩增，肯定文件会越来越多的，这就涉及到如何组织管理这些源码的问题了，在Java中我们使用的是import 包的方式，而包里面还有各种子包，于是就是形成一种了循环嵌套的源码框架了，看起来也简单明了，其实Go语言也是差不多，他也是以代码包为基本组织单位的，而且在文件系统中，这些代码包其实是与目录一一对应的。由于目录可以有子目录，所以代码包也可以有子包。</p>
<p>Go也是一样的使用import方式的，具体方式就是：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"github.com/labstack/echo"</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果需要引用多个文件的话该如何使用呢？</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">    <span class="string">"encoding/binary"</span></span><br><span class="line">    <span class="string">"encoding/gob"</span></span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/recoilme/slowpoke"</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>

<p>这里随便给出一个示例，可以看见如果需要包含多个子包是使用import() 的方式，在工作区中，一个代码包的导入路径实际上就是从 src 子目录，到该包的实际存储位置的相对路径。</p>
<p>这是怎么理解呢？我们可以看看在windows下面的GOPATH的截图：</p>
<p><img src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200515144325.png" alt="GOPATH目录路径"></p>
<p>进入GOPATH中的src目录下可以看见：</p>
<p><img src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200515144412.png" alt="D:\GOPATH\src"></p>
<p>我们再进入github.com，发现如下，这些都是我在浏览Go相关项目下自动导入或者我手动导入的一些github包。</p>
<p><img src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200515144425.png" alt="D:\GOPATH\src\github.com"></p>
<p>大概个源码组织结构如上，让我比较吃惊的是，居然可以直接导入github包中的内容？？？真是前所未见，这样一来速度会快吗？如果网络不好的话，岂不是一直都会编译不过吗？真是各种疑问了，以后再回头看看会不会有新的发现。</p>
<p>在浏览项目的过程中，我发现让我十分心急的一点就是，编译过程中需要导很多github的包，又因为特色的问题，网络速度上不去，有些包还被墙掉（比如：golang.org下面的文件几乎都导不进来），还好golang.org将他们的镜像上传到github上面，可以通过github上面的包下载到本地，再根据路径名进行配置好，这样方可通过。</p>
<p>这样一来，也太麻烦了点，和之前使用C、Java、Python的感觉都完全不一样，这也是让我比较吃惊的一点，居然为了通过一个文件的编译，要手动下载好几个包文件。</p>
<p>总的来说，Go 语言源码的组织方式就是以环境变量 GOPATH、工作区、src 目录和代码包为主线的。一般情况下，Go 语言的源码文件都需要被存放在环境变量 GOPATH 包含的某个工作区（目录）中的 src 目录下的某个代码包（目录）中。</p>
<hr>
<h2 id="2-2-归档文件"><a href="#2-2-归档文件" class="headerlink" title="2.2 归档文件"></a>2.2 归档文件</h2><p>上面的GOPATH路径下，我们已经了解到了，源码文件通常会被放在某个工作区的 src 子目录下。我们注意到除了src，还有另外一个文件夹是pkg，欸，这就有点意思，这个pkg是什么东西？</p>
<p><img src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200515144325.png" alt="GOPATH目录路径"></p>
<p>Go 语言源码在安装后如果产生了归档文件（以“.a”为扩展名的文件），就会放进该工作区的 pkg 子目录；如果产生了可执行文件，就可能会放进该工作区的 bin 子目录。</p>
<blockquote>
<p>归档文件在Linux下就是扩展名是.a的文件，也就是archive文件。写过C程序的朋友都知道，这是程序编译后生成的静态库文件。</p>
</blockquote>
<p>这里讲讲归档文件存放的具体位置和规则。</p>
<p>源码文件会以代码包的形式组织起来，一个代码包其实就对应一个目录。安装某个代码包而产生的归档文件是与这个代码包同名的。</p>
<p>放置它的相对目录就是该代码包的导入路径的直接父级。比如，一个已存在的代码包的导入路径是</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">github.com/dongxiem/xxx</span><br></pre></td></tr></tbody></table></figure>

<p>那么执行命令</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> install github.com/dongxiem/xxx</span><br></pre></td></tr></tbody></table></figure>

<p>这样一来就生成了归档文件，而归档文件的相对目录就是：github.com/dongxiem，其下面的文件名则会有一个：xxx.a</p>
<p>需要注意到的是：归档文件的相对目录与 pkg 目录之间还有一级目录，叫做平台相关目录。</p>
<p>平台相关目录的名称是由 build（也称“构建”）的目标操作系统、下划线和目标计算架构的代号组成的。比如，构建某个代码包时的目标操作系统是 Linux，目标计算架构是 64 位的，那么对应的平台相关目录就是 linux_amd64。</p>
<p>比如我Windows下面的则为：</p>
<p><img src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200515152211.png" alt="D:\GOPATH\pkg"></p>
<p>但是如果构建某个代码包时的目标操作系统是 Linux，目标计算架构是 64 位的，那么对应的平台相关目录就是 linux_amd64。</p>
<p>其大概的目录架构如下：</p>
<p><img src="https://garmen-imgsubmit.oss-cn-shenzhen.aliyuncs.com/img/20200515152331.png" alt="GOPATH目录架构"></p>
<hr>
<h2 id="2-3-Go-程序构建与安装过程"><a href="#2-3-Go-程序构建与安装过程" class="headerlink" title="2.3 Go 程序构建与安装过程"></a>2.3 Go 程序构建与安装过程</h2><p>我们可以将这块的内容用两条命令进行归纳开来，觉得<code>go get</code>还挺重要的，于是也提及到一下。</p>
<h3 id="2-3-1-go-build"><a href="#2-3-1-go-build" class="headerlink" title="2.3.1 go build"></a>2.3.1 go build</h3><p>对于构建，我们会使用<code>go builid</code>命令对程序进行构建，构建过程会执行编译、打包等操作，这些操作生成的任何文静都会先被保存到某个临时目录中。</p>
<p>如果构建的是库源码文件，那么操作后产生的结果文件只会存在于临时目录中。这里的构建的主要意义在于检查和验证。如果构建的是命令源码文件，那么操作的结果文件会被搬运到源码文件所在的目录中。</p>
<p>关于<code>go build</code>，这里需要注意的是：在运行go build命令的时候，<strong>默认不会编译目标代码包所依赖的那些代码包</strong>。当然，如果被依赖的代码包的归档文件不存在，或者源码文件有了变化，那它还是会被编译。</p>
<p>这里注意一下两点：</p>
<ol>
<li>如果需要强制编译，可以在执行命令的时候加入标记-a。此时，不但目标代码包总是会被编译，它依赖的代码包也总会被编译，即使依赖的是标准库中的代码包也是如此。</li>
<li>如果不但要编译依赖的代码包，还要安装它们的归档文件，那么可以加入标记-i</li>
</ol>
<p>那么我们<strong>怎么确定哪些代码包被编译了呢？</strong>有两种方法。</p>
<ol>
<li>运行go build命令时加入标记-x，这样可以看到go build命令具体都执行了哪些操作。另外也可以加入标记-n，这样可以只查看具体操作而不执行它们。</li>
<li>运行go build命令时加入标记-v，这样可以看到go build命令编译的代码包的名称。它在与-a标记搭配使用时很有用。</li>
</ol>
<h3 id="2-3-2-go-install"><a href="#2-3-2-go-install" class="headerlink" title="2.3.2 go install"></a>2.3.2 go install</h3><p>对于安装，我们会使用<code>go install</code>命令进行安装，安装操作会先执行构建，然后还会进行链接操作，并且把结果文件搬运到指定目录。</p>
<p>如果安装的是库源码文件，那么结果文件会被搬运到它所在工作区的 pkg 目录下的某个子目录中。如果安装的是命令源码文件，那么结果文件会被搬运到它所在工作区的 bin 目录中，或者环境变量GOBIN指向的目录中。</p>
<h3 id="2-3-3-go-get"><a href="#2-3-3-go-get" class="headerlink" title="2.3.3 go get"></a>2.3.3 go get</h3><p>关于<code>go get</code>，这里也是插讲一下，因为其余Go 源码的安装关系挺大，命令<code>go get</code>会自动从一些主流公用代码仓库（比如 GitHub）下载目标代码包，并把它们安装到环境变量GOPATH包含的第 1 工作区的相应目录中。如果存在环境变量GOBIN，那么仅包含命令源码文件的代码包会被安装到GOBIN指向的那个目录。</p>
<p>其主要的几个参数如下：</p>
<ul>
<li>-u：下载并安装代码包，不论工作区中是否已存在它们。</li>
<li>-d：只下载代码包，不安装代码包。</li>
<li>-fix：在下载代码包后先运行一个用于根据当前 Go 语言版本修正代码的工具，然后再安装代码包。</li>
<li>-t：同时下载测试所需的代码包。</li>
<li>-insecure：允许通过非安全的网络协议下载和安装代码包。HTTP 就是这样的协议。</li>
</ul>
<p>有时候，我们可能会出于某种目的变更存储源码的代码仓库或者代码包的相对路径。这时，为了让代码包的远程导入路径不受此类变更的影响，我们会使用自定义的代码包导入路径。</p>
<p>对代码包的远程导入路径进行自定义的方法是：<strong>在该代码包中的库源码文件的包声明语句的右边加入导入注释</strong>，像这样：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> semaphore <span class="comment">// import "golang.org/x/sync/semaphore"</span></span><br></pre></td></tr></tbody></table></figure>

<p>有没有很吃惊，这又和之前使用的一些编程语言不一样了，之前我们使用的一些编程语言例如Java，都是使用了“//”之后后面无论写什么都是不起作用的，起到的是一个注释的作用了，而现在居然还有这种做法，有点意思。</p>
<p>这个代码包原本的完整导入路径是<code>github.com/golang/sync/semaphore</code>。这与实际存储它的网络地址对应的。该代码包的源码实际存在 GitHub 网站的 golang 组的 sync 代码仓库的 semaphore 目录下。而加入导入注释之后，用以下命令即可下载并安装该代码包了：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> get golang.org/x/sync/semaphore</span><br></pre></td></tr></tbody></table></figure>

<p>而 Go 语言官网 golang.org 下的路径 <code>/x/sync/semaphore</code> 并不是存放semaphore包的真实地址。我们称之为代码包的自定义导入路径。不过，这还需要在 golang.org 这个域名背后的服务端程序上，添加一些支持才能使这条命令成功。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - 多线程：线程间通信交替打印</title>
    <url>/2020/04/16/java-bing-fa-duo-xian-cheng-xian-cheng-jian-tong-xin-jiao-ti-da-yin/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>这一部分，我通过一个经典的问题来引出几个线程间通信的方法，即：三个线程如何实现交替打印ABC？</p>
<h1 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h1><h2 id="2-1-Synchronized"><a href="#2-1-Synchronized" class="headerlink" title="2.1 Synchronized"></a>2.1 Synchronized</h2><p>基本思路：使用同步块和wait、notify的方法控制三个线程的执行次序。具体方法如下：从大的方向上来讲，该问题为三线程间的同步唤醒操作，主要的目的就是<code>ThreadA-&gt;ThreadB-&gt;ThreadC-&gt;ThreadA</code>循环执行三个线程。为了控制线程执行的顺序，那么就必须要确定唤醒、等待的顺序，所以每一个线程必须同时持有两个对象锁，才能进行打印操作。一个对象锁是prev，就是前一个线程所对应的对象锁，其主要作用是保证当前线程一定是在前一个线程操作完成后（即前一个线程释放了其对应的对象锁）才开始执行。还有一个锁就是自身对象锁。主要的思想就是，为了控制执行的顺序，必须要先持有prev锁（也就前一个线程要释放其自身对象锁），然后当前线程再申请自己对象锁，两者兼备时打印。之后首先调用<code>self.notify()</code>唤醒下一个等待线程（注意notify不会立即释放对象锁，只有等到同步块代码执行完毕后才会释放），再调用<code>prev.wait()</code>立即释放prev对象锁，当前线程进入休眠，等待其他线程的notify操作再次唤醒。</p>
<p>下面程序可以看到程序一共定义了a,b,c三个对象锁，分别对应A、B、C三个线程。A线程最先运行，A线程按顺序申请c,a对象锁，打印操作后按顺序释放a,c对象锁，并且通过notify操作唤醒线程B。线程B首先等待获取A锁，再申请B锁，后打印B，再释放B，A锁，唤醒C。线程C等待B锁，再申请C锁，后打印C，再释放C,B锁，唤醒A。看起来似乎没什么问题，但如果你仔细想一下，就会发现有问题，就是初始条件，三个线程必须按照A,B,C的顺序来启动，但是这种假设依赖于JVM中线程调度、执行的顺序。</p>
<a id="more"></a>



<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseSynchronized</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPrinter</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> Object prev;</span><br><span class="line">        <span class="keyword">private</span> Object self;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">ThreadPrinter</span><span class="params">(String name, Object prev, Object self)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.prev = prev;</span><br><span class="line">            <span class="keyword">this</span>.self = self;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">while</span> (count &gt; <span class="number">0</span>) {<span class="comment">// 多线程并发，不能用if，必须使用while循环</span></span><br><span class="line">                <span class="keyword">synchronized</span> (prev) { <span class="comment">// 先获取 prev 锁</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (self) {<span class="comment">// 再获取 self 锁</span></span><br><span class="line">                        System.out.print(name);<span class="comment">// 打印</span></span><br><span class="line">                        count--;</span><br><span class="line">                        self.notifyAll();<span class="comment">// 唤醒其他线程竞争self锁，注意此时self锁并未立即释放。</span></span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">// 此时执行完self的同步块，这时self锁才释放。</span></span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        <span class="keyword">if</span> (count == <span class="number">0</span>) { <span class="comment">// 如果count==0,表示这是最后一次打印操作，通过notifyAll操作释放对象锁。</span></span><br><span class="line">                            prev.notifyAll();</span><br><span class="line">                        } <span class="keyword">else</span> {</span><br><span class="line">                            prev.wait(); <span class="comment">// 立即释放 prev锁，当前线程休眠，等待唤醒</span></span><br><span class="line">                        }</span><br><span class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        Object a = <span class="keyword">new</span> Object();</span><br><span class="line">        Object b = <span class="keyword">new</span> Object();</span><br><span class="line">        Object c = <span class="keyword">new</span> Object();</span><br><span class="line">        ThreadPrinter pa = <span class="keyword">new</span> ThreadPrinter(<span class="string">"A"</span>, c, a);</span><br><span class="line">        ThreadPrinter pb = <span class="keyword">new</span> ThreadPrinter(<span class="string">"B"</span>, a, b);</span><br><span class="line">        ThreadPrinter pc = <span class="keyword">new</span> ThreadPrinter(<span class="string">"C"</span>, b, c);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(pa).start();</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);<span class="comment">// 保证初始ABC的启动顺序</span></span><br><span class="line">        <span class="keyword">new</span> Thread(pb).start();</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(pc).start();</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出如下：</p>
<figure class="highlight ebnf"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attribute">ABCABCABCABCABCABCABCABCABCABC</span></span><br></pre></td></tr></tbody></table></figure>

<p>从这里，我们也可以得出wait和notify操作的异同：</p>
<ol>
<li><code>wait()</code> 与 <code>notify/notifyAll()</code> 是Object类的方法，在执行两个方法时，要先获得锁。</li>
<li>当线程执行<code>wait()</code>时，会把当前的锁释放，然后让出CPU，进入等待状态。</li>
<li>当执行<code>notify/notifyAll</code>方法时，会唤醒一个处于等待该 对象锁 的线程，然后继续往下执行，直到执行完退出对象锁锁住的区域（synchronized修饰的代码块）后再释放锁。</li>
</ol>
<p>从这里还可以看出，<code>notify/notifyAll()</code>执行后，并不立即释放锁，而是要等到执行完临界区中代码后，再释放。所以在实际编程中，我们应该尽量在线程调用<code>notify/notifyAll()</code>后，立即退出临界区。即不要在<code>notify/notifyAll()</code>后面再写一些耗时的代码。</p>
<hr>
<h2 id="2-2-Lock锁方法"><a href="#2-2-Lock锁方法" class="headerlink" title="2.2 Lock锁方法"></a>2.2 Lock锁方法</h2><p>基本思路：通过ReentrantLock我们可以很方便的进行显式的锁操作，即获取锁和释放锁，对于同一个对象锁而言，同一时刻只可能有一个线程拿到了这个锁，此时其他线程通过<code>lock.lock()</code>来获取对象锁时都会被阻塞，直到这个线程通过<code>lock.unlock()</code>操作释放这个锁后，其他线程才能拿到这个锁。</p>
<p>值得注意的是ReentrantLock是可重入锁，它持有一个锁计数器，当已持有锁的线程再次获得该锁时计数器值加1，每调用一次<code>lock.unlock()</code>时所计数器值减一，直到所计数器值为0，此时线程释放锁。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseLock</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过Lock锁来保证线程的访问的互斥</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock(); </span><br><span class="line">    <span class="comment">// 通过state的值来确定是否打印</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> state = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    <span class="comment">// 多线程并发，不能用if，必须用循环测试等待条件，避免虚假唤醒</span></span><br><span class="line">                    <span class="keyword">while</span> (state % <span class="number">3</span> == <span class="number">0</span>) { </span><br><span class="line">                        System.out.print(<span class="string">"A"</span>);</span><br><span class="line">                        state++;</span><br><span class="line">                        i++;</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    <span class="comment">// unlock()操作必须放在finally块中</span></span><br><span class="line">                    lock.unlock(); </span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    <span class="keyword">while</span> (state % <span class="number">3</span> == <span class="number">1</span>) { </span><br><span class="line">                        System.out.print(<span class="string">"B"</span>);</span><br><span class="line">                        state++;</span><br><span class="line">                        i++;</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    lock.unlock(); </span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadC</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    <span class="keyword">while</span> (state % <span class="number">3</span> == <span class="number">2</span>) { </span><br><span class="line">                        System.out.print(<span class="string">"C"</span>);</span><br><span class="line">                        state++;</span><br><span class="line">                        i++;</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    lock.unlock(); </span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">new</span> ThreadA().start();</span><br><span class="line">        <span class="keyword">new</span> ThreadB().start();</span><br><span class="line">        <span class="keyword">new</span> ThreadC().start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出如下：</p>
<figure class="highlight ebnf"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attribute">ABCABCABCABCABCABCABCABCABCABC</span></span><br></pre></td></tr></tbody></table></figure>



<hr>
<h2 id="2-3-ReentrantLock结合Condition"><a href="#2-3-ReentrantLock结合Condition" class="headerlink" title="2.3 ReentrantLock结合Condition"></a>2.3 ReentrantLock结合Condition</h2><p>与ReentrantLock搭配的通行方式是Condition，Condition是被绑定到Lock上的，必须使用<code>lock.newCondition()</code>才能创建一个Condition。从下面的代码可以看出，Synchronized能实现的通信方式，Condition都可以实现，功能类似的代码写在同一行中。这样解题思路就和第一种方法基本一致，只是采用的方法不同。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseCondition</span> </span>{</span><br><span class="line">    <span class="comment">// 创建一个可重入锁lock</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// 再在上面创建的lock 进行三个条件的绑定</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Condition A = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Condition B = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Condition C = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">                    <span class="comment">// 注意这里是不等于0，也就是说在count % 3为0之前，当前线程一直阻塞状态</span></span><br><span class="line">                    <span class="keyword">while</span> (count % <span class="number">3</span> != <span class="number">0</span>) </span><br><span class="line">                        <span class="comment">// ConditionA 进入等待状态</span></span><br><span class="line">                        A.await(); </span><br><span class="line">                    System.out.print(<span class="string">"A"</span>);</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="comment">// A执行完唤醒B线程</span></span><br><span class="line">                    B.signal(); </span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                lock.unlock();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">                    <span class="comment">// 条件不满足时，ConditionB进行等待</span></span><br><span class="line">                    <span class="comment">// 当前面A线程执行后会通过B.signal()唤醒该线程，才会往下走</span></span><br><span class="line">                    <span class="keyword">while</span> (count % <span class="number">3</span> != <span class="number">1</span>)</span><br><span class="line">                        B.await(); </span><br><span class="line">                    System.out.print(<span class="string">"B"</span>);</span><br><span class="line">                    count++;</span><br><span class="line">                    C.signal(); <span class="comment">// B执行完唤醒C线程</span></span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                lock.unlock();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadC</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">                    <span class="comment">// 同上不再解释</span></span><br><span class="line">                    <span class="keyword">while</span> (count % <span class="number">3</span> != <span class="number">2</span>)</span><br><span class="line">                        C.await(); </span><br><span class="line">                    System.out.print(<span class="string">"C"</span>);</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="comment">// C执行完唤醒A线程</span></span><br><span class="line">                    A.signal(); </span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                lock.unlock();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        <span class="keyword">new</span> ThreadA().start();</span><br><span class="line">        <span class="keyword">new</span> ThreadB().start();</span><br><span class="line">        <span class="keyword">new</span> ThreadC().start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出如下：</p>
<figure class="highlight ebnf"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attribute">ABCABCABCABCABCABCABCABCABCABC</span></span><br></pre></td></tr></tbody></table></figure>





<hr>
<h2 id="2-4-Semaphore信号量方式"><a href="#2-4-Semaphore信号量方式" class="headerlink" title="2.4 Semaphore信号量方式"></a>2.4 Semaphore信号量方式</h2><p>Semaphore又称信号量，是操作系统中的一个概念，在Java并发编程中，信号量控制的是线程并发的数量。<code>public Semaphore (int permits)</code>，其中参数permits就是允许同时运行的线程数目；</p>
<p>Semaphore是用来保护一个或者多个共享资源的访问，Semaphore内部维护了一个计数器，其值为可以访问的共享资源的个数。一个线程要访问共享资源，先获得信号量，如果信号量的计数器值大于1，意味着有共享资源可以访问，则使其计数器值减去1，再访问共享资源。如果计数器值为0,线程进入休眠。当某个线程使用完共享资源后，释放信号量，并将信号量内部的计数器加1，之前进入休眠的线程将被唤醒并再次试图获得信号量。</p>
<p>Semaphore使用时需要先构建一个参数来指定共享资源的数量，Semaphore构造完成后即是获取Semaphore、共享资源使用完毕后释放Semaphore。</p>
<figure class="highlight arduino"><table><tbody><tr><td class="code"><pre><span class="line">Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">10</span>, <span class="literal">true</span>);</span><br><span class="line">semaphore.acquire();</span><br><span class="line"><span class="comment">// do something here</span></span><br><span class="line">semaphore.<span class="built_in">release</span>();</span><br></pre></td></tr></tbody></table></figure>

<p>Demo 代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseSemaphore</span> </span>{</span><br><span class="line">    <span class="comment">// 以A开始的信号量,初始信号量数量为1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore A = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// B、C信号量,A完成后开始,初始信号数量为0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore B = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore C = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">                    A.acquire(); <span class="comment">// A获取信号执行,A信号量减1,当A为0时将无法继续获得该信号量</span></span><br><span class="line">                    System.out.print(<span class="string">"A"</span>);</span><br><span class="line">                    B.release(); <span class="comment">// B释放信号，B信号量加1（初始为0），此时可以获取B信号量</span></span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">                    B.acquire();</span><br><span class="line">                    System.out.print(<span class="string">"B"</span>);</span><br><span class="line">                    C.release();</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadC</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">                    C.acquire();</span><br><span class="line">                    System.out.println(<span class="string">"C"</span>);</span><br><span class="line">                    A.release();</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        <span class="comment">// 三个线程开启</span></span><br><span class="line">        <span class="keyword">new</span> ThreadA().start();</span><br><span class="line">        <span class="keyword">new</span> ThreadB().start();</span><br><span class="line">        <span class="keyword">new</span> ThreadC().start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>输出如下：</p>
<figure class="highlight ebnf"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attribute">ABC</span></span><br><span class="line"><span class="attribute">ABC</span></span><br><span class="line"><span class="attribute">ABC</span></span><br><span class="line"><span class="attribute">ABC</span></span><br><span class="line"><span class="attribute">ABC</span></span><br><span class="line"><span class="attribute">ABC</span></span><br><span class="line"><span class="attribute">ABC</span></span><br><span class="line"><span class="attribute">ABC</span></span><br><span class="line"><span class="attribute">ABC</span></span><br><span class="line"><span class="attribute">ABC</span></span><br></pre></td></tr></tbody></table></figure>



<hr>
<h2 id="2-5-使用join"><a href="#2-5-使用join" class="headerlink" title="2.5 使用join"></a>2.5 使用join</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseJoin</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkersA</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            System.out.println(<span class="string">"A"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkersB</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            System.out.println(<span class="string">"B"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkersC</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            System.out.println(<span class="string">"C"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">            Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> WorkersA());</span><br><span class="line">            thread1.start();</span><br><span class="line">            thread1.join();</span><br><span class="line">            Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> WorkersB());</span><br><span class="line">            thread2.start();</span><br><span class="line">            thread2.join();</span><br><span class="line">            Thread thread3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> WorkersC());</span><br><span class="line">            thread3.start();</span><br><span class="line">            thread3.join();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出如下：</p>
<figure class="highlight armasm"><table><tbody><tr><td class="code"><pre><span class="line">A</span><br><span class="line"><span class="keyword">B</span></span><br><span class="line"><span class="keyword">C</span></span><br><span class="line"><span class="keyword">A</span></span><br><span class="line"><span class="keyword">B</span></span><br><span class="line"><span class="keyword">C</span></span><br><span class="line"><span class="keyword">A</span></span><br><span class="line"><span class="keyword">B</span></span><br><span class="line"><span class="keyword">C</span></span><br><span class="line"><span class="keyword">A</span></span><br><span class="line"><span class="keyword">B</span></span><br><span class="line"><span class="keyword">C</span></span><br><span class="line"><span class="keyword">A</span></span><br><span class="line"><span class="keyword">B</span></span><br><span class="line"><span class="keyword">C</span></span><br><span class="line"><span class="keyword">A</span></span><br><span class="line"><span class="keyword">B</span></span><br><span class="line"><span class="keyword">C</span></span><br><span class="line"><span class="keyword">A</span></span><br><span class="line"><span class="keyword">B</span></span><br><span class="line"><span class="keyword">C</span></span><br><span class="line"><span class="keyword">A</span></span><br><span class="line"><span class="keyword">B</span></span><br><span class="line"><span class="keyword">C</span></span><br><span class="line"><span class="keyword">A</span></span><br><span class="line"><span class="keyword">B</span></span><br><span class="line"><span class="keyword">C</span></span><br><span class="line"><span class="keyword">A</span></span><br><span class="line"><span class="keyword">B</span></span><br><span class="line"><span class="keyword">C</span></span><br></pre></td></tr></tbody></table></figure>

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>AQS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - CAS 分析</title>
    <url>/2020/04/16/java-bing-fa-cas-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-CAS-介绍"><a href="#1-CAS-介绍" class="headerlink" title="1.CAS 介绍"></a>1.CAS 介绍</h1><p><strong>什么是CAS？</strong></p>
<p>CAS，全称：Compare and Swap，即比较-替换；CAS是一种无锁算法<strong>，</strong>通过无锁的方式实现了多个线程间变量的同步；CAS 是乐观锁的一种实现方式，是一种轻量级锁，JUC 中很多工具类的实现就是基于 CAS 的。</p>
<p>注意：JVM中的CAS操作正是利用了处理器提供的<strong>CMPXCHG指令实现</strong>的。</p>
<p><strong>具体内容：</strong></p>
<p>假设有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false。<strong>当然CAS一定要volatile变量配合</strong>，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功。</p>
<a id="more"></a>

<p><strong>意思代码如下：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.value == A){</span><br><span class="line">    <span class="keyword">this</span>.value = B;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这是一种乐观策略，认为并发操作并不总会发生。</p>
<p>还是不明白？那我再说明下，就比如我现在要修改数据库的一条数据，修改之前我先拿到他原来的值，然后在SQL里面还会加个判断，原来的值和我手上拿到的他的原来的值是否一样，一样我们就可以去修改了，不一样就证明被别的线程修改了你就return错误就好了。</p>
<p>其在SQL 中的伪代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">update a set value = newValue where value = #{oldValue} // oldValue 就是我们执行前查询出来的值</span><br></pre></td></tr></tbody></table></figure>

<p><strong>底层实现：</strong></p>
<p>留空，后面补上！</p>
<hr>
<h1 id="2-CAS-存在的问题"><a href="#2-CAS-存在的问题" class="headerlink" title="2.CAS 存在的问题"></a>2.CAS 存在的问题</h1><p>CAS虽然高效地解决了原子操作，但是还是存在一些缺陷的，主要表现在三个方法：循环时间太长、只能保证一个共享变量原子操作、ABA问题。</p>
<ol>
<li><strong>循环时间太长</strong>：如果CAS一直不成功呢？这种情况绝对有可能发生，如果自旋CAS长时间地不成功，则会给CPU带来非常大的开销。在JUC中有些地方就限制了CAS自旋的次数，例如BlockingQueue的SynchronousQueue。</li>
<li><strong>只能保证一个共享变量原子操作</strong>：看了CAS的实现就知道这只能针对一个共享变量，如果是多个共享变量就只能使用锁了，当然如果你有办法把多个变量整成一个变量，利用CAS也不错。例如读写锁中state的高地位</li>
<li><strong>ABA问题</strong>：就是说来了一个线程把值改回了B，又来了一个线程把值又改回了A，对于这个时候判断的线程，就发现他的值还是A，所以他就不知道这个值到底有没有被人改过，其实很多场景如果只追求最后结果正确，这是没关系的。但是实际过程中还是需要记录修改过程的，比如资金修改什么的，你每次修改的都应该有记录，方便回溯。</li>
</ol>
<p>主要问题：怎么解决ABA问题？</p>
<ol>
<li>用版本号去保证就好了，就比如说，我在修改前去查询他原来的值的时候再带一个版本号，每次判断就连值和版本号一起判断，判断成功就给版本号加1。判断原来的值和版本号是否匹配，中间有别的线程修改，值可能相等，但是版本号100%不一样。</li>
<li><strong>Java提供了AtomicStampedReference来解决</strong>。AtomicStampedReference通过包装[<code>E,Integer]</code>的元组来对对象标记版本戳stamp，从而避免ABA问题。</li>
</ol>
<p>下面详细讲讲AtomicStampedReference 中的compareAndSet方法：</p>
<p><img src="https://i.loli.net/2020/04/16/aI6s9W3Li15fcMm.png" alt="AtomicStampedReference的CAS方法"></p>
<p>compareAndSet有四个参数，分别表示：预期引用、更新后的引用、预期标志、更新后的标志。源码部门很好理解：预期的引用 == 当前引用，预期的标识 == 当前标识，如果更新后的引用和标志和当前的引用和标志相等则直接返回true，否则通过Pair生成一个新的pair对象与当前pair CAS替换。Pair为AtomicStampedReference的内部类，主要用于记录引用和版本戳信息（标识），定义如下：</p>
<p><img src="https://i.loli.net/2020/04/16/5XUY1sgthj7rIa6.png" alt="pair方法"></p>
<p>Pair记录着对象的引用和版本戳，版本戳为int型，保持自增。同时Pair是一个不可变对象，其所有属性全部定义为final，对外提供一个of方法，该方法返回一个新建的Pari对象。pair对象定义为volatile，保证多线程环境下的可见性。在AtomicStampedReference中，大多方法都是通过调用Pair的of方法来产生一个新的Pair对象，然后赋值给变量pair。如set方法：</p>
<p><img src="https://i.loli.net/2020/04/16/mgfhSdbFvHz7856.png" alt="set方法"></p>
<p>使用atomicStampedReference进行解决ABA示例代码</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABAdemo</span> </span>{</span><br><span class="line">    <span class="comment">// 真实值</span></span><br><span class="line">    <span class="keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference = <span class="keyword">new</span> AtomicReference &lt;&gt;(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">// 真实值 版本号</span></span><br><span class="line">    <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="keyword">new</span> AtomicStampedReference &lt;&gt;(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ABA 问题</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="comment">// 修改为101然后又马上修改回来</span></span><br><span class="line">            atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>);   <span class="comment">// B</span></span><br><span class="line">            atomicReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>);   <span class="comment">// A</span></span><br><span class="line">        }, <span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="comment">// 睡1秒，让t1线程完成了ABA</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            System.out.println(atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>) + <span class="string">"\t"</span> + atomicReference.get());</span><br><span class="line">        }, <span class="string">"t2"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> { TimeUnit.SECONDS.sleep(<span class="number">2</span>); } <span class="keyword">catch</span> (InterruptedException e) { e.printStackTrace(); }</span><br><span class="line">        System.out.println(<span class="string">"=====================以下是 ABA 的解决============================================"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="comment">// 获取版本号</span></span><br><span class="line">            <span class="keyword">int</span>  stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"\t 第一次版本号："</span>+atomicStampedReference.getStamp());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 睡1秒，让t4线程也拿到atomicStampedReference</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// atomicStampedReference 的compareAndSet四个参数： 期望值，想要修改的值，现在版本号，修改之后的版本号</span></span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">100</span>,<span class="number">101</span>,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"\t 第二次版本号："</span>+atomicStampedReference.getStamp());</span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">101</span>,<span class="number">100</span>,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"\t 第三次版本号："</span>+atomicStampedReference.getStamp());</span><br><span class="line">        }, <span class="string">"t3"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">int</span>  stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"\t 第一次版本号："</span>+atomicStampedReference.getStamp());</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">boolean</span> b =  atomicStampedReference.compareAndSet(<span class="number">100</span>,<span class="number">2019</span>,stamp,stamp+<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" 修改成功否："</span>+b);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"以为的版本号 ："</span>+stamp+<span class="string">" 当前最新的版本号 ："</span>+atomicStampedReference.getStamp());</span><br><span class="line">            System.out.println(<span class="string">"当前实际最新的值 :"</span> +atomicStampedReference.getReference());</span><br><span class="line">        }, <span class="string">"t4"</span>).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出如下</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="literal">true</span>	<span class="number">2019</span></span><br><span class="line">=====================以下是 ABA 的解决============================================</span><br><span class="line">t3	 第一次版本号：<span class="number">1</span></span><br><span class="line">t4	 第一次版本号：<span class="number">1</span></span><br><span class="line">t3	 第二次版本号：<span class="number">2</span></span><br><span class="line">t3	 第三次版本号：<span class="number">3</span></span><br><span class="line">t4 修改成功否：<span class="literal">false</span></span><br><span class="line">t4以为的版本号 ：<span class="number">1</span> 当前最新的版本号 ：<span class="number">3</span></span><br><span class="line">当前实际最新的值 :<span class="number">100</span></span><br></pre></td></tr></tbody></table></figure>



















<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - AQS：自定义同步工具</title>
    <url>/2020/04/14/java-bing-fa-aqs-zi-ding-yi-tong-bu-gong-ju/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>通过前面的AQS的基本原理了解:之后：<a href="https://dongxiem.github.io/2020/03/31/java-bing-fa-aqs-kuang-jia-fen-xi/">Java 并发 - AQS：框架分析</a>，我了解了大概的AQS的一整个流程，也明白了大部分的同步工具都是基于AQS来实现的，好像比较重要的就是重写tryAcquire 和 tryRelease 两个方法而已，那么我借鉴了其他同步工具的写法，试了试尝试自己实现一个基于AQS的同步工具，看看能不能正常跑起来。</p>
<p>以下是基于独占式的写法，并不是共享式的，所以实现的也是<code>tryAcquire</code>和<code>tryRelease</code>。主要想做的事情就是同一个时刻只能让一个线程一直抱有资源做一件事情，直到这件事情做完了之后，才可以让其他线程去做一些事情，这不就是同步的概念嘛！</p>
<a id="more"></a>

<h1 id="2-自定义工具"><a href="#2-自定义工具" class="headerlink" title="2.自定义工具"></a>2.自定义工具</h1><p>实现自定义同步器需要实现<code>tryAcquire</code>和<code>tryRelease</code>，这里再重新提及一下state状态的意思，他代表当前锁的状态，0代表没有被占用，大于 0 代表有线程持有当前锁。</p>
<p>具体Demo如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockBaseAQS</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现内部类继承AQS</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>{</span><br><span class="line">        <span class="comment">// 重写tryAcquire方法</span></span><br><span class="line">        <span class="comment">// 返回1则代表获取锁成功，返回0则代表获取锁失败</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span> <span class="params">(<span class="keyword">int</span> arg)</span></span>{</span><br><span class="line">            <span class="comment">// 省略了this，AQS中state默认为0</span></span><br><span class="line">            <span class="keyword">return</span> compareAndSetState(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 重写tryRelease方法</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span> <span class="params">(<span class="keyword">int</span> arg)</span></span>{</span><br><span class="line">            <span class="comment">// 将状态设置为0</span></span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 并返回1，代表该锁没有被任何线程持有</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该线程是否正在独占资源</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="comment">// 如果state为1，代表资源正在被线程占有，否则没有</span></span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现给用户上锁的api：lock</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>{</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现给用户解锁的api：unLock</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unLock</span><span class="params">()</span> </span>{</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>这里我想还是把acquire和release的源码放出来，比较容易理解：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="comment">// 上面实现了这个tryAcquire！</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="comment">// 我们上面就实现了这个tryRelease！</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) {</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>







<hr>
<h1 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h1><p>编写了一个测试Demo如下，我们创建两个线程，然后启动这两个线程，让两个线程各自从0打印10000000，看结果会不会统一。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> MyLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> LockBaseAQS myLock = <span class="keyword">new</span> LockBaseAQS();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="comment">// 进行上锁，同一时间，只允许一个线程创建累加计数</span></span><br><span class="line">                    <span class="comment">// 这块代码同一时间只能有一个线程进来(获取到锁的线程)</span></span><br><span class="line">                    <span class="comment">// 其他的线程在lock()方法上阻塞，等待获取到锁，再进来</span></span><br><span class="line">                    myLock.lock();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) {</span><br><span class="line">                        count++;</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    <span class="comment">// 解锁</span></span><br><span class="line">                    myLock.unLock();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样一来每次都会打印出：</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">20000000</span></span><br></pre></td></tr></tbody></table></figure>



<p>假如将同步方法给屏蔽了之后，会发现每次都打印出不一样的数字！</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - AQS：LockSupport阻塞唤醒线程</title>
    <url>/2020/04/11/java-bing-fa-aqs-locksupport-zu-sai-huan-xing-xian-cheng/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>LockSupport在AQS中经常被调用，可以经常看到LockSupport的出现，看了很久也不清楚大概是个什么作用，总结了一些，它大概就是AQS用来实现线程的阻塞和唤醒的，分别通过<code>LockSupport .park()</code>和 <code>LockSupport .unpark()</code>进行实现的。</p>
<p>使用LockSupport的线程会与一个许可关联，其实就像是一个二元信号量（意思就是只有一个许可证可以使用），如果这个许可没有被占用，那么当前线程可以获得许可并继续执行，如果许可以已经被占用，则当前线程就会被阻塞，然后等待许可的获取。注意：<strong>许可默认是被占用的！</strong></p>
<a id="more"></a>

<p>可以看看如下的一个小的测试：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">     Thread thread = Thread.currentThread();</span><br><span class="line">     LockSupport.unpark(thread);<span class="comment">//释放许可</span></span><br><span class="line">     LockSupport.park();<span class="comment">// 获取许可</span></span><br><span class="line">     System.out.println(<span class="string">"b"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样一来先释放许可，再获取许可，主线程是能够正常打印出字符的，但是如果没有先释放许可的话，就会被阻塞了：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">     LockSupport.park();</span><br><span class="line">     System.out.println(<span class="string">"block."</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行该代码，可以发现主线程一直处于阻塞状态。因为 <strong>许可默认是被占用的</strong> ，调用park()时获取不到许可，所以进入阻塞状态。</p>
<p>还需要注意的是<strong>LockSupport是不可重入</strong> 的，如果一个线程连续2次调用 LockSupport .park()，那么该线程一定会一直阻塞下去。</p>
<p>LockSupport定义了一系列以park开头的方法来阻塞当前线程，unpark(Thread thread)方法来唤醒一个被阻塞的线程。如下：</p>
<p><img src="https://i.loli.net/2020/04/11/eIlXKaFYn2rdcgh.jpg" alt="LockSupport的几个方法"></p>
<hr>
<h1 id="2-源码"><a href="#2-源码" class="headerlink" title="2.源码"></a>2.源码</h1><h2 id="2-1-park"><a href="#2-1-park" class="headerlink" title="2.1 park"></a>2.1 park</h2><p>park(Object blocker)方法的blocker参数，主要是用来标识当前线程在等待的对象，该对象主要用于问题排查和系统监控。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>{</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    setBlocker(t, blocker);</span><br><span class="line">    U.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>setBlocker主要完成的也就是设置屏障，其源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setBlocker</span><span class="params">(Thread t, Object arg)</span> </span>{</span><br><span class="line">    <span class="comment">// Even though volatile, hotspot doesn't need a write barrier here.</span></span><br><span class="line">    U.putReference(t, PARKBLOCKER, arg);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>需要注意的是：park方法和unpark(Thread thread)都是成对出现的，同时unpark必须要在park执行之后执行，当然并不是说没有不调用unpark线程就会一直阻塞，park有一个方法，它带了时间戳（parkNanos(long nanos)：为了线程调度禁用当前线程，最多等待指定的等待时间，除非许可可用）。</p>
<hr>
<h2 id="2-2-unpark"><a href="#2-2-unpark" class="headerlink" title="2.2 unpark"></a>2.2 unpark</h2><p>unpark(Thread thread)方法源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">        U.unpark(thread);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>U是什么？查看源码可以发现一系列UNSAFE相关的方法：</p>
<figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Hotspot implementation via intrinsics API</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe U = Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> PARKBLOCKER = U.objectFieldOffset</span><br><span class="line">        (Thread.class, "parkBlocker");</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SECONDARY = U.objectFieldOffset</span><br><span class="line">        (Thread.class, "threadLocalRandomSecondarySeed");</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TID = U.objectFieldOffset</span><br><span class="line">        (Thread.class, "tid");</span><br></pre></td></tr></tbody></table></figure>



<p>可以发现park和unpark其内部都是通过UNSAFE（sun.misc.Unsafe UNSAFE）来实现的，其定义如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> var1, <span class="keyword">long</span> var2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Object var1)</span></span>;</span><br></pre></td></tr></tbody></table></figure>



<p>关于Unusafe，我想后面还是要去了解一下，Unusafe是一个比较危险的类，主要是用于执行低级别、不安全的方法集合。</p>
<hr>
<h1 id="3-官方案例"><a href="#3-官方案例" class="headerlink" title="3.官方案例"></a>3.官方案例</h1><p>JDK源码给了一个案例，理解一下其具体操作，如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FIFOMutex</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean locked = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Thread&gt; waiters = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上锁操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">boolean</span> wasInterrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// publish current thread for unparkers</span></span><br><span class="line">        waiters.add(Thread.currentThread());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Block while not first in queue or cannot acquire lock</span></span><br><span class="line">        <span class="keyword">while</span> (waiters.peek() != Thread.currentThread() ||</span><br><span class="line">               !locked.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) {</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// ignore interrupts while waiting</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                wasInterrupted = <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        waiters.remove();</span><br><span class="line">        <span class="comment">// ensure correct interrupt status on return</span></span><br><span class="line">        <span class="keyword">if</span> (wasInterrupted)</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>{</span><br><span class="line">        locked.set(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        LockSupport.unpark(waiters.peek());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        <span class="comment">// Reduce the risk of "lost unpark" due to classloading</span></span><br><span class="line">        Class&lt;?&gt; ensureLoaded = LockSupport<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<hr>
<p>参考文章：</p>
<ol>
<li><a href="http://cmsblogs.com/?p=2205" target="_blank" rel="noopener">【死磕Java并发】—–J.U.C之AQS：阻塞和唤醒线程</a></li>
<li><a href="https://www.tuicool.com/articles/MveUNzF" target="_blank" rel="noopener">LockSupport的park和unpark的基本使用,以及对线程中断的响应性</a></li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - 多线程：FutureTask源码分析</title>
    <url>/2020/04/10/java-bing-fa-duo-xian-cheng-futuretask-yuan-ma-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-什么是FutureTask？"><a href="#1-什么是FutureTask？" class="headerlink" title="1. 什么是FutureTask？"></a>1. 什么是FutureTask？</h1><p>前面的Blog介绍了<u><code>Future</code>接口。这个接口有一个实现类叫<code>FutureTask</code></u>。FutureTask类有什么用？为什么要有一个FutureTask类？前面说到了Future只是一个接口，而它里面的<code>cancel</code>，<code>get</code>，<code>isDone</code>等方法要自己实现起来都是<strong>非常复杂</strong>的。所以JDK提供了一个<code>FutureTask</code>类来供我们使用。</p>
<p>FutureTask是Future的具体实现，且实现了Runnable接口，即FutureTask满足了Task的行为，是一个可以被用来执行的Future。FutureTask是JUC提供的线程池实现用到的任务基本单元，<u>线程池主要接收两种对象：一个是Runnable任务，一种是Callable任务</u>。按照ExecutorService接口定义的行为，可以将Runnable或Callable任务提交到线程池执行，而<u>被提交的Runnable或Callable任务都会被包装成FutureTask</u>，由线程池的工作线程去执行。</p>
<p>还有的就是前面的文章中所讲的FutureTask 为什么可以使用Executor 也可以使用线程直接执行？因为FutureTask是实现的<code>RunnableFuture</code>接口的，而<code>RunnableFuture</code>接口同时继承了<code>Runnable</code>接口和<code>Future</code>接口。因此，FutureTask可以交给Executor执行，也可以由调用线程直接执行（<code>FutureTask.run()</code>）。</p>
<a id="more"></a>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 片段一</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets this Future to the result of its computation</span></span><br><span class="line"><span class="comment">     * unless it has been cancelled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 片段二</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>{</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>FutureTask</code>还是可以研究一下的，我将里面实现的一个方法一点一点进行分析。</p>
<hr>
<h1 id="2-FutureTask-核心内容"><a href="#2-FutureTask-核心内容" class="headerlink" title="2.FutureTask 核心内容"></a>2.FutureTask 核心内容</h1><p>FutureTask的实现基于<code>AbstractQueuedSynchronizer</code>（以下简称为AQS）。<code>java.util.concurrent</code>中的很多可阻塞类（比如ReentrantLock）都是基于AQS来实现的。AQS是一个同步框架，它提供通用机制来原子性管理同步状态、阻塞和唤醒线程，以及维护被阻塞线程的队列。JDK 6中AQS被广泛使用，基于AQS实现的同步器包括：ReentrantLock、Semaphore、ReentrantReadWriteLock、CountDownLatch和FutureTask。</p>
<p>每一个基于AQS实现的同步器都会包含两种类型的操作，如下：</p>
<ul>
<li>至少一个acquire操作。这个操作阻塞调用线程，除非/直到AQS的状态允许这个线程继续执行。FutureTask的acquire操作为<code>get()</code>/<code>get（long timeout，TimeUnit unit）</code>方法调用。</li>
<li>至少一个release操作。这个操作改变AQS的状态，改变后的状态可允许一个或多个阻塞线程被解除阻塞。FutureTask的release操作包括<code>run()</code>方法和<code>cancel（…）</code>方法。</li>
</ul>
<p>基于“复合优先于继承”的原则，FutureTask声明了一个<strong>内部私有的继承于AQS的子类Sync</strong>，对FutureTask所有公有方法的调用都会委托给这个内部子类。</p>
<p>AQS被作为“模板方法模式”的基础类提供给FutureTask 的内部子类Sync，这个内部子类只需要实现状态检查和状态更新的方法即可，这些方法将控制FutureTask的获取和释放操作。具体来说，Sync实现了<code>AQS的tryAcquireShared(int)</code>方法和<code>tryReleaseShared(int)</code>方法，Sync通过这两个方法来检查和更新同步状态。</p>
<p><img src="https://i.loli.net/2020/04/16/NJlD2HdkfUybRtx.png" alt="FutureTask的设计示意图"></p>
<p>如图所示，Sync是FutureTask的内部私有类，它继承自AQS。创建FutureTask时会创建内部私有的成员对象Sync，FutureTask所有的的公有方法都直接委托给了内部私有的Sync。</p>
<hr>
<h1 id="3-FutureTask源码分析"><a href="#3-FutureTask源码分析" class="headerlink" title="3.FutureTask源码分析"></a>3.FutureTask源码分析</h1><h2 id="3-1-FutureTask的几个状态"><a href="#3-1-FutureTask的几个状态" class="headerlink" title="3.1 FutureTask的几个状态"></a>3.1 FutureTask的几个状态</h2><p>根据<code>FutureTask.run()</code>方法被执行的时机，FutureTask可以处于下面3种状态（图源：Java并发编程的艺术）。</p>
<p><img src="https://i.loli.net/2020/04/10/NcqZ1HBFIQuvwbt.png" alt="几种状态"></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The run state of this task, initially NEW.  The run state</span></span><br><span class="line"><span class="comment"> * transitions to a terminal state only in methods set,</span></span><br><span class="line"><span class="comment"> * setException, and cancel.  During completion, state may take on</span></span><br><span class="line"><span class="comment"> * transient values of COMPLETING (while outcome is being set) or</span></span><br><span class="line"><span class="comment"> * INTERRUPTING (only while interrupting the runner to satisfy a</span></span><br><span class="line"><span class="comment"> * cancel(true)). Transitions from these intermediate to final</span></span><br><span class="line"><span class="comment"> * states use cheaper ordered/lazy writes because values are unique</span></span><br><span class="line"><span class="comment"> * and cannot be further modified.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Possible state transitions:</span></span><br><span class="line"><span class="comment"> * NEW -&gt; COMPLETING -&gt; NORMAL</span></span><br><span class="line"><span class="comment"> * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span></span><br><span class="line"><span class="comment"> * NEW -&gt; CANCELLED</span></span><br><span class="line"><span class="comment"> * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="comment">// 初始创建时的状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 当任务执行完毕，FutureTask会将执行结果设置给outcome属性，在设置之前会将FutureTask的状态修改为COMPLETING。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 当任务执行完毕，FutureTask会将执行结果设置给outcome属性，在设置之后会将FutureTask的状态修改为NORMAL。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 当任务在执行的过程中抛了异常，FutureTask会将异常信息设置给outcome属性，</span></span><br><span class="line"><span class="comment">// 在设置之前会将FutureTask的状态修改为COMPLETING，在设置之后将状态修改为EXCEPTIONAL。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 当外部想要取消任务，而又不允许当任务正在执行的时候被取消时会将FutureTask的状态修改为CANCELLED。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 当外部想要取消任务，同时允许当任务正在执行的时候被取消时，会先将FutureTask的状态设置为INTERRUPTING，</span></span><br><span class="line"><span class="comment">// 然后设置执行任务的线程的中断标记位。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 当外部想要取消任务，同时允许当任务正在执行的时候被取消时，会先将FutureTask的状态设置为INTERRUPTING，</span></span><br><span class="line"><span class="comment">// 然后设置执行任务的线程的中断标记位，最后将Future的状态设置为INTERRUPTED。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>FutureTask的状态流转可能流程：</p>
<ul>
<li>NEW—&gt;COMPLETING—&gt;NORMAL（任务执行正常）</li>
<li>NEW—&gt;COMPLETING—&gt;EXCEPTIONAL（任务执行异常）</li>
<li>NEW—&gt;CANCELLED（不允许执行中的取消）</li>
<li>NEW—&gt;INTERRUPTING—&gt;INTERRUPTED（允许执行中的取消）</li>
</ul>
<p>需要注意的是：FutureTask中使用<u>CAS操作</u>更新state来表示任务完成，极大地降低了使用加锁进行同步控制的性能开销。</p>
<h2 id="3-2-Treiber-堆"><a href="#3-2-Treiber-堆" class="headerlink" title="3.2 Treiber 堆"></a>3.2 Treiber 堆</h2><p>FutureTask中使用简单的Treiber堆栈来保存等待线程，Treiber堆是非阻塞的，使用CAS操作来实现节点的出栈和入栈操作。FutureTask中使用WaitNode来表示等待节点，源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/** Treiber stack of waiting threads */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Simple linked list nodes to record waiting threads in a Treiber</span></span><br><span class="line"><span class="comment"> * stack.  See other classes such as Phaser and SynchronousQueue</span></span><br><span class="line"><span class="comment"> * for more detailed explanation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNode</span> </span>{</span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="keyword">volatile</span> WaitNode next;</span><br><span class="line">    WaitNode() { thread = Thread.currentThread(); }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<hr>
<h2 id="3-3-构造方法"><a href="#3-3-构造方法" class="headerlink" title="3.3 构造方法"></a>3.3 构造方法</h2><p>可以发现<code>FutureTask</code>的参数可以有<code>Callable</code>或者<code>Runnable</code>和<code>result</code>，<code>FutureTask</code>的构造方法将提交的<code>Runnable</code>或<code>Callable</code>任务都会被包装成<code>FutureTask</code>。源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 参数为callable</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>{</span><br><span class="line">     <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">     <span class="keyword">this</span>.callable = callable;</span><br><span class="line">     <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 参数为runnable 和 result</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>{</span><br><span class="line">     <span class="comment">// 返回的还是一个callable</span></span><br><span class="line">     <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">     <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>



<p>查看<code>Executors.callable(runnable, result);</code> 源码如下，会发现其实<code>FutureTask</code>最终将<code>Runnabl</code>转化为<code>Callable</code>，而且这里还使用了一种模式：适配器模式。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 返回这么RunnableAdapter一个对象，其实现了Callable接口</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(task, result);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>其中<code>RunnableAdapter</code>的源码如下所示，你会发现兜兜转转，还是实现了<code>Callable</code>，这就很有意思了。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A callable that runs given task and returns given result.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable task;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T result;</span><br><span class="line">    <span class="comment">// 构造函数，上面就是根据传递进来的task和result构建了这么一个对象然后返回</span></span><br><span class="line">    RunnableAdapter(Runnable task, T result) {</span><br><span class="line">        <span class="keyword">this</span>.task = task;</span><br><span class="line">        <span class="keyword">this</span>.result = result;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 其call 方法也就是run方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> </span>{</span><br><span class="line">        task.run();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString() + <span class="string">"[Wrapped task = "</span> + task + <span class="string">"]"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<hr>
<h2 id="3-4-运行任务-run"><a href="#3-4-运行任务-run" class="headerlink" title="3.4 运行任务 run"></a>3.4 运行任务 run</h2><p><code>FutureTask</code>中使用run方法来执行任务，源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 如果当前状态不为NEW，而且没有其他线程运行当前任务</span></span><br><span class="line">    <span class="comment">// 否则直接return;</span></span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !RUNNER.compareAndSet(<span class="keyword">this</span>, <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="comment">// callable不为null，且在此判断状态</span></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) {</span><br><span class="line">            V result;</span><br><span class="line">            <span class="keyword">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 进行执行任务</span></span><br><span class="line">                <span class="comment">// 发现FutureTask的run的方法调用的就是Callable的call方法</span></span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            } <span class="keyword">catch</span> (Throwable ex) { <span class="comment">// 如果发生异常，则记录异常result</span></span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">                ran = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 修改状态为EXCEPTIONAL，并且记录异常</span></span><br><span class="line">                setException(ex);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                <span class="comment">// 没有发生异常，则记录call 返回的数据到outcome中</span></span><br><span class="line">                <span class="comment">// 并同时修改状态，set方法会将状态state设置为NORMAL</span></span><br><span class="line">                set(result);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="comment">// 在设置状态state前runner必须非空，防止并发调用run()方法</span></span><br><span class="line">        <span class="comment">// 而且将runner置空，主要是使后续等待线程可继续执行</span></span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// runner置为null后，必须重新读取state以防止有中断发生</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果state被其他线程调用cancel（true）修改为INTERRUPTING</span></span><br><span class="line">        <span class="comment">// 这表示有中断事件发生，那就要调用下面的方法进行暂停了</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            <span class="comment">// 这里主要就是调用Thread.yield()让出CPU，保证线程能够成功暂停。</span></span><br><span class="line">            <span class="comment">// 注意：执行yield()的线程有可能在进入到暂停状态后马上又被执行。</span></span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>以上的过程大概如此：</p>
<ol>
<li>运行任务之前必须要保证其状态是NEW，并且没有其他线程在执行当前任务。然后调用<code>c.call();</code>执行任务并接收返回值，然后修改状态。</li>
<li>任务运行中如果发生了异常则调用<code>setException(ex);</code>进行异常处理；</li>
<li>任务正常完成时，记录call执行返回的数据，同时将调用set方法修改state为normal，最后将runner置空。同时判断是否有中断事件发生，有的话进行线程暂停，释放资源。</li>
</ol>
<p>其实就是上面蕴含了两条状态变化的线路：</p>
<ol>
<li>NEW—&gt;COMPLETING—&gt;EXCEPTIONAL（任务执行异常）</li>
<li>NEW—&gt;COMPLETING—&gt;NORMAL（任务执行正常）</li>
</ol>
<p>可以看看<code>setException</code> 和 <code>set</code>方法做了一些什么：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setException</span><span class="params">(Throwable t)</span> </span>{</span><br><span class="line">    <span class="comment">// 将状态由NEW修改为COMPLETING </span></span><br><span class="line">    <span class="keyword">if</span> (STATE.compareAndSet(<span class="keyword">this</span>, NEW, COMPLETING)) {</span><br><span class="line">        <span class="comment">// 并且记录异常</span></span><br><span class="line">        outcome = t;</span><br><span class="line">        <span class="comment">// 设置状态为EXCEPTIONAL</span></span><br><span class="line">        STATE.setRelease(<span class="keyword">this</span>, EXCEPTIONAL); <span class="comment">// final state</span></span><br><span class="line">        <span class="comment">// 唤醒等待队列中的所有后续线程（若有）</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (STATE.compareAndSet(<span class="keyword">this</span>, NEW, COMPLETING)) {</span><br><span class="line">        <span class="comment">// 保存call 返回的数据</span></span><br><span class="line">        outcome = v;</span><br><span class="line">        STATE.setRelease(<span class="keyword">this</span>, NORMAL); <span class="comment">// final state</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p><code>finishCompletion</code>做了一些什么？<code>finishCompletion</code>用于唤醒等待队列中的所有后续线程（若有）。当任务未完成时，调用get()方法会被加入等待队列并阻塞。<code>FutureTask</code>中done()什么也不做，该方法主要用于子类个性化定制，如<code>ExecutorCompletionService</code>中<code>QueueingFuture</code>实现<code>FutureTask</code>，实现done()以达到任务完成自动将Future加入结果队列。</p>
<p>可以查看一下他的源码，如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes and signals all waiting threads, invokes done(), and</span></span><br><span class="line"><span class="comment"> * nulls out callable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// assert state &gt; COMPLETING;</span></span><br><span class="line">    <span class="comment">// 遍历所有的等待线程</span></span><br><span class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) {</span><br><span class="line">        <span class="comment">// 将waiters设置为null</span></span><br><span class="line">        <span class="keyword">if</span> (WAITERS.weakCompareAndSet(<span class="keyword">this</span>, q, <span class="keyword">null</span>)) {</span><br><span class="line">            <span class="comment">// 如果上面的设置成功，则进入一个死循环等待</span></span><br><span class="line">            <span class="keyword">for</span> (;;) {</span><br><span class="line">                Thread t = q.thread;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) {</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 进行线程的唤醒</span></span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 下一个等待线程</span></span><br><span class="line">                WaitNode next = q.next;</span><br><span class="line">                <span class="comment">// 如果没有下一个等待线程，则结束</span></span><br><span class="line">                <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                q = next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    done();</span><br><span class="line">    callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>i</p>
<hr>
<h2 id="3-6-取消任务-cancel"><a href="#3-6-取消任务-cancel" class="headerlink" title="3.6 取消任务 cancel"></a>3.6 取消任务 cancel</h2><p>当FutureTask处于未启动状态时，执行<code>FutureTask.cancel()</code>方法将导致此任务永远不会被执行；当FutureTask处于已启动状态时，执行<code>FutureTask.cancel（true）</code>方法将以<u>中断执行此任务线程的方式来试图停止任务</u>，即是说这个cancel 是允许中断的；当FutureTask处于已启动状态时，执行<code>FutureTask.cancel（false）</code>方法将不会对正在执行此任务的线程产生影响（让正在执行的任务运行完成）；当FutureTask处于已完成状态时，执行<code>FutureTask.cancel(...)</code>方法将返回false。</p>
<p>我们根据状态的变化来捋一下取消任务的主要流程，其主要有两条线路：</p>
<ol>
<li>NEW—&gt;INTERRUPTING—&gt;INTERRUPTED（允许执行中的取消）</li>
<li>NEW—&gt;CANCELLED（不允许执行中的取消）</li>
</ol>
<p>就是当外部想要取消任务的时候，看看当前任务是否能够允许被取消。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>{</span><br><span class="line">    <span class="comment">// 当前状态为NEW，并且且判断当前线程运行时候时候能够中断</span></span><br><span class="line">    <span class="comment">// 可以的话将状态设置为INTERRUPTING，否则设置为CANCELLED并返回false</span></span><br><span class="line">    <span class="keyword">if</span> (!(state == NEW &amp;&amp; STATE.compareAndSet</span><br><span class="line">          (<span class="keyword">this</span>, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> {    <span class="comment">// in case call to interrupt throws exception</span></span><br><span class="line">        <span class="keyword">if</span> (mayInterruptIfRunning) { <span class="comment">// 判断是否允许在运行时候进行中断,即判断传进来为true还是false</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 保存当前运行的线程</span></span><br><span class="line">                Thread t = runner;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 进行中断</span></span><br><span class="line">                    t.interrupt();</span><br><span class="line">            } <span class="keyword">finally</span> { <span class="comment">// final state</span></span><br><span class="line">                <span class="comment">// 将当前执行线程状态state设置成为INTERRUPTED</span></span><br><span class="line">                STATE.setRelease(<span class="keyword">this</span>, INTERRUPTED);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        finishCompletion();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<hr>
<h2 id="3-7-获取任务结果-get"><a href="#3-7-获取任务结果-get" class="headerlink" title="3.7 获取任务结果 get"></a>3.7 获取任务结果 get</h2><p>当FutureTask处于未启动或已启动状态时，执行<code>FutureTask.get()</code>方法将导致调用线程阻塞；当FutureTask处于已完成状态时，执行<code>FutureTask.get()</code>方法将导致调用线程立即返回结果或抛出异常。</p>
<p>get操作主要用于计算完成后获取结果，还可以使用带等待时间的get方法，其源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 取得返回值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>{</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="comment">// 判断FutureTask 状态，如果为未启动或者已启动状态，则进行阻塞</span></span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="comment">// 如果FutureTask 为完成状态</span></span><br><span class="line">    <span class="comment">// 通过调用report 返回一个结果或者抛出一个异常</span></span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带超时的get方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>{</span><br><span class="line">    <span class="keyword">if</span> (unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING &amp;&amp;</span><br><span class="line">        (s = awaitDone(<span class="keyword">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>其中report方法的实现如下，主要完成的是：通过进行状态的判断，返回一个结果，或者抛出异常。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns result or throws exception for completed task.</span></span><br><span class="line"><span class="comment"> * 对于已经完成的任务，返回一个结果，或者抛出一个异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s completed state value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>{</span><br><span class="line">    <span class="comment">// 取出记录的outcome</span></span><br><span class="line">    Object x = outcome;</span><br><span class="line">    <span class="comment">// 如果线程状态state为NORMAL时，则返回一个结果</span></span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">        <span class="keyword">return</span> (V)x;</span><br><span class="line">    <span class="comment">// 如果线程状态state为CANCELLED、INTERRUPTING、INTERRUPTED，则抛出一个异常</span></span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<hr>
<h1 id="以上参考"><a href="#以上参考" class="headerlink" title="以上参考"></a>以上参考</h1><ol>
<li>Java 并发编程的艺术</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - 多线程：线程池的使用</title>
    <url>/2020/04/08/java-bing-fa-duo-xian-cheng-xian-cheng-chi-de-shi-yong/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-如何配置线程池"><a href="#1-如何配置线程池" class="headerlink" title="1 如何配置线程池"></a>1 如何配置线程池</h1><p>如果我们设置的线程池数量太小的话，如果同一时间有大量任务/请求需要处理，可能会导致大量的请求/任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务/请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。这样很明显是有问题的！ CPU 根本没有得到充分利用。</p>
<p>但是，如果我们设置线程数量太大，大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。</p>
<p>注：上下文切换的解释</p>
<ul>
<li>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。</li>
<li><strong>上下文切换通常是计算密集型的</strong>。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</li>
<li>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</li>
</ul>
<p>需要肯定的一点是：线程池肯定是不是越大越好。</p>
<a id="more"></a>

<p>通常我们是需要根据这批任务执行的性质来确定的。</p>
<ul>
<li><strong>CPU 密集型任务(N+1)</strong>： 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了<strong>防止线程偶发的缺页中断</strong>，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li>
<li><strong>I/O 密集型任务(2N)</strong>： 由于IO密集型任务的线程并不是一直在执行任务，则应配置尽可能多的线程，如CPU核数 * 2。</li>
</ul>
<p>这里还有一种参考的IO 密集型的线程池大小设置方式：IO密集型，即任务需要大量的IO，即大量的阻塞。在单线程上运行IO密集型的任务会导致浪费大量的CPU运算能力浪费在等待。所以在IO密集型任务中使用多线程可以大大的加速程序运行。故需要·多配置线程数：参考公式：</p>
<ul>
<li><code>CPU核数/（1-阻塞系数 ）</code> 阻塞系数在（0.8-0.9）之间</li>
<li>比如8核CPU：<code>8/（1-0.9） = 80</code>个线程数</li>
</ul>
<p>举个简单的实例如下：</p>
<p><strong>假如一分钟内要写 1 万个 1M 的文件到磁盘，core 和 maximum 怎么设？</strong></p>
<ul>
<li>这个是IO密集型的任务，如果是四核，core 和 maximum 就设置为8个；</li>
</ul>
<p><strong>要对一个数 0 加到一亿，要怎么设 core 和 maxim？</strong></p>
<ul>
<li>加法操作，CPU利用率高，这是CPU密集型的任务，如果是四核，则core 和 maximum 就设置为5个；</li>
<li>如果按照阻塞系数的方程来解决的话：四核CPU，则：4 / (1 - 0.9) = 40，则core 和 maximum 需要设置为40；</li>
</ul>
<hr>
<h1 id="2-如何优雅的关闭线程池"><a href="#2-如何优雅的关闭线程池" class="headerlink" title="2 如何优雅的关闭线程池"></a>2 如何优雅的关闭线程池</h1><p>如果线程池需要执行的任务完成了之后，我们也应该着手一下进行关闭线程池，那么有一些什么办法呢？无非就两种方法：<code>shutdown()/shutdownNow()</code></p>
<p>那么这两者的区别是什么呢？</p>
<ul>
<li><code>shutdown()</code> ：执行后停止接受新任务，会把队列的任务执行完毕。</li>
<li><code>shutdownNow()</code> ：也是停止接受新任务，但会中断所有的任务，将线程池状态变为 stop。</li>
</ul>
<p>两个方法都会中断线程，用户可自行判断是否需要响应中断。</p>
<p><code>shutdownNow()</code> 要更简单粗暴，可以根据实际场景选择不同的方法。</p>
<p>这里借鉴一个方法，可以采取以下的方法关闭线程池：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++) {</span><br><span class="line">    pool.execute(<span class="keyword">new</span> Job());</span><br><span class="line">}</span><br><span class="line">pool.shutdown();</span><br><span class="line"><span class="keyword">while</span> (!pool.awaitTermination(<span class="number">1</span>, TimeUnit.SECONDS)) {</span><br><span class="line">    LOGGER.info(<span class="string">"线程还在执行。。。"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">LOGGER.info(<span class="string">"一共处理了【{}】"</span>, (end - start));</span><br></pre></td></tr></tbody></table></figure>

<p><code>pool.awaitTermination(1, TimeUnit.SECONDS)</code> 会每隔一秒钟检查一次是否执行完毕（状态为 <code>TERMINATED</code>），当从 while 循环退出时就表明线程池已经完全终止了。</p>
<hr>
<h1 id="3-线程池使用的两个Demo"><a href="#3-线程池使用的两个Demo" class="headerlink" title="3 线程池使用的两个Demo"></a>3 线程池使用的两个Demo</h1><p>为了更好的理解线程池的参数的设置与如何使用，这里有两个Demo：</p>
<h2 id="3-1-Runnable-ThreadPoolExecutor"><a href="#3-1-Runnable-ThreadPoolExecutor" class="headerlink" title="3.1 Runnable+ThreadPoolExecutor"></a>3.1 Runnable+ThreadPoolExecutor</h2><p>首先创建一个 Runnable 接口的实现类</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。 </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@author</span> shuang.kou </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String command;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRunnable</span><span class="params">(String s)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.command = s;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" Start. Time = "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        processCommand();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" End. Time = "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processCommand</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写toString方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.command;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>编写测试程序，我们这里以阿里巴巴推荐的使用 ThreadPoolExecutor 构造函数自定义参数的方式来创建线程池。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">5</span>;    <span class="comment">// 核心线程为5</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">10</span>;    <span class="comment">// 最大线程数为10</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUEUE_CAPACITY = <span class="number">100</span>;    <span class="comment">// 队列数为100</span></span><br><span class="line">    <span class="comment">// 只有当线程池中的线程数大于corePoolSize时，这个参数才会起作用。</span></span><br><span class="line">    <span class="comment">// 当线程数大于corePoolSize时，终止前多余的空闲线程等待新任务的最长时间,等待时间为 1L。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long KEEP_ALIVE_TIME = <span class="number">1L</span>;    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class="line">        <span class="comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                CORE_POOL_SIZE,</span><br><span class="line">                MAX_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,    </span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY),    <span class="comment">// 任务队列为 ArrayBlockingQueue，并且容量为 100;</span></span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());    <span class="comment">// 饱和策略为 CallerRunsPolicy</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">            <span class="comment">//创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span></span><br><span class="line">            Runnable worker = <span class="keyword">new</span> MyRunnable(<span class="string">""</span> + i);</span><br><span class="line">            <span class="comment">//执行Runnable</span></span><br><span class="line">            executor.execute(worker);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//终止线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executor.isTerminated()) {</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"Finished all threads"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="3-2-Callable-ThreadPoolExecutor"><a href="#3-2-Callable-ThreadPoolExecutor" class="headerlink" title="3.2 Callable+ThreadPoolExecutor"></a>3.2 Callable+ThreadPoolExecutor</h2><p>首先创建一个 Callable 接口的实现类</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//返回执行当前 Callable 的线程名字</span></span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>编写测试程序，我们这里以阿里巴巴推荐的使用 ThreadPoolExecutor 构造函数自定义参数的方式来创建线程池。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUEUE_CAPACITY = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long KEEP_ALIVE_TIME = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class="line">        <span class="comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                CORE_POOL_SIZE,</span><br><span class="line">                MAX_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 申请一个List，用来装返回的数据</span></span><br><span class="line">        List&lt;Future&lt;String&gt;&gt; futureList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 开始进行实例的创建</span></span><br><span class="line">        Callable&lt;String&gt; callable = <span class="keyword">new</span> MyCallable();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">            <span class="comment">//提交任务到线程池</span></span><br><span class="line">            Future&lt;String&gt; future = executor.submit(callable);</span><br><span class="line">            <span class="comment">//将返回值 future 添加到 list，我们可以通过 future 获得 执行 Callable 得到的返回值</span></span><br><span class="line">            futureList.add(future);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 进行返回数据的遍历输出</span></span><br><span class="line">        <span class="keyword">for</span> (Future&lt;String&gt; fut : futureList) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 使用fut.get()得到数据</span></span><br><span class="line">                System.out.println(<span class="keyword">new</span> Date() + <span class="string">"::"</span> + fut.get());</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException | ExecutionException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - 多线程：线程创建的几种方式</title>
    <url>/2020/04/01/java-bing-fa-duo-xian-cheng-xian-cheng-chuang-jian-de-ji-chong-fang-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>在这阶段的学习过程中我会先抛出一系列：线程如何创建？这是一个很关键的问题，并发的关键在于多线程，那么如何创建线程呢？大概有几种方式呢？这几种方式的区别是什么？什么情况下应该使用这种创建方式？什么时候又不应该呢？那么具体的过程应该是如何呢？是否应该给出一两个例子会更好的说明一下？</p>
<p>问题太多，搞得自己都乱了，最主要的还是要一点点的去了解，最后串成一根线，才能更好对知识的进行掌握。</p>
<p>我想应该将这几种方式联系起来做一个对比，这样才能更好的理解这些创建线程方式的优点与缺点。</p>
<p>按照现有的认识，总的来说有两种实现线程的方式：</p>
<ol>
<li><strong>实现Runnable接口</strong></li>
<li><strong>继承Thread类</strong></li>
</ol>
<p>其实按照我的理解的话，详细分一下的话可以分为三种，就是继承Thread类，实现Runnable接口，实现Callable接口（虽然其内部也是实现Runnable接口），主要就是实现Runnable接口没有返回值，而实现Callable接口可以有返回值，所以也可以按照这三种方式去思考实际开发过程中到底需要哪种创建方式。</p>
<a id="more"></a>

<hr>
<h1 id="2-几种实现方式详解"><a href="#2-几种实现方式详解" class="headerlink" title="2.几种实现方式详解"></a>2.几种实现方式详解</h1><h2 id="2-1-继承Thread类"><a href="#2-1-继承Thread类" class="headerlink" title="2.1 继承Thread类"></a>2.1 继承Thread类</h2><p>实现：</p>
<ol>
<li>需要实现 run() 方法，因为 Thread 类也实现了 <code>Runable</code> 接口。</li>
<li>当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。</li>
</ol>
<p>Demo如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>{</span><br><span class="line">    <span class="comment">// 注意就是这里extend 进行继承了Thread</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">        <span class="comment">// 重写run方法，需要线程做的事情在这里进行编辑！</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>{</span><br><span class="line">            System.out.printl(<span class="string">"MyThread"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">        Thread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        myThread.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>关于start()方法需要注意的有两点：</p>
<ol>
<li>我们在程序里面调用了start()方法后，虚拟机会先为我们创建一个线程，然后等到这个线程第一次得到时间片时再调用run()方法。</li>
<li>注意<strong>不可多次调用start()方法</strong>。在第一次调用start()方法后，再次调用start()方法会抛出异常。</li>
</ol>
<p>此处我有两个疑惑，根据平时的积累之后给出了答案，问题如下：</p>
<ol>
<li><p><strong>start()方法和run()方法的区别？</strong></p>
<ul>
<li>只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。</li>
</ul>
</li>
<li><p><strong>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</strong></p>
<ul>
<li>new 一个 Thread，线程进入了新建状态；<u>调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了</u>。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 <u>而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行</u>，并不会在某个线程中执行它，所以这并不是多线程工作。</li>
<li>总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="2-2-实现Runnable接口"><a href="#2-2-实现Runnable接口" class="headerlink" title="2.2 实现Runnable接口"></a>2.2 实现Runnable接口</h2><p>实现：</p>
<ol>
<li>实现接口方式<ul>
<li>需要实现接口中的 run() 方法。</li>
<li>使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 run() 方法来启动线程。</li>
</ul>
</li>
<li>函数式编程实现方式(<code>JDK 1.8 +</code>)<ul>
<li>可以使用函数式编程：<code>new Thread(() -&gt; { .... }).start();</code>方便快捷！</li>
</ul>
</li>
</ol>
<p><code>Runnable</code>是一个函数式接口，这意味着我们可以使用<strong>Java 8的函数式编程</strong>来简化代码。</p>
<p>首先还是来认识一下函数式编程是个什么东西吧？</p>
<p>函数式编程这是在Java 8 之后才有的，它的声明是<u>通过一个注解</u>来实现的，可以查看Runnable 的接口实现便可知道</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Demo如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>{</span><br><span class="line">    <span class="comment">// 1.实现接口的方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>{</span><br><span class="line">            System.out.println(<span class="string">"MyThread"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">        <span class="comment">// 需要注意的是这里是run而不是start！</span></span><br><span class="line">        <span class="keyword">new</span> MyThread().run();</span><br><span class="line">        <span class="comment">// 2.函数式编程</span></span><br><span class="line">        <span class="comment">// Java 8 之后的函数式编程如下</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            Ststem.out.println(<span class="string">"Java 8 匿名内部类"</span>);</span><br><span class="line">        }).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出如下：</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="code"><pre><span class="line">MyThread</span><br><span class="line">Java <span class="number">8</span> 匿名内部类</span><br></pre></td></tr></tbody></table></figure>

<p>需要注意的是实现了Runnable接口(<code>implements Runnable</code>)要进行使用的时候是使用<code>new MyThread().run();</code>而不是<code>new Thread().start();</code></p>
<p>所以实现Runnable接口，我们有两种方式可以去实现创建线程，总的来说，使用匿名内部类的函数式编程会比较方便一点，不用那么多操作，那当然什么方便使用什么了~</p>
<p>上面的实现接口方式还可以这么写，都是一样的，就是知道多个写法</p>
<ol>
<li>需要实现接口中的 run() 方法。</li>
<li>使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 start() 方法来启动线程。</li>
</ol>
<p>Demo如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">    MyRunnable instance = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">    <span class="comment">// 将这个实现Runnable 接口的实例传递进来</span></span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">    <span class="comment">// 调用thread的start 方法</span></span><br><span class="line">    <span class="comment">// 注意和上面的实现方式对比，不是run方法</span></span><br><span class="line">    thread.start();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<hr>
<h2 id="2-3-实现-Callable接口"><a href="#2-3-实现-Callable接口" class="headerlink" title="2.3 实现 Callable接口"></a>2.3 实现 Callable接口</h2><h3 id="2-3-1-Callable接口"><a href="#2-3-1-Callable接口" class="headerlink" title="2.3.1 Callable接口"></a>2.3.1 Callable接口</h3><p>其实也算是实现Runnable接口！<code>Callable</code>与<code>Runnable</code>类似，同样是只有一个抽象方法的函数式接口。不同的是，<code>Callable</code>提供的方法是<strong>有返回值</strong>的，而且支持<strong>泛型</strong>。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>{</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>那么这个返回值该如何接受呢？这就引出了实现Callable 接口的几种方法了，可以使用下面的<code>Callable+ Future</code> 接口完成，也可以使用再下面的<code>Callable+ FutureTask</code> 类进行实现，一般来说，选择后者的做法居多。</p>
<p>其实这两者的差别就是使用：<code>submit(Runnable task)</code> 和 <code>submit(Callable task)</code> 的差别而已了！</p>
<hr>
<h3 id="2-3-2-Future接口"><a href="#2-3-2-Future接口" class="headerlink" title="2.3.2 Future接口"></a>2.3.2 Future接口</h3><p><code>Future</code>接口只有几个比较简单的方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> paramBoolean)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> V <span class="title">get</span><span class="params">(<span class="keyword">long</span> paramLong, TimeUnit paramTimeUnit)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p><code>cancel</code>方法是试图取消一个线程的执行，但是并不一定能够成功，因为任务可能已完成、已取消、或者一些其它因素不能取消，存在取消失败的可能。<code>boolean</code>类型的返回值是“是否取消成功”的意思。参数<code>paramBoolean</code>表示是否采用中断的方式取消线程执行。</p>
<p>所以有时候，<u>为了让任务有能够取消的功能，就使用<code>Callable</code>来代替<code>Runnable</code></u>。如果为了可取消性而使用 <code>Future</code>但又不提供可用的结果，则可以声明 <code>Future</code>形式类型、并返回 <code>null</code>作为底层任务的结果。</p>
<p>那一般是怎么配合使用<code>Callable</code>的呢？<u><code>Callable</code>一般是配合线程池工具<code>ExecutorService</code>来使用的。</u></p>
<p><u><code>ExecutorService</code>可以使用<code>submit</code>方法来让一个<code>Callable</code>接口执行。它会返回一个<code>Future</code></u>，我们后续的程序可以通过这个<code>Future</code>的<code>get</code>方法得到结果。</p>
<p>再注意些：下面是通过<code>new Task ();</code>然后将这个Task使用线程池的<code>submit</code>进行提交的，<code>submit</code>是有返回值的，然后使用一个<code>Future&lt;&gt;</code>进行接收，再在下面我讲到了<code>FutureTask</code>之后，发现我们使用<code>FutureTask</code>或者更加方便一些，应该将这两者结合起来，就能更明白<code>FutureTask</code>的作用了。</p>
<p>简单的使用Future 接口的Demo如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义Callable</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>{</span><br><span class="line">    <span class="comment">// 因为是接口，且只有一个call，所以实现他即可</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">// 模拟计算需要一秒</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>{</span><br><span class="line">        <span class="comment">// 申请线程池</span></span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">// 新建一个Task</span></span><br><span class="line">        Task task = <span class="keyword">new</span> Task();</span><br><span class="line">        <span class="comment">// 使用submit方法进行任务的提交，返回一个Future</span></span><br><span class="line">        Future&lt;Integer&gt; result = executor.submit(task);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注意调用get方法会阻塞当前线程，直到得到结果。</span></span><br><span class="line">        <span class="comment">// 所以实际编码中建议使用可以设置超时时间的重载get方法。</span></span><br><span class="line">        System.out.println(result.get()); </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></tbody></table></figure>

<p>在线程池中的使用，可以具体看看我之前写的博客中的一个Demo：<a href="https://dongxiem.github.io/2020/04/08/java-bing-fa-xian-cheng-chi-de-shi-yong/#3-2-Callable-ThreadPoolExecutor">Callable+ThreadPoolExecutor</a>，可以申请一个List，用来装返回的数据：<code>List&lt;Future&lt;String&gt;&gt; futureList = new ArrayList&lt;&gt;();</code>，然后可以对这个<code>futureList</code>进行遍历输出。</p>
<hr>
<h3 id="2-3-3-FutureTask类"><a href="#2-3-3-FutureTask类" class="headerlink" title="2.3.3 FutureTask类"></a>2.3.3 FutureTask类</h3><p>关于FutureTask的源码分析，我在这篇文章进行了分析：<a href="https://dongxiem.github.io/2020/04/10/java-bing-fa-duo-xian-cheng-futuretask-yuan-ma-fen-xi/">Java 并发 - 多线程：FutureTask源码分析</a>。可以查看一下。</p>
<p>需要注意通过使用Thread 方式配合FutureTask 的方式时，主线程在调用 <code>futureTask.get()</code> 方法时阻塞主线程；然后 Callable 内部开始执行，并返回运算结果；此时 <code>futureTask.get()</code> 得到结果，主线程恢复运行。当然，如果不希望阻塞主线程，可以考虑利用 ExecutorService，把 FutureTask 放到线程池去管理执行。</p>
<p>示例Demo1：</p>
<p>配合Executors 进行使用</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义Callable，与上面一样</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">// 模拟计算需要一秒</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>{</span><br><span class="line">        <span class="comment">// 申请线程池</span></span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">// 注意，这里是申请了一个FutureTask，将实现Callable 接口的Task作为参数传入</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Task());</span><br><span class="line">        <span class="comment">// 提交这个FutureTask，注意和最上面的Future实现的方式对比：submit没有返回值</span></span><br><span class="line">        executor.submit(futureTask);</span><br><span class="line">        <span class="comment">// 使用的是FutureTask的一些方法</span></span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>使用上与第一个Demo有一点小的区别。首先，<u>调用<code>submit</code>方法是没有返回值的。这里实际上是调用的<code>submit(Runnable task)</code>方法，而上面的Demo，调用的是<code>submit(Callable task)</code>方法。</u></p>
<p>然后，<u>这里是使用<code>FutureTask</code>直接取<code>get</code>取值，而上面的Demo是通过<code>submit</code>方法返回的<code>Future</code>去取值。</u></p>
<p>在很多高并发的环境下，有可能Callable 和FutureTask 会创建多次。FutureTask能够在高并发环境下<strong>确保任务只执行一次</strong>。</p>
<p>示例Demo2：</p>
<p>配合线程Thread 进行使用</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskExample</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>{</span><br><span class="line">        <span class="comment">// 创建实例</span></span><br><span class="line">        FutureTaskExample mc = <span class="keyword">new</span> FutureTaskExample();</span><br><span class="line">        <span class="comment">// 将实现Callable 接口作为参数给FutureTask</span></span><br><span class="line">        FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(mc);</span><br><span class="line">        <span class="comment">// 因为FutureTask 实现Runnable 接口，所以使用线程创建的方式</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(ft);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(ft.get());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出：</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">123</span></span><br></pre></td></tr></tbody></table></figure>



<p>还可以参考的Demo3 创建的方式其实一样，就是较为简单易看，这里作为一个参考：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskExample</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException</span>{</span><br><span class="line">        <span class="comment">// 创建一个FutreTask，传入一个callable 实现的函数</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt; (<span class="keyword">new</span> Callable&lt;Integer&gt;(){</span><br><span class="line">            <span class="comment">// 里面进行一个计数，并到点返回</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">                <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++){</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    result += i;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用futureTask 已经封装过的任务，创建一个线程</span></span><br><span class="line">        Thread computeThread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        computeThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实现其他线程</span></span><br><span class="line">        Thread otherThread = <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            System.out.println(<span class="string">"other task is running..."</span>);</span><br><span class="line">            <span class="keyword">try</span>{</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e){</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动其他线程</span></span><br><span class="line">        otherThread.start();</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>输出：</p>
<figure class="highlight ada"><table><tbody><tr><td class="code"><pre><span class="line">other <span class="keyword">task</span> <span class="keyword">is</span> running...</span><br><span class="line"><span class="number">4950</span></span><br></pre></td></tr></tbody></table></figure>



<hr>
<h2 id="2-4-其他实现线程的方法"><a href="#2-4-其他实现线程的方法" class="headerlink" title="2.4 其他实现线程的方法"></a>2.4 其他实现线程的方法</h2><p>Java5 之后的<code>Executors</code>，<code>Executors</code>工具类可以用来创建线程池。</p>
<p><code>Executors</code>工具类是用来创建线程池的，这个线程池可以指定线程个数，也可以不指定，也可以指定定时器的线程池，它有如下常用的方法：</p>
<figure class="highlight reasonml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">new</span><span class="constructor">FixedThreadPool(<span class="params">int</span> <span class="params">nThreads</span>)</span>：创建固定数量的线程池</span><br><span class="line"><span class="keyword">new</span><span class="constructor">CachedThreadPool()</span>：创建缓存线程池</span><br><span class="line"><span class="keyword">new</span><span class="constructor">SingleThreadExecutor()</span>：创建单个线程</span><br><span class="line"><span class="keyword">new</span><span class="constructor">ScheduledThreadPool(<span class="params">int</span> <span class="params">corePoolSize</span>)</span>：创建定时器线程池</span><br></pre></td></tr></tbody></table></figure>

<p>这就涉及线程池的概念了，关于线程池的一些可以查看之前的文章：<a href="https://dongxiem.github.io/2020/03/31/java-bing-fa-duo-xian-cheng-shen-ru-xian-cheng-chi-yuan-li/">Java 并发 - 多线程：深入线程池原理</a></p>
<hr>
<h1 id="3-深入理解Thread类"><a href="#3-深入理解Thread类" class="headerlink" title="3.深入理解Thread类"></a>3.深入理解Thread类</h1><h2 id="3-1-Thread类构造方法"><a href="#3-1-Thread类构造方法" class="headerlink" title="3.1 Thread类构造方法"></a>3.1 Thread类构造方法</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Thread的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Thread</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>{</span><br><span class="line">    <span class="comment">// 如果名字为空则抛出异常，线程名字不可为空</span></span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name cannot be null"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 名字</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程的父线程为当前线程</span></span><br><span class="line">    Thread parent = currentThread();</span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果线程组为空</span></span><br><span class="line">    <span class="keyword">if</span> (g == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">/* Determine if it's an applet or not */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果安全管理security不为空，则使用安全管理security获取一个线程组</span></span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) {</span><br><span class="line">            g = security.getThreadGroup();</span><br><span class="line">        }</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 如果没有安全管理security没有设置线程组，则使用父线程组</span></span><br><span class="line">        <span class="keyword">if</span> (g == <span class="keyword">null</span>) {</span><br><span class="line">            g = parent.getThreadGroup();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 无论是否显式传入threadgroup，都可以进行checkAccess</span></span><br><span class="line">    g.checkAccess();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 权限检查</span></span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (isCCLOverridden(getClass())) {</span><br><span class="line">            security.checkPermission(</span><br><span class="line">                SecurityConstants.SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里会使用synchronized去同步线程组，然后进行一个nUnstartedThreads++;</span></span><br><span class="line">    g.addUnstarted();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.group = g;</span><br><span class="line">    <span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">    <span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line">    <span class="keyword">if</span> (security == <span class="keyword">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">    <span class="comment">// 初始化AccessControlContext类型的私有属性</span></span><br><span class="line">    <span class="keyword">this</span>.inheritedAccessControlContext =</span><br><span class="line">        acc != <span class="keyword">null</span> ? acc : AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    <span class="comment">// 设置线程优先级</span></span><br><span class="line">    setPriority(priority);</span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 两个对用于支持ThreadLocal的私有属性</span></span><br><span class="line">        <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">        ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    <span class="comment">// 保存指定的栈堆大小</span></span><br><span class="line">    <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程ID</span></span><br><span class="line">    <span class="keyword">this</span>.tid = nextThreadID();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>Thread类有很多构造方法，不过都是以上面这个构造方法为基准进行改造的，所以总的来说了解上面这个构造方法就可以了。比如有以下这么几个：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 无参构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带Runnable的构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, target, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带ThreadGroup和Runnable的构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(ThreadGroup group, Runnable target)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(group, target, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带名字参数的构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(String name)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">null</span>, name, <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们大多调用下面两个构造方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Thread(Runnable target)</span><br><span class="line">Thread(Runnable target, String name)</span><br></pre></td></tr></tbody></table></figure>

<p>Thread的构造方法主要有以下的几个参数：</p>
<ol>
<li><p>g：线程组，指定这个线程是在哪个线程组下；</p>
</li>
<li><p>target：指定要执行的任务；</p>
</li>
<li><p>name：线程的名字，多个线程的名字是可以重复的。如果不指定名字，见片段2；</p>
</li>
<li><p>acc：用于初始化私有变量<code>inheritedAccessControlContext</code>。</p>
<blockquote>
<p>它是一个私有变量，但是在<code>Thread</code>类里只有<code>init</code>方法对它进行初始化，在<code>exit</code>方法把它设为<code>null</code>。其它没有任何地方使用它。一般我们是不会使用它的，那什么时候会使用到这个变量呢？可以参考这个stackoverflow的问题：<a href="https://stackoverflow.com/questions/13516766/restrict-permissions-to-threads-which-execute-third-party-software" target="_blank" rel="noopener">Restrict permissions to threads which execute third party software</a>；</p>
</blockquote>
</li>
<li><p>inheritThreadLocals：可继承的<code>ThreadLocal</code>，<code>Thread</code>类里面有两个私有属性来支持`ThreadLocal。</p>
</li>
</ol>
<hr>
<h2 id="3-2-Thread类的几个常用方法"><a href="#3-2-Thread类的几个常用方法" class="headerlink" title="3.2 Thread类的几个常用方法"></a>3.2 Thread类的几个常用方法</h2><h3 id="3-2-1-currentThread"><a href="#3-2-1-currentThread" class="headerlink" title="3.2.1 currentThread"></a>3.2.1 currentThread</h3><p><code>currentThread()</code>：静态方法，返回对当前正在执行的线程对象的引用；</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a reference to the currently executing thread object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  the currently executing thread.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> Thread <span class="title">currentThread</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p>像获取当前线程的名字，一般就可以这么使用了：<code>Thread.currentThread().getName();</code></p>
<h3 id="3-2-2-start"><a href="#3-2-2-start" class="headerlink" title="3.2.2 start"></a>3.2.2 start</h3><p><code>start()</code>：<u>开始执行线程的方法，java虚拟机会调用线程内的run()方法；</u></p>
<p>需要注意的是：不可以多次启动线程，而且线程一旦完成执行，就不可以再次启动。意思就是同一个线程多次调用<code>start()</code>就会出现问题了！</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 线程被执行，JVM调用run方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is not invoked for the main method thread or "system"</span></span><br><span class="line"><span class="comment">     * group threads created/set up by the VM. Any new functionality added</span></span><br><span class="line"><span class="comment">     * to this method in the future may have to also be added to the VM.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * A zero status value corresponds to state "NEW".</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)<span class="comment">// 状态校验  0：NEW 新建状态</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment">     * so that it can be added to the group's list of threads</span></span><br><span class="line"><span class="comment">     * and the group's unstarted count can be decremented. */</span></span><br><span class="line">    group.add(<span class="keyword">this</span>); <span class="comment">// 添加进线程组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        start0(); <span class="comment">// 调用native方法执行线程run方法</span></span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">if</span> (!started) {</span><br><span class="line">                group.threadStartFailed(<span class="keyword">this</span>); <span class="comment">// 启动失败，从线程组中移除当前前程。</span></span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable ignore) {</span><br><span class="line">            <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">              it will be passed up the call stack */</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure>





<h3 id="3-2-3-yield"><a href="#3-2-3-yield" class="headerlink" title="3.2.3 yield"></a>3.2.3 yield</h3><p><code>yield()</code>：<code>yield()</code>指的是当前线程愿意让出对当前处理器的占用。这里需要注意的是，就算当前线程调用<code>了yield()</code>方法，程序在调度的时候，也还有可能继续运行这个线程的；</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure>





<h3 id="3-2-4-sleep"><a href="#3-2-4-sleep" class="headerlink" title="3.2.4 sleep"></a>3.2.4 sleep</h3><p><code>sleep()</code>：静态方法，使当前线程睡眠一段时间；</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 进行睡眠 线程不会失去任何监视器的所有权。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></tbody></table></figure>





<h3 id="3-2-5-join"><a href="#3-2-5-join" class="headerlink" title="3.2.5 join"></a>3.2.5 join</h3><p><code>join()</code>：使当前线程等待另一个线程执行完毕之后再继续执行，内部调用的是Object类的wait方法实现的；</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 最多等待millis毫秒，使此线程死亡。如果参数为0则意味着永远等待。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    <span class="keyword">if</span> (millis &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 测试此线程是否处于活动状态。如果线程已启动但尚未死亡，则它是活动的。</span></span><br><span class="line">        <span class="keyword">if</span> (isAlive()) {</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">            <span class="comment">// 等待多长时间</span></span><br><span class="line">            <span class="keyword">long</span> delay = millis;</span><br><span class="line">            <span class="keyword">do</span> {</span><br><span class="line">                wait(delay);</span><br><span class="line">            } <span class="keyword">while</span> (isAlive() &amp;&amp; (delay = millis -</span><br><span class="line">                    TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime)) &gt; <span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (millis == <span class="number">0</span>) { <span class="comment">// millis为0，则进行永远等待</span></span><br><span class="line">        <span class="keyword">while</span> (isAlive()) {</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<hr>
<h1 id="4-关于submit与execute"><a href="#4-关于submit与execute" class="headerlink" title="4.关于submit与execute"></a>4.关于submit与execute</h1><p>关于execute 的详解请看这里：<a href="https://dongxiem.github.io/2020/03/31/java-bing-fa-duo-xian-cheng-shen-ru-xian-cheng-chi-yuan-li/">Java 并发 - 多线程：深入线程池原理</a>，这里列出其源码，方便对比。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) {</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) {</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>submit方法则是在ExecutorService接口中定义的。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//ExecutorService</span></span><br><span class="line"><span class="keyword">public</span>` `<span class="class"><span class="keyword">interface</span>` `<span class="title">ExecutorService</span> ``<span class="keyword">extends</span>` `<span class="title">Executor</span> </span>{</span><br><span class="line">　　...</span><br><span class="line">　　 <span class="function">Future <span class="title">submit</span><span class="params">(Callable task)</span></span>;</span><br><span class="line">　　 <span class="function">Future <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">　　 <span class="function">Future <span class="title">submit</span><span class="params">(Runnable task)</span></span>;</span><br><span class="line">　　...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在其子类AbstractExecutorService实现了submit方法。</p>
<p>submit有Future返回值 :</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//AbstractExecutorService</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException {<span class="doctag">@inheritDoc</span>}</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException       {<span class="doctag">@inheritDoc</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) {</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException {<span class="doctag">@inheritDoc</span>}</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException       {<span class="doctag">@inheritDoc</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException {<span class="doctag">@inheritDoc</span>}</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException       {<span class="doctag">@inheritDoc</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>在AbstractExecutorService实现的submit方法实际上是一个模板方法，定义了submit方法的算法骨架，其execute交给了子类。</p>
<p>尽管submit方法能提供线程执行的返回值，但只有实现了Callable才会有返回值，而实现Runnable的线程则是没有返回值的，也就是说在上面的3个方法中，<code>submit(Callable&lt;T&gt; task)</code>能获取到它的返回值，<code>submit(Runnable task, T result)</code>能通过传入的载体result间接获得线程的返回值或者准确来说交给线程处理一下，而最后一个方法<code>submit(Runnable task)</code>则是没有返回值的，就算获取它的返回值也是null。</p>
<p>从上面的源码可以看到，这三者方法几乎是一样的，关键就在于：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">execute(ftask);</span><br></pre></td></tr></tbody></table></figure>

<p>它是如何将一个任务作为参数传递给了newTaskFor，然后调用execute方法，最后进而返回ftask的呢？</p>
<p>关于<code>newTaskFor(task)</code> 其源码为：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//AbstractExecutorService#newTaskFor</span></span><br><span class="line"><span class="comment">// 返回了一个FutureTask实例</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面我们已经说了，FutureTask实现了Future和Runnable接口。Future接口是Java线程Future模式的实现，可用用来异步计算，实现Runnable接口表示可以作为一个线程执行。FutureTask实现了这两个接口意味着它代表异步计算的结果，同时可以作为一个线程交给Executor来执行。</p>
<p>两者的主要区别，简略说明有以下几个：</p>
<ol>
<li><p>executor 方法，无返回值；submit 方法，可以提供<code>Future &lt; T &gt;</code> 类型的返回值。</p>
</li>
<li><p>excute 方法会抛出异常；sumbit 方法不会抛出异常，除非你调用<code>Future.get()</code>。</p>
</li>
<li><p>excute 入参Runnable；submit 入参可以为Callable，也可以为Runnable。</p>
</li>
</ol>
<p>注：关于第二种，传入Runnable 和 result 的使用一直有疑惑，这里给出一个Demo</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Submit2</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>{</span><br><span class="line">        ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class="line">        Data data = <span class="keyword">new</span> Data();</span><br><span class="line">        Future&lt;Data&gt; future = executor.submit(<span class="keyword">new</span> Task(data), data);</span><br><span class="line">        System.out.println(future.get().getName());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 这里就是充当result了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>{</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>{ <span class="keyword">return</span> name;}</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>{ <span class="keyword">this</span>.name = name;}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建一个Task 继承Runnable接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    Data data;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(Data data)</span> </span>{ <span class="keyword">this</span>.data = data; }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"This is ThreadPoolExetor#submit(Runnable task, T result) method."</span>);</span><br><span class="line">        data.setName(<span class="string">"kevin"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<hr>
<h1 id="5-几种比较"><a href="#5-几种比较" class="headerlink" title="5.几种比较"></a>5.几种比较</h1><h2 id="5-1-实现接口-VS-继承Thread"><a href="#5-1-实现接口-VS-继承Thread" class="headerlink" title="5.1 实现接口 VS 继承Thread"></a>5.1 <strong>实现接口 VS 继承Thread</strong></h2><p>这里再稍微总结一下线程创建的两种方式：</p>
<ol>
<li>继承Thread类，并重写run()方法</li>
<li>实现Runnable接口，覆盖接口中的run()方法，并把Runnable接口的实现扔给Thread。</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    <span class="comment">// 第一种</span></span><br><span class="line">    MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">    myThread.start();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第二种</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"自己实现的run-2"</span>)).start();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种继承Thread方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"自己实现的run-1"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>这里抛出一个问题：<strong>写的两种创建线程的方式，都涉及到了<code>run()</code>方法，那么<code>Thread</code>里的<code>run()</code>方法具体是怎么实现的吗？</strong></p>
<p><code>Thread</code> 中的<code>run()</code>方法里东西很少，就一个 if 判断：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) {</span><br><span class="line">        target.run();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>有个<code>target</code>对象，判断该变量是否为null，非空的时候，去执行<code>target</code>对象中的<code>run()</code>方法，否则啥也不干。<u>而这个<code>target</code>对象，就是我们说的<code>Runnable</code></u>：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* What will be run. */</span></span><br><span class="line"><span class="keyword">private</span> Runnable target;</span><br></pre></td></tr></tbody></table></figure>



<p><code>Runnable</code>类很简单，就一个抽象方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    <span class="comment">// run方法是抽象的！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个抽象方法也是<code>run()</code>！如果我们使用<code>Runnable</code>，就需要实现这个方法，由于这个<code>Runnable</code>类上面标了<code>@FunctionalInterface</code>注解，所以可以使用函数式编程。</p>
<p>这样一来：</p>
<ol>
<li>假如我用第一种方式：继承了<code>Thread</code>类，然后重写了<code>run()</code>方法，那么它就不会去执行上面这个默认的<code>run()</code>方法了（即不会去判断<code>target</code>），会执行我重写的<code>run()</code>方法逻辑。</li>
<li>假如我是用的第二种方式：实现<code>Runnable</code>接口的方式，那么它会执行默认的<code>run()</code>方法，然后判断<code>target</code>不为空，再去执行我在<code>Runnable</code>接口中实现的<code>run()</code>方法。</li>
</ol>
<p>还有个问题：如果我既继承了<code>Thread</code>类，同时我又实现了<code>Runnable</code>接口，比如这样，最后会打印什么信息出来呢？</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"runnable run"</span>)) <span class="comment">// 实现Runnable接口的写法</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 继承Thread的写法</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            System.out.println(<span class="string">"Thread run"</span>);</span><br><span class="line">        }</span><br><span class="line">    }.start();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出：</p>
<figure class="highlight dockerfile"><table><tbody><tr><td class="code"><pre><span class="line">Thread <span class="keyword">run</span></span><br></pre></td></tr></tbody></table></figure>

<p>其实这个答案很简单，我们来分析一下代码便知：其实是 new 了一个对象（子对象）继承了<code>Thread</code>对象（父对象），在子对象里重写了父类的<code>run()</code>方法；然后父对象里面扔了个<code>Runnable</code>进去，父对象中的<code>run()</code>方法就是最初那个带有 if 判断的<code>run()</code>方法。</p>
<p>现在执行<code>start()</code>后，肯定先在子类中找<code>run()</code>方法，找到了，父类的<code>run()</code>方法自然就被干掉了，所以会打印出：Thread run。</p>
<p>如果我们现在假设子类中没有重写<code>run()</code>方法，那么必然要去父类找<code>run()</code>方法，父类的<code>run()</code>方法中就得判断是否有<code>Runnable</code>传进来，现在有一个，所以执行<code>Runnable</code>中的<code>run()</code>方法，那么就会打印：Runnable run 出来。</p>
<p>说白了，就是 Java 语言本身的父子继承关系，会优先执行子类重写的方法而已！</p>
<p>我理解的实现接口会更好一些，因为：</p>
<ol>
<li>Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；</li>
<li>类可能只要求可执行就行，继承整个 Thread 类开销过大，如果使用线程时不需要使用Thread类的诸多方法，显然使用<code>Runnable</code> 接口更为轻量。</li>
<li><code>Runnable</code> 接口出现更符合面向对象，将线程单独进行对象的封装。</li>
<li><code>Runnable</code> 接口出现，降低了线程对象和线程任务的耦合性。</li>
</ol>
<p>所以总的来说，还是优先使用实现<code>Runnable</code> 接口方式进行线程的实现较为友好。</p>
<hr>
<h2 id="5-2-Runnable接口-VS-Callable接口"><a href="#5-2-Runnable接口-VS-Callable接口" class="headerlink" title="5.2 Runnable接口 VS Callable接口"></a>5.2 Runnable接口 VS Callable接口</h2><p>总得来说有两个不一样的地方：</p>
<ol>
<li>Runnable 接口不会返回结果或抛出检查异常，但是Callable 接口可以</li>
<li>Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</li>
<li>如果想任务有能够取消的功能，就使用<code>Callable</code>来代替<code>Runnable</code></li>
</ol>
<p>Runnable自Java 1.0以来一直存在，但Callable仅在Java 1.5中引入,目的就是为了来处理Runnable不支持的用例。<strong>Runnable 接口不会返回结果或抛出检查异常，但是Callable 接口可以</strong>。所以，如果任务不需要返回结果或抛出异常推荐使用 Runnable 接口，这样代码看起来会更加简洁。</p>
<p>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    <span class="comment">// 被线程执行，没有返回值也无法抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>Callable接口中的<strong>call()方法是有返回值的，是一个泛型</strong>，和Future、FutureTask配合可以用来获取异步执行的结果。</p>
<p>这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为<strong>多线程充满着未知性</strong>，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>{</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 计算结果，或者在无法这样做的时候抛出异常</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 计算得出的结果</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> 如果无法计算结果，则抛出异常</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注意：</p>
<ul>
<li><strong>工具类 Executors 可以实现 Runnable 对象和 Callable 对象之间的相互转换</strong>。（<code>Executors.callable（Runnable task）</code>或 <code>Executors.callable（Runnable task，Object resule）</code>）。</li>
</ul>
<hr>
<h1 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h1><p>自上面整个流程分析下来，可以很清楚的对几种创建线程方式的理解了，总的来说还是实现Runnable接口比继承Thread更好一些，所以对于我来说比较偏向于使用继承接口，在继承接口有两种可供选择，一种是有返回值的callable，一种是没有返回值的Runnable接口，这就要具体情况具体分析了，看看实际过程中需要使用哪种，对于Thread类也更清晰了，Thread类的几个常用方法也有了一定的理解，总得来说学习过程也更清晰了，还是很开心的。</p>
<h1 id="以上参考"><a href="#以上参考" class="headerlink" title="以上参考"></a>以上参考</h1><ol>
<li><a href="https://www.php.cn/java-article-371806.html" target="_blank" rel="noopener">JAVA中ThreadPoolExecutor线程池的submit方法详解</a></li>
<li><a href="https://www.cnblogs.com/liuchuanfeng/p/6956014.html" target="_blank" rel="noopener">线程池的submit和execute方法区别</a></li>
<li>书籍：<a href="http://concurrent.redspider.group/RedSpider.html" target="_blank" rel="noopener">深入浅出Java多线程</a></li>
<li>书籍：Java并发编程的艺术</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - Synchronized 与其他一些锁机制的对比</title>
    <url>/2020/03/31/java-bing-fa-synchronized-yu-qi-ta-yi-xie-suo-ji-zhi-de-dui-bi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>我们前面已经 Synchronized 在JDK1.6 进行哪一些方面的优化，通过这些底层的优化之后Synchronized  变得好用了很多，那么它究竟和其他锁机制有什么差别？换种方式说，我在进行编程的过程中，究竟要如何进行选择？什么时候应该选择Synchronized？而什么时候不选用Synchronized而选用其他的锁机制。</p>
<p>总感觉学习了Synchronized之后，对于其内部原理熟悉了，不知道有没有其他人跟我一样困惑，我究竟该何时进行使用它呢？在哪个场景下我该第一时间想到这货？我觉得进行选择还应该先进行对比，将和我们之前学习到的一些同步机制进行联系起来，有对比才有总结，尽量多进行比较，多点思考，才有更深入的理解与认识。</p>
<a id="more"></a>

<hr>
<h1 id="2-区别分析"><a href="#2-区别分析" class="headerlink" title="2.区别分析"></a>2.区别分析</h1><h2 id="2-1-Synchronized-和-Reentrantlock（可重入锁）的联系与区别："><a href="#2-1-Synchronized-和-Reentrantlock（可重入锁）的联系与区别：" class="headerlink" title="2.1 Synchronized 和 Reentrantlock（可重入锁）的联系与区别："></a>2.1 Synchronized 和 Reentrantlock（可重入锁）的联系与区别：</h2><ul>
<li><p><strong>总体而言</strong>：Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。</p>
<ul>
<li>注意：ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。</li>
</ul>
</li>
<li><p><strong>联系</strong>：</p>
<ul>
<li><strong>两者都是可重入锁</strong><ul>
<li>“可重入锁”  概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>区别</strong>：</p>
<ul>
<li><strong>锁的实现：</strong>synchronized 依赖于 JVM ，而 ReentrantLock 依赖于 API。<ul>
<li>synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</li>
</ul>
</li>
<li><strong>性能：</strong>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。 性能已不是选择标准。</li>
<li><strong>ReentrantLock 比 synchronized 增加了一些高级功能：</strong><ol>
<li><strong>等待可中断：</strong>ReentrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li>
<li><strong>公平锁：</strong>ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。 ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的ReentrantLock(boolean fair)构造方法来制定是否是公平的。</li>
<li><strong>锁绑定多个条件：</strong>synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知”，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>使用选择</strong>：<u>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized</u>。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p>
</li>
</ul>
<hr>
<h2 id="2-2-Synchronized-和-Lock-的联系与区别："><a href="#2-2-Synchronized-和-Lock-的联系与区别：" class="headerlink" title="2.2 Synchronized 和 Lock 的联系与区别："></a>2.2 Synchronized 和 Lock 的联系与区别：</h2><ul>
<li><strong>总的来说：</strong>Synchronized是 Java 内置关键字在 Jvm 层面，Lock是个 Java 类。Lock有比 Synchronized 更精确的线程语义和更好的性能。Lock的锁定是通过代码实现的，而Synchronized是在 JVM 层面上实现的。</li>
<li><strong>区别</strong>：<ul>
<li>是否可以获得锁状态：<ul>
<li>synchronized无法判断是否获取锁的状态；</li>
<li>Lock可以判断是否获取到锁，并且可以主动尝试去获取锁。</li>
</ul>
</li>
<li>是否自动释放锁：<ul>
<li>synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)；</li>
<li>Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁。</li>
</ul>
</li>
<li>是否阻塞：<ul>
<li>用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去；</li>
<li>而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了。它的tryLock方法可以非阻塞方式去拿锁。</li>
</ul>
</li>
<li>范围：<ul>
<li>Lock锁的范围有局限性，块范围；</li>
<li>而synchronized可以锁住块、对象、类。</li>
</ul>
</li>
</ul>
</li>
<li><strong>区别小结：</strong>synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）</li>
<li><strong>适用场景：</strong><u>Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题</u>。</li>
</ul>
<hr>
<h2 id="2-3-Synchronized-和-CAS-联系与区别？"><a href="#2-3-Synchronized-和-CAS-联系与区别？" class="headerlink" title="2.3 Synchronized 和 CAS 联系与区别？"></a>2.3 <strong>Synchronized 和 CAS 联系与区别？</strong></h2><ul>
<li><strong>总括：</strong><u>简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）。</u></li>
<li><strong>使用场景选择</strong>：<ul>
<li>对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</li>
<li>对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</li>
</ul>
</li>
<li><strong>补充</strong>： Java并发编程这个领域中synchronized关键字一直都是元老级的角色，很久之前很多人都会称它为 “重量级锁” 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 偏向锁 和 轻量级锁 以及其它各种优化之后变得在某些情况下并不是那么重了。synchronized的底层实现主要依靠 Lock-Free 的队列，基本思路是 自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - Synchronized 几种使用方式</title>
    <url>/2020/03/31/java-bing-fa-synchronized-ji-chong-shi-yong-fang-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-概括"><a href="#1-概括" class="headerlink" title="1.概括"></a>1.概括</h1><p>Synchronized 可以有几种修饰方法，总体使用如下图所示：</p>
<p><img src="https://i.loli.net/2020/03/31/HiZIwJm32rGoFPv.png" alt="image.png"></p>
<a id="more"></a>

<h1 id="2-具体使用"><a href="#2-具体使用" class="headerlink" title="2.具体使用"></a>2.具体使用</h1><h2 id="2-1-修饰代码块"><a href="#2-1-修饰代码块" class="headerlink" title="2.1 修饰代码块"></a>2.1 <strong>修饰代码块</strong></h2><p>指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</p>
<ul>
<li>注意：<u>它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步</u>。和 synchronized 方法一样，synchronized(this)代码块也是锁定当前对象的。synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。这里再提一下：synchronized关键字加到非 static 静态方法上是给对象实例上锁。另外需要注意的是：尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓冲功能！</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="2-2-修饰实例方法"><a href="#2-2-修饰实例方法" class="headerlink" title="2.2 修饰实例方法"></a>2.2 <strong>修饰实例方法</strong></h2><ul>
<li>作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁。</li>
<li>注意：它和同步代码块一样，作用于同一个对象。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="2-3-同步一个类"><a href="#2-3-同步一个类" class="headerlink" title="2.3 同步一个类"></a>2.3 <strong>同步一个类</strong></h2><ul>
<li>注意：作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">synchronized</span> (SynchronizedExample<span class="class">.<span class="keyword">class</span>)</span>{</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="2-4-修饰静态方法"><a href="#2-4-修饰静态方法" class="headerlink" title="2.4 修饰静态方法"></a>2.4 <strong>修饰静态方法</strong></h2><p>作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁 。</p>
<ul>
<li>注意：作用于整个类。也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份，所以对该类的所有对象都加了锁）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> synchronzied <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span> <span class="params">()</span></span>{</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Synchronized 修饰静态方法相当于如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>{</span><br><span class="line">    <span class="comment">// 修饰静态方法</span></span><br><span class="line">    <span class="keyword">synchronized</span>(X<span class="class">.<span class="keyword">class</span>) <span class="title">static</span> <span class="title">void</span> <span class="title">bar</span>()</span>{</span><br><span class="line">        <span class="comment">// 临界区</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - Synchronized 原理分析</title>
    <url>/2020/03/31/java-bing-fa-synchronized-yuan-li-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><p>JDK1.6 之后 Synchronized  的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。</p>
<p>Java中的<code>synchronized</code> 的偏向锁、轻量级锁、重量级锁三种形式，分别对应了锁只被一个线程持有、不同线程交替持有锁、多线程竞争锁三种情况。当条件不满足时，锁会按偏向锁-&gt;轻量级锁-&gt;重量级锁 的顺序升级。JVM种的锁也是能降级的，只不过条件很苛刻，可以相当于没有了，策略是为了提高获得锁和释放锁的效率。</p>
<p>所以对Synchronized 的重点分析应该是其升级流程，以前是我觉得So easy，不就这几个状态升上去而已，不过在某天看了 <a href="https://github.com/farmerjohngit/myblog/issues/12" target="_blank" rel="noopener">死磕Synchronized底层实现</a> 之后，发现我还是太嫩了，这才是真正的深入，也许对知识的求知就该如此不断的进行深入，对于Synchronized 还是有很多值得发现的知识，以下记录了学习到的一些笔记，大概对一整个锁的升级流程有了一些认识和了解。</p>
<ul>
<li>锁升级的过程可以具体看该图，大致的流程框架图很清晰（文末已注明出处）</li>
</ul>
<p><img src="https://i.loli.net/2020/03/31/nCGAmlfKqzhjdv1.png" alt="Synchronized锁升级流程图"></p>
<a id="more"></a>

<hr>
<h1 id="2-Synchronized-锁升级流程分析"><a href="#2-Synchronized-锁升级流程分析" class="headerlink" title="2.Synchronized 锁升级流程分析"></a>2.Synchronized 锁升级流程分析</h1><h2 id="2-1-偏向锁"><a href="#2-1-偏向锁" class="headerlink" title="2.1 偏向锁"></a>2.1 <strong>偏向锁</strong></h2><ul>
<li><p><strong>目的：</strong>引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径。但是不同是：轻量级锁在无竞争的情况下使用 <code>CAS</code> 操作去代替使用互斥量，而偏向锁在无竞争的情况下会把整个同步都消除掉。那么偏向锁是如何来减少不必要的<code>CAS</code>操作呢？我们可以查看<code>Mark work</code>的结构就明白了。只需要检查是否为偏向锁、锁标识为以及<code>ThreadID</code>即可。</p>
</li>
<li><ul>
<li>注意：Java并发编程的艺术中是这么讲的：HotSpot[1]的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。</li>
</ul>
</li>
<li><p><strong>定义：</strong>偏向锁的“偏”就是偏心的偏，它的意思是会偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步！关于偏向锁的原理可以查看《深入理解Java虚拟机：JVM高级特性与最佳实践》第二版的13章第三节锁优化。当<code>JVM</code>启用了偏向锁模式（<code>JDK6</code>以上默认开启），新创建对象的Mark Word中的<code>Thread Id</code>为0，说明此时处于可偏向但未偏向任何线程，也叫<strong>做匿名偏向状态(anonymously biased)。</strong></p>
</li>
<li><p><strong>适用场合：</strong>但是对于锁竞争比较激烈的场合，偏向锁就失效了，<strong>因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失</strong>，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。</p>
</li>
<li><p><strong>关闭偏向锁：</strong>偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用<code>JVM</code>参数来关闭延迟：<code>-XX:BiasedLockingStartupDelay</code>=0。如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过<code>JVM</code>参数关闭偏向锁：<code>-XX:-UseBiasedLocking</code>=false，那么程序默认会进入轻量级锁状态。</p>
</li>
</ul>
<h3 id="2-1-1-Mark-Work-结构"><a href="#2-1-1-Mark-Work-结构" class="headerlink" title="2.1.1 Mark Work 结构"></a>2.1.1 Mark Work 结构</h3><p>关于<code>Mark work</code>结构，可以在任何一本关于Java内存结构的书中了解到很详细了，我们主要关注的是下面的几个字段：<code>thread id</code>、lock flag、biased lock flag。</p>
<p><img src="https://i.loli.net/2020/03/31/tBr7NFPumz63acj.png" alt="image.png"></p>
<h3 id="2-1-2-对象创建"><a href="#2-1-2-对象创建" class="headerlink" title="2.1.2 对象创建"></a>2.1.2 对象创建</h3><p>当 <code>JVM</code> 启用了偏向锁模式（1.6以上默认开启），当新创建一个对象的时候，如果该对象所属的class没有关闭偏向锁模式（默认所有class的偏向模式都是是开启的），那新创建对象的<code>mark word</code>将是可偏向状态，此时mark word中的thread id（参见上文偏向状态下的<code>mark word</code>格式）为0，表示未偏向任何线程，也叫做<u>匿名偏向(anonymously biased)</u>。</p>
<h3 id="2-1-3-偏向锁加锁"><a href="#2-1-3-偏向锁加锁" class="headerlink" title="2.1.3 偏向锁加锁"></a>2.1.3 偏向锁加锁</h3><p>对于偏向锁的加锁，主要分为三种不同情况来看：</p>
<ul>
<li><code>case 1</code>：当该对象第一次被线程获得锁的时候，发现是匿名偏向状态（可偏向未锁定），则会用CAS指令，将<code>mark word</code>中的<code>thread id</code>由0改成当前线程Id。如果成功，则代表获得了偏向锁，继续执行同步块中的代码。否则，即<code>CAS</code>竞争锁失败，对象锁已经被其他线程占用，证明当前存在多线程竞争情况，当到达全局安全点（即为<code>safepoint</code>，<code>safepoint</code>是什么可以具体参考这篇文章：<a href="https://blog.csdn.net/iter_zc/article/details/41847887" target="_blank" rel="noopener">聊聊JVM（六）理解JVM的safepoint</a>），将偏向锁撤销，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块；</li>
<li><code>case 2</code>：当被偏向的线程再次进入同步块时，发现锁对象偏向的就是当前线程（对象头Mark Word中Thread Id是当前线程ID），在通过一些额外的检查后（细节见后面的文章），会往当前线程的栈中添加一条Displaced Mark Word为空的Lock Record中，用来统计重入的次数（如图为当对象所处于偏向锁时，当前线程重入3次，线程栈帧中Lock Record记录）。然后继续执行同步块的代码，因为操纵的是线程私有的栈，因此不需要用到CAS指令；由此可见偏向锁模式下，当被偏向的线程再次尝试获得锁时，仅仅进行几个简单的操作就可以了，在这种情况下，synchronized关键字带来的性能开销基本可以忽略。<ul>
<li><img src="https://i.loli.net/2020/03/31/AtEPUg6GSiOurk3.png" alt="线程栈帧"></li>
</ul>
</li>
<li>case 3.当其他线程进入同步块时，发现已经有偏向的线程了，则会进入到撤销偏向锁的逻辑里，一般来说，会在<code>safepoint</code>中去查看偏向的线程是否还存活，如果存活且还在同步块中则将锁升级为轻量级锁，原偏向的线程继续拥有锁，当前线程则走入到锁升级的逻辑里；如果偏向的线程已经不存活或者不在同步块中，则将对象头的<code>mark word</code>改为无锁状态（<code>unlocked</code>），之后再升级为轻量级锁。</li>
</ul>
<p>由此可见，偏向锁升级的时机为：当锁已经发生偏向后，只要有另一个线程尝试获得偏向锁，则该偏向锁就会升级成轻量级锁。当然这个说法不绝对，因为还有批量重偏向这一机制。</p>
<h3 id="2-1-4-偏向锁解锁"><a href="#2-1-4-偏向锁解锁" class="headerlink" title="2.1.4 偏向锁解锁"></a>2.1.4 偏向锁解锁</h3><p>当有其他线程尝试获得锁时，是根据遍历偏向线程的<code>lock record</code>来确定该线程是否还在执行同步块中的代码。因此偏向锁的解锁很简单，仅仅将栈中的最近一条<code>lock record</code>的obj字段设置为null。需要注意的是，偏向锁的解锁步骤中并不会修改对象头中的<code>thread id</code>。</p>
<h3 id="2-1-5-偏向锁获取锁"><a href="#2-1-5-偏向锁获取锁" class="headerlink" title="2.1.5 偏向锁获取锁"></a>2.1.5 偏向锁获取锁</h3><p><strong>取自Java并发编程的艺术：</strong></p>
<ol>
<li>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行<code>CAS</code>操作来加锁和解锁，只需简单地测试一下对象头的<code>Mark Word</code>里是否存储着指向当前线程的偏向锁。</li>
<li>如果测试成功，表示线程已经获得了锁。</li>
<li>如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS<code>竞争</code>锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程</li>
</ol>
<p>网上参考了很多文章，发现说辞不一，十分混乱，大部分都各持己见，这让我看得很晕乎，于是还是更相信底层代码的逻辑，查看官方提供给的 JVM 底层C++代码： <a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/interpreter/bytecodeInterpreter.cpp#l1816" target="_blank" rel="noopener">bytecodeInterpreter.cpp#1816</a>，结合 <a href="https://github.com/farmerjohngit/myblog" target="_blank" rel="noopener">farmerjohngit</a> 大佬所给的一些解释，可以对整个底层实现有更加深刻的理解。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">CASE(_monitorenter): {</span><br><span class="line">  <span class="comment">// lockee 就是锁对象</span></span><br><span class="line">  oop lockee = STACK_OBJECT(<span class="number">-1</span>);</span><br><span class="line">  <span class="comment">// derefing's lockee ought to provoke implicit null check</span></span><br><span class="line">  CHECK_NULL(lockee);</span><br><span class="line">  <span class="comment">// code 1：找到一个空闲的Lock Record</span></span><br><span class="line">  BasicObjectLock* limit = istate-&gt;monitor_base();</span><br><span class="line">  BasicObjectLock* most_recent = (BasicObjectLock*) istate-&gt;stack_base();</span><br><span class="line">  BasicObjectLock* entry = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">while</span> (most_recent != limit ) {</span><br><span class="line">    <span class="keyword">if</span> (most_recent-&gt;obj() == <span class="literal">NULL</span>) entry = most_recent;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (most_recent-&gt;obj() == lockee) <span class="keyword">break</span>;</span><br><span class="line">    most_recent++;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">//entry不为null，代表还有空闲的Lock Record</span></span><br><span class="line">  <span class="keyword">if</span> (entry != <span class="literal">NULL</span>) {</span><br><span class="line">    <span class="comment">// code 2：将Lock Record的obj指针指向锁对象</span></span><br><span class="line">    entry-&gt;set_obj(lockee);</span><br><span class="line">    <span class="keyword">int</span> success = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">uintptr_t</span> epoch_mask_in_place = (<span class="keyword">uintptr_t</span>)markOopDesc::epoch_mask_in_place;</span><br><span class="line">	<span class="comment">// markoop即对象头的mark word</span></span><br><span class="line">    markOop mark = lockee-&gt;mark();</span><br><span class="line">    <span class="keyword">intptr_t</span> hash = (<span class="keyword">intptr_t</span>) markOopDesc::no_hash;</span><br><span class="line">    <span class="comment">// code 3：如果锁对象的mark word的状态是偏向模式</span></span><br><span class="line">    <span class="keyword">if</span> (mark-&gt;has_bias_pattern()) {</span><br><span class="line">      <span class="keyword">uintptr_t</span> thread_ident;</span><br><span class="line">      <span class="keyword">uintptr_t</span> anticipated_bias_locking_value;</span><br><span class="line">      thread_ident = (<span class="keyword">uintptr_t</span>)istate-&gt;thread();</span><br><span class="line">     <span class="comment">// code 4：这里有几步操作，下文分析</span></span><br><span class="line">      anticipated_bias_locking_value =</span><br><span class="line">        (((<span class="keyword">uintptr_t</span>)lockee-&gt;klass()-&gt;prototype_header() | thread_ident) ^ (<span class="keyword">uintptr_t</span>)mark) &amp;</span><br><span class="line">        ~((<span class="keyword">uintptr_t</span>) markOopDesc::age_mask_in_place);</span><br><span class="line">	 <span class="comment">// code 5：如果偏向的线程是自己且epoch等于class的epoch</span></span><br><span class="line">      <span class="keyword">if</span>  (anticipated_bias_locking_value == <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// already biased towards this thread, nothing to do</span></span><br><span class="line">        <span class="keyword">if</span> (PrintBiasedLockingStatistics) {</span><br><span class="line">          (* BiasedLocking::biased_lock_entry_count_addr())++;</span><br><span class="line">        }</span><br><span class="line">        success = <span class="literal">true</span>;</span><br><span class="line">      }</span><br><span class="line">       <span class="comment">// code 6：如果偏向模式关闭，则尝试撤销偏向锁</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((anticipated_bias_locking_value &amp; markOopDesc::biased_lock_mask_in_place) != <span class="number">0</span>) {</span><br><span class="line">        markOop header = lockee-&gt;klass()-&gt;prototype_header();</span><br><span class="line">        <span class="keyword">if</span> (hash != markOopDesc::no_hash) {</span><br><span class="line">          header = header-&gt;copy_set_hash(hash);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 利用CAS操作将mark word替换为class中的mark word</span></span><br><span class="line">        <span class="keyword">if</span> (Atomic::cmpxchg_ptr(header, lockee-&gt;mark_addr(), mark) == mark) {</span><br><span class="line">          <span class="keyword">if</span> (PrintBiasedLockingStatistics)</span><br><span class="line">            (*BiasedLocking::revoked_lock_entry_count_addr())++;</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">         <span class="comment">// code 7：如果epoch不等于class中的epoch，则尝试重偏向</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((anticipated_bias_locking_value &amp; epoch_mask_in_place) !=<span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 构造一个偏向当前线程的mark word</span></span><br><span class="line">        markOop new_header = (markOop) ( (<span class="keyword">intptr_t</span>) lockee-&gt;klass()-&gt;prototype_header() | thread_ident);</span><br><span class="line">        <span class="keyword">if</span> (hash != markOopDesc::no_hash) {</span><br><span class="line">          new_header = new_header-&gt;copy_set_hash(hash);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// CAS替换对象头的mark word  </span></span><br><span class="line">        <span class="keyword">if</span> (Atomic::cmpxchg_ptr((<span class="keyword">void</span>*)new_header, lockee-&gt;mark_addr(), mark) == mark) {</span><br><span class="line">          <span class="keyword">if</span> (PrintBiasedLockingStatistics)</span><br><span class="line">            (* BiasedLocking::rebiased_lock_entry_count_addr())++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">          <span class="comment">// 重偏向失败，代表存在多线程竞争，则调用monitorenter方法进行锁升级</span></span><br><span class="line">          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);</span><br><span class="line">        }</span><br><span class="line">        success = <span class="literal">true</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span> {</span><br><span class="line">         <span class="comment">// 走到这里说明当前要么偏向别的线程，要么是匿名偏向（即没有偏向任何线程）</span></span><br><span class="line">       	<span class="comment">// code 8：下面构建一个匿名偏向的mark word，尝试用CAS指令替换掉锁对象的mark word</span></span><br><span class="line">        markOop header = (markOop) ((<span class="keyword">uintptr_t</span>) mark &amp; ((<span class="keyword">uintptr_t</span>)markOopDesc::biased_lock_mask_in_place |(<span class="keyword">uintptr_t</span>)markOopDesc::age_mask_in_place |epoch_mask_in_place));</span><br><span class="line">        <span class="keyword">if</span> (hash != markOopDesc::no_hash) {</span><br><span class="line">          header = header-&gt;copy_set_hash(hash);</span><br><span class="line">        }</span><br><span class="line">        markOop new_header = (markOop) ((<span class="keyword">uintptr_t</span>) header | thread_ident);</span><br><span class="line">        <span class="comment">// debugging hint</span></span><br><span class="line">        DEBUG_ONLY(entry-&gt;lock()-&gt;set_displaced_header((markOop) (<span class="keyword">uintptr_t</span>) <span class="number">0xdeaddead</span>);)</span><br><span class="line">        <span class="keyword">if</span> (Atomic::cmpxchg_ptr((<span class="keyword">void</span>*)new_header, lockee-&gt;mark_addr(), header) == header) {</span><br><span class="line">           <span class="comment">// CAS修改成功</span></span><br><span class="line">          <span class="keyword">if</span> (PrintBiasedLockingStatistics)</span><br><span class="line">            (* BiasedLocking::anonymously_biased_lock_entry_count_addr())++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">          <span class="comment">// 如果修改失败说明存在多线程竞争，所以进入monitorenter方法</span></span><br><span class="line">          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);</span><br><span class="line">        }</span><br><span class="line">        success = <span class="literal">true</span>;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果偏向线程不是当前线程或没有开启偏向模式等原因都会导致success==false</span></span><br><span class="line">    <span class="keyword">if</span> (!success) {</span><br><span class="line">      <span class="comment">// 轻量级锁的逻辑</span></span><br><span class="line">      <span class="comment">//code 9: 构造一个无锁状态的Displaced Mark Word，并将Lock Record的lock指向它</span></span><br><span class="line">      markOop displaced = lockee-&gt;mark()-&gt;set_unlocked();</span><br><span class="line">      entry-&gt;lock()-&gt;set_displaced_header(displaced);</span><br><span class="line">      <span class="comment">//如果指定了-XX:+UseHeavyMonitors，则call_vm=true，代表禁用偏向锁和轻量级锁</span></span><br><span class="line">      <span class="keyword">bool</span> call_vm = UseHeavyMonitors;</span><br><span class="line">      <span class="comment">// 利用CAS将对象头的mark word替换为指向Lock Record的指针</span></span><br><span class="line">      <span class="keyword">if</span> (call_vm || Atomic::cmpxchg_ptr(entry, lockee-&gt;mark_addr(), displaced) != displaced) {</span><br><span class="line">        <span class="comment">// 判断是不是锁重入</span></span><br><span class="line">        <span class="keyword">if</span> (!call_vm &amp;&amp; THREAD-&gt;is_lock_owned((address) displaced-&gt;clear_lock_bits())) {		<span class="comment">//code 10: 如果是锁重入，则直接将Displaced Mark Word设置为null</span></span><br><span class="line">          entry-&gt;lock()-&gt;set_displaced_header(<span class="literal">NULL</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    UPDATE_PC_AND_TOS_AND_CONTINUE(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">// lock record不够，重新执行</span></span><br><span class="line">    istate-&gt;set_msg(more_monitors);</span><br><span class="line">    UPDATE_PC_AND_RETURN(<span class="number">0</span>); <span class="comment">// Re-execute</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>JVM中的每个类也有一个类似mark word的prototype_header，用来标记该class的epoch和偏向开关等信息。上面的代码中<code>lockee-&gt;klass()-&gt;prototype_header()</code>即获取class的prototype_header。</p>
<p><code>code 1</code></p>
<ul>
<li>从当前线程的栈中找到一个空闲的<code>Lock Record</code>（<strong>即代码中的BasicObjectLock，下文都用Lock Record代指</strong>），判断<code>Lock Record</code>是否空闲的依据是其obj字段 是否为null。注意这里是按内存地址从低往高找到最后一个可用的<code>Lock Record</code>，换而言之，就是找到内存地址最高的可用<code>Lock Record</code>。</li>
</ul>
<p><code>code 2</code></p>
<ul>
<li>获取到<code>Lock Record</code>后，首先要做的就是为其obj字段赋值。</li>
</ul>
<p><code>code 3</code></p>
<ul>
<li>判断锁对象的<code>mark word</code>是否是偏向模式，即低3位是否为101。</li>
</ul>
<p><code>code 4</code></p>
<ul>
<li>这里有几步位运算的操作<code>anticipated_bias_locking_value = (((uintptr_t)lockee-&gt;klass()-&gt;prototype_header() | thread_ident) ^ (uintptr_t)mark) &amp;  ~((uintptr_t) markOopDesc::age_mask_in_place);</code> 这个位运算可以分为3个部分。<ul>
<li>第一部分<code>((uintptr_t)lockee-&gt;klass()-&gt;prototype_header() | thread_ident)</code> 将当前线程id和类的prototype_header相或，这样得到的值为（当前线程id + prototype_header中的（epoch + 分代年龄 + 偏向锁标志 + 锁标志位）），注意prototype_header的分代年龄那4个字节为0</li>
<li>第二部分 <code>^ (uintptr_t)mark</code> 将上面计算得到的结果与锁对象的markOop进行异或，相等的位全部被置为0，只剩下不相等的位。</li>
<li>第三部分 <code>&amp; ~((uintptr_t) markOopDesc::age_mask_in_place)</code> markOopDesc::age_mask_in_place为…0001111000,取反后，变成了…1110000111,除了分代年龄那4位，其他位全为1；将取反后的结果再与上面的结果相与，将上面异或得到的结果中分代年龄给忽略掉。</li>
</ul>
</li>
</ul>
<p><code>code 5</code></p>
<ul>
<li><code>anticipated_bias_locking_value==0</code>代表偏向的线程是当前线程且<code>mark word</code>的epoch等于class的epoch，这种情况下什么都不用做。</li>
</ul>
<p><code>code 6</code></p>
<ul>
<li><p><code>(anticipated_bias_locking_value &amp; markOopDesc::biased_lock_mask_in_place) != 0</code>代表class的prototype_header或对象的<code>mark word</code>中偏向模式是关闭的，又因为能走到这已经通过了<code>mark-&gt;has_bias_pattern()</code>判断，即对象的<code>mark word</code>中偏向模式是开启的，那也就是说class的prototype_header不是偏向模式。</p>
</li>
<li><p>然后利用<code>CAS</code>指令<code>Atomic::cmpxchg_ptr(header, lockee-&gt;mark_addr(), mark) == mark</code>撤销偏向锁，我们知道<code>CAS</code>会有几个参数，1是预期的原值，2是预期修改后的值 ，3是要修改的对象，与之对应，<code>cmpxchg_ptr</code>方法第一个参数是预期修改后的值，第2个参数是修改的对象，第3个参数是预期原值，方法返回实际原值，如果等于预期原值则说明修改成功。</p>
</li>
</ul>
<p><code>code 7</code></p>
<ul>
<li>如果epoch已过期，则需要重偏向，利用CAS指令将锁对象的<code>mark word</code>替换为一个偏向当前线程且epoch为类的epoch的新的<code>mark word</code>。</li>
</ul>
<p><code>code 8</code></p>
<ul>
<li>CAS将偏向线程改为当前线程，如果当前是匿名偏向则能修改成功，否则进入锁升级的逻辑。</li>
</ul>
<p><code>code 9</code></p>
<ul>
<li>这一步已经是轻量级锁的逻辑了。从上图的<code>mark word</code>的格式可以看到，轻量级锁中<code>mark word</code>存的是指向<code>Lock Record</code>的指针。这里构造一个无锁状态的<code>mark word</code>，然后存储到<code>Lock Record</code>（<code>Lock Record</code>的格式可以看第一篇文章）。设置<code>mark word</code>是无锁状态的原因是：轻量级锁解锁时是将对象头的<code>mark word</code>设置为<code>Lock Record</code>中的<code>Displaced Mark Word</code>，所以创建时设置为无锁状态，解锁时直接用CAS替换就好了。</li>
</ul>
<p><code>code 10</code></p>
<ul>
<li>如果是锁重入，则将<code>Lock Record</code>的<code>Displaced Mark Word</code>设置为null，起到一个锁重入计数的作用。</li>
</ul>
<p>通过这部分代码，其实可以对偏向锁加锁的流程（包括部分轻量级锁的加锁流程）有一定的认识了，如果当前锁已偏向其他线程||epoch值过期||偏向模式关闭||获取偏向锁的过程中存在并发冲突，都会进入到<code>InterpreterRuntime::monitorenter</code>方法， 在该方法中会对偏向锁撤销和升级。</p>
<h3 id="2-1-6-偏向锁释放"><a href="#2-1-6-偏向锁释放" class="headerlink" title="2.1.6 偏向锁释放"></a>2.1.6 偏向锁释放</h3><p>偏向锁的释放入口：<a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/interpreter/bytecodeInterpreter.cpp#l1923" target="_blank" rel="noopener">bytecodeInterpreter.cpp#1923</a></p>
<p>上面的代码结合注释理解起来应该不难，偏向锁的释放很简单，只要将对应Lock Record释放就好了，而轻量级锁则需要将Displaced Mark Word替换到对象头的mark word中。如果CAS失败或者是重量级锁则进入到<code>InterpreterRuntime::monitorexit</code>方法中。</p>
<ul>
<li>注意：撤销是指在获取偏向锁的过程因为不满足条件导致要将锁对象改为非偏向锁状态；释放是指退出同步块时的过程</li>
</ul>
<h3 id="2-1-7-偏向锁撤销"><a href="#2-1-7-偏向锁撤销" class="headerlink" title="2.1.7 偏向锁撤销"></a>2.1.7 偏向锁撤销</h3><p>偏向锁的撤销采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）。其步骤如下：</p>
<ol>
<li>暂停拥有偏向锁的线程，检查持有偏向锁的线程状态（遍历当前<code>JVM</code>的所有线程，如果能找到，则说明偏向的线程还存活）；<code>JVM</code>维护了一个集合存放所有存活的线程，通过遍历该集合判断某个线程是否存活。</li>
<li>如果线程还存活，则检查线程是否在执行同步代码块中的代码，如果是，则升级为轻量级锁，进行CAS竞争锁；<ul>
<li>注：每次进入同步块（即执行<code>monitorenter</code>）的时候都会以从高往低的顺序在栈中找到第一个可用的<code>Lock Record</code>，并设置偏向线程ID；每次解锁（即执行<code>monitorexit</code>）的时候都会从最低的一个<code>Lock Record</code>移除。所以如果能找到对应的Lock Record说明偏向的线程还在执行同步代码块中的代码。</li>
</ul>
</li>
<li>如果持有偏向锁的线程未存活，或者持有偏向锁的线程未在执行同步代码块中的代码，则进行校验是否允许重偏向：<ul>
<li>如果不允许重偏向，则撤销偏向锁，将<code>Mark Word</code>设置为无锁状态（未锁定不可偏向状态），然后升级为轻量级锁，进行CAS<code>竞争</code>锁；</li>
<li>如果允许重偏向，设置为匿名偏向锁状态,<code>CAS</code>将偏向锁重新指向线程A（在对象头和线程栈帧的锁记录中存储当前线程ID）；</li>
</ul>
</li>
<li>唤醒暂停的线程，从安全点继续执行代码。</li>
</ol>
<p>偏向锁撤销的具体流程如下所示：</p>
<p><img src="https://i.loli.net/2020/03/31/EUIOaiTgNluLqzw.png" alt="偏向锁撤销流程图"></p>
<p>偏向锁撤销的具体底层代码分析如下：</p>
<h3 id="2-1-8-批量重偏向与撤销"><a href="#2-1-8-批量重偏向与撤销" class="headerlink" title="2.1.8 批量重偏向与撤销"></a>2.1.8 批量重偏向与撤销</h3><p>JVM中还增加了一种批量重偏向/撤销的机制，主要是解决如下两种情况：</p>
<ol>
<li>重偏向（<code>bulk rebias</code>）机制解决的场景：一个线程创建了大量对象并执行了初始的同步操作，之后在另一个线程中将这些对象作为锁进行之后的操作。这种case下，会导致大量的偏向锁撤销操作。</li>
<li>批量撤销（<code>bulk revoke</code>）解决的场景：存在明显多线程竞争的场景下使用偏向锁是不合适的，例如生产者/消费者队列。</li>
</ol>
<hr>
<h2 id="2-2-轻量级锁"><a href="#2-2-轻量级锁" class="headerlink" title="2.2 轻量级锁"></a>2.2 轻量级锁</h2><ul>
<li><strong>描述：</strong>倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)。== 轻量级锁不是为了代替重量级锁，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量。== 另外，轻量级锁的加锁和解锁都用到了CAS操作。 关于轻量级锁的加锁和解锁的原理可以查看《深入理解Java虚拟机：JVM高级特性与最佳实践》第二版的13章第三节锁优化。</li>
<li><strong>轻量级锁能够提升程序同步性能的依据：</strong>“对于绝大部分锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用 <code>CAS</code> 操作避免了使用互斥操作的开销。但如果存在锁竞争，除了互斥量开销外，还会额外发生<code>CAS</code>操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁！</li>
</ul>
<h3 id="2-2-1-轻量级锁获取锁"><a href="#2-2-1-轻量级锁获取锁" class="headerlink" title="2.2.1 轻量级锁获取锁"></a>2.2.1 轻量级锁获取锁</h3><p>其获取锁步骤如下：</p>
<ol>
<li>判断当前对象是否处于无锁状态（<code>hashcode</code>、0、01），若是，则JVM首先将在当前线程的栈帧中建立一个名为锁记录（<code>Lock Record</code>）的空间，用于存储锁对象目前的Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即<code>Displaced Mark Word</code>）；否则执行步骤（3）；</li>
<li><code>JVM</code>利用<code>CAS</code>操作尝试将对象的<code>Mark Word</code>更新为指向<code>Lock Record</code>的指正，如果成功表示竞争到锁，则将锁标志位变成00（表示此对象处于轻量级锁状态），执行同步操作；如果失败则执行步骤（3）；</li>
<li>判断当前对象的<code>Mark Word</code>是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态；</li>
</ol>
<p>栈帧 与 <code>Mark Work</code> 关系图示如下：</p>
<p><img src="https://i.loli.net/2020/03/31/pKTxoGV4clYetOL.png" alt="image.png"></p>
<p>整体流程图示如下：</p>
<p><img src="https://i.loli.net/2020/03/31/dCB5fQcuU49j3Pn.png" alt="image.png"></p>
<p>轻量级锁的锁获取源码：</p>
<h3 id="2-2-2-轻量级锁释放锁"><a href="#2-2-2-轻量级锁释放锁" class="headerlink" title="2.2.2 轻量级锁释放锁"></a>2.2.2 轻量级锁释放锁</h3><p>其释放锁步骤如下（轻量级锁的释放也是通过CAS操作来进行的）：</p>
<ol>
<li>取出在获取轻量级锁保存在<code>Displaced Mark Word</code>中的数据；</li>
<li>用<code>CAS</code>操作将取出的数据替换当前对象的<code>Mark Word</code>中，如果成功，则说明释放锁成功，否则执行（3）；</li>
<li>如果<code>CAS</code>操作替换失败，说明有其他线程尝试获取该锁，则需要在释放锁的同时需要唤醒被挂起的线程。</li>
</ol>
<p>其过程流程图如下所示：</p>
<p><img src="https://i.loli.net/2020/03/31/8WLE1HjunDXfxJO.png" alt="轻量级锁释放锁.png"></p>
<h3 id="2-2-3-轻量级锁膨胀"><a href="#2-2-3-轻量级锁膨胀" class="headerlink" title="2.2.3 轻量级锁膨胀"></a>2.2.3 轻量级锁膨胀</h3><p>其过程流程图如下所示</p>
<p><img src="https://i.loli.net/2020/03/31/QZesVDEtJqmHl9C.png" alt="轻量级锁膨胀.png"></p>
<ul>
<li><strong>一个问题：为什么在撤销轻量级锁的时候会有失败的可能？</strong><ul>
<li>假设<code>thread1</code>拥有了轻量级锁，Mark Word指向<code>thread1</code>栈帧，<code>thread2</code>请求锁的时候，就会膨胀初始化<code>ObjectMonitor</code>对象，将Mark Word更新为指向<code>ObjectMonitor</code>的指针，那么在thread1退出的时候，<code>CAS</code>操作会失败，因为Mark Word不再指向<code>thread1</code>的栈帧，这个时候<code>thread1</code>自旋等待<code>infalte</code>完毕，执行重量级锁的退出操作</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-4-重量级锁"><a href="#2-4-重量级锁" class="headerlink" title="2.4 重量级锁"></a>2.4 重量级锁</h2><ul>
<li>描述：重量级锁通过对象内部的监视器（<code>monitor</code>）实现，其中<code>monitor</code>的本质是依赖于底层操作系统的<code>Mutex Lock</code>实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</li>
</ul>
<hr>
<h1 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h1><h2 id="4-1-总结锁的升级流程："><a href="#4-1-总结锁的升级流程：" class="headerlink" title="4.1 总结锁的升级流程："></a>4.1 总结锁的升级流程：</h2><p>每一个线程在准备获取共享资源时： </p>
<ol>
<li>第一步：检查<code>MarkWord</code>里面是不是放的自己的<code>ThreadId</code> ,如果是，表示当前线程是处于 “偏向锁” 。  </li>
<li>第二步：如果<code>MarkWord</code>不是自己的<code>ThreadId</code>，锁升级，这时候，使用<code>CAS</code>来执行切换，新的线程根据<code>MarkWord</code>里面现有的<code>ThreadId</code>，通知之前线程暂停，之前线程将<code>Markword</code>的内容置为空。</li>
<li>第三步：两个线程都把锁对象的<code>HashCode</code>复制到自己新建的用于存储锁的记录空间，接着开始通过<code>CAS</code>操作， 把锁对象的<code>MarKword</code>的内容修改为自己新建的记录空间的地址的方式竞争<code>MarkWord</code>。  </li>
<li>第四步：第三步中成功执行<code>CAS</code>的获得资源，失败的则进自旋 。</li>
<li>第五步：自旋的线程在自旋过程中，成功获得资源(即之前获的资源的线程执行完成并释放了共享资源)，则整个状态依然处于轻量级锁的状态，如果自旋失败进入第六步 。</li>
<li>第六步：进行重量级锁的状态，这个时候，自旋的线程进行阻塞，等待之前线程执行完成并唤醒自己。</li>
</ol>
<h2 id="4-2-几种锁的优缺点对比"><a href="#4-2-几种锁的优缺点对比" class="headerlink" title="4.2 几种锁的优缺点对比"></a>4.2 几种锁的优缺点对比</h2><p>下图摘自：并发编程的艺术</p>
<p><img src="https://i.loli.net/2020/03/31/8U6mNSjGLeKMrEB.png" alt="image.png"></p>
<p>以上参考文章：</p>
<ul>
<li><a href="https://blog.dreamtobe.cn/2015/11/13/java_synchronized/" target="_blank" rel="noopener">Java Synchronised机制</a></li>
<li><a href="https://github.com/farmerjohngit/myblog/issues/13" target="_blank" rel="noopener">死磕Synchronized底层实现–偏向锁</a></li>
<li><a href="https://blog.csdn.net/iter_zc/article/details/41847887" target="_blank" rel="noopener">聊聊JVM（六）理解JVM的safepoint</a></li>
<li><a href="http://cmsblogs.com/?p=2071" target="_blank" rel="noopener">【死磕Java并发】—–深入分析synchronized的实现原理</a></li>
<li>书籍：Java 并发编程的艺术</li>
<li>书籍：深入理解Java虚拟机：JVM高级特性与最佳实践</li>
<li>书籍：深入浅出Java 多线程</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - 多线程：深入线程池原理</title>
    <url>/2020/03/31/java-bing-fa-duo-xian-cheng-shen-ru-xian-cheng-chi-yuan-li/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-线程池简介"><a href="#1-线程池简介" class="headerlink" title="1.线程池简介"></a>1.线程池简介</h1><h2 id="1-1-线程池是什么？"><a href="#1-1-线程池是什么？" class="headerlink" title="1.1 线程池是什么？"></a>1.1 线程池是什么？</h2><p>线程池（Thread Pool）是一种基于池化思想管理线程的工具，经常出现在多线程服务器中，如MySQL。</p>
<p>线程池可以简单看做是一组线程的集合，通过使用线程池，我们可以方便的复用线程，避免了频繁创建和销毁线程所带来的开销。在应用上，线程池可应用在后端相关服务中。比如 Web 服务器，数据库服务器等。以 Web 服务器为例，假如 Web 服务器会收到大量短时的 HTTP 请求，如果此时我们简单的为每个 HTTP 请求创建一个处理线程，那么服务器的资源将会很快被耗尽。当然我们也可以自己去管理并复用已创建的线程，以限制资源的消耗量，但这样会使用程序的逻辑变复杂。好在，幸运的是，我们不必那样做。在 JDK 1.5 中，官方已经提供了强大的线程池工具类。通过使用这些工具类，我们可以用低廉的代价使用多线程技术。</p>
<p>线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。线程池维护多个线程，等待监督管理者分配可并发执行的任务。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。</p>
<a id="more"></a>



<h2 id="1-2-为什么要使用线程池？"><a href="#1-2-为什么要使用线程池？" class="headerlink" title="1.2 为什么要使用线程池？"></a>1.2 为什么要使用线程池？</h2><p>使用线程池主要有以下三个原因：</p>
<ol>
<li><p>创建/销毁线程需要消耗系统资源，线程池可以<strong>复用已创建的线程</strong>。</p>
<blockquote>
<p>例如：</p>
<p>记创建线程消耗时间T1，执行任务消耗时间T2，销毁线程消耗时间T3</p>
<p>如果T1+T3&gt;T2，那么是不是说开启一个线程来执行这个任务太不划算了！</p>
<p>正好，线程池缓存线程，可用已有的闲置线程来执行新任务，避免了T1+T3带来的系统开销</p>
</blockquote>
</li>
<li><p><strong>控制并发的数量</strong>。并发数量过多，可能会导致资源消耗过多，从而造成服务器崩溃。（主要原因）</p>
<blockquote>
<p>我们知道线程能共享系统资源，如果同时执行的线程过多，就有可能导致系统资源不足而产生阻塞的情况</p>
<p>运用线程池能有效的控制线程最大并发数，避免以上的问题</p>
</blockquote>
</li>
<li><p><strong>可以对线程做统一管理</strong></p>
<blockquote>
<p>比如：延时执行、定时循环执行的策略等</p>
<p>运用线程池都能进行很好的实现</p>
</blockquote>
</li>
</ol>
<p>线程池带来的一系列好处：</p>
<ol>
<li><strong>降低资源消耗</strong>：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。</li>
<li><strong>提高响应速度</strong>：任务到达时，无需等待线程创建即可立即执行。</li>
<li><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。</li>
<li><strong>提供更多更强大的功能</strong>：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池<code>ScheduledThreadPoolExecutor</code>，就允许任务延期执行或定期执行。</li>
</ol>
<h2 id="1-3-线程池解决的问题是什么？"><a href="#1-3-线程池解决的问题是什么？" class="headerlink" title="1.3 线程池解决的问题是什么？"></a>1.3 线程池解决的问题是什么？</h2><p><strong>线程池解决的核心问题就是资源管理问题</strong>。在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入。这种不确定性将带来以下若干问题：</p>
<ol>
<li>频繁申请/销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。</li>
<li>对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。</li>
<li>系统无法合理管理内部的资源分布，会降低系统的稳定性。</li>
</ol>
<p>为解决资源分配这个问题，线程池采用了“池化”（Pooling）思想。池化，顾名思义，是为了最大化收益并最小化风险，而将资源统一在一起管理的一种思想。</p>
<blockquote>
<p>Pooling is the grouping together of resources (assets, equipment, personnel, effort, etc.) for the purposes of maximizing advantage or minimizing risk to the users. The term is used in finance, computing and equipment management.——wikipedia</p>
</blockquote>
<p>“池化”思想不仅仅能应用在计算机领域，在金融、设备、人员管理、工作管理等领域也有相关的应用。</p>
<p>在计算机领域中的表现为：统一管理IT资源，包括服务器、存储、和网络资源等等。通过共享资源，使用户在低投入中获益。除去线程池，还有其他比较典型的几种使用策略包括：</p>
<ol>
<li>内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。</li>
<li>连接池(Connection Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。</li>
<li>实例池(Object Pooling)：循环使用对象，减少资源在初始化和释放时的昂贵损耗。</li>
</ol>
<hr>
<h1 id="2-线程池核心设计与实现"><a href="#2-线程池核心设计与实现" class="headerlink" title="2.线程池核心设计与实现"></a>2.线程池核心设计与实现</h1><h2 id="2-1-线程池的总体设计"><a href="#2-1-线程池的总体设计" class="headerlink" title="2.1 线程池的总体设计"></a>2.1 线程池的总体设计</h2><p>Java中的线程池核心实现类是<code>ThreadPoolExecutor</code>，本章基于<code>JDK 1.8</code>的源码来分析Java线程池的核心设计与实现。我们首先来看一下<code>ThreadPoolExecutor</code>的UML类图，了解下<code>ThreadPoolExecutor</code>的继承关系。</p>
<p><img src="https://i.loli.net/2020/04/03/GEHWRmfyZnB1u95.png" alt="线程池UML图"></p>
<p><code>ThreadPoolExecutor</code> 实现的顶层接口是<code>Executor</code>，顶层接口<code>Executor</code>提供了一种思想：将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供<code>Runnable</code>对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。</p>
<p><code>ExecutorService</code> 接口增加了一些能力：</p>
<ol>
<li>扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法；</li>
<li>提供了管控线程池的方法，比如停止线程池的运行。</li>
</ol>
<p><code>AbstractExecutorService</code> 则是上层的抽象类，将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。最下层的实现类<code>ThreadPoolExecutor</code> 实现最复杂的运行部分，<code>ThreadPoolExecutor</code> 将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。</p>
<p><code>ThreadPoolExecutor</code> 是如何运行，如何同时维护线程和执行任务的呢？其运行机制如下图所示：</p>
<p><img src="https://i.loli.net/2020/04/03/jrgxYTBGiMvQOnb.png" alt="ThreadPoolExecutor 机制"></p>
<hr>
<h2 id="2-2-线程池的生命周期管理"><a href="#2-2-线程池的生命周期管理" class="headerlink" title="2.2 线程池的生命周期管理"></a>2.2 线程池的生命周期管理</h2><p>此部分是尤为重要的一点，要了解内部是如何运作的，肯定要了解一些线程的状态是如何设定的。</p>
<p>下面介绍下线程池的运行状态. 线程池一共有五种状态, 分别是：</p>
<ol>
<li><p><strong>RUNNING</strong> ：能接受新提交的任务，并且也能处理阻塞队列中的任务；</p>
</li>
<li><p><strong>SHUTDOWN</strong>：关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。在线程池处于 RUNNING 状态时，调用 <code>shutdown()</code>方法会使线程池进入到该状态。（<code>finalize()</code> 方法在执行过程中也会调用<code>shutdown()</code>方法进入该状态）；</p>
</li>
<li><p><strong>STOP</strong>：不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 <code>shutdownNow()</code> 方法会使线程池进入到该状态；</p>
</li>
<li><p><strong>TIDYING</strong>：如果所有的任务都已终止了，<code>workerCount</code> (有效线程数) 为0，线程池进入该状态后会调用 <code>terminated()</code> 方法进入TERMINATED 状态。</p>
</li>
<li><p><strong>TERMINATED</strong>：在<code>terminated()</code> 方法执行完后进入该状态，默认<code>terminated()</code>方法中什么也没有做。</p>
<p>进入TERMINATED的条件如下：</p>
<ul>
<li>线程池不是RUNNING状态；</li>
<li>线程池状态不是TIDYING状态或TERMINATED状态；</li>
<li>如果线程池状态是SHUTDOWN并且<code>workerQueue</code>为空；</li>
<li><code>workerCount</code>为0；</li>
<li>设置TIDYING状态成功。</li>
</ul>
</li>
</ol>
<p>这五种状态如下所示：</p>
<p><img src="https://i.loli.net/2020/04/03/MKbLGHAohriWvJ2.png" alt="五种运行状态"></p>
<p>下图为线程池的状态转换过程：</p>
<p><img src="https://i.loli.net/2020/04/03/nA6PoyfibGhe149.png" alt="线程池状态转换"></p>
<hr>
<h2 id="2-3-线程池主要的任务执行机制"><a href="#2-3-线程池主要的任务执行机制" class="headerlink" title="2.3 线程池主要的任务执行机制"></a>2.3 线程池主要的任务执行机制</h2><p>主要分为四点进行解析：任务调度、任务缓存、任务申请、任务拒绝</p>
<h3 id="2-3-1-任务调度"><a href="#2-3-1-任务调度" class="headerlink" title="2.3.1 任务调度"></a>2.3.1 任务调度</h3><p>任务调度是线程池的主要入口，当用户提交了一个任务，接下来这个任务将如何执行都是由这个阶段决定的。了解这部分就相当于了解了线程池的核心运行机制。</p>
<p>首先，所有任务的调度都是由execute方法完成的（接下来会分析这个方法），这部分完成的工作是：检查现在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。其执行过程如下：</p>
<ol>
<li>首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。</li>
<li>如果<code>workerCount &lt; corePoolSize</code>，则创建并启动一个线程来执行新提交的任务。</li>
<li>如果<code>workerCount &gt;= corePoolSize</code>，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。</li>
<li>如果<code>workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize</code>，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。</li>
<li>如果<code>workerCount &gt;= maximumPoolSize</code>，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</li>
</ol>
<p>其执行流程如下图所示（参考的是美团团队所写的文章）：</p>
<p><img src="https://i.loli.net/2020/04/03/yUDvVaOl3RWfFgh.png" alt="任务调度执行流程"></p>
<p>需要注意的是，看了很多博客的流程图都没有写有关于线程池状态监测是否为运行状态这一步，于是在上面很有必要补上，有一些博客的流程图画得也挺不错的，以下作为参考：</p>
<p><img src="https://i.loli.net/2020/04/03/VFNAwKU6zLSdhIv.png" alt="线程池执行流程图"></p>
<h3 id="2-3-2-任务缓冲"><a href="#2-3-2-任务缓冲" class="headerlink" title="2.3.2 任务缓冲"></a>2.3.2 任务缓冲</h3><p>任务缓冲模块是线程池能够管理任务的核心部分。线程池的本质是对任务和线程的管理，而做到这一点最关键的思想就是将任务和线程两者解耦，不让两者直接关联，才可以做后续的分配工作。线程池中是以生产者消费者模式，通过一个阻塞队列来实现的。阻塞队列缓存任务，工作线程从阻塞队列中获取任务。</p>
<p>阻塞队列(<code>BlockingQueue</code>)是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p>
<p>阻塞队列作为一个线程池必须要的参数之一，对阻塞队列的一些类别需要认识清楚，比如有界队列和无界队列的区别在哪里？使用无界队列会带来什么影响？这些都是一些使用线程池时候重点的知识点所在。</p>
<p>下图中展示了线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素：</p>
<p><img src="https://i.loli.net/2020/04/03/93vot42lDnyAcpN.png" alt="阻塞队列"></p>
<p>关于阻塞队列的一些知识，接下来我也会进行一个解析，对这几个队列还是需要有所了解的，这里有一个简单的描述表格：</p>
<p><img src="https://i.loli.net/2020/04/03/fitBsSdm9EJQzqD.png" alt="阻塞队列介绍"></p>
<p>线程池主要涉及到的是以下几种阻塞队列：</p>
<ol>
<li>LinkedBlockingQueue：链式阻塞队列，底层数据结构是链表，默认大小是<code>Integer.MAX_VALUE</code>，也可以指定大小。</li>
<li>ArrayBlockingQueue：数组阻塞队列，底层数据结构是数组，需要指定队列的大小。</li>
<li>SynchronousQueue：同步队列，内部容量为0，每个put操作必须等待一个take操作，反之亦然。</li>
<li>DelayQueue：延迟队列，该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素 。</li>
</ol>
<p>关于队列，这里还要BB多几句，线程池主要有以下几种处理方式:</p>
<ol>
<li><p><strong>直接切换</strong>：这种方式常用的队列是<code>SynchronousQueue</code>，但现在还没有研究过该队列，这里暂时还没法介绍；</p>
</li>
<li><p><strong>使用无界队列</strong>：一般使用基于链表的阻塞队列<code>LinkedBlockingQueue</code>。如果使用这种方式，那么线程池中能够创建的最大线程数就是<code>corePoolSize</code>，而<code>maximumPoolSize</code>就不会起作用了（后面也会说到）。当线程池中所有的核心线程都是RUNNING状态时，这时一个新的任务提交就会放入等待队列中。</p>
</li>
<li><p>使用有界队列</p>
<p><strong>使用有界队列</strong>：一般使用<code>ArrayBlockingQueue</code>。使用该方式可以将线程池的最大线程数量限制为<code>maximumPoolSize</code>，这样能够降低资源的消耗，但同时这种方式也使得线程池对线程的调度变得更困难，因为线程池和队列的容量都是有限的值，所以要想使线程池处理任务的吞吐率达到一个相对合理的范围，又想使线程调度相对简单，并且还要尽可能的降低线程池对资源的消耗，就需要合理的设置这两个数量。</p>
<ul>
<li>如果要想降低系统资源的消耗（包括CPU的使用率，操作系统资源的消耗，上下文环境切换的开销等）, 可以设置较大的队列容量和较小的线程池容量, 但这样也会降低线程处理任务的吞吐量。</li>
<li>如果提交的任务经常发生阻塞，那么可以考虑通过调用 <code>setMaximumPoolSize()</code> 方法来重新设定线程池的容量。</li>
<li>如果队列的容量设置的较小，通常需要将线程池的容量设置大一点，这样CPU的使用率会相对的高一些。但如果线程池的容量设置的过大，则在提交的任务数量太多的情况下，并发量会增加，那么线程之间的调度就是一个要考虑的问题，因为这样反而有可能降低处理任务的吞吐量。</li>
</ul>
</li>
</ol>
<p><strong>这里还是有一个疑惑：线程池中使用有限的阻塞队列和无限的阻塞队列的区别？</strong></p>
<p>经过多方面的资料和书籍查找，可以给出如下的答案：</p>
<p>JDK使用了无界队列<code>LinkedBlockingQueue</code>作为<code>WorkQueue</code>而不是有界队列<code>ArrayBlockingQueue</code>，尽管后者可以对资源进行控制，但是个人认为，使用有界队列相比无界队列有三个缺点：</p>
<ul>
<li><strong>性能问题：</strong>使用有界队列，<code>corePoolSize</code>、<code>maximumPoolSize</code>两个参数势必要根据实际场景不断调整以求达到一个最佳，这势必给开发带来极大的麻烦，必须经过大量的性能测试。所以干脆就使用无界队列，任务永远添加到队列中，不会溢出，自然<code>maximumPoolSize</code>也没什么用了，只需要根据系统处理能力调整<code>corePoolSize</code>就可以了；</li>
<li><strong>防止业务突刺：</strong>尤其是在Web应用中，某些时候突然大量请求的到来都是很正常的。这时候使用无界队列，不管早晚，至少保证所有任务都能被处理到。但是使用有界队列呢？那些超出<code>maximumPoolSize</code>的任务直接被丢掉了，处理地慢还可以忍受，但是任务直接就不处理了，这似乎有些糟糕；</li>
<li>不仅仅是<code>corePoolSize</code>和<code>maximumPoolSize</code>需要相互调整，有界队列的队列大小和<code>maximumPoolSize</code>也需要相互折衷，这也是一块比较难以控制和调整的方面。</li>
</ul>
<p>小结：当然，最后还是那句话，就像Java中的各种<code>Comparable</code>和<code>Comparator</code>的对比、<code>synchronized</code>和<code>ReentrantLock</code>对比，再到线程池这里的无界队列和有界队列的对比，看似都有一个的优点稍微突出一些，有些东西的存在一定有他的道理，需要适应的地方去使用，各有各的长处，只是要看处于何处。</p>
<h3 id="2-3-3-任务申请"><a href="#2-3-3-任务申请" class="headerlink" title="2.3.3 任务申请"></a>2.3.3 任务申请</h3><p>由上文的任务分配部分可知，任务的执行有两种可能：一种是任务直接由新创建的线程执行。另一种是线程从任务队列中获取任务然后执行，执行完任务的空闲线程会再次去从队列中申请任务再去执行。第一种情况仅出现在线程初始创建的时候，第二种是线程获取任务绝大多数的情况。</p>
<p>线程需要从任务缓存模块中不断地取任务执行，帮助线程从阻塞队列中获取任务，实现线程管理模块和任务管理模块之间的通信。这部分策略由<code>getTask</code>方法实现，其执行流程如下图所示：</p>
<p><img src="https://i.loli.net/2020/04/03/ZUc6LKwbjSNyuWl.png" alt="任务申请流程图"></p>
<p><code>getTask</code>这部分进行了多次判断，为的是控制线程的数量，使其符合线程池的状态。如果线程池现在不应该持有那么多线程，则会返回null值。工作线程Worker会不断接收新任务去执行，而当工作线程Worker接收不到任务的时候，就会开始被回收。</p>
<p>下面对<code>getTask</code> 会再一次贴上源码，这里只是抛出了这么一个思路，主要是介绍整个任务机制。</p>
<h3 id="2-3-4-任务拒绝"><a href="#2-3-4-任务拒绝" class="headerlink" title="2.3.4 任务拒绝"></a>2.3.4 任务拒绝</h3><p>任务拒绝模块是线程池的保护部分，线程池有一个最大的容量，当线程池的任务缓存队列已满，并且线程池中的线程数目达到<code>maximumPoolSize</code>时，就需要拒绝掉该任务，采取任务拒绝策略，保护线程池。</p>
<p>拒绝策略其实就是一个接口，源码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RejectedExecutionHandler</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>用户可以通过实现这个接口去定制拒绝策略，也可以选择JDK提供的四种已有拒绝策略，其特点如下：</p>
<ul>
<li>hreadPoolExecutor.AbortPolicy：<strong>默认拒绝处理策略</strong>，丢弃任务并直接抛出<code>RejectedExecutionException</code>异常。</li>
<li>ThreadPoolExecutor.DiscardPolicy：丢弃新来的任务，但是不抛出异常。</li>
<li>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列头部（最旧的）的任务，然后重新尝试执行程序（如果再次失败，重复此过程）。</li>
<li>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务。</li>
</ul>
<hr>
<h2 id="2-4-Executor-框架"><a href="#2-4-Executor-框架" class="headerlink" title="2.4 Executor 框架"></a>2.4 Executor 框架</h2><h3 id="2-4-1-Executor-接口"><a href="#2-4-1-Executor-接口" class="headerlink" title="2.4.1 Executor 接口"></a>2.4.1 Executor 接口</h3><p>Java中的线程池顶层接口是Executor接口，<code>ThreadPoolExecutor</code>是这个接口的实现类。所以我们当然要先分析一下Executor 这个框架接口：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Executor接口只有一个execute方法，用来替代通常创建或启动线程的方法。例如，使用Thread来创建并启动线程的代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread();</span><br><span class="line">t.start();</span><br></pre></td></tr></tbody></table></figure>

<p>使用Executor来启动线程执行任务的代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread();</span><br><span class="line">executor.execute(t);</span><br></pre></td></tr></tbody></table></figure>

<p>对于不同的Executor实现，execute()方法可能是创建一个新线程并立即启动，也有可能是使用已有的工作线程来运行传入的任务，也可能是根据设置线程池的容量或者阻塞队列的容量来决定是否要将传入的线程放入阻塞队列中或者拒绝接收传入的线程。</p>
<h3 id="2-4-2-ExecutorService-接口"><a href="#2-4-2-ExecutorService-接口" class="headerlink" title="2.4.2 ExecutorService 接口"></a>2.4.2 ExecutorService 接口</h3><p><code>ExecutorService</code>接口继承自Executor接口，提供了管理终止的方法，以及可为跟踪一个或多个异步任务执行状况而生成 Future 的方法。增加了<code>shutDown()</code>，<code>shutDownNow()</code>，<code>invokeAll()</code>，<code>invokeAny()</code>和<code>submit()</code>等方法。如果需要支持即时关闭，也就是<code>shutDownNow()</code>方法，则任务需要正确处理中断。</p>
<h3 id="2-4-3-ScheduledExecutorService-接口"><a href="#2-4-3-ScheduledExecutorService-接口" class="headerlink" title="2.4.3 ScheduledExecutorService 接口"></a>2.4.3 ScheduledExecutorService 接口</h3><p><code>ScheduledExecutorService</code>扩展<code>ExecutorService</code>接口并增加了<code>schedule</code>方法。调用schedule方法可以在指定的延时后执行一个Runnable或者Callable任务。<code>ScheduledExecutorService</code>接口还定义了按照指定时间间隔定期执行任务的<code>scheduleAtFixedRate()</code>方法和<code>scheduleWithFixedDelay()</code>方法。</p>
<p>注意：记得对比 UML 图进行这几个接口的查看，就知道大概的一个流程了。</p>
<h3 id="2-4-4-Executor-框架详解"><a href="#2-4-4-Executor-框架详解" class="headerlink" title="2.4.4 Executor 框架详解"></a>2.4.4 Executor 框架详解</h3><p>Executor 框架结构(主要由三大部分组成：</p>
<p><strong>1. 任务(Runnable /Callable)</strong></p>
<p>执行任务需要实现的 Runnable 接口 或 Callable接口。Runnable 接口或 Callable 接口 实现类都可以被 <code>ThreadPoolExecutor</code> 或 <code>ScheduledThreadPoolExecutor</code> 执行。</p>
<p><strong>2. 任务的执行(Executor)</strong></p>
<p>上面已经提及到了任务执行机制的核心接口 <code>Executor</code> ，以及继承自 <code>Executor</code> 接口的 <code>ExecutorService</code> 接口。<code>ThreadPoolExecutor</code> 和 <code>ScheduledThreadPoolExecutor</code> 这两个关键类实现了 <code>ExecutorService</code> 接口。</p>
<p>这里提了很多底层的类关系，但是，实际上我们需要更多关注的是 <code>ThreadPoolExecutor</code> 这个类，这个类在我们实际使用线程池的过程中，使用频率还是非常高的，也是接下来重点分析的对象。</p>
<p><strong>3. 异步计算的结果(Future)</strong></p>
<p>Future 接口以及 Future 接口的实现类 <code>FutureTask</code> 类都可以代表异步计算的结果。当我们把 <code>Runnable</code>接口 或 <code>Callable</code> 接口 的实现类提交给 <code>ThreadPoolExecutor</code> 或 <code>ScheduledThreadPoolExecutor</code> 执行。（调用 <code>submit()</code> 方法时会返回一个 <code>FutureTask</code> 对象）</p>
<p><strong>Executor 框架的使用示意图</strong>（摘自 Java 并发编程的艺术）</p>
<p><img src="https://i.loli.net/2020/04/03/IayJADbjuNfYGnx.png" alt="Executor 框架的使用示意图"></p>
<p>其主要过程如下：</p>
<ol>
<li>主线程首先要创建实现 <code>Runnable</code> 或者 <code>Callable</code> 接口的任务对象。</li>
<li>把创建完成的实现 <code>Runnable/Callable</code>接口的对象直接交给 <code>ExecutorService</code> 执行: <code>ExecutorService.execute（Runnable command）</code>）或者也可以把 Runnable 对象或Callable 对象提交给 <code>ExecutorService</code> 执行（<code>ExecutorService.submit（Runnable task）</code>或 <code>ExecutorService.submit（Callable  task）</code>）。</li>
<li>如果执行 <code>ExecutorService.submit（…）</code>，<code>ExecutorService</code> 将返回一个实现Future接口的对象（我们刚刚也提到过了执行 <code>execute()</code>方法和 <code>submit()</code>方法的区别，<code>submit()</code>会返回一个 <code>FutureTask</code> 对象）。由于 <code>FutureTask</code> 实现了 <code>Runnable</code>，我们也可以创建 <code>FutureTask</code>，然后直接交给 <code>ExecutorService</code> 执行。</li>
<li>最后，主线程可以执行 <code>FutureTask.get()</code>方法来等待任务执行完成。主线程也可以执行 <code>FutureTask.cancel（boolean mayInterruptIfRunning）</code>来取消此任务的执行。</li>
</ol>
<p><strong>注意这里有一个问题：执行execute()方法和submit()方法的区别是什么呢？</strong></p>
<p><strong>1.execute()方法：</strong></p>
<ul>
<li>作用：<strong>用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</strong></li>
<li>在Executor中声明的方法，在ThreadPoolExecutor进行了具体的实现，这个方法是ThreadPoolExecutor的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。</li>
</ul>
<p><strong>2.submit()方法：</strong></p>
<ul>
<li>作用：<strong>用于提交需要返回值的任务</strong>。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功，并且可以通过 Future 的 get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 <code>get（long timeout，TimeUnit unit）</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li>
</ul>
<p>在<code>ExecutorService</code>中声明的方法，在<code>AbstractExecutorService</code>就已经有了具体的实现，在<code>ThreadPoolExecutor</code>中并没有对其进行重写，我们以<strong><code>AbstractExecutorService</code></strong>接口中的一个 submit 方法为例子来看看源代码：</p>
<p><img src="https://i.loli.net/2020/04/04/HWAp2dEvkRDntef.png" alt="submit源码"></p>
<p>上面方法调用的 <code>newTaskFor</code> 方法返回了一个 <code>FutureTask</code> 对象。</p>
<p><img src="https://i.loli.net/2020/04/04/9E6utLUh1bKcsp3.png" alt="newTaskFor源码"></p>
<p><code>submit()</code>方法的实现，会发现它实际上还是调用的<code>execute()</code>方法，只不过它利用了Future来获取任务执行结果.</p>
<p><img src="https://i.loli.net/2020/04/04/zTeBZmRNsYMJaco.png" alt="FutureTask源码"></p>
<hr>
<h2 id="2-5-ThreadPoolExecutor-分析"><a href="#2-5-ThreadPoolExecutor-分析" class="headerlink" title="2.5 ThreadPoolExecutor 分析"></a>2.5 ThreadPoolExecutor 分析</h2><h3 id="2-5-1-几个重要字段"><a href="#2-5-1-几个重要字段" class="headerlink" title="2.5.1 几个重要字段"></a>2.5.1 几个重要字段</h3><p>线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，由内部来维护。线程池内部使用一个变量维护两个值：运行状态(<code>runState</code>)和线程数量 (<code>workerCount</code>)。在具体实现中，线程池将运行状态(<code>runState</code>)、线程数量 (<code>workerCount</code>)两个关键参数的维护放在了一起，如下代码所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></tbody></table></figure>

<p><code>ctl</code>这个<code>AtomicInteger</code>类型，是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它同时包含两部分的信息：线程池的运行状态 (<code>runState</code>) 和线程池内有效线程的数量 (<code>workerCount</code>)，高3位保存<code>runState</code>，低29位保存<code>workerCount</code>，两个变量之间互不干扰。<code>COUNT_BITS</code> 就是29，<code>CAPACITY</code>就是1左移29位减1（29个1），这个常量表示<code>workerCount</code>的上限值，大约是5亿。</p>
<p><strong>为什么仅仅使用一个变量去存两个值呢？不分开存储？</strong></p>
<p>用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，不必为了维护两者的一致，而占用锁资源。通过阅读线程池源代码也可以发现，经常出现要同时判断线程池运行状态和线程数量的情况。线程池也提供了若干方法去供用户获得线程池当前的运行状态、线程个数。这里都使用的是位运算的方式，相比于基本运算，速度也会快很多。</p>
<h3 id="2-5-2-ctl-相关方法"><a href="#2-5-2-ctl-相关方法" class="headerlink" title="2.5.2 ctl 相关方法"></a>2.5.2 ctl 相关方法</h3><p>关于内部封装的获取生命周期状态、获取线程池线程数量的计算方法如以下代码所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>{ <span class="keyword">return</span> c &amp; ~CAPACITY; }</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>{ <span class="keyword">return</span> c &amp; CAPACITY; }</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>{ <span class="keyword">return</span> rs | wc; }</span><br></pre></td></tr></tbody></table></figure>

<p>这几个方法的具体含义如下所示：</p>
<ul>
<li><strong>runStateOf</strong>：获取运行状态；</li>
<li><strong>workerCountOf</strong>：获取活动线程数；</li>
<li><strong>ctlOf</strong>：获取运行状态和活动线程数的值。</li>
</ul>
<hr>
<h3 id="2-5-3-ThreadPoolExecutor-的构造方法及核心参数"><a href="#2-5-3-ThreadPoolExecutor-的构造方法及核心参数" class="headerlink" title="2.5.3 ThreadPoolExecutor 的构造方法及核心参数"></a>2.5.3 ThreadPoolExecutor 的构造方法及核心参数</h3><h4 id="四种构造方法"><a href="#四种构造方法" class="headerlink" title="四种构造方法"></a>四种构造方法</h4><p><code>ThreadPoolExecutror</code> 一共有四个构造方法，一共如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 五个参数的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 六个参数的构造函数-1</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 六个参数的构造函数-2</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 七个参数的构造函数</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="7个核心参数的解析"><a href="#7个核心参数的解析" class="headerlink" title="7个核心参数的解析"></a>7个核心参数的解析</h4><p>涉及到5~7个参数，我们先看看必须的5个参数是什么意思：</p>
<ul>
<li><p><strong>int corePoolSize</strong>：该线程池中核心线程数最大值</p>
<p>核心线程：线程池中有两类线程，核心线程和非核心线程。核心线程默认情况下会一直存在于线程池中，即使这个核心线程什么都不干（铁饭碗），而非核心线程如果长时间的闲置，就会被销毁（临时工）。</p>
<p>在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务除非调用了<code>prestartAllCoreThreads()</code>（ 初始化一个核心线程）或者prestartCoreThread()（ 初始化一个核心线程）方法。从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。</p>
<p>默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；</p>
</li>
<li><p><strong>int maximumPoolSize</strong>：该线程池中线程总数最大值 。</p>
<p>该值等于核心线程数量 + 非核心线程数量。</p>
<p>描述：池中允许的最大线程数，这个参数表示了线程池中最多能创建的线程数量，当任务数量比corePoolSize大时，任务添加到workQueue，当workQueue满了，将继续创建线程以处理任务maximumPoolSize表示的就是wordQueue满了，线程池中最多可以创建的线程数量</p>
</li>
<li><p><strong>long keepAliveTime</strong>：非核心线程闲置超时时长。</p>
<p>非核心线程如果处于闲置状态超过该值，就会被销毁。如果设置allowCoreThreadTimeOut(true)，则会也作用于核心线程。</p>
</li>
<li><p><strong>TimeUnit unit</strong>：keepAliveTime 时间单位，有7种取值，在TimeUnit类中有7种静态属性：</p>
<ol>
<li>TimeUnit.DAYS; //天</li>
<li>TimeUnit.HOURS; //小时</li>
<li>TimeUnit.MINUTES; //分钟</li>
<li>TimeUnit.SECONDS; //秒</li>
<li>TimeUnit.MILLISECONDS; //毫秒</li>
<li>TimeUnit.MICROSECONDS; //微妙</li>
<li>TimeUnit.NANOSECONDS; //纳秒</li>
</ol>
</li>
<li><p><strong>BlockingQueue workQueue</strong>：阻塞队列，维护着等待执行的Runnable任务对象。一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，其具体的几种类型，在前面已经给出。</p>
</li>
</ul>
<p>介绍完5个必须的参数之后，还有两个非必须的参数。</p>
<ul>
<li><strong>ThreadFactory threadFactory</strong> ：创建线程的工厂 ，用于批量创建线程，统一在创建线程时设置一些参数，如是否守护线程、线程的优先级等。如果不指定，会新建一个默认的线程工厂。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>{</span><br><span class="line">    <span class="comment">// 省略属性</span></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    DefaultThreadFactory() {</span><br><span class="line">        SecurityManager s = System.getSecurityManager();</span><br><span class="line">        group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">        Thread.currentThread().getThreadGroup();</span><br><span class="line">        namePrefix = <span class="string">"pool-"</span> +</span><br><span class="line">            poolNumber.getAndIncrement() +</span><br><span class="line">            <span class="string">"-thread-"</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>RejectedExecutionHandler handler</strong>：<strong>拒绝处理策略</strong>，线程数量大于最大线程数就会采用拒绝处理策略，在上面我已经列出了详细的几种类型了。</li>
</ul>
<hr>
<h3 id="2-5-4-execute-方法"><a href="#2-5-4-execute-方法" class="headerlink" title="2.5.4 execute 方法"></a>2.5.4 execute 方法</h3><p>这个方法其实就是线程池任务调度的核心所在了！</p>
<p>下面有一个很重要的东西叫ctl，我在前面已经提及，我怕又忘了，这里再点名一下：<code>private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</code>，其中蕴含的就是运行状态(<code>runState</code>)和线程数量 (<code>workerCount</code>)。</p>
<p>下面有几个方法，前面已经提及，这里再补充一下：</p>
<ul>
<li><strong>runStateOf</strong>：获取运行状态；</li>
<li><strong>workerCountOf</strong>：获取活动线程数；</li>
<li><strong>ctlOf</strong>：获取运行状态和活动线程数的值。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * clt记录着runState和workerCount</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 第一步</span></span><br><span class="line"><span class="comment">     * workerCountOf方法取出低29位的值，表示当前活动的线程数；</span></span><br><span class="line"><span class="comment">     * 如果当前活动线程数小于corePoolSize，则新建一个线程放入线程池中；</span></span><br><span class="line"><span class="comment">     * 并把任务添加到该线程中。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * addWorker中的第二个参数表示限制添加线程的数量是根据corePoolSize来判断还是maximumPoolSize来判断；</span></span><br><span class="line"><span class="comment">         * 如果为true，根据corePoolSize来判断；</span></span><br><span class="line"><span class="comment">         * 如果为false，则根据maximumPoolSize来判断</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果上面直接return; 则表明添加Worker成功</span></span><br><span class="line"><span class="comment">         * 如果添加失败，则重新获取ctl值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 第二步</span></span><br><span class="line"><span class="comment">     * 上面判断不小于corePoolSize，则将任务添加到workQueue队列。</span></span><br><span class="line"><span class="comment">     * 则判断是否线程池是运行状态并且任务添加到队列成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) {</span><br><span class="line">        <span class="comment">// 重新获取ctl值</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 再次判断线程池的运行状态，如果不是运行状态，由于之前已经把command添加到workQueue中了，</span></span><br><span class="line">        <span class="comment">// 这时需要移除该command</span></span><br><span class="line">        <span class="comment">// 执行过后通过handler使用拒绝策略对该任务进行处理，整个方法返回</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 获取线程池中的有效线程数，如果数量是0，则执行addWorker方法</span></span><br><span class="line"><span class="comment">         * 这里传入的参数表示：</span></span><br><span class="line"><span class="comment">         * 1. 第一个参数为null，表示在线程池中创建一个线程，但不去启动；</span></span><br><span class="line"><span class="comment">         * 2. 第二个参数为false，将线程池的有限线程数量的上限设置为maximumPoolSize，添加线程时根据maximumPoolSize来判断；</span></span><br><span class="line"><span class="comment">         * 如果判断workerCount大于0，则直接返回，在workQueue中新增的command会在将来的某个时刻被执行。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 第三步</span></span><br><span class="line"><span class="comment">     * 如果执行到这里，有两种情况：</span></span><br><span class="line"><span class="comment">     * 1. 线程池已经不是RUNNING状态；</span></span><br><span class="line"><span class="comment">     * 2. 线程池是RUNNING状态，但 workerCount &gt;= corePoolSize并且workQueue已满。</span></span><br><span class="line"><span class="comment">     * 这时，再次调用addWorker方法，但第二个参数传入为false，将线程池的有限线程数量的上限设置为maximumPoolSize；</span></span><br><span class="line"><span class="comment">     * 如果这时创建非核心线程失败(当前线程总数不小于maximumPoolSize时)，就会执行拒绝策略。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>ctl.get()</code>是获取线程池状态，用<code>int</code>类型表示。第二步中，入队前进行了一次<code>isRunning</code>判断，入队之后，又进行了一次<code>isRunning</code>判断。</p>
<p>这里先抛出一个疑问：<strong>为什么要二次检查线程池的状态?</strong></p>
<ul>
<li>主要是因为在多线程的环境下，线程池的状态是时刻发生变化的。很有可能刚获取线程池状态后线程池状态就改变了。判断是否将<code>command</code>加入<code>workqueue</code>是线程池之前的状态。倘若没有二次检查，万一线程池处于非<strong>RUNNING</strong>状态（在多线程环境下很有可能发生），那么<code>command</code>永远不会执行。</li>
</ul>
<p>需要注意的是，需要进行判断是否为RUNNING状态，如果在执行execute()方法时如果状态一直是RUNNING时，的执行过程如下：</p>
<ol>
<li>如果<code>workerCount &lt; corePoolSize</code>，则创建并启动一个线程来执行新提交的任务；</li>
<li>如果<code>workerCount &gt;= corePoolSize</code>，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中；</li>
<li>如果<code>workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize</code>，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务；</li>
<li>如果<code>workerCount &gt;= maximumPoolSize</code>，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</li>
</ol>
<p>其流程图如下所示：</p>
<p><img src="https://i.loli.net/2020/04/03/4ZKr6ulWQMOTP3e.png" alt="execute流程图"></p>
<hr>
<h3 id="2-5-5-addWorker-方法"><a href="#2-5-5-addWorker-方法" class="headerlink" title="2.5.5 addWorker 方法"></a>2.5.5 addWorker 方法</h3><p><code>addWorker</code>方法的主要工作是<strong>在线程池中创建一个新的线程并执行</strong>。增加线程是通过线程池中的addWorker方法，该方法的功能就是增加一个线程，该方法不考虑线程池是在哪个阶段增加的该线程，这个分配线程的策略是在上个步骤完成的，该步骤仅仅完成增加线程，并使它运行，最后返回是否成功这个结果。</p>
<p>其主要有两个参数：</p>
<ul>
<li><code>firstTask</code>参数 用于指定新增的线程执行的第一个任务</li>
<li>core参数为true表示在新增线程时会判断当前活动线程数是否少于<code>corePoolSize</code>，false表示新增线程前需要判断当前活动线程数是否少于<code>maximumPoolSize</code>。</li>
</ul>
<p>代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>{</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">// 获取运行状态</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 这个if判断</span></span><br><span class="line"><span class="comment">         * 如果rs &gt;= SHUTDOWN，则表示此时不再接收新任务；</span></span><br><span class="line"><span class="comment">         * 接着判断以下3个条件，只要有1个不满足，则返回false：</span></span><br><span class="line"><span class="comment">         * 1. rs == SHUTDOWN，这时表示关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务</span></span><br><span class="line"><span class="comment">         * 2. firsTask为空</span></span><br><span class="line"><span class="comment">         * 3. 阻塞队列不为空</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 首先考虑rs == SHUTDOWN的情况</span></span><br><span class="line"><span class="comment">         * 这种情况下不会接受新提交的任务，所以在firstTask不为空的时候会返回false；</span></span><br><span class="line"><span class="comment">         * 然后，如果firstTask为空，并且workQueue也为空，则返回false，</span></span><br><span class="line"><span class="comment">         * 因为队列中已经没有任务了，不需要再添加线程了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="comment">// 获取线程数</span></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">// 如果wc超过CAPACITY，也就是ctl的低29位的最大值（二进制是29个1），返回false；</span></span><br><span class="line">            <span class="comment">// 这里的core是addWorker方法的第二个参数，如果为true表示根据corePoolSize来比较，</span></span><br><span class="line">            <span class="comment">// 如果为false则根据maximumPoolSize来比较。        </span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 尝试增加workerCount，如果成功，则跳出第一个for循环</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            <span class="comment">// 如果增加workerCount失败，则重新获取ctl的值</span></span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">// 如果当前的运行状态不等于rs，说明状态已被改变，返回第一个for循环继续执行</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 根据firstTask来创建Worker对象</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="comment">// 每一个Worker对象都会创建一个线程</span></span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                <span class="comment">// rs &lt; SHUTDOWN表示是RUNNING状态；</span></span><br><span class="line">                <span class="comment">// 如果rs是RUNNING状态或者rs是SHUTDOWN状态并且firstTask为null，向线程池中添加线程。</span></span><br><span class="line">                <span class="comment">// 因为在SHUTDOWN时不会在添加新的任务，但还是会执行workQueue中的任务</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) {</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    <span class="comment">// workers是一个HashSet</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="comment">// largestPoolSize记录着线程池中出现过的最大线程数量</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) {</span><br><span class="line">                <span class="comment">// 启动线程</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其主要流程如下所示：</p>
<p><img src="https://i.loli.net/2020/04/03/RdTa4IpEtJ9ighf.png" alt="addWork流程图"></p>
<hr>
<h3 id="2-5-6-Worker-类"><a href="#2-5-6-Worker-类" class="headerlink" title="2.5.6 Worker 类"></a>2.5.6 Worker 类</h3><p>线程池为了掌握线程的状态并维护线程的生命周期，设计了线程池内的工作线程Worker。线程池中的每一个线程被封装成一个Worker对象，<code>ThreadPool</code>维护的其实就是一组Worker对象，看一下Worker的定义：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This class will never be serialized, but we provide a</span></span><br><span class="line"><span class="comment">     * serialVersionUID to suppress a javac warning.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line">    <span class="comment">/** Thread this worker is running in.  Null if factory fails. */</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">/** Initial task to run.  Possibly null. */</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">/** Per-thread task counter */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates with given first task and thread from ThreadFactory.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstTask the first task (null if none)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Worker(Runnable firstTask) {</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// Lock methods</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The value 0 represents the unlocked state.</span></span><br><span class="line">    <span class="comment">// The value 1 represents the locked state.</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 注意次数的tryAcquire是不允许重入的，而ReentrantLock是允许重入的。</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) {</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>{</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>{ acquire(<span class="number">1</span>); }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>{ <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>{ release(<span class="number">1</span>); }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>{ <span class="keyword">return</span> isHeldExclusively(); }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>{</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                t.interrupt();</span><br><span class="line">            } <span class="keyword">catch</span> (SecurityException ignore) {</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过上面的代码我们可以知道，Worker类继承了<code>AbstractQueuedSynchronizer</code>，并实现了<code>Runnable</code>接口，注意其中的<code>firstTask</code>和<code>thread</code>属性：</p>
<ul>
<li><code>firstTask</code>用它来保存传入的任务；</li>
<li><code>thread</code>是在调用构造方法时通过<code>ThreadFactory</code>来创建的线程，是用来处理任务的线程。</li>
</ul>
<p>在调用构造方法时，需要把任务传入，这里通过<code>getThreadFactory().newThread(this);</code>来新建一个线程，<code>newThread</code>方法传入的参数是this，因为Worker本身继承了Runnable接口，也就是一个线程，所以一个Worker对象在启动的时候会调用Worker类中的run方法。</p>
<p>Worker执行任务的模型如下图所示：</p>
<p><img src="https://i.loli.net/2020/04/03/cXwlEDfIoe5pgF8.png" alt="worker 执行任务模型"></p>
<p>Worker继承了<code>AbstractQueuedSynchronizer</code>，使用<code>AbstractQueuedSynchronizer</code>来实现独占锁的功能。为什么不使用<code>ReentrantLock</code>来实现呢？可以看到<code>tryAcquire</code>方法，它是不允许重入的，而<code>ReentrantLock</code>是允许重入的：</p>
<ol>
<li><p>lock方法一旦获取了独占锁，表示当前线程正在执行任务中；</p>
</li>
<li><p>如果正在执行任务，则不应该中断线程；</p>
</li>
<li><p>如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断；</p>
</li>
<li><p>线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；</p>
</li>
<li><p>之所以设置为不可重入，是因为我们不希望任务在调用像<code>setCorePoolSize</code>这样的线程池控制方法时重新获取锁。如果使用<code>ReentrantLock</code>，它是可重入的，这样如果在任务中调用了如<code>setCorePoolSize</code>这类线程池控制的方法，会中断正在运行的线程。</p>
<p>所以，Worker继承自<code>AbstractQueuedSynchronizer</code>，用于判断线程是否空闲以及是否可以被中断。</p>
</li>
</ol>
<p>在线程回收过程中就使用到了这种特性，回收过程如下图所示：</p>
<p><img src="https://i.loli.net/2020/04/03/aCo5DEI3pnYRN9Q.png" alt="线程回收模型"></p>
<p>在构造方法中执行了<code>setState(-1);</code>，把state变量设置为-1，为什么这么做呢？</p>
<p>其实人家源码中的注解也已经说明了：<code>inhibit interrupts until runWorker</code></p>
<p>大概的原因是<code>AQS</code>中默认的state是0，如果刚创建了一个Worker对象，还没有执行任务时，这时就不应该被中断，查看上面的<code>tryAcquire</code>方法，发现其调用的是：<code>if (compareAndSetState(0, 1))</code>，其是根据state是否是0来判断的，所以，<code>setState(-1);</code>将state设置为-1是为了禁止在执行任务前对线程进行中断。</p>
<p>就是因为这个原因，在<code>runWorker</code>方法中会先调用Worker对象的unlock方法将state设置为0.</p>
<hr>
<h3 id="2-5-7-runWorker-方法"><a href="#2-5-7-runWorker-方法" class="headerlink" title="2.5.7 runWorker 方法"></a>2.5.7 runWorker 方法</h3><p>在Worker类中的run方法调用了runWorker方法来执行任务，runWorker方法的代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>{</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取第一个任务</span></span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 1.线程启动之后，通过unlock方法释放锁</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="comment">// 是否因为异常退出循环</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 2.Worker执行firstTask或从workQueue中获取任务，如果getTask方法不返回null,循环不退出</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 2.1进行加锁操作，保证thread不被其他线程中断（除非线程池被中断）</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="comment">// 此处英文注释容易懂，不容易懂下面有解释</span></span><br><span class="line">            <span class="comment">// 2.2检查线程池状态，倘若线程池处于中断状态，当前线程将中断。 </span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                <span class="comment">// 进行中断，然后再接着往下走</span></span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 2.3执行beforeExecute </span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="comment">// 2.4这里执行任务了</span></span><br><span class="line">                    task.run();</span><br><span class="line">                } <span class="keyword">catch</span> (RuntimeException x) {</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                } <span class="keyword">catch</span> (Error x) {</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                } <span class="keyword">catch</span> (Throwable x) {</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    <span class="comment">// 2.5执行afterExecute方法 </span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                <span class="comment">// 2.6解锁操作</span></span><br><span class="line">                w.unlock();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="comment">// 这里很有意思，如果一个线程发生了异常会走到这个方法</span></span><br><span class="line">        <span class="comment">// 注意completedAbruptly 为true 就代表了因为异常而退出循环了</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>第一个if判断，目的是：</p>
<ul>
<li>如果线程池正在停止，那么要保证当前线程是中断状态；</li>
<li>如果不是的话，则要保证当前线程不是中断状态；</li>
</ul>
<p>为什么要做这些判断呢？</p>
<p>这是因为考虑在执行该if语句期间可能也执行了<code>shutdownNow</code>方法，<code>shutdownNow</code>方法会把状态设置为STOP，回顾一下STOP状态：</p>
<blockquote>
<p>不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 <code>shutdownNow()</code> 方法会使线程池进入到该状态。</p>
</blockquote>
<p>STOP状态要中断线程池中的所有线程，而这里使用<code>Thread.interrupted()</code>来判断是否中断是为了确保在RUNNING或者SHUTDOWN状态时线程是非中断状态的，因为<code>Thread.interrupted()</code>方法会复位中断的状态。</p>
<p>其实整个流程下来，大概就是做了这么几件事：</p>
<ol>
<li>while循环不断地通过<code>getTask()</code>方法获取任务。</li>
<li><code>getTask()</code>方法从阻塞队列中取任务。</li>
<li>如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态。</li>
<li>调用<code>task.run()</code>执行任务；</li>
<li>如果task为null则跳出循环，执行processWorkerExit()方法；</li>
<li>runWorker方法执行完毕，也代表着Worker中的run方法执行完毕，销毁线程。</li>
</ol>
<p>这里的<code>beforeExecute</code>方法和<code>afterExecute</code>方法在<code>ThreadPoolExecutor</code>类中是空的，留给子类来实现。</p>
<p><code>completedAbruptly</code>变量来表示在执行任务过程中是否出现了异常，在<code>processWorkerExit</code>方法中会对该变量的值进行判断。</p>
<p>总结一下<code>runWorker</code>方法的执行过程如下图所示：</p>
<p><img src="https://i.loli.net/2020/04/03/YH9cdUgDVbnQN74.png" alt="runWorker执行流程"></p>
<p>通过上图其实也可以看到<code>runWorker</code> 在线程复用是如何起作用的：</p>
<ul>
<li>首先去执行创建这个worker时就有的任务，当执行完这个任务后，worker的生命周期并没有结束，在<code>while</code>循环中，worker会不断地调用<code>getTask</code>方法从<strong>阻塞队列</strong>中获取任务然后调用<code>task.run()</code>执行任务,从而达到<strong>复用线程</strong>的目的。只要<code>getTask</code>方法不返回<code>null</code>,此线程就不会退出。</li>
<li>当然，核心线程池中创建的线程想要拿到阻塞队列中的任务，先要判断线程池的状态，如果<strong>STOP</strong>或者<strong>TERMINATED</strong>，返回<code>null</code>。</li>
</ul>
<hr>
<h3 id="2-5-8-getTask-方法"><a href="#2-5-8-getTask-方法" class="headerlink" title="2.5.8 getTask 方法"></a>2.5.8 getTask 方法</h3><p><code>getTask</code>方法用来从阻塞队列中取任务，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// timeOut变量的值表示上次从阻塞队列中取任务时是否超时</span></span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果线程池状态rs &gt;= SHUTDOWN，也就是非RUNNING状态，再进行以下判断：</span></span><br><span class="line"><span class="comment">         * 	a. rs &gt;= STOP，线程池是否正在stop；</span></span><br><span class="line"><span class="comment">         * 	b. 阻塞队列是否为空。</span></span><br><span class="line"><span class="comment">         * 如果以上条件满足，则将workerCount减1并返回null。</span></span><br><span class="line"><span class="comment">         * 因为如果当前线程池状态的值是SHUTDOWN或以上时，不允许再向阻塞队列中添加任务。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) {</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">        <span class="comment">// 1.</span></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="comment">// timed变量用于判断是否需要进行超时控制。</span></span><br><span class="line">        <span class="comment">// allowCoreThreadTimeOut变量默认是false,核心线程即使空闲也不会被销毁</span></span><br><span class="line">        <span class="comment">// 	如果为true,核心线程在keepAliveTime内仍空闲则会被销毁。 </span></span><br><span class="line">        <span class="comment">// wc &gt; corePoolSize，表示当前线程池中的线程数量大于核心线程数量；</span></span><br><span class="line">        <span class="comment">// 对于超过核心线程数量的这些线程，需要进行超时控制</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 2.</span></span><br><span class="line"><span class="comment">         * wc &gt; maximumPoolSize的情况是因为可能在此方法执行阶段同时执行了setMaximumPoolSize方法；</span></span><br><span class="line"><span class="comment">         * timed &amp;&amp; timedOut 如果为true，表示当前操作需要进行超时控制，并且上次从阻塞队列中获取任务发生了超时</span></span><br><span class="line"><span class="comment">         * 接下来判断，如果有效线程数量大于1，或者阻塞队列是空的，那么尝试将workerCount减1；</span></span><br><span class="line"><span class="comment">         * 如果减1失败，则返回重试。</span></span><br><span class="line"><span class="comment">         * 如果wc == 1时，也就说明当前线程是线程池中唯一的一个线程了。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) {</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 3.如果timed为true(想想哪些情况下timed为true),则会调用workQueue的poll方法获取任务.</span></span><br><span class="line">            <span class="comment">// 超时时间是keepAliveTime。如果超过keepAliveTime时长，</span></span><br><span class="line">            <span class="comment">// poll返回了null，上边提到的while循序就会退出，线程也就执行完了。</span></span><br><span class="line">            <span class="comment">// 如果timed为false（allowCoreThreadTimeOut为falsefalse</span></span><br><span class="line">            <span class="comment">// 且wc &gt; corePoolSize为false），则会调用workQueue的take方法阻塞在当前。</span></span><br><span class="line">            <span class="comment">// 队列中有任务加入时，线程被唤醒，take方法返回任务，并执行。</span></span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            <span class="comment">// 如果 r == null，说明已经超时，timedOut设置为true</span></span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException retry) {</span><br><span class="line">            <span class="comment">// 如果获取任务时当前线程发生了中断，则设置timedOut为false并返回循环重试</span></span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里是线程如何进行复用的核心代码所在：</p>
<ul>
<li>核心线程的会一直卡在<code>workQueue.take</code>方法，被阻塞并挂起，不会占用CPU资源，直到拿到<code>Runnable</code> 然后返回（当然如果<code>**allowCoreThreadTimeOut**</code>设置为<code>true</code>,那么核心线程就会去调用<code>poll</code>方法，因为<code>poll</code>可能会返回<code>null</code>,所以这时候核心线程满足超时条件也会被销毁）。</li>
<li>非核心线程会<code>workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)</code> ，如果超时还没有拿到，下一次循环判断<strong><code>compareAndDecrementWorkerCount</code></strong>就会返回<code>null</code>,Worker对象的<code>run()</code>方法循环体的判断为<code>null</code>,任务结束，然后线程被系统回收 。</li>
</ul>
<p>这里重要的地方是第二个if判断，目的是控制线程池的有效线程数量。由上文中的分析可以知道，在执行execute方法时，如果当前线程池的线程数量超过了<code>corePoolSize</code>且小于<code>maximumPoolSize</code>，并且<code>workQueue</code>已满时，则可以增加工作线程，但这时如果超时没有获取到任务，也就是<code>timedOut</code>为true的情况，说明<code>workQueue</code>已经为空了，也就说明了当前线程池中不需要那么多线程来执行任务了，可以把多于<code>corePoolSize</code>数量的线程销毁掉，保持线程数量在<code>corePoolSize</code>即可。</p>
<p>什么时候会销毁？当然是<code>runWorker</code>方法执行完之后，也就是Worker中的run方法执行完，由JVM自动回收。</p>
<p><code>getTask</code>方法返回null时，在<code>runWorker</code>方法中会跳出while循环，然后会执行<code>processWorkerExit</code>方法。</p>
<hr>
<h3 id="2-5-9-proccessWorkerExite-方法"><a href="#2-5-9-proccessWorkerExite-方法" class="headerlink" title="2.5.9 proccessWorkerExite 方法"></a>2.5.9 proccessWorkerExite 方法</h3><p>线程回收的工作是在processWorkerExit方法完成的，其源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>{</span><br><span class="line">    <span class="comment">// 如果completedAbruptly值为true，则说明线程执行时出现了异常，需要将workerCount减1；</span></span><br><span class="line">    <span class="comment">// 如果线程执行时没有出现异常，说明在getTask()方法中已经已经对workerCount进行了减1操作，这里就不必再减了。 </span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn't adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 统计完成的任务数</span></span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        <span class="comment">// 从workers中移除，也就表示着从线程池中移除了一个工作线程</span></span><br><span class="line">        workers.remove(w);</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 根据线程池状态进行判断是否结束线程池</span></span><br><span class="line">    <span class="comment">// 为什么需要判断呢？上面已经讲了。</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当线程池是RUNNING或SHUTDOWN状态时，如果worker是异常结束，那么会直接addWorker；</span></span><br><span class="line"><span class="comment">     * 	意思就是因为异常结束的话，会创建一个新的线程放到线程池中！</span></span><br><span class="line"><span class="comment">     * 如果allowCoreThreadTimeOut=true，并且等待队列有任务，至少保留一个worker；</span></span><br><span class="line"><span class="comment">     * 如果allowCoreThreadTimeOut=false，workerCount不少于corePoolSize。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) {</span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) {</span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        }</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上的代码流程图如下所示：</p>
<p><img src="https://i.loli.net/2020/04/03/SZVNJKE7Tn9LRBP.png" alt="processWorkerExit执行流程"></p>
<p>其实在这个方法中，主要工作是<code>workers.remove(w)</code>将线程引用移出线程池就已经结束了线程销毁的部分。但我们还要去分析一下引起线程销毁的原因，分为几种情况，如果是异常结束的话，那么那么会直接<code>addWorker</code>，还有进行判断<code>allowCoreThreadTimeOut</code> ，根据不同情况，对线程进行一个重新的分配。</p>
<p>至此，<code>processWorkerExit</code>执行完之后，工作线程被销毁，以上就是整个工作线程的生命周期，从execute方法开始，Worker使用<code>ThreadFactory</code>创建新的工作线程，<code>runWorker</code>通过<code>getTask</code>获取任务，然后执行任务，如果<code>getTask</code>返回null，进入<code>processWorkerExit</code>方法，整个线程结束，如图所示：</p>
<p><img src="https://i.loli.net/2020/04/03/gulAMmVIwtQisC5.png" alt="工作线程的整个生命周期"></p>
<hr>
<h3 id="2-5-10-tryTerminater-方法"><a href="#2-5-10-tryTerminater-方法" class="headerlink" title="2.5.10 tryTerminater 方法"></a>2.5.10 tryTerminater 方法</h3><p>这个方法的作用是根据线程池状态进行判断是否结束线程池，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 当前线程池的状态为以下几种情况时，直接返回：</span></span><br><span class="line"><span class="comment">         * 1. RUNNING，因为还在运行中，不能停止；</span></span><br><span class="line"><span class="comment">         * 2. TIDYING或TERMINATED，因为线程池中已经没有正在运行的线程了；</span></span><br><span class="line"><span class="comment">         * 3. SHUTDOWN并且等待队列非空，这时要执行完workQueue中的task；</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 如果线程数量不为0，则中断一个空闲的工作线程，并返回</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) { <span class="comment">// Eligible to terminate</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 这里尝试设置状态为TIDYING，如果设置成功，则调用terminated方法</span></span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="comment">// terminated方法默认什么都不做，留给子类实现</span></span><br><span class="line">                    terminated();</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    <span class="comment">// 设置状态为TERMINATED</span></span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// else retry on failed CAS</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>interruptIdleWorkers(ONLY_ONE);</code>的作用是因为在<code>getTask</code>方法中执行<code>workQueue.take()</code>时，如果不执行中断会一直阻塞。</p>
<p><code>processWorkerExite</code> 方法中会调用<code>tryTerminate</code>从而根据线程池状态进行判断是否结束线程池。</p>
<p>每次在工作线程结束时调用<code>tryTerminate</code>方法来尝试中断一个空闲工作线程，避免在队列为空时取任务一直阻塞的情况，这是因为在下面在的shutdown方法中，会中断所有空闲的工作线程，如果在执行shutdown时工作线程没有空闲，然后又去调用了<code>getTask</code>方法，这时如果<code>workQueue</code>中没有任务了，调用<code>workQueue.take()</code>时就会一直阻塞。</p>
<hr>
<h3 id="2-5-11-shutdown-方法"><a href="#2-5-11-shutdown-方法" class="headerlink" title="2.5.11 shutdown 方法"></a>2.5.11 shutdown 方法</h3><p>shutdown方法要将线程池切换到SHUTDOWN状态，并调用<code>interruptIdleWorkers</code>方法请求中断所有空闲的worker，最后调用<code>tryTerminate</code>尝试结束线程池。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 安全策略判断</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 切换状态为SHUTDOWN</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">// 中断空闲线程</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 尝试结束线程池</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里思考一个问题：在<code>runWorker</code>方法中，执行任务时对Worker对象w进行了lock操作，为什么要在执行任务的时候对每个工作线程都加锁呢？</p>
<p>分析如下：</p>
<ul>
<li>在getTask方法中，如果这时线程池的状态是SHUTDOWN并且workQueue为空，那么就应该返回null来结束这个工作线程，而使线程池进入SHUTDOWN状态需要调用shutdown方法；</li>
<li>shutdown方法会调用<code>interruptIdleWorkers</code>来中断空闲的线程，<code>interruptIdleWorkers</code>持有<code>mainLock</code>，会遍历workers来逐个判断工作线程是否空闲。但<code>getTask</code>方法中没有<code>mainLock</code>；</li>
<li>在<code>getTask</code>中，如果判断当前线程池状态是RUNNING，并且阻塞队列为空，那么会调用<code>workQueue.take()</code>进行阻塞；</li>
<li>如果在判断当前线程池状态是RUNNING后，这时调用了<code>shutdown</code>方法把状态改为了SHUTDOWN，这时如果不进行中断，那么当前的工作线程在调用了<code>workQueue.take()</code>后会一直阻塞而不会被销毁，因为在SHUTDOWN状态下不允许再有新的任务添加到<code>workQueue</code>中，这样一来线程池永远都关闭不了了；</li>
<li>由上可知，<code>shutdown</code>方法与<code>getTask</code>方法（从队列中获取任务时）存在竞态条件；</li>
<li>解决这一问题就需要用到线程的中断，也就是为什么要用interruptIdleWorkers方法。在调用<code>workQueue.take()</code>时，如果发现当前线程在执行之前或者执行期间是中断状态，则会抛出<code>InterruptedException</code>，解除阻塞的状态；</li>
<li>但是要中断工作线程，还要判断工作线程是否是空闲的，如果工作线程正在处理任务，就不应该发生中断；</li>
<li>所以Worker继承自<code>AQS</code>，在工作线程处理任务时会进行lock，<code>interruptIdleWorkers</code>在进行中断时会使用tryLock来判断该工作线程是否正在处理任务，如果<code>tryLock</code>返回true，说明该工作线程当前未执行任务，这时才可以被中断。</li>
</ul>
<hr>
<h3 id="2-5-12-interruptldleWorkers-方法"><a href="#2-5-12-interruptldleWorkers-方法" class="headerlink" title="2.5.12 interruptldleWorkers 方法"></a>2.5.12 interruptldleWorkers 方法</h3><p><code>interruptIdleWorkers</code>遍历<code>workers</code>中所有的工作线程，若线程没有被中断<code>tryLock</code>成功，就中断该线程。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">()</span> </span>{</span><br><span class="line">    interruptIdleWorkers(<span class="keyword">false</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>{</span><br><span class="line">    <span class="comment">// mainLock 是可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    <span class="comment">// 进行遍历之前先上锁</span></span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 遍历所有工作线程</span></span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) {</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                } <span class="keyword">catch</span> (SecurityException ignore) {</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    w.unlock();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>为什么需要持有<code>mainLock</code>？</p>
<ul>
<li>因为workers是<code>HashSet</code>类型的，不能保证线程安全。</li>
</ul>
<hr>
<h3 id="2-5-13-shutdownNow-方法"><a href="#2-5-13-shutdownNow-方法" class="headerlink" title="2.5.13 shutdownNow 方法"></a>2.5.13 shutdownNow 方法</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>{</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        <span class="comment">// 中断所有工作线程，无论是否空闲</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">        <span class="comment">// 取出队列中没有被执行的任务</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    }</span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>shutdownNow</code>方法与<code>shutdown</code>方法类似，不同的地方在于：</p>
<ol>
<li>设置状态为STOP；</li>
<li>中断所有工作线程，无论是否是空闲的；</li>
<li>取出阻塞队列中没有被执行的任务并返回</li>
</ol>
<p><code>shutdownNow</code>方法执行完之后调用<code>tryTerminate</code>方法，该方法在上文已经分析过了，目的就是使线程池的状态设置为TERMINATED。</p>
<hr>
<h2 id="2-6-ThreadPoolExecutor-如何做到线程复用的？"><a href="#2-6-ThreadPoolExecutor-如何做到线程复用的？" class="headerlink" title="2.6 ThreadPoolExecutor 如何做到线程复用的？"></a>2.6 ThreadPoolExecutor 如何做到线程复用的？</h2><p>我们知道，一个线程在创建的时候会指定一个线程任务，当执行完这个线程任务之后，线程自动销毁。但是线程池却可以复用线程，即一个线程执行完线程任务后不销毁，继续执行另外的线程任务。<strong>那么，线程池如何做到线程复用呢？</strong></p>
<p>原来，<code>ThreadPoolExecutor</code>在创建线程时，会将线程封装成<strong>工作线程worker</strong>,并放入<strong>工作线程组</strong>中，然后这个worker反复从阻塞队列中拿任务去执行。</p>
<p>在上面的源码我们已经进行了一个流程的分析了，大体过程就是:</p>
<p><code>execute</code> 方法会调用 <code>addWorker</code> 方法，<code>addWoker</code>方法会做些什么呢？</p>
<ul>
<li>在<code>addWorker</code> 方法中会创建<code>worker</code>对象，并初始化一个<code>Thread</code>对象，然后通过<code>thread.start()</code>启动这个线程对象，它会会触发<code>Worker</code>类的<code>run</code>方法被JVM调用。</li>
</ul>
<p><code>runWorker</code>方法会做些什么呢：</p>
<ul>
<li>首先去执行创建这个worker时就有的任务，当执行完这个任务后，worker的生命周期并没有结束，在<code>while</code>循环中，worker会不断地调用<code>getTask</code>方法从<strong>阻塞队列</strong>中获取任务然后调用<code>task.run()</code>执行任务,从而达到<strong>复用线程</strong>的目的。只要<code>getTask</code>方法不返回<code>null</code>,此线程就不会退出。</li>
<li>当然，核心线程池中创建的线程想要拿到阻塞队列中的任务，先要判断线程池的状态，如果<strong>STOP</strong>或者<strong>TERMINATED</strong>，返回<code>null</code>。</li>
</ul>
<p>而<code>getTask</code>方法也是一个核心：</p>
<ul>
<li>核心线程的会一直卡在<code>workQueue.take</code>方法，被阻塞并挂起，不会占用CPU资源，直到拿到<code>Runnable</code> 然后返回（当然如果<strong><code>allowCoreThreadTimeOut</code></strong>设置为<code>true</code>,那么核心线程就会去调用<code>poll</code>方法，因为<code>poll</code>可能会返回<code>null</code>,所以这时候核心线程满足超时条件也会被销毁）。</li>
<li>非核心线程会<code>workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)</code> ，如果超时还没有拿到，下一次循环判断<strong><code>compareAndDecrementWorkerCount</code></strong>就会返回<code>null</code>,Worker对象的<code>run()</code>方法循环体的判断为<code>null</code>,任务结束，然后线程被系统回收 。</li>
</ul>
<p>大概就是这么一个过程了。</p>
<hr>
<h2 id="2-7-一个线程池中的线程异常了，那么线程池会怎么处理这个线程"><a href="#2-7-一个线程池中的线程异常了，那么线程池会怎么处理这个线程" class="headerlink" title="2.7 一个线程池中的线程异常了，那么线程池会怎么处理这个线程?"></a>2.7 <strong>一个线程池中的线程异常了，那么线程池会怎么处理这个线程?</strong></h2><p>这个问题是出自Why 博客中的阿里的面试题，整个流程分析下来也挺有意思的，详细的分析过程可以查看这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=MzIxNTQ4MzE1NA==&amp;mid=2247483741&amp;idx=1&amp;sn=238fc933c3b9b19ab1754b23283ac6fd&amp;chksm=9796d720a0e15e364f4105c29de606e7329760a41607136a722dc97bb177f9362aeacd92f762&amp;mpshare=1&amp;scene=1&amp;srcid=0327sk1b22zCDOAxzazzEBon&amp;sharer_sharetime=1585311891544&amp;sharer_shareid=b9c5b20e14a5ec65e524cd503ba56884&amp;key=362c475b03eb9012c3a4814de16c542df00e00cb88ad625adda59fe05e00e41bf016bca7d19de52329538b9719e995fa2746837543243fdd9b9a8a873c4b7306ae9be2f34fc0a8f197397eec5bcf36d7&amp;ascene=1&amp;uin=MjkxODQzNTgxMg%3D%3D&amp;devicetype=Windows+7&amp;version=62080079&amp;lang=zh_TW&amp;exportkey=A7VoXZ0wFQgcHgODYeWgoNo%3D&amp;pass_ticket=cBjPmhH%2B5L9207Zh9fWCw5cVrpKDK%2B3yqD%2FHI0IlhthmyIKGfVv3OEP8DCmqTYVl" target="_blank" rel="noopener">有的线程它死了，于是它变成一道面试题</a>。这里大概讲解了最终的答案，具体分析过程可以点进去查看，不过源码还是上面的那一套。</p>
<p>当一个线程池里面的线程异常后:</p>
<ol>
<li>当执行方式是execute时，可以看到堆栈异常的输出。</li>
<li>当执行方式是submit时，堆栈异常没有输出。但是调用<code>Future.get()</code>方法时，可以捕获到异常。</li>
<li>不会影响线程池里面其他线程的正常执行。</li>
<li>线程池会把这个线程移除掉，并创建一个新的线程放到线程池中。</li>
</ol>
<p>主要的图示如下：</p>
<p><img src="https://i.loli.net/2020/04/04/MIUmeaZ5E4zBb7o.png" alt="线程异常如何处理"></p>
<hr>
<h2 id="2-7-四种线程池"><a href="#2-7-四种线程池" class="headerlink" title="2.7 四种线程池"></a>2.7 四种线程池</h2><h3 id="2-7-1-newCachedThreadPool"><a href="#2-7-1-newCachedThreadPool" class="headerlink" title="2.7.1 newCachedThreadPool"></a>2.7.1 newCachedThreadPool</h3><p>介绍：<code>CachedThreadPool</code> 是<strong>一个会根据需要创建新线程的线程池</strong>。下面通过源码来看看 <code>CachedThreadPool</code> 的实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>CachedThreadPool</code> 的 <code>corePoolSize</code> 被设置为空（0），<code>maximumPoolSize</code> 被设置为 <code>Integer.MAX.VALUE</code>，即它是无界的，这也就意味着如果主线程提交任务的速度高于 <code>maximumPool</code> 中线程处理任务的速度时，<code>CachedThreadPool</code> 会不断创建新的线程。极端情况下，这样会导致耗尽 cpu 和内存资源。</p>
<p><strong><code>newCachedThreadPool</code> 执行任务过程介绍：</strong></p>
<p><img src="https://i.loli.net/2020/04/03/9dF5A1UfK4RN83m.png" alt="newCachedThreadPool 执行任务模型"></p>
<p><code>CacheThreadPool</code>的<strong>运行流程</strong>如下：</p>
<ol>
<li>提交任务进线程池。</li>
<li>因为<strong><code>corePoolSize</code></strong>为0的关系，不创建核心线程，线程池最大为<code>Integer.MAX_VALUE</code>。</li>
<li>尝试将任务添加到<strong><code>SynchronousQueue</code></strong>队列。</li>
<li>如果<code>SynchronousQueue</code>入列成功，等待被当前运行的线程空闲后拉取执行。如果当前没有空闲线程，那么就创建一个非核心线程，然后从<code>SynchronousQueue</code>拉取任务并在当前线程执行。</li>
<li>如果<code>SynchronousQueue</code>已有任务在等待，入列操作将会阻塞。</li>
</ol>
<p>当需要执行很多<strong>短时间</strong>的任务时，<code>CacheThreadPool</code>的线程复用率比较高， 会显著的<strong>提高性能</strong>。而且线程60s后会回收，意味着即使没有任务进来，<code>CacheThreadPool</code>并不会占用很多资源。</p>
<p><strong>为什么不推荐使用<code>CachedThreadPool</code>？</strong></p>
<ul>
<li><code>CachedThreadPool</code>允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 OOM。</li>
</ul>
<hr>
<h3 id="2-7-2-newFixedThreadPool"><a href="#2-7-2-newFixedThreadPool" class="headerlink" title="2.7.2 newFixedThreadPool"></a>2.7.2 newFixedThreadPool</h3><p><code>newFixedThreadPool</code> 的源码实现如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>分析一下：</p>
<p>核心线程数量和总线程数量相等，都是传入的参数<code>nThreads</code>，所以只能创建核心线程，不能创建非核心线程。因为<code>LinkedBlockingQueue</code>的默认大小是<code>Integer.MAX_VALUE</code>，故如果核心线程空闲，则交给核心线程处理；如果核心线程不空闲，则入列等待，直到核心线程空闲。</p>
<p><strong><code>FixedThreadPool</code> 执行任务过程介绍：</strong></p>
<p><code>FixedThreadPool</code> 的 <code>execute()</code> 方法运行示意图（该图片来源：《Java 并发编程的艺术》）：</p>
<p><img src="https://i.loli.net/2020/04/03/ys3GoqdfXANMJIR.png" alt="FixedThreadPool 执行任务模型"></p>
<p>上图说明：</p>
<ol>
<li>如果当前运行的线程数小于 corePoolSize， 如果再来新任务的话，就创建新的线程来执行任务；</li>
<li>当前运行的线程数等于 corePoolSize 后， 如果再来新任务的话，会将任务加入 LinkedBlockingQueue；</li>
<li>线程池中的线程执行完 手头的任务后，会在循环中反复从 LinkedBlockingQueue 中获取任务来执行；</li>
</ol>
<p><strong>为什么不推荐使用<code>FixedThreadPool</code>？（注意这也是阿里巴巴不推荐使用的理由！）</strong></p>
<ul>
<li><code>FixedThreadPool</code> 使用无界队列 <code>LinkedBlockingQueue</code>（队列的容量为 <code>Intger.MAX_VALUE</code>）作为线程池的工作队列会对线程池带来如下影响 ：<ol>
<li>当线程池中的线程数达到 <code>corePoolSize</code> 后，新任务将在无界队列中等待，因此线程池中的线程数不会超过 <code>corePoolSize</code>；</li>
<li>由于使用无界队列时 <code>maximumPoolSize</code> 将是一个无效参数，因为不可能存在任务队列满的情况。所以，通过创建 <code>FixedThreadPool</code>的源码可以看出创建的 <code>FixedThreadPool</code> 的 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 被设置为同一个值。</li>
<li>由于 1 和 2，使用无界队列时 <code>keepAliveTime</code> 将是一个无效参数；</li>
<li>运行中的 <code>FixedThreadPool</code>（未执行 <code>shutdown()</code>或 <code>shutdownNow()</code>）不会拒绝任务，在任务比较多的时候会导致 OOM（内存溢出）。</li>
</ol>
</li>
</ul>
<p><strong>注意：<code>newFixedThreadPool</code> 与<code>CachedThreadPool</code> 的联系与区别：</strong></p>
<ul>
<li>因为 <code>corePoolSize == maximumPoolSize</code> ，所以<code>FixedThreadPool</code>只会创建核心线程。 而<code>CachedThreadPool</code>因为<code>corePoolSize=0</code>，所以只会创建非核心线程。</li>
<li>在 <code>getTask()</code> 方法，如果队列里没有任务可取，线程会一直阻塞在 <code>LinkedBlockingQueue.take()</code> ，线程不会被回收。 <code>CachedThreadPool</code>会在60s后收回。</li>
<li>由于线程不会被回收，会一直卡在阻塞，所以<strong>没有任务的情况下， FixedThreadPool占用资源更多</strong>。</li>
<li>都几乎不会触发拒绝策略，但是原理不同。<code>FixedThreadPool</code>是因为阻塞队列可以很大（最大为Integer最大值），故几乎不会触发拒绝策略；<code>CachedThreadPool</code>是因为线程池很大（最大为Integer最大值），几乎不会导致线程数量大于最大线程数，故几乎不会触发拒绝策略。</li>
</ul>
<hr>
<h3 id="2-7-3-newSingleThreadExecutor"><a href="#2-7-3-newSingleThreadExecutor" class="headerlink" title="2.7.3 newSingleThreadExecutor"></a>2.7.3 newSingleThreadExecutor</h3><p>其创建函数如下所示：</p>
<figure class="highlight haxe"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">SingleThreadExecutor</span>() {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">FinalizableDelegatedExecutorService</span></span><br><span class="line"><span class="type"></span>        (<span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0</span>L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>有且仅有一个核心线程（ <code>corePoolSize == maximumPoolSize=1</code>），使用了<code>LinkedBlockingQueue</code>（容量很大），所以，<strong>不会创建非核心线程</strong>。所有任务按照<strong>先来先执行</strong>的顺序执行。如果这个唯一的线程不空闲，那么新来的任务会存储在任务队列里等待执行。</p>
<p>从上面源代码可以看出新创建的 <code>SingleThreadExecutor</code> 的 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 都被设置为 1.其他参数和 <code>FixedThreadPool</code> 相同。</p>
<p><strong><code>newSingleThreadExecutor</code> 执行任务过程介绍：</strong></p>
<p><code>SingleThreadExecutor</code> 的运行示意图（该图片来源：《Java 并发编程的艺术》）：</p>
<p><img src="https://i.loli.net/2020/04/03/JAtXSsHNvQyw4dx.png" alt="SingleThreadExecutor 执行任务模型"></p>
<p>上图说明：</p>
<ol>
<li>如果当前运行的线程数少于 <code>corePoolSize</code>，则创建一个新的线程执行任务；</li>
<li>当前线程池中有一个运行的线程后，将任务加入 <code>LinkedBlockingQueue</code>线程执行完；</li>
<li>当前的任务后，会在循环中反复从 <code>LinkedBlockingQueue</code> 中获取任务来执行；</li>
</ol>
<p><strong>为什么不推荐使用<code>SingleThreadExecutor</code>？</strong></p>
<ul>
<li><code>SingleThreadExecutor</code> 使用无界队列 <code>LinkedBlockingQueue</code> 作为线程池的工作队列（队列的容量为 <code>Intger.MAX_VALUE</code>）。对线程池带来的影响与 <code>FixedThreadPool</code> 相同。说简单点就是可能会导致 OOM。</li>
</ul>
<hr>
<h3 id="2-7-4-newScheduledThreadPool"><a href="#2-7-4-newScheduledThreadPool" class="headerlink" title="2.7.4 newScheduledThreadPool"></a>2.7.4 newScheduledThreadPool</h3><p><code>ScheduledThreadPool</code>是一<strong>个支持任务定时调度的线程池</strong>。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//ScheduledThreadPoolExecutor():</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong><code>newScheduledThreadPool</code> 执行任务过程介绍：</strong></p>
<p><code>ScheduledThreadPoolExecutor</code>继承自<code>ThreadPoolExecutor</code>。它主要用来在给定的延迟之后运行任务，或者定期执行任务。<code>ScheduledThreadPoolExecutor</code>的功能与Timer类似，但<code>ScheduledThreadPoolExecutor</code>功能更强大、更灵活。Timer对应的是单个后台线程，而<code>ScheduledThreadPoolExecutor</code>可以在构造函数中指定多个对应的后台线程数。</p>
<p>其源码如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//ScheduledThreadPoolExecutor():</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>newScheduledThreadPool</code> 的运行示意图（该图片来源：《Java 并发编程的艺术》）：</p>
<p><img src="https://i.loli.net/2020/04/03/AuUxb6LqDC9OHKv.png" alt="newScheduledThreadPool 任务机制"></p>
<p><code>ScheduledThreadPoolExecutor</code>的执行主要分为两大部分</p>
<ol>
<li>当调用<code>ScheduledThreadPoolExecutor</code>的<code>scheduleAtFixedRate()</code>方法或者<code>scheduleWithFixedDelay()</code>方法时，会向<code>cheduledThreadPoolExecutor</code>的<code>DelayQueue</code>添加一个实现了<code>RunnableScheduledFutur</code>接口的<code>cheduledFutureTask</code>。</li>
<li>线程池中的线程从<code>DelayQueue</code>中获取<code>ScheduledFutureTask</code>，然后执行任务。</li>
</ol>
<hr>
<h1 id="3-线程池监控"><a href="#3-线程池监控" class="headerlink" title="3.线程池监控"></a>3.线程池监控</h1><p>通过线程池提供的参数进行监控。线程池里有一些属性在监控线程池的时候可以使用</p>
<ul>
<li>getTaskCount：线程池已经执行的和未执行的任务总数；</li>
<li>getCompletedTaskCount：线程池已完成的任务数量，该值小于等于taskCount；</li>
<li>getLargestPoolSize：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过，也就是达到了maximumPoolSize；</li>
<li>getPoolSize：线程池当前的线程数量；</li>
<li>getActiveCount：当前线程池中正在执行任务的线程数量。</li>
</ul>
<p><strong>通过扩展线程池进行监控</strong>。通过继承线程池并重写线程池的<code>beforeExecute</code>，<code>afterExecute</code>和<code>terminated</code>方法，我们可以在任务执行前，执行后和线程池关闭前干一些事情。如监控任务的平均执行时间，最大执行时间和最小执行时间等。</p>
<hr>
<h1 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h1><p>通过这么一系列从头到尾的对线程池进行了一个剖析，大概了解了其内部的运行机制了，线程池在Java 并发当中占据很重要的一个部分，能够运用好是一个很不容易的事情，如果对原理有更深入的了解的话，应该可以避免一些坑，多线程并发编程很多知识都在这里展示出来，需要了解多个方面的知识，应该要进行掌握线程池的原理和使用。</p>
<p>这篇文章大概说了以下几个内容：</p>
<ul>
<li>线程池总体设计</li>
<li>线程池任务执行的机制</li>
<li>ThreadPoolExecutor 的核心参数解析</li>
<li>ThreadPoolExecutor 的整体流程源码剖析</li>
<li>线程池复用是如何进行的</li>
<li>线程池线程异常的处理</li>
<li>四种线程池</li>
<li>如何配置及关闭线程池</li>
<li>两种使用ThreadPoolExecutor 的Demo</li>
</ul>
<p>最后留意一下阿里Java开发手册中关于线程池涉及到这几个问题：</p>
<ul>
<li>【强制】 线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。<ul>
<li>说明：线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换” 的问题。</li>
</ul>
</li>
<li>【强制】 线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。<ul>
<li>说明：Executors 返回的线程池对象的弊端如下：<ol>
<li><code>FixedThreadPool</code> 和 <code>SingleThreadPool</code>：<strong>允许的请求队列长度为 <code>Integer.MAX_VALUE</code>，可能会堆积大量的请求，从而导致 OOM</strong>。</li>
<li><code>CachedThreadPool</code>：<strong>允许的创建线程数量为 <code>Integer.MAX_VALUE</code>，可能会创建大量的线程，从而导致 OOM</strong>。</li>
</ol>
</li>
</ul>
</li>
<li>【强制】 必须回收自定义的 <code>ThreadLocal</code> 变量，尤其在线程池场景下，线程经常会被复用，如果不清理自定义的 <code>ThreadLocal</code> 变量，可能会影响后续业务逻辑和造成内存泄露等问题。尽量在代理中使用 <code>try-finally</code> 块进行回收。</li>
</ul>
<p><img src="https://i.loli.net/2020/04/03/McIv6xRuoEqQODY.png" alt="image.png"></p>
<hr>
<p>参考资料：</p>
<ul>
<li><a href="[http://www.ideabuffer.cn/2017/04/04/深入理解Java线程池：ThreadPoolExecutor/](http://www.ideabuffer.cn/2017/04/04/深入理解Java线程池：ThreadPoolExecutor/)">深入理解Java线程池：ThreadPoolExecutor</a></li>
<li><a href="https://mp.weixin.qq.com/s/baYuX8aCwQ9PP6k7TDl2Ww" target="_blank" rel="noopener">Java线程池实现原理及其在美团业务中的实践</a></li>
<li><a href="http://www.tianxiaobo.com/2018/04/17/Java-线程池原理分析/" target="_blank" rel="noopener">Java 线程池原理分析</a></li>
<li><a href="https://www.cnblogs.com/dongguacai/p/6030187.html" target="_blank" rel="noopener">JAVA线程池原理详解一</a></li>
<li><a href="https://blog.csdn.net/lift_class/article/details/70216690" target="_blank" rel="noopener">线程池，这一篇或许就够了</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzIxNTQ4MzE1NA==&amp;mid=2247483741&amp;idx=1&amp;sn=238fc933c3b9b19ab1754b23283ac6fd&amp;chksm=9796d720a0e15e364f4105c29de606e7329760a41607136a722dc97bb177f9362aeacd92f762&amp;mpshare=1&amp;scene=1&amp;srcid=0327sk1b22zCDOAxzazzEBon&amp;sharer_sharetime=1585311891544&amp;sharer_shareid=b9c5b20e14a5ec65e524cd503ba56884&amp;key=362c475b03eb9012c3a4814de16c542df00e00cb88ad625adda59fe05e00e41bf016bca7d19de52329538b9719e995fa2746837543243fdd9b9a8a873c4b7306ae9be2f34fc0a8f197397eec5bcf36d7&amp;ascene=1&amp;uin=MjkxODQzNTgxMg%3D%3D&amp;devicetype=Windows+7&amp;version=62080079&amp;lang=zh_TW&amp;exportkey=A7VoXZ0wFQgcHgODYeWgoNo%3D&amp;pass_ticket=cBjPmhH%2B5L9207Zh9fWCw5cVrpKDK%2B3yqD%2FHI0IlhthmyIKGfVv3OEP8DCmqTYVl" target="_blank" rel="noopener">有的线程它死了，于是它变成一道面试题</a></li>
<li><a href="https://crossoverjie.top/2018/07/29/java-senior/ThreadPool/#" target="_blank" rel="noopener">如何优雅的使用和理解线程池</a></li>
<li>书籍：Java 并发编程的艺术</li>
<li>书籍：深入浅出Java 多线程</li>
<li>书籍：阿里巴巴Java开发手册</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - AQS：框架分析</title>
    <url>/2020/03/31/java-bing-fa-aqs-kuang-jia-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-介绍AQS"><a href="#1-介绍AQS" class="headerlink" title="1.介绍AQS"></a>1.介绍AQS</h1><p>AbstractQueuedSynchronizer （抽象队列同步器，以下简称 AQS）出现在 JDK 1.5 中，AQS 这个东西在Java的并发中是很重要的一部分，因为他是很多同步器的基础框架，比如 ReentrantLock、CountDownLatch 和 Semaphore 等等都是基于 AQS 实现的。基于AQS来构建同步器可以带来很多好处。它不仅能够极大地减少实现工作，而且也不必处理在多个位置上发生的竞争问题。 </p>
<p>在基于AQS构建的同步器中，<u>只能在一个时刻发生阻塞，从而降低上下文切换的开销，提高了吞吐量</u>。同时在设计AQS时充分考虑了可伸缩行，因此J.U.C中所有基于AQS构建的同步器均可以获得这个优势。 </p>
<p>AQS的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态。</p>
<p>AQS使用一个int类型的成员变量state来表示同步状态，<u>当state&gt;0时表示已经获取了锁，当state = 0时表示释放了锁</u>。它提供了三个方法（<code>getState()</code>、<code>setState(int newState)</code>、<code>compareAndSetState(int expect,int update)</code>）来对同步状态state进行操作，当然AQS可以确保对state的操作是安全的。</p>
<p>AQS通过内置的<strong>FIFO同步队列</strong>（这个会重点分析一下）来完成资源获取线程的排队工作，如果当前线程获取同步状态失败（锁）时，AQS则会将当前线程以及等待状态等信息构造成一个节点（Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，则会把节点中的线程唤醒，使其再次尝试获取同步状态。 </p>
<p>一句话：AQS使用一个Volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值的修改。</p>
<a id="more"></a>

<p>这里列出了AQS主要提供的一些方法，方便快速定位：</p>
<ul>
<li><code>getState()</code>：返回同步状态的当前值；</li>
<li><code>setState(int newState)</code>：设置当前同步状态；</li>
<li><code>compareAndSetState(int expect, int update)</code>：使用CAS设置当前状态，该方法能够保证状态设置的原子性；</li>
<li><code>tryAcquire(int arg)</code>：独占式获取同步状态，获取同步状态成功后，其他线程需要等待该线程释放同步状态才能获取同步状态；</li>
<li><code>tryRelease(int arg)</code>：独占式释放同步状态；</li>
<li><code>tryAcquireShared(int arg)</code>：共享式获取同步状态，返回值大于等于0则表示获取成功，否则获取失败；</li>
<li><code>tryReleaseShared(int arg)</code>：共享式释放同步状态；</li>
<li><code>isHeldExclusively()</code>：当前同步器是否在独占式模式下被线程占用，一般该方法表示是否被当前线程所独占；</li>
<li><code>acquire(int arg)</code>：独占式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回，否则，将会进入同步队列等待，该方法将会调用可重写的tryAcquire(int arg)方法；</li>
<li><code>acquireInterruptibly(int arg)</code>：与acquire(int arg)相同，但是该方法响应中断，当前线程为获取到同步状态而进入到同步队列中，如果当前线程被中断，则该方法会抛出InterruptedException异常并返回；</li>
<li><code>tryAcquireNanos(int arg,long nanos)</code>：超时获取同步状态，如果当前线程在nanos时间内没有获取到同步状态，那么将会返回false，已经获取则返回true；</li>
<li><code>acquireShared(int arg)</code>：共享式获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，与独占式的主要区别是在同一时刻可以有多个线程获取到同步状态；</li>
<li><code>acquireSharedInterruptibly(int arg)</code>：共享式获取同步状态，响应中断；</li>
<li><code>tryAcquireSharedNanos(int arg, long nanosTimeout)</code>：共享式获取同步状态，增加超时限制；</li>
<li><code>release(int arg)</code>：独占式释放同步状态，该方法会在释放同步状态之后，将同步队列中第一个节点包含的线程唤醒；</li>
<li><code>releaseShared(int arg)</code>：共享式释放同步状态；</li>
</ul>
<p>以上这些方法在下面的源码分析中都会有所涉及，这个AQS框架还是有些代码量挺复杂的，好好理解的话对于后面的其他的一些锁相关机制、通信工具类都是很有帮助的，内功心法都学会了，其他的就简单很多了。</p>
<p>大体整个框架图（图出自美团）：</p>
<p><img src="https://i.loli.net/2020/04/12/W2c1Kex85fz3Z6V.png" alt="AQS框架图"></p>
<hr>
<h1 id="2-AQS理论的数据结构"><a href="#2-AQS理论的数据结构" class="headerlink" title="2.AQS理论的数据结构"></a>2.AQS理论的数据结构</h1><p>AQS类中维护了一个双向链表(FIFO队列)， 这个队列也称CLH同步队列，有什么用呢？AQS就是靠这个队列来完成同步状态的管理的！</p>
<p>怎么进行管理的？这个问题问得好，大概流程就是这样：当前线程如果获取同步状态失败时，AQS则会将当前线程已经等待状态等信息构造成一个节点（Node）并将其加入到CLH同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点唤醒（公平锁），使其再次尝试获取同步状态。 </p>
<p>Node源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line">    <span class="comment">//标记一个结点（对应的线程）在共享模式下等待</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">// 标记一个结点（对应的线程）在独占模式下等待</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// waitStatus的值，表示该结点（对应的线程）已被取消</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED = <span class="number">1</span>; </span><br><span class="line">    <span class="comment">//waitStatus的值，表示后继结点（对应的线程）需要被唤醒</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//waitStatus的值，表示该结点（对应的线程）在等待某一条件</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// waitStatus的值，表示有资源可用，新head结点需要继续唤醒后继结点</span></span><br><span class="line">    <span class="comment">// （共享模式下，多线程并发释放资源，而head唤醒其后继结点后，需要把多出来的资源留给后面的结点；</span></span><br><span class="line">    <span class="comment">//  设置新的head结点时，会继续唤醒其后继结点）*/</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 等待状态，取值范围，-3，-2，-1，0，1(如上)</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">    <span class="comment">// 前驱结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev; </span><br><span class="line">    <span class="comment">// 后继结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next; </span><br><span class="line">    <span class="comment">// 结点对应的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread; </span><br><span class="line">    <span class="comment">// 等待队列里下一个等待条件的结点</span></span><br><span class="line">    Node nextWaiter; </span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>线程两种锁的模式：</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SHARED</td>
<td align="left">表示线程以共享的模式等待锁</td>
</tr>
<tr>
<td align="left">EXCLUSIVE</td>
<td align="left">表示线程正在以独占的方式等待锁</td>
</tr>
</tbody></table>
<p>waitStatus有下面几个枚举值：</p>
<table>
<thead>
<tr>
<th align="left">枚举</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">当一个Node被初始化的时候的默认值</td>
</tr>
<tr>
<td align="left">CANCELLED</td>
<td align="left">为1，表示线程获取锁的请求已经取消了</td>
</tr>
<tr>
<td align="left">CONDITION</td>
<td align="left">为-2，表示节点在等待队列中，节点线程等待唤醒</td>
</tr>
<tr>
<td align="left">PROPAGATE</td>
<td align="left">为-3，当前线程处在SHARED情况下，该字段才会使用</td>
</tr>
<tr>
<td align="left">SIGNAL</td>
<td align="left">为-1，表示线程已经准备好了，就等资源释放了</td>
</tr>
</tbody></table>
<p>Node的内部其实是这样的：</p>
<p><img src="https://i.loli.net/2020/04/11/1k73AyCUJz9lVTd.png" alt="Node结点内部"></p>
<p>如上图所示，Node 的数据结构其实也挺简单的，就是 thread + waitStatus + pre + next 四个属性而已。</p>
<p>而AQS还有哪些属性呢？如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 头结点，可以理解为：当前持有锁的线程 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个链表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意区分state和waiteState！！！</span></span><br><span class="line"><span class="comment">// 这个是最重要的，代表当前锁的状态，0代表没有被占用，大于 0 代表有线程持有当前锁</span></span><br><span class="line"><span class="comment">// 这个值可以大于 1，是因为锁可以重入，每次重入都加上 1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表当前持有独占锁的线程，举个最重要的使用例子，因为锁可以重入</span></span><br><span class="line"><span class="comment">// reentrantLock.lock()可以嵌套调用多次，所以每次用这个来判断当前线程是否已经拥有了锁</span></span><br><span class="line"><span class="comment">// if (currentThread == getExclusiveOwnerThread()) {state++}</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread; <span class="comment">//继承自AbstractOwnableSynchronizer</span></span><br></pre></td></tr></tbody></table></figure>


<p>再抽象一点就是这样了，使用图示的话就如下可以很清晰的表达了（图源文末参考文章），不过需要注意的是：<u>阻塞队列不包含 head 节点。（如上图所示）</u></p>
<p>解释一下head：head是队列中标志，用于指示下一个被unpack的node，head来源于初始化的或曾取得过锁的node。</p>
<p>AbstractQueuedSynchronizer 的等待队列示意如下所示：</p>
<p><img src="https://i.loli.net/2020/04/11/9WIVEU64vpXCcP7.png" alt="CLH队列（FIFO）"></p>
<p>关于双向队列的入队操作和出队操作这些应该比较容易理解，这里就不再讲了。</p>
<hr>
<h1 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3.源码分析"></a>3.源码分析</h1><p>AQS同时提供了互斥模式（exclusive）和共享模式（shared）两种不同的同步逻辑。一般情况下，子类只需要根据需求实现其中一种模式，当然也有同时实现两种模式的同步类，如<code>ReadWriteLock</code>。接下来将详细介绍这两种模式。</p>
<h2 id="3-1-独占模式"><a href="#3-1-独占模式" class="headerlink" title="3.1 独占模式"></a>3.1 独占模式</h2><h3 id="3-1-1-独占式同步状态获取：acquire"><a href="#3-1-1-独占式同步状态获取：acquire" class="headerlink" title="3.1.1 独占式同步状态获取：acquire"></a>3.1.1 独占式同步状态获取：acquire</h3><p>独占式获取同步状态时通过 acquire 进行的，他是AQS提供的模板方法，该方法为独占式获取同步状态。但是该方法对中断不敏感，也就是说由于线程获取同步状态失败加入到CLH同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移除。</p>
<p>acquire的主要完成的事情是这样的：</p>
<ol>
<li>获取独占锁，对中断不敏感。</li>
<li>首先尝试获取一次锁，如果成功，则返回，就结束了！！！</li>
<li>否则会把当前线程包装成Node插入到队列中，在队列中会检测是否为head的直接后继，并尝试获取锁</li>
<li>如果获取失败，则会通过LockSupport阻塞当前线程，直至被释放锁的线程唤醒或者被中断，随后再次尝试获取锁，如此反复。</li>
</ol>
<p>其源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">       <span class="comment">// tryAcquire:去尝试获取锁，获取成功则设置锁状态并返回true，否则返回false。</span></span><br><span class="line">       <span class="comment">// addWaiter：如果tryAcquire返回FALSE（获取同步状态失败），则调用该方法将当前线程加入到CLH同步队列尾部。</span></span><br><span class="line">       <span class="comment">// acquireQueued：当前线程会根据公平性原则来进行阻塞等待（自旋）,直到获取锁为止；并且返回当前线程在等待过程中有没有中断过。</span></span><br><span class="line">       <span class="comment">// selfInterrupt：产生一个中断。</span></span><br><span class="line">       <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; </span><br><span class="line">           <span class="comment">// tryAcquire(arg)没有成功，这个时候需要把当前线程挂起，放到阻塞队列中。</span></span><br><span class="line">           acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">           selfInterrupt();</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>



<h4 id="tryAcquire-int"><a href="#tryAcquire-int" class="headerlink" title="tryAcquire(int)"></a>tryAcquire(int)</h4><p>上面提到的<code>tryAcquire</code>方法， tryAcquire尝试以独占的方式获取资源，如果获取成功，则直接返回true，否则直接返回false。该方法可以用于实现Lock中的tryLock()方法。而AQS中并没有实现上面的<code>tryAcquire(arg)</code>方法，当你跟进去的时候会发现，只是抛出一个异常而已，该方法自定义同步组件自己实现，该方法必须要保证线程安全的获取同步状态。AQS在这里只负责定义了一个公共的方法框架。</p>
<p>这里之所以没有定义成abstract，是因为独占模式下只用实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。</p>
<p>其代码如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 去尝试获取锁，获取成功则设置锁状态并返回true，否则返回false。</span></span><br><span class="line"><span class="comment"> * 该方法自定义同步组件自己实现，该方法必须要保证线程安全的获取同步状态。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>而具体获取锁的操作需要由其子类进行实现，比如ReentrantLock中的Sync实现，如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fair version of tryAcquire.  Don't grant access unless</span></span><br><span class="line"><span class="comment"> * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 尝试直接获取锁，返回值是boolean，代表是否获取到锁</span></span><br><span class="line"><span class="comment">// 返回true：1.没有线程在等待锁；2.重入锁，线程本来就持有锁，也就可以理所当然可以直接获取</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// state == 0 此时此刻没有线程持有锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 虽然此时此刻锁是可以用的，但是这是公平锁，既然是公平，就得讲究先来后到，</span></span><br><span class="line">        <span class="comment">// 看看有没有别人在队列中等了半天了</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            <span class="comment">// 如果没有线程在等待，那就用CAS尝试一下，成功了就获取到锁了，</span></span><br><span class="line">            <span class="comment">// 不成功的话，只能说明一个问题，就在刚刚几乎同一时刻有个线程抢先了 =_=</span></span><br><span class="line">            <span class="comment">// 因为刚刚还没人的，我判断过了</span></span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) {</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 到这里就是获取到锁了，标记一下，告诉大家，现在是我占用了锁</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 会进入这个else if分支，说明是重入了，需要操作：state=state+1</span></span><br><span class="line">    <span class="comment">// 这里不存在并发问题</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) {</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果到这里，说明前面的if和else if都没有返回true，说明没有获取到锁</span></span><br><span class="line">    <span class="comment">// 回到上面一个外层调用方法继续看:</span></span><br><span class="line">    <span class="comment">// if (!tryAcquire(arg) </span></span><br><span class="line">    <span class="comment">//        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) </span></span><br><span class="line">    <span class="comment">//     selfInterrupt();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里你会发现上面有重入锁的概念，意思就是已经获取到锁的线程还可以再次获取到同一个锁，这里多嘴一下，有哪些锁是重入锁呢？比如：syschronized、ReentrantLock都属于重入锁，而自旋锁不属于重入锁。</p>
<hr>
<h4 id="addWaiter-Node"><a href="#addWaiter-Node" class="headerlink" title="addWaiter(Node)"></a>addWaiter(Node)</h4><p>假设<code>tryAcquire(arg)</code> 返回false，那么代码将执行：<code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code>，这个方法，首先需要执行：<code>addWaiter(Node.EXCLUSIVE)</code></p>
<p>该方法用于将当前线程根据不同的模式（<code>Node.EXCLUSIVE</code>互斥模式、<code>Node.SHARED</code>共享模式）加入到等待队列的队尾，并返回当前线程所在的结点。其添加过程是一个自旋过程，会去尝试能否添加到尾结点，如果队列为空会进行同步队列的初始化。需要注意的是，这里取消了快速尝试这个方法，<code>addWaiter</code>直接就自旋了，所以在这里是没有<code>enq(node);</code>这个方法的。</p>
<p>源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>{</span><br><span class="line">    <span class="comment">// 新建Node</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(mode);</span><br><span class="line">    <span class="comment">// 通过 CAS + 自旋的方式插入节点到队尾</span></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="comment">// 如果队列不为空，则先记录当前尾结点为旧的尾结点</span></span><br><span class="line">        Node oldTail = tail;</span><br><span class="line">        <span class="comment">// 判断队列是否为空，队列为空的话就先初始化队列再重新进入for循环当中，将结点node入队！</span></span><br><span class="line">        <span class="keyword">if</span> (oldTail != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 这个操作其实就是：node.prev = pred;</span></span><br><span class="line"><span class="comment">             * AQS的精妙就是体现在很多细节的代码，比如需要用CAS往队尾里增加一个元素</span></span><br><span class="line"><span class="comment">             * 此处的else分支是先在CAS的if前设置node.prev = oldTail，而不是在CAS成功之后再设置。</span></span><br><span class="line"><span class="comment">             * 一方面是基于CAS的双向链表插入目前没有完美的解决方案，另一方面这样子做的好处是：</span></span><br><span class="line"><span class="comment">             * 保证每时每刻tail.prev都不会是一个null值，否则如果node.prev = t</span></span><br><span class="line"><span class="comment">             * 放在下面if的里面，会导致一个瞬间tail.prev = null，这样会使得队列不完整。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            node.setPrevRelaxed(oldTail);</span><br><span class="line">            <span class="comment">// CAS设置tail为node，成功后把老的tail也就是连接到node。</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(oldTail, node)) {</span><br><span class="line">                <span class="comment">// 实现了和之前的尾节点双向连接了</span></span><br><span class="line">                oldTail.next = node;</span><br><span class="line">                <span class="comment">// 线程入队了，可以返回了</span></span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 如果队列为空，则初始化该同步队列</span></span><br><span class="line">            <span class="comment">// 初始化之后，没有return，会继续for循环！！！</span></span><br><span class="line">            initializeSyncQueue();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>initializeSyncQueue就是一个初始化同步队列的方法，其源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes head and tail fields on first contention.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initializeSyncQueue</span><span class="params">()</span> </span>{</span><br><span class="line">    Node h;</span><br><span class="line">    <span class="keyword">if</span> (HEAD.compareAndSet(<span class="keyword">this</span>, <span class="keyword">null</span>, (h = <span class="keyword">new</span> Node())))</span><br><span class="line">        <span class="comment">// 这个时候有了head，但是tail还是null，设置一下， 把tail指向head</span></span><br><span class="line">        <span class="comment">//，但是很快有线程进来，tail就会重新指向</span></span><br><span class="line">        <span class="comment">// 注意：这里只是设置了tail=head，此处没有return;</span></span><br><span class="line">        <span class="comment">// 所以，设置完了以后，继续for循环</span></span><br><span class="line">        tail = h;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<hr>
<h4 id="acquireQueued-Node-int"><a href="#acquireQueued-Node-int" class="headerlink" title="acquireQueued(Node, int)"></a>acquireQueued(Node, int)</h4><p>返回<code>acquire</code>方法中，参数node，经过addWaiter(Node.EXCLUSIVE)，此时已经进入阻塞队列，注意一下：如果acquireQueued(addWaiter(Node.EXCLUSIVE), arg))返回true的话，意味着上面这段代码将进入<code>selfInterrupt()</code>，所以正常情况下，下面应该返回false。</p>
<p>这个方法非常重要，应该说真正的线程挂起，然后被唤醒后去获取锁，都在这个方法里了！！！</p>
<p><code>acquireQueued</code>方法为一个<u>自旋的过程</u>，也就是说当前线程（Node）进入同步队列后，就会进入一个自旋的过程，每个节点都会自省地观察，当条件满足，获取到同步状态后，就可以从这个自旋过程中退出，否则会一直执行下去。如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="comment">// 中断标志</span></span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 自旋的过程</span></span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="comment">// 当前线程的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 检测当前节点前驱是否head，这是试获取锁的资格</span></span><br><span class="line">            <span class="comment">// 如果是的话，则调用tryAcquire尝试获取锁</span></span><br><span class="line">            <span class="comment">// 成功，则将head置为当前节点。</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) {</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 到这里，说明上面的if分支没有成功，要么当前node本来就不是队头，要么就是tryAcquire(arg)没有抢赢别人</span></span><br><span class="line">            <span class="comment">// 如果未成功获取锁则根据前驱节点判断是否要阻塞</span></span><br><span class="line">            <span class="comment">// 注意：在获取同步状态失败后，线程并不是立马进行阻塞，需要检查该线程的状态</span></span><br><span class="line">            <span class="comment">// 如果shouldParkAfterFailedAcquire返回false，会继续上面的for循环！！！</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node))</span><br><span class="line">                <span class="comment">// 上面的判断如果返回true, 说明前驱节点的waitStatus==-1，是正常情况</span></span><br><span class="line">                <span class="comment">//    那么当前线程需要被挂起，等待以后被唤醒</span></span><br><span class="line">                <span class="comment">//    以后是被前驱节点唤醒，就等着前驱节点拿到锁，然后释放锁的时候叫你好了</span></span><br><span class="line">                <span class="comment">// 如果返回false, 说明当前不需要被挂起</span></span><br><span class="line">                <span class="comment">//    仔细看shouldParkAfterFailedAcquire(p, node)，我们可以发现，其实第一次进来的时候，一般都不会返回true的</span></span><br><span class="line">                <span class="comment">//    原因很简单，前驱节点的waitStatus=-1是依赖于后继节点设置的。</span></span><br><span class="line">                <span class="comment">//    也就是说，我都还没给前驱设置-1呢，怎么可能是true呢，但是要看到，这个方法是套在循环里的，所以第二次进来的时候状态就是-1了。</span></span><br><span class="line">                <span class="comment">//    所以：是为了应对在经过这个方法后，node已经是head的直接后继节点了</span></span><br><span class="line">                interrupted |= parkAndCheckInterrupt();</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">        <span class="comment">// 如果tryAcquire 抛出异常的话，则进行状态获取的取消</span></span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">        <span class="comment">// 如果是中断状态的话，进行一个自我中断</span></span><br><span class="line">        <span class="keyword">if</span> (interrupted)</span><br><span class="line">            selfInterrupt();</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>从上面代码中可以看到，当前线程会一直尝试获取同步状态，当然前提是只有其前驱节点为头结点才能够尝试获取同步状态，理由：</p>
<ol>
<li>保持FIFO同步队列原则。</li>
<li>头节点释放同步状态后，将会唤醒其后继节点，后继节点被唤醒后需要检查自己是否为头节点。</li>
</ol>
<p>上面还有一点，就是当获取同步状态失败后，线程并不是立马进行阻塞，需要检查该线程的状态，检查状态的方法为 <code>shouldParkAfterFailedAcquire(Node pred, Node node)</code> 方法。该方法主要用途是：当线程在获取同步状态失败时，根据前驱节点的等待状态，决定后续的动作。比如前驱节点等待状态为 SIGNAL，表明当前节点线程应该被阻塞住了。不能老是尝试，避免 CPU 忙等。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 会到这里就是没有抢到锁，这个方法说的是："当前线程没有抢到锁，是否需要挂起当前线程？"</span></span><br><span class="line"><span class="comment">// 第一个参数是前驱节点，第二个参数才是代表当前线程的节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>{</span><br><span class="line">    <span class="comment">// 前驱节点</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">// 前驱节点状态为SIGNAL（-1），说明前驱节点状态正常，当前线程需要挂起，直接可以返回true</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 前驱节点 waitStatus大于0 ，之前说过，大于0 说明前驱节点取消了排队。</span></span><br><span class="line">    <span class="comment">// 这里需要知道这点：进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。</span></span><br><span class="line">    <span class="comment">// 所以下面这块代码说的是将当前节点的prev指向waitStatus&lt;=0的节点，</span></span><br><span class="line">    <span class="comment">// 简单说，就是为了找个好爹，因为你还得依赖它来唤醒呢，如果前驱节点取消了排队，</span></span><br><span class="line">    <span class="comment">// 找前驱节点的前驱节点做爹，往前遍历总能找到一个好爹的！！！</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">do</span> {</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        } <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 仔细想想，如果进入到这个分支意味着什么</span></span><br><span class="line">        <span class="comment">// 前驱节点的waitStatus不等于-1和1，那也就是只可能是0，-2，-3</span></span><br><span class="line">        <span class="comment">// 在我们前面的源码中，都没有看到有设置waitStatus的，所以每个新的node入队时，waitStatu都是0</span></span><br><span class="line">        <span class="comment">// 正常情况下，前驱节点是之前的 tail，那么它的 waitStatus 应该是 0</span></span><br><span class="line">        <span class="comment">// 用CAS将前驱节点的waitStatus设置为Node.SIGNAL(也就是-1)</span></span><br><span class="line">        pred.compareAndSetWaitStatus(ws, Node.SIGNAL);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 这个方法返回 false，那么会再走一次 for 循序，</span></span><br><span class="line">    <span class="comment">// 然后再次进来此方法，此时会从第一个分支返回 true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>这段代码主要检查当前线程是否需要被阻塞，具体规则如下：</p>
<ol>
<li>如果当前线程的前驱节点状态为SIGNAL，则表明当前线程需要被阻塞，调用unpark()方法唤醒，直接返回true，当前线程阻塞</li>
<li>如果当前线程的前驱节点状态为CANCELLED（ws &gt; 0），则表明该线程的前驱节点已经等待超时或者被中断了，则需要从CLH队列中将该前驱节点删除掉，直到回溯到前驱节点状态 &lt;= 0 ，返回false</li>
<li>如果前驱节点非SINGAL，非CANCELLED，则通过CAS的方式将其前驱节点设置为SIGNAL，返回false</li>
</ol>
<p>上面一堆看得眼花，简略来说如下：</p>
<ol>
<li>前驱节点为SIGNAL：阻塞。</li>
<li>前驱节点为CANCELLED ：向前遍历, 移除前面所有为该状态的节点。</li>
<li>前驱节点为waitStatus &lt; 0：将前驱节点状态设为 SIGNAL, 并再次尝试获取同步状态。</li>
</ol>
<p>如果<code>shouldParkAfterFailedAcquire</code>返回true，则<code>acquireQueued</code>则会接着调用<code>parkAndCheckInterrupt</code>来阻塞当前线程，该方法主要是把当前线程挂起，从而阻塞住线程的调用栈，同时返回当前线程的中断状态，其源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 调用LockSupport工具类的park()方法来阻塞该方法。</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 返回当前线程的中断状态</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>而关于<code>LockSupport</code>相关的东西，可以查看我对其分析的笔记：<a href="https://dongxiem.github.io/2020/04/11/java-bing-fa-aqs-locksupport-zu-sai-huan-xing-xian-cheng/">Java 并发 - AQS：LockSupport阻塞唤醒线程</a></p>
<p>再回到acquireQueued中，如果在获取同步状态中出现异常，<code>failed = true</code>，<code>cancelAcquire</code> 方法会被执行。因为tryAcquire 需同步组件开发者覆写，难免不了会出现异常。该方法主要的作用就是：取消获取同步状态。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>{</span><br><span class="line">       <span class="comment">// Ignore if node doesn't exist</span></span><br><span class="line">       <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">       node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 遍历并更新节点前驱，把node的prev指向前部第一个非取消节点</span></span><br><span class="line">       Node pred = node.prev;</span><br><span class="line">       <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">           node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 记录pred节点的后继为predNext，后续CAS会用到</span></span><br><span class="line">       Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 直接把当前节点的等待状态置为取消,后继节点即便也在cancel可以跨越node节点。</span></span><br><span class="line">       node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 如果CAS将tail从node置为pred节点了</span></span><br><span class="line"><span class="comment">       * 则剩下要做的事情就是尝试用CAS将pred节点的next更新为null以彻底切断pred和node的联系。</span></span><br><span class="line"><span class="comment">       * 这样一来就断开了pred与pred的所有后继节点，这些节点由于变得不可达，最终会被回收掉。</span></span><br><span class="line"><span class="comment">       * 由于node没有后继节点，所以这种情况到这里整个cancel就算是处理完毕了。</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * 这里的CAS更新pred的next即使失败了也没关系，说明有其它新入队线程或者其它取消线程更新掉了。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) {</span><br><span class="line">           <span class="comment">/* </span></span><br><span class="line"><span class="comment">            * 执行到这里，表明 pred 节点被成功设为了尾节点，这里通过 CAS 将 pred 节点的后继节点</span></span><br><span class="line"><span class="comment">            * 设为 null。注意这里的 CAS 即使失败了，也没关系。失败了，表明 pred 的后继节点更新</span></span><br><span class="line"><span class="comment">            * 了。pred 此时已经是尾节点了，若后继节点被更新，则是有新节点入队了。这种情况下，CAS </span></span><br><span class="line"><span class="comment">            * 会失败，但失败不会影响同步队列的结构。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           pred.compareAndSetNext(predNext, <span class="keyword">null</span>);</span><br><span class="line">       } <span class="keyword">else</span> {</span><br><span class="line">           <span class="comment">// 根据条件判断是唤醒后继节点，还是将前驱节点和后继节点连接到一起</span></span><br><span class="line">           <span class="keyword">int</span> ws;</span><br><span class="line">           <span class="comment">// 如果当前节点不是head的后继节点，1:判断当前节点前驱节点的是否为SIGNAL，2:如果不是，则把前驱节点设置为SINGAL看是否成功</span></span><br><span class="line">           <span class="comment">// 如果1和2中有一个为true，再判断当前节点的线程是否为null</span></span><br><span class="line">           <span class="comment">// 如果上述条件都满足，把当前节点的前驱节点的后继指针指向当前节点的后继节点    </span></span><br><span class="line">           <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">               ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">                (ws &lt;= <span class="number">0</span> &amp;&amp; pred.compareAndSetWaitStatus(ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">               pred.thread != <span class="keyword">null</span>) {</span><br><span class="line">               Node next = node.next;</span><br><span class="line">               <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                   <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    * 这里使用 CAS 设置 pred 的 next，表明多个线程同时在取消，这里存在竞争。</span></span><br><span class="line"><span class="comment">                    * 不过此处没针对 compareAndSetNext 方法失败后做一些处理，表明即使失败了也</span></span><br><span class="line"><span class="comment">                    * 没关系。实际上，多个线程同时设置 pred 的 next 引用时，只要有一个能设置成</span></span><br><span class="line"><span class="comment">                    * 功即可。</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                   pred.compareAndSetNext(predNext, next);</span><br><span class="line">           } <span class="keyword">else</span> {</span><br><span class="line">               <span class="comment">/*</span></span><br><span class="line"><span class="comment">                * 如果当前节点是head的后继节点，或者上述条件不满足，那就唤醒当前节点的后继节点</span></span><br><span class="line"><span class="comment">                * 这里简单讲一下为什么要唤醒后继线程，考虑下面一种情况：</span></span><br><span class="line"><span class="comment">                *        head          node1         node2         tail</span></span><br><span class="line"><span class="comment">                *        ws=0          ws=1          ws=-1         ws=0</span></span><br><span class="line"><span class="comment">                *      +------+  prev +-----+  prev +-----+  prev +-----+</span></span><br><span class="line"><span class="comment">                *      |      | &lt;---- |     | &lt;---- |     | &lt;---- |     |  </span></span><br><span class="line"><span class="comment">                *      |      | ----&gt; |     | ----&gt; |     | ----&gt; |     |</span></span><br><span class="line"><span class="comment">                *      +------+  next +-----+  next +-----+  next +-----+</span></span><br><span class="line"><span class="comment">                *      </span></span><br><span class="line"><span class="comment">                * 头结点初始状态为 0，node1、node2 和 tail 节点依次入队。node1 自旋过程中调用 </span></span><br><span class="line"><span class="comment">                * tryAcquire 出现异常，进入 cancelAcquire。head 节点此时等待状态仍然是 0，它</span></span><br><span class="line"><span class="comment">                * 会认为后继节点还在运行中，所它在释放同步状态后，不会去唤醒后继等待状态为非取消的</span></span><br><span class="line"><span class="comment">                * 节点 node2。如果 node1 再不唤醒 node2 的线程，该线程面临无法被唤醒的情况。此</span></span><br><span class="line"><span class="comment">                * 时，整个同步队列就回全部阻塞住。</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">               unparkSuccessor(node);</span><br><span class="line">           }</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">           * 取消节点的next之所以设置为自己本身而不是null,</span></span><br><span class="line"><span class="comment">           * 是为了方便AQS中Condition部分的isOnSyncQueue方法,</span></span><br><span class="line"><span class="comment">           * 判断一个原先属于条件队列的节点是否转移到了同步队列。</span></span><br><span class="line"><span class="comment">           *</span></span><br><span class="line"><span class="comment">           * 因为同步队列中会用到节点的next域，取消节点的next也有值的话，</span></span><br><span class="line"><span class="comment">           * 可以断言next域有值的节点一定在同步队列上。</span></span><br><span class="line"><span class="comment">           *</span></span><br><span class="line"><span class="comment">           * 在GC层面，和设置为null具有相同的效果。</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">           node.next = node; <span class="comment">// help GC</span></span><br><span class="line">       }</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line"><span class="comment">// unparkSuccessor的作用是唤醒后继节点，其源码如下：</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>{</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">        * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">        * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">// 当前节点状态</span></span><br><span class="line">       <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">       <span class="comment">// 通过 CAS 将等待状态设为 0，让后继节点线程多一次尝试获取同步状态的机会</span></span><br><span class="line">       <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">           node.compareAndSetWaitStatus(ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 当前节点的后继节点</span></span><br><span class="line">       Node s = node.next;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 这里的逻辑就是如果node.next存在并且状态不为取消，则直接唤醒s即可</span></span><br><span class="line"><span class="comment">        * 否则需要从tail开始向前找到node之后最近的非取消节点。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 这里为什么要从tail开始向前查找也是值得琢磨的:</span></span><br><span class="line"><span class="comment">        * 如果读到s == null，不代表node就为tail，参考addWaiter以及enq函数中的我的注释。</span></span><br><span class="line"><span class="comment">        * 不妨考虑到如下场景：</span></span><br><span class="line"><span class="comment">        * 1. node某时刻为tail</span></span><br><span class="line"><span class="comment">        * 2. 有新线程通过addWaiter中的if分支或者enq方法添加自己</span></span><br><span class="line"><span class="comment">        * 3. compareAndSetTail成功</span></span><br><span class="line"><span class="comment">        * 4. 此时这里的Node s = node.next读出来s == null，但事实上node已经不是tail，它有后继了!</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) {</span><br><span class="line">           s = <span class="keyword">null</span>;</span><br><span class="line">           <span class="comment">// 从tail节点开始往前遍历来找可用节点</span></span><br><span class="line">           <span class="comment">// 为何是从tail尾节点开始，而不是从node.next开始呢？</span></span><br><span class="line">           <span class="comment">// 原因在于node.next仍然可能会存在null或者取消了，所以采用tail回溯办法找第一个可用的线程。</span></span><br><span class="line">           <span class="comment">// 最后调用LockSupport的unpark(Thread thread)方法唤醒该线程。</span></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">           * 这里如果 s == null 处理，是不是表明 node 是尾节点？答案是不一定。 </span></span><br><span class="line"><span class="comment">           * 新节点入队时，队列瞬时结构可能如下：</span></span><br><span class="line"><span class="comment">           *                      node1         node2</span></span><br><span class="line"><span class="comment">           *      +------+  prev +-----+ prev  +-----+</span></span><br><span class="line"><span class="comment">           * head |      | &lt;---- |     | &lt;---- |     |  tail</span></span><br><span class="line"><span class="comment">           *      |      | ----&gt; |     |       |     |</span></span><br><span class="line"><span class="comment">           *      +------+ next  +-----+       +-----+</span></span><br><span class="line"><span class="comment">           * </span></span><br><span class="line"><span class="comment">           * node2 节点为新入队节点，此时 tail 已经指向了它，但 node1 后继引用还未设置。</span></span><br><span class="line"><span class="comment">           * 这里 node1 就是 node 参数，s = node1.next = null，但此时 node1 并不是尾</span></span><br><span class="line"><span class="comment">           * 节点。所以这里不能从前向后遍历同步队列，应该从后向前。</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">           <span class="keyword">for</span> (Node p = tail; p != node &amp;&amp; p != <span class="keyword">null</span>; p = p.prev)</span><br><span class="line">               <span class="keyword">if</span> (p.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                   s = p;</span><br><span class="line">       }</span><br><span class="line">       <span class="comment">// 唤醒后继节点</span></span><br><span class="line">       <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">           LockSupport.unpark(s.thread);</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>



<p>上面大概就是：获取当前节点的前驱节点，如果前驱节点的状态是CANCELLED，那就一直往前遍历，找到第一个waitStatus &lt;= 0的节点，将找到的Pred节点和当前Node关联，将当前Node设置为CANCELLED。</p>
<p>进行了上述的一些操作之后根据当前节点的位置，其实需要考虑以下三种情况：</p>
<ol>
<li>当前节点是尾节点。</li>
<li>当前节点是Head的后继节点。</li>
<li>当前节点不是Head的后继节点，也不是尾节点。</li>
</ol>
<p>具体分析一下一上三种情况：</p>
<p>当前节点是尾节点</p>
<p><img src="https://i.loli.net/2020/04/12/cRFCu2bP7m4a5Yt.png" alt="当前节点是尾节点"></p>
<p>当前节点是Head的后继节点：</p>
<p>取消节点的next可以设置为自己本身，不设置为null，上面的注释中有进行解释了，这里就不再解释了，如果有疑惑就往上面翻一下下。</p>
<p><img src="https://i.loli.net/2020/04/12/qSL31JfmY86jkCF.png" alt="当前节点是Head的后继节点"></p>
<p>当前节点不是Head的后继节点，也不是尾节点</p>
<p><img src="https://i.loli.net/2020/04/12/xJrFBz24lspPAIw.png" alt="当前节点不是Head的后继节点 也不是尾节点"></p>
<hr>
<h4 id="selfInterrupt"><a href="#selfInterrupt" class="headerlink" title="selfInterrupt"></a>selfInterrupt</h4><p>在上面如果acquireQueued为True，就会执行selfInterrupt方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>{</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread()) {</span><br><span class="line">        checkAccess();</span><br><span class="line">        <span class="comment">// 线程可能因为IO操作被阻塞</span></span><br><span class="line">        <span class="keyword">synchronized</span> (blockerLock) {</span><br><span class="line">            Interruptible b = blocker;</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="keyword">null</span>) {</span><br><span class="line">                interrupt0();  <span class="comment">// 设置中断状态</span></span><br><span class="line">                b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 设置中断状态</span></span><br><span class="line">    interrupt0();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>该方法其实是为了中断线程。但<u>为什么获取了锁以后还要中断线程呢</u>？这部分属于Java提供的协作式中断知识内容，这里简单介绍一下：</p>
<ol>
<li>当中断线程被唤醒时，并不知道被唤醒的原因，可能是当前线程在等待中被中断，也可能是释放了锁以后被唤醒。因此我们通过Thread.interrupted()方法检查中断标记（该方法返回了当前线程的中断状态，并将当前线程的中断标识设置为False），并记录下来，如果发现该线程被中断过，就再中断一次。</li>
<li>线程在等待资源的过程中被唤醒，唤醒后还是会不断地去尝试获取锁，直到抢到锁为止。也就是说，在整个流程中，并不响应中断，只是记录中断记录。最后抢到锁返回了，那么如果被中断过的话，就需要补充一次中断。</li>
</ol>
<p>这里的处理方式主要是运用线程池中基本运作单元Worder中的runWorker，通过Thread.interrupted()进行额外的判断处理。</p>
<p>整个流程大概就是这么一个回事了，大概的流程还是清楚的，但是个中细节还有待深挖。</p>
<hr>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>总结一下，acquire的大概流程如下：</p>
<ol>
<li>调用 tryAcquire 方法尝试获取同步状态</li>
<li>获取成功，直接返回</li>
<li>获取失败，将线程封装到节点中，并将节点入队</li>
<li>入队节点在 acquireQueued 方法中自旋获取同步状态</li>
<li>若节点的前驱节点是头节点，则再次调用 tryAcquire 尝试获取同步状态</li>
<li>获取成功，当前节点将自己设为头节点并返回</li>
<li>获取失败，可能再次尝试，也可能会被阻塞。这里简单认为会被阻塞。</li>
</ol>
<p>acquire的流程图如下（图源见文末文章出处）：</p>
<p><img src="https://i.loli.net/2020/04/11/TSpwJ46vCqWVF9l.png" alt="acquire执行过程"></p>
<h4 id="示例分析："><a href="#示例分析：" class="headerlink" title="示例分析："></a>示例分析：</h4><p>以下摘自：<a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer" target="_blank" rel="noopener">一行一行源码分析清楚AbstractQueuedSynchronizer</a>，他以<code>reentrantLock</code>进行一个简单的分析：</p>
<p>首先，第一个线程调用 reentrantLock.lock()，<code>tryAcquire(1)</code> 直接就返回 true 了，结束。只是设置了 <code>state=1</code>，连 head 都没有初始化，更谈不上什么阻塞队列了。要是线程 1 调用 unlock() 了，才有线程 2 来，完全没有交集嘛，AQS就派不上用场了。</p>
<p>于是便引出一个问题：如果线程 1 没有调用 unlock() 之前，线程 2 调用了 lock(), 想想会发生什么？</p>
<p>线程 2 会初始化 head【<code>new Node()</code>】，同时线程 2 也会插入到阻塞队列并挂起 （注意看这里是一个 for 循环，而且设置 head 和 tail 的部分是不 return 的，只有入队成功才会跳出循环）</p>
<p>首先，是线程 2 初始化 head 节点，此时 <code>head== tail</code>,  <code>waitStatus==0</code></p>
<p><img src="https://i.loli.net/2020/04/12/2P9voOH3txybzYM.png" alt="初始化head节点"></p>
<p>然后线程 2 入队：</p>
<p><img src="https://i.loli.net/2020/04/12/nexW1CDvzYcRPAh.png" alt="线程2入队"></p>
<p>同时我们也要看此时节点的 <code>waitStatus</code>，我们知道 head 节点是线程 2 初始化的，此时的 <code>waitStatus</code> 没有设置， java 默认会设置为 0，但是到 <code>shouldParkAfterFailedAcquire</code> 这个方法的时候，线程 2 会把前驱节点，也就是 head 的<code>waitStatus</code>设置为 -1。</p>
<p>那线程 2 节点此时的 <code>waitStatus</code> 是多少呢，由于没有设置，所以是 0；</p>
<p>如果线程 3 此时再进来，直接插到线程 2 的后面就可以了，此时线程 3 的 waitStatus 是 0，到 <code>shouldParkAfterFailedAcquire</code> 方法的时候把前驱节点线程 2 的 waitStatus 设置为 -1。</p>
<p><img src="https://i.loli.net/2020/04/12/v6EI48NwXt9Hsx3.png" alt="线程3入队"></p>
<p>这里可以简单说下 <code>waitStatus</code> 中 <code>SIGNAL(-1)</code> 状态的意思，Doug Lea 注释的是：<strong>代表后继节点需要被唤醒</strong>。也就是说<u>这个 waitStatus 其实代表的不是自己的状态，而是后继节点的状态</u>，我们知道，每个 node 在入队的时候，都会把前驱节点的状态改为 SIGNAL，然后阻塞，等待被前驱唤醒。这里涉及的是两个问题：有线程取消了排队、唤醒操作。其实本质是一样的，可以顺着 “waitStatus代表后继节点的状态” 这种思路去看一遍源码。</p>
<hr>
<h3 id="3-1-2-独占式获取响应中断"><a href="#3-1-2-独占式获取响应中断" class="headerlink" title="3.1.2 独占式获取响应中断"></a>3.1.2 独占式获取响应中断</h3><p>AQS提供了<code>acquire(int arg)</code>方法以供独占式获取同步状态，但是该方法对中断不响应，对线程进行中断操作后，该线程会依然位于CLH同步队列中等待着获取同步状态。为了响应中断，AQS提供了<code>acquireInterruptibly(int arg)</code>方法，<u>该方法在等待获取同步状态时，如果当前线程被中断了，会立刻响应中断抛出异常`InterruptedException</u></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>{ <span class="comment">// 这里直接抛出InterruptedException</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 还是一样自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) {</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">        <span class="comment">// 如果有异常，一样要取消申请</span></span><br><span class="line">        <span class="comment">// 然后再抛出异常，而不是使用interrupted标志</span></span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>首先校验该线程是否已经中断了，如果是则抛出<code>InterruptedException</code>，否则执行<code>tryAcquire(int arg)</code>方法获取同步状态，如果获取成功，则直接返回，否则执行<code>doAcquireInterruptibly(int arg)</code>。<code>doAcquireInterruptibly(int arg)</code>定义如下：</p>
<p>doAcquireInterruptibly(int arg)方法与acquire(int arg)方法仅有两个差别：</p>
<ol>
<li>方法声明抛出InterruptedException异常</li>
<li>在中断方法处不再是使用interrupted标志，而是直接抛出InterruptedException异常。</li>
</ol>
<hr>
<h3 id="3-1-3-独占式超时获取"><a href="#3-1-3-独占式超时获取" class="headerlink" title="3.1.3 独占式超时获取"></a>3.1.3 独占式超时获取</h3><p>AQS除了提供上面两个方法外，还提供了一个<u>增强版的方法</u>：<code>tryAcquireNanos(int arg,long nanos)</code>。该方法为<code>acquireInterruptibly</code>方法的进一步增强，它除了响应中断外，还有超时控制。即如果当前线程没有在指定时间内获取同步状态，则会返回false，否则返回true。如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">     <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">     <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">         doAcquireNanos(arg, nanosTimeout);</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">     <span class="comment">// nanosTimeout &lt;= 0</span></span><br><span class="line">     <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     <span class="comment">// 超时时间</span></span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">     <span class="comment">// 新增Node节点</span></span><br><span class="line">     <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">     <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">     <span class="keyword">try</span> {</span><br><span class="line">         <span class="comment">// 自旋</span></span><br><span class="line">         <span class="keyword">for</span> (;;) {</span><br><span class="line">             <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">             <span class="comment">// 获取同步状态成功</span></span><br><span class="line">             <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) {</span><br><span class="line">                 setHead(node);</span><br><span class="line">                 p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                 failed = <span class="keyword">false</span>;</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">             }</span><br><span class="line">             <span class="comment">/*</span></span><br><span class="line"><span class="comment">              * 获取失败，做超时、中断判断</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">             <span class="comment">// 重新计算需要休眠的时间</span></span><br><span class="line">             nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">             <span class="comment">// 已经超时，返回false</span></span><br><span class="line">             <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             <span class="comment">// 如果没有超时，则等待nanosTimeout纳秒</span></span><br><span class="line">             <span class="comment">// 注：该线程会直接从LockSupport.parkNanos中返回，</span></span><br><span class="line">             <span class="comment">// LockSupport为JUC提供的一个阻塞和唤醒的工具类，后面做详细介绍</span></span><br><span class="line">             <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                     nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                 LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">             <span class="comment">// 线程是否已经中断了</span></span><br><span class="line">             <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                 <span class="comment">// 抛出一个异常并且结束</span></span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">         }</span><br><span class="line">     } <span class="keyword">finally</span> {</span><br><span class="line">         <span class="keyword">if</span> (failed)</span><br><span class="line">             cancelAcquire(node);</span><br><span class="line">     }</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>



<p>其大概流程如下：</p>
<p><img src="https://i.loli.net/2020/04/11/LKxausrV8qbcQm6.png" alt="独占式超时获取"></p>
<hr>
<h3 id="3-1-4-独占式同步状态释放：release"><a href="#3-1-4-独占式同步状态释放：release" class="headerlink" title="3.1.4 独占式同步状态释放：release"></a>3.1.4 独占式同步状态释放：release</h3><p>释放的过程会比较简单点：</p>
<ol>
<li>调用 <code>tryRelease(arg)</code> 尝试释放同步状态</li>
<li>如果 <code>tryRelease</code> 返回true也就是独占锁被完全释放，唤醒后继线程。</li>
</ol>
<p>这里的唤醒是根据head几点来判断的，下面代码的注释中也分析了head节点的情况，只有在head存在并且等待状态小于零的情况下唤醒。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Releases in exclusive mode.  Implemented by unblocking one or</span></span><br><span class="line"><span class="comment"> * more threads if {<span class="doctag">@link</span> #tryRelease} returns true.</span></span><br><span class="line"><span class="comment"> * This method can be used to implement method {<span class="doctag">@link</span> Lock#unlock}.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment"> *        {<span class="doctag">@link</span> #tryRelease} but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment"> *        can represent anything you like.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the value returned from {<span class="doctag">@link</span> #tryRelease}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 当线程获取同步状态后，执行完相应逻辑后就需要释放同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 此时的head节点可能有3种情况:</span></span><br><span class="line"><span class="comment">     * 1. null (AQS的head延迟初始化+无竞争的情况)</span></span><br><span class="line"><span class="comment">     * 2. 当前线程在获取锁时new出来的节点通过setHead设置的</span></span><br><span class="line"><span class="comment">     * 3. 由于通过tryRelease已经完全释放掉了独占锁，有新的节点在acquireQueued中获取到了独占锁，并设置了head</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 第三种情况可以再分为两种情况：</span></span><br><span class="line"><span class="comment">     * （一）时刻1:线程A通过acquireQueued，持锁成功，set了head</span></span><br><span class="line"><span class="comment">     *          时刻2:线程B通过tryAcquire试图获取独占锁失败失败，进入acquiredQueued</span></span><br><span class="line"><span class="comment">     *          时刻3:线程A通过tryRelease释放了独占锁</span></span><br><span class="line"><span class="comment">     *          时刻4:线程B通过acquireQueued中的tryAcquire获取到了独占锁并调用setHead</span></span><br><span class="line"><span class="comment">     *          时刻5:线程A读到了此时的head实际上是线程B对应的node</span></span><br><span class="line"><span class="comment">     * （二）时刻1:线程A通过tryAcquire直接持锁成功，head为null</span></span><br><span class="line"><span class="comment">     *          时刻2:线程B通过tryAcquire试图获取独占锁失败失败，入队过程中初始化了head，进入acquiredQueued</span></span><br><span class="line"><span class="comment">     *          时刻3:线程A通过tryRelease释放了独占锁，此时线程B还未开始tryAcquire</span></span><br><span class="line"><span class="comment">     *          时刻4:线程A读到了此时的head实际上是线程B初始化出来的傀儡head</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) {</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// head节点状态不会是CANCELLED，所以这里h.waitStatus != 0相当于h.waitStatus &lt; 0</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 释放成功后，会调用unparkSuccessor(Node node)方法唤醒后继节点</span></span><br><span class="line">            <span class="comment">// 上面已经分析过了，不再叙述</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>跟tryAcquire一样，tryRelease也是由用户自己去实现了，其源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 独占式释放同步状态；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<hr>
<h2 id="3-2-共享模式"><a href="#3-2-共享模式" class="headerlink" title="3.2 共享模式"></a>3.2 共享模式</h2><p>其实如果理解了上面的独享模式之后再来理解共享模式，难度不大，主要是与共享模式下，同一时刻会有多个线程获取共享同步状态。共享模式是实现读写锁中的读锁、CountDownLatch 和 Semaphore 等同步组件的基础，这样再去理解一些共享同步组件就不难了。</p>
<h3 id="3-2-1-同步状态获取：acquireShared"><a href="#3-2-1-同步状态获取：acquireShared" class="headerlink" title="3.2.1 同步状态获取：acquireShared"></a>3.2.1 同步状态获取：acquireShared</h3><p>共享式获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，与独占式的主要区别是在同一时刻可以有多个线程获取到同步状态；</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="comment">// 尝试获取共享同步状态，tryAcquireShared 返回的是整型</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 获取失败，自旋获取同步状态</span></span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>其中<code>doAcquireShared</code>以自旋方式获取同步状态，共享式获取同步状态的标志是返回 &gt;= 0 的值表示获取成功，该方法不响应中断，与独占式相似；</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="comment">// 共享式节点</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 这里和前面一样，也是通过有限次自旋的方式获取同步状态</span></span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="comment">// 前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 前驱是头结点，其类型可能是 EXCLUSIVE，也可能是 SHARED.</span></span><br><span class="line"><span class="comment">             * 如果是 EXCLUSIVE，线程无法获取共享同步状态。</span></span><br><span class="line"><span class="comment">             * 如果是 SHARED，线程则可获取共享同步状态。</span></span><br><span class="line"><span class="comment">             * 能不能获取共享同步状态要看 tryAcquireShared 具体的实现。比如多个线程竞争读写</span></span><br><span class="line"><span class="comment">             * 锁的中的读锁时，均能成功获取读锁。但多个线程同时竞争信号量时，可能就会有一部分线</span></span><br><span class="line"><span class="comment">             * 程因无法竞争到信号量资源而阻塞。</span></span><br><span class="line"><span class="comment">             */</span> </span><br><span class="line">            <span class="keyword">if</span> (p == head) {</span><br><span class="line">                <span class="comment">// 尝试获取同步状态</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) {</span><br><span class="line">                    <span class="comment">// 设置头结点，如果后继节点是共享类型，唤醒后继节点</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node))</span><br><span class="line">                interrupted |= parkAndCheckInterrupt();</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (interrupted)</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p><code>setHeadAndPropagate</code>这个函数主要做了两件事：</p>
<ol>
<li>在获取共享锁成功后，设置head节点</li>
<li>根据调用tryAcquireShared返回的状态以及节点本身的等待状态来判断是否要需要唤醒后继线程。</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>{</span><br><span class="line">    <span class="comment">// 把当前的head封闭在方法栈上，用以下面的条件检查。</span></span><br><span class="line">    Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Try to signal next queued node if:</span></span><br><span class="line"><span class="comment">     *   Propagation was indicated by caller,</span></span><br><span class="line"><span class="comment">     *     or was recorded (as h.waitStatus either before</span></span><br><span class="line"><span class="comment">     *     or after setHead) by a previous operation</span></span><br><span class="line"><span class="comment">     *     (note: this uses sign-check of waitStatus because</span></span><br><span class="line"><span class="comment">     *      PROPAGATE status may transition to SIGNAL.)</span></span><br><span class="line"><span class="comment">     * and</span></span><br><span class="line"><span class="comment">     *   The next node is waiting in shared mode,</span></span><br><span class="line"><span class="comment">     *     or we don't know, because it appears null</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The conservatism in both of these checks may cause</span></span><br><span class="line"><span class="comment">     * unnecessary wake-ups, but only when there are multiple</span></span><br><span class="line"><span class="comment">     * racing acquires/releases, so most need signals now or soon</span></span><br><span class="line"><span class="comment">     * anyway.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// propagate是tryAcquireShared的返回值，这是决定是否传播唤醒的依据之一。</span></span><br><span class="line">    <span class="comment">// h.waitStatus为SIGNAL或者PROPAGATE时也根据node的下一个节点共享来决定是否传播唤醒</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        <span class="comment">// h.waitStatus &lt; 0 时，waitStatus = SIGNAL 或 PROPAGATE。</span></span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) {</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="comment">// 节点 s 如果是共享类型节点，则应该唤醒该节点</span></span><br><span class="line">        <span class="comment">// 至于 s == null 的情况前面分析过，这里不在赘述。</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>那继续到<code>doReleaseShared</code>里面看看做了些什么：</p>
<p><code>doReleaseShared</code>该方法用于在 acquires/releases 存在竞争的情况下，确保唤醒动作向后传播。这是共享锁中的核心唤醒函数，主要做的事情就是唤醒下一个线程或者设置传播状态。后继线程被唤醒后，会尝试获取共享锁，如果成功之后，则又会调用setHeadAndPropagate,将唤醒传播下去。</p>
<p>总的来说：<u>这个函数的作用是保障在acquire和release存在竞争的情况下，保证队列中处于等待状态的节点能够有办法被唤醒。</u></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Release action for shared mode -- signals successor and ensures</span></span><br><span class="line"><span class="comment"> * propagation. (Note: For exclusive mode, release just amounts</span></span><br><span class="line"><span class="comment"> * to calling unparkSuccessor of head if it needs signal.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 以下的循环做的事情就是，在队列存在后继线程的情况下，唤醒后继线程；</span></span><br><span class="line"><span class="comment">     * 或者由于多线程同时释放共享锁由于处在中间过程，读到head节点等待状态为0的情况下，</span></span><br><span class="line"><span class="comment">     * 虽然不能unparkSuccessor，但为了保证唤醒能够正确稳固传递下去，设置节点状态为PROPAGATE。</span></span><br><span class="line"><span class="comment">     * 这样的话获取锁的线程在执行setHeadAndPropagate时可以读到PROPAGATE，从而由获取锁的线程去释放后继等待线程。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// 如果队列中存在后继线程。</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) {</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) {</span><br><span class="line">                <span class="keyword">if</span> (!h.compareAndSetWaitStatus(Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 如果h节点的状态为0，需要设置为PROPAGATE用以保证唤醒的传播。</span></span><br><span class="line">            <span class="comment">// setHeadAndPropagate 在读到 h.waitStatus &lt; 0 时，可以继续唤醒后面的节点。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !h.compareAndSetWaitStatus(<span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 检查h是否仍然是head，如果不是的话需要再进行循环。</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>最后说一下共享模式下获取同步状态的大致流程，如下：</p>
<ol>
<li>获取共享同步状态</li>
<li>若获取失败，则生成节点，并入队</li>
<li>如果前驱为头结点，再次尝试获取共享同步状态</li>
<li>获取成功则将自己设为头结点，如果后继节点是共享类型的，则唤醒</li>
<li>若失败，将节点状态设为 SIGNAL，再次尝试。若再次失败，线程进入等待状态</li>
</ol>
<hr>
<h3 id="3-2-2-共享状态释放：releaseShared"><a href="#3-2-2-共享状态释放：releaseShared" class="headerlink" title="3.2.2 共享状态释放：releaseShared"></a>3.2.2 共享状态释放：releaseShared</h3><p>释放共享状态主要逻辑在 doReleaseShared ，而我们前面已经分析过他了，所以就不继续了。共享节点线程在获取同步状态和释放同步状态时都会调用 doReleaseShared，所以 doReleaseShared 是多线程竞争集中的地方。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) {</span><br><span class="line">        <span class="comment">// 因为可能会存在多个线程同时进行释放同步状态资源</span></span><br><span class="line">        <span class="comment">// 所以在doReleaseShared需要确保同步状态安全地成功释放，一般都是通过CAS和循环来完成的。</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<hr>
<h1 id="4-一些疑问"><a href="#4-一些疑问" class="headerlink" title="4.一些疑问"></a>4.一些疑问</h1><h2 id="4-1-插入节点时的代码顺序"><a href="#4-1-插入节点时的代码顺序" class="headerlink" title="4.1 插入节点时的代码顺序"></a>4.1 插入节点时的代码顺序</h2><p><code>addWaiter</code> 方法中新增一个节点时为什么要先将新节点的prev置为tail再尝试CAS，而不是CAS成功后来构造节点之间的双向链接？</p>
<p>这是因为，双向链表目前没有基于CAS原子插入的手段，如果我们将<code>node.prev = t</code>和<code>t.next = node</code>（t为方法执行时读到的tail，引用封闭在栈上）放到<code>compareAndSetTail(t, node)</code>成功后执行，如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (compareAndSetTail(t, node)) {</span><br><span class="line">   node.prev = t;</span><br><span class="line">   t.next = node;</span><br><span class="line">   <span class="keyword">return</span> t;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>会导致这一瞬间的tail也就是t的prev为null，这就使得这一瞬间队列处于一种不一致的中间状态。</p>
<h2 id="4-2-唤醒节点时为什么从tail向前遍历"><a href="#4-2-唤醒节点时为什么从tail向前遍历" class="headerlink" title="4.2 唤醒节点时为什么从tail向前遍历"></a>4.2 唤醒节点时为什么从tail向前遍历</h2><p>unparkSuccessor方法中为什么唤醒后继节点时要从tail向前查找最接近node的非取消节点，而不是直接从node向后找到第一个后break掉?</p>
<p>其实上面的注释中也解释得很清楚了，如果读到<code>s == null</code>，不代表node就为tail。</p>
<p>考虑如下场景：</p>
<ol>
<li>node某时刻为tail</li>
<li>有新线程通过addWaiter中的if分支或者enq方法添加自己</li>
<li>compareAndSetTail成功</li>
<li>此时这里的Node s = node.next读出来s == null，<strong>但事实上node已经不是tail，它有后继了!</strong></li>
</ol>
<h2 id="4-3-AQS如何保证队列活跃"><a href="#4-3-AQS如何保证队列活跃" class="headerlink" title="4.3 AQS如何保证队列活跃"></a>4.3 AQS如何保证队列活跃</h2><p>AQS如何保证在节点释放的同时又有新节点入队的情况下，不出现原持锁线程释放锁，后继线程被自己阻塞死的情况,保持同步队列的活跃？</p>
<p>回答这个问题，需要理解<code>shouldParkAfterFailedAcquire</code>和<code>unparkSuccessor</code>这两个方法。</p>
<ul>
<li>以独占锁为例，后继争用线程阻塞自己的情况是读到前驱节点的等待状态为SIGNAL,只要不是这种情况都会再试着去争取锁。假设后继线程读到了前驱状态为SIGNAL，说明之前在tryAcquire的时候，前驱持锁线程还没有tryRelease完全释放掉独占锁。</li>
<li>此时如果前驱线程完全释放掉了独占锁，则在<code>unparkSuccessor</code>中还没执行完置<code>waitStatus</code>为0的操作，也就是还没执行到下面唤醒后继线程的代码，否则后继线程会再去争取锁。那么就算后继争用线程此时把自己阻塞了，也一定会马上被前驱线程唤醒。</li>
<li>那么是否可能持锁线程执行唤醒后继线程的逻辑时，后继线程读到前驱等待状态为SIGNAL把自己给阻塞，再也无法苏醒呢？</li>
<li>确实可能在扫描后继需要唤醒线程时读不到新来的线程，但只要<code>tryRelease</code>语义实现正确，在true时表示完全释放独占锁，则后继线程理应能够<code>tryAcquire</code>成功，<code>shouldParkAfterFailedAcquire</code>在读到前驱状态不为<code>SIGNAL</code>会给当前线程再一次获取锁的机会的。</li>
</ul>
<h2 id="4-4-AQS如何防止内存泄露"><a href="#4-4-AQS如何防止内存泄露" class="headerlink" title="4.4 AQS如何防止内存泄露"></a>4.4 AQS如何防止内存泄露</h2><p>AQS维护了一个FIFO队列，它是如何保证在运行期间不发生内存泄露的？</p>
<p>AQS在无竞争条件下，甚至都不会new出head和tail节点。线程成功获取锁时设置head节点的方法为setHead，由于头节点的thread并不重要，此时会置node的thread和prev为null，完了之后还会置原先head也就是线程对应node的前驱的next为null，从而实现队首元素的安全移出。而在取消节点时，也会令<code>node.thread = null</code>，在node不为tail的情况下，会使<code>node.next = node</code>（之所以这样也是为了<code>isOnSyncQueue</code>实现更加简洁）</p>
<hr>
<h1 id="5小结"><a href="#5小结" class="headerlink" title="5小结"></a>5小结</h1><p>在并发环境下，加锁和解锁需要以下三个部件的协调：</p>
<ol>
<li>锁状态。我们要知道锁是不是被别的线程占有了，这个就是 state 的作用，它为 0 的时候代表没有线程占有锁，可以去争抢这个锁，用 CAS 将 state 设为 1，如果 CAS 成功，说明抢到了锁，这样其他线程就抢不到了，如果锁重入的话，state进行 +1 就可以，解锁就是减 1，直到 state 又变为 0，代表释放锁，所以 lock() 和 unlock() 必须要配对啊。然后唤醒等待队列中的第一个线程，让其来占有锁。</li>
<li>线程的阻塞和解除阻塞。AQS 中采用了 LockSupport.park(thread) 来挂起线程，用 unpark 来唤醒线程。</li>
<li>阻塞队列。因为争抢锁的线程可能很多，但是只能有一个线程拿到锁，其他的线程都必须等待，这个时候就需要一个 queue 来管理这些线程，AQS 用的是一个 FIFO 的队列，就是一个链表，每个 node 都持有后继节点的引用。AQS 采用了 CLH 锁的变体来实现。</li>
</ol>
<p>用了好几天，看了很多博客还有翻了一些书，对着JDK源码一点一点的抠了出来上面的这些阅读理解，感觉这个源码还是有些难度，还是需要时不时的回头看看，其实主要就分为独占式和共享式，然后各有没有完成的方法需要继承AQS的子类去完成，要对大致的状态获取、状态释放有所了解，这些会比较重要点，对那几个状态需要多了解了解是什么个意思，一般会出现在什么情况，感觉看了一些源码之后，发现这些源码中的状态位其实很重要，每个方法都伴随着状态位的改变，通过状态位可以了解到很多内部细节，最后还是说分析得太烂，以后又有认识之后一定要把上面这个重新整理一遍，还是不太深刻，盲人摸象，只了解到了一小部分罢了。</p>
<hr>
<p>以上参考：</p>
<ol>
<li><a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer" target="_blank" rel="noopener">一行一行源码分析清楚AbstractQueuedSynchronizer</a></li>
<li><a href="http://cmsblogs.com/?p=2174" target="_blank" rel="noopener">【死磕Java并发】—–J.U.C之AQS：AQS简介</a></li>
<li><a href="http://www.tianxiaobo.com/2018/05/01/AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-%E7%8B%AC%E5%8D%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F/#41-%E8%8A%82%E7%82%B9%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">AbstractQueuedSynchronizer 原理分析 - 独占/共享模式</a></li>
<li><a href="https://www.cnblogs.com/showing/p/6858410.html" target="_blank" rel="noopener">JDK源码之AQS源码剖析</a></li>
<li><a href="https://www.cnblogs.com/micrari/p/6937995.html" target="_blank" rel="noopener">AbstractQueuedSynchronizer源码解读</a></li>
<li><a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html" target="_blank" rel="noopener">从ReentrantLock的实现看AQS的原理及应用</a></li>
<li>书籍：Java并发编程的艺术</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>AQS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - 锁相关：Condition接口分析</title>
    <url>/2020/03/31/java-bing-fa-suo-xiang-guan-condition-jie-kou-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>Condition就是一接口，而在AQS 中的<code>ConditionObject</code>内部类实现了这个接口。Condition接口中只是进行了一些等待和通知方法的声明，并没有进行实现，Condition 经常可以用在<strong>生产者-消费者</strong>的场景中，关于Condition相关的东西，我们需要先了解AQS相关的知识，可以看看之前的那篇文章：<a href="https://dongxiem.github.io/2020/03/31/java-bing-fa-aqs-kuang-jia-fen-xi/">Java 并发 - AQS：框架分析</a>，然后再进行Condition的了解</p>
<p>这里先讲一句：Condition 中的方法则要配合锁对象使用，并通过<code>newCondition</code>方法获取实现类对象。这有点像Object 中的方法需要配合 synchronized 关键字使用。关于Condition与Object类实现的这些方法可以看这篇文章中最下面的那个对比，Ojbect类的<code>wait()</code>, <code>notify()</code> 或 <code>notifyAll()</code> 方法是基于对象的监视器锁的，我们现在所讲的Condition是基于 <code>ReentrantLock</code>  实现的，而ReentrantLock 是依赖于 AbstractQueuedSynchronizer 实现的。</p>
<a id="more"></a>

<h3 id="Demo开场"><a href="#Demo开场" class="headerlink" title="Demo开场"></a>Demo开场</h3><p>我们可以先从源码中给出的一个Demo来进行了解：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// condition 依赖于 lock 来产生</span></span><br><span class="line">    <span class="keyword">final</span> Condition notFull = lock.newCondition();</span><br><span class="line">    <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> putptr, takeptr, count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (count == items.length)</span><br><span class="line">                notFull.await();  <span class="comment">// 队列已满，等待，直到 not full 才能继续生产</span></span><br><span class="line">            items[putptr] = x;</span><br><span class="line">            <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;</span><br><span class="line">            ++count;</span><br><span class="line">            notEmpty.signal(); <span class="comment">// 生产成功，队列已经 not empty 了，发个通知出去</span></span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">                notEmpty.await(); <span class="comment">// 队列为空，等待，直到队列 not empty，才能继续消费</span></span><br><span class="line">            Object x = items[takeptr];</span><br><span class="line">            <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;</span><br><span class="line">            --count;</span><br><span class="line">            notFull.signal(); <span class="comment">// 被我消费掉一个，队列 not full 了，发个通知出去</span></span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>这里创建两个线程让上面JDK给的Demo跑起来：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// condition 依赖于 lock 来产生</span></span><br><span class="line">    <span class="keyword">final</span> Condition notFull = lock.newCondition();</span><br><span class="line">    <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> putptr, takeptr, count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略put和take方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        BoundedBuffer boundedBuffer = <span class="keyword">new</span> BoundedBuffer();</span><br><span class="line"></span><br><span class="line">        ExecutorService executor1 = Executors.newCachedThreadPool();</span><br><span class="line">        executor1.execute(</span><br><span class="line">            <span class="keyword">new</span> Runnable() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) {</span><br><span class="line">                        <span class="keyword">try</span> {</span><br><span class="line">                            boundedBuffer.put(i);</span><br><span class="line">                            System.out.println(<span class="string">"放入了："</span> + i);</span><br><span class="line">                        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        ExecutorService executor2 = Executors.newCachedThreadPool();</span><br><span class="line">        executor2.execute(</span><br><span class="line">            <span class="keyword">new</span> Runnable() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) {</span><br><span class="line">                        <span class="keyword">try</span> {</span><br><span class="line">                            <span class="comment">// Thread.sleep(200);</span></span><br><span class="line">                            System.out.println(<span class="string">"取出了："</span> + boundedBuffer.take());</span><br><span class="line">                        } <span class="keyword">catch</span> (InterruptedException e){</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//终止线程池</span></span><br><span class="line">        executor1.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executor1.isTerminated()) {</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"Finished executor1"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//终止线程池</span></span><br><span class="line">        executor2.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executor2.isTerminated()) {</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"Finished executor2"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>因为设置了容量为5，所以会不断的生产和消费：</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="code"><pre><span class="line">放入了：<span class="number">0</span></span><br><span class="line">放入了：<span class="number">1</span></span><br><span class="line">放入了：<span class="number">2</span></span><br><span class="line">放入了：<span class="number">3</span></span><br><span class="line">放入了：<span class="number">4</span></span><br><span class="line">取出了：<span class="number">0</span></span><br><span class="line">取出了：<span class="number">1</span></span><br><span class="line">取出了：<span class="number">2</span></span><br><span class="line">取出了：<span class="number">3</span></span><br><span class="line">取出了：<span class="number">4</span></span><br></pre></td></tr></tbody></table></figure>



<p>通过上面我们可以大概了解到：</p>
<ol>
<li>在使用Condition的时候，必须要先持有相对应的锁，而Object类也是差不多这样的一种机制，我们在Object类中，如果要使用<code>wait()</code>, <code>notify()</code> 或 <code>notifyAll()</code> 方法，则我们必须要先持有某个对象的监视器！</li>
<li>还有一点：ArrayBlockingQueue 采用这种方式实现了生产者-消费者，所以请只把这个例子当做学习例子，<u>实际生产中可以直接使用 ArrayBlockingQueue！！！</u></li>
</ol>
<h3 id="Condition与ReentrantLock的联系"><a href="#Condition与ReentrantLock的联系" class="headerlink" title="Condition与ReentrantLock的联系"></a>Condition与ReentrantLock的联系</h3><p>上面的例子是要让我们清楚的知道，就是condition是与ReentrantLock是息息相关的，可以说他们一般都是结合在一起使用的，那么我们在使用condition的一些方法，比如<code>await()</code> 或者 <code>signale()</code>方法的时候，我们就应该获取到这个Lock才能进行使用！</p>
<p>而每个 <code>ReentrantLock</code>  实例可以通过调用多次 <code>newCondition</code> 产生多个 <code>ConditionObject</code> 的实例：</p>
<p>就如同我们上面的Demo中所示那样：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Condition notFull = lock.newCondition();</span><br><span class="line"><span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br></pre></td></tr></tbody></table></figure>

<p>在<code>ReentrantLock</code> 源码中可以看到：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们再继续看看这个<code>ConditionObject</code>是个什么东西，进去源码发现，原来是个 Condition 的实现类 ，它存在于<code>AbstractQueuedSynchronizer</code>中：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1173984872572414699L</span>;</span><br><span class="line">        <span class="comment">// 条件队列的第一个节点</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">        <span class="comment">// 条件队列的最后一个节点</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">        ......</span><br></pre></td></tr></tbody></table></figure>

<p>需要注意的是Condition就是一个接口，里面就是实现一些规范而已了，并没有具体实现代码细节，我们要分析的也是这下面的一些内容了：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们上面也看到了每个 <code>ReentrantLock</code>  实例可以通过调用多次 <code>newCondition</code> 产生多个 <code>ConditionObject</code> 的实例，那么该如何去管理这些实例呢？我们可以引入跟AQS中的同步队列相似的另一种概念，称之为条件队列或者同步队列，图示如下：</p>
<p><img src="https://i.loli.net/2020/04/12/XU31Grz9CI6FPfD.png" alt="条件队列"></p>
<p>其实这里差不多就代表了整个Condition的核心思想所在了：</p>
<ol>
<li>条件队列和同步队列的节点，都是 Node 的实例，因为条件队列的节点是需要转移到同步队列中去的；</li>
<li>我们知道一个 ReentrantLock 实例可以通过多次调用 newCondition() 来产生多个 Condition 实例，这里对应 condition1 和 condition2。注意，ConditionObject 只有两个属性 firstWaiter 和 lastWaiter；</li>
<li>每个 condition 有一个关联的<strong>条件队列</strong>，如线程 1 调用 <code>condition1.await()</code> 方法即可将当前线程 1 包装成 Node 后加入到条件队列中，然后阻塞在这里，不继续往下执行，条件队列是一个单向链表；</li>
<li>调用<code>condition1.signal()</code> 触发一次唤醒，此时唤醒的是队头，会将condition1 对应的<strong>条件队列</strong>的 firstWaiter（队头） 移到<strong>同步队列的队尾</strong>，等待获取锁，获取锁后 await 方法才能返回，继续往下执行。</li>
</ol>
<p>可以先看一下这张图，了解一下简单的流程所在，具体的源码展开在下面。</p>
<h3 id="Condition主要的方法"><a href="#Condition主要的方法" class="headerlink" title="Condition主要的方法"></a>Condition主要的方法</h3><p>这里可以先明白Condition有一些什么方法：</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>await()</td>
<td>当前线程进入等待状态直到被通知（signal）或者中断；当前线程进入运行状态并从await()方法返回的场景包括：（1）其他线程调用相同Condition对象的signal/signalAll方法，并且当前线程被唤醒；（2）其他线程调用interrupt方法中断当前线程；</td>
</tr>
<tr>
<td>awaitUninterruptibly()</td>
<td>当前线程进入等待状态直到被通知，在此过程中对中断信号不敏感，不支持中断当前线程</td>
</tr>
<tr>
<td>awaitNanos(long)</td>
<td>当前线程进入等待状态，直到被通知、中断或者超时。如果返回值小于等于0，可以认定就是超时了</td>
</tr>
<tr>
<td>awaitUntil(Date)</td>
<td>当前线程进入等待状态，直到被通知、中断或者超时。如果没到指定时间被通知，则返回true，否则返回false</td>
</tr>
<tr>
<td>signal()</td>
<td>唤醒一个等待在Condition上的线程，被唤醒的线程在方法返回前必须获得与Condition对象关联的锁</td>
</tr>
<tr>
<td>signalAll()</td>
<td>唤醒所有等待在Condition上的线程，能够从await()等方法返回的线程必须先获得与Condition对象关联的锁</td>
</tr>
</tbody></table>
<hr>
<h1 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2.源码分析"></a>2.源码分析</h1><h2 id="2-1-等待-await"><a href="#2-1-等待-await" class="headerlink" title="2.1 等待 await"></a>2.1 等待 await</h2><p>主要分析<code>await()</code>方法，因为其他的几个等待方法也差不多，大同小异，只要将这个最基本的方法了解清楚了，相比其他方法也不难！</p>
<p>await方法的主要流程如下：</p>
<ol>
<li>将当先线程封装成节点，并将节点添加到Condition条件队列尾部。</li>
<li>节点入队了之后，完全释放独占锁。</li>
<li>判断节点是否在同步队列上，如果不在则阻塞线程(等待其他线程调用signal/signalAll或是被中断)。</li>
<li>重新获取互斥锁。</li>
</ol>
<p>await方法源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// await是可响应中断的等待方法，而不可响应中断的是`awaitUninterruptibly()`</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">       <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">       <span class="comment">// 1.将当先线程封装成节点，并将节点添加到Condition条件队列尾部</span></span><br><span class="line">       Node node = addConditionWaiter();</span><br><span class="line">       <span class="comment">/* 2.节点入队了之后，完全释放独占锁(无论锁是否可以重入)</span></span><br><span class="line"><span class="comment">        * 返回值是释放锁之前的state状态值</span></span><br><span class="line"><span class="comment">        * await之前，当前线程是持有锁的，所以要进行锁的释放</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">       <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">/* 3.判断节点是否在同步队列上，如果不在则阻塞线程</span></span><br><span class="line"><span class="comment">        * 循环结束有两个条件：</span></span><br><span class="line"><span class="comment">        * a.其他线程调用 singal/singalAll，node 将会被转移到同步队列上，然后被唤醒。</span></span><br><span class="line"><span class="comment">        * b.其它线程中断了当前线程,当前线程会自行尝试进入同步队列。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">while</span> (!isOnSyncQueue(node)) {</span><br><span class="line">           <span class="comment">// 调用 LockSupport.park 阻塞当前线程</span></span><br><span class="line">           LockSupport.park(<span class="keyword">this</span>);        </span><br><span class="line">           <span class="comment">/* 4.获取中断模式，线程从park中被唤醒的时候，需要判断是否此时被中断，若中断则尝试转移到同步队列。</span></span><br><span class="line"><span class="comment">            * 这里有两种中断模式，如下：</span></span><br><span class="line"><span class="comment">            * THROW_IE(值-1)：</span></span><br><span class="line"><span class="comment">            *    中断在 node 转移到同步队列“前”发生，需要当前线程自行将 node 转移到同步队列中</span></span><br><span class="line"><span class="comment">            *    并在随后抛出 InterruptedException 异常。</span></span><br><span class="line"><span class="comment">            * REINTERRUPT：</span></span><br><span class="line"><span class="comment">            *    中断在 node 转移到同步队列“期间”或“之后”发生</span></span><br><span class="line"><span class="comment">            *    此时表明有线程正在调用singal/singalAll 转移节点。</span></span><br><span class="line"><span class="comment">            *    在该种中断模式下，再次设置线程的中断状态。向后传递中断标志，由后续代码去处理中断。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       }</span><br><span class="line">       <span class="comment">/* 5.被转移到同步队列的节点 node 在 acquireQueued 方法中重新获取同步状态</span></span><br><span class="line"><span class="comment">        * 不懂？因为while 出来后，我们确定节点已经进入了同步队列，准备获取锁！</span></span><br><span class="line"><span class="comment">        * 此处的saveState 即为上面调用fullyRelease 所返回的值.</span></span><br><span class="line"><span class="comment">        * 重新获取互斥锁过程中,如果中断并且interruptMode不为"抛出异常",则设置为REINTERRUPT。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">           interruptMode = REINTERRUPT;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 正常通过 singal/singalAll 转移节点到同步队列时，nextWaiter 引用会被置空。</span></span><br><span class="line"><span class="comment">        * 若发生线程产生中断（THROW_IE）或 fullyRelease 方法出现错误等异常情况，该引用则不会被置空</span></span><br><span class="line"><span class="comment">        * 于是需要进行一些后续步骤处理</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) </span><br><span class="line">           <span class="comment">// 清理等待状态非 CONDITION 的节点</span></span><br><span class="line">           unlinkCancelledWaiters();</span><br><span class="line">       <span class="comment">/* 6.根据不同的中断模式进行不同的处理 </span></span><br><span class="line"><span class="comment">        * 如果线程发生过中断则根据THROW_IE或是REINTERRUPT分别抛出异常或者重新中断。</span></span><br><span class="line"><span class="comment">        *    THROW_IE：抛出 InterruptedException 异常</span></span><br><span class="line"><span class="comment">        *    REINTERRUPT：重新设置线程中断标志</span></span><br><span class="line"><span class="comment">        */</span>        </span><br><span class="line">       <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">           reportInterruptAfterWait(interruptMode);</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>



<hr>
<h3 id="2-1-1-将结点加入条件队列"><a href="#2-1-1-将结点加入条件队列" class="headerlink" title="2.1.1 将结点加入条件队列"></a>2.1.1 将结点加入条件队列</h3><p>该<code>addConditionWaiter()</code>方法主要是将当前线程加入到Condition条件队列中。当然在加入到尾节点之前会清楚所有状态不为Condition的节点，即将已取消的所有节点清除出队列。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 将当先线程封装成节点，并将节点添加到Condition条件队列尾部</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 这里之前的JDK版本没有添加，其实算是一个Bug，经过博客园博主：活在梦里，提交了之后JDK添加了</span></span><br><span class="line">    <span class="comment">// BUG 链接为 JDK-8187408，感兴趣的可以看看</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    <span class="comment">/* 如果条件队列中最后一个waiter节点状态为取消,即不为CONDITION</span></span><br><span class="line"><span class="comment">     * 则调用unlinkCancelledWaiters清理队列。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) {</span><br><span class="line">        <span class="comment">// 这个方法会遍历整个条件队列，然后会将已取消的所有节点清除出队列</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        <span class="comment">// 重读lastWaiter。</span></span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点，并将节点置于队列尾部</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Node.CONDITION);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理等待状态为 CANCELLED 的节点</span></span><br><span class="line"><span class="comment">// 等待队列是一个单向链表，遍历链表将已经取消等待的节点清除出去</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>{</span><br><span class="line">    Node t = firstWaiter;</span><br><span class="line">    <span class="comment">// 记住其作用：记录上一个非取消节点</span></span><br><span class="line">    Node trail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (t != <span class="keyword">null</span>) {</span><br><span class="line">        Node next = t.nextWaiter;</span><br><span class="line">        <span class="comment">// 如果节点的状态不是 Node.CONDITION 的话，这个节点就是被取消的</span></span><br><span class="line">        <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) {</span><br><span class="line">            <span class="comment">// 进行断开</span></span><br><span class="line">            t.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 如果trail 为 null，则表明之前所有节点等待状态都为CANCELLED，需要取消！</span></span><br><span class="line">            <span class="comment">// 直接将头结点指向该next，跳过t 节点了！</span></span><br><span class="line">            <span class="keyword">if</span> (trail == <span class="keyword">null</span>)</span><br><span class="line">                firstWaiter = next;</span><br><span class="line">            <span class="comment">// 如果trail 不为 null，则证明之前有的节点等待状态为 CONDITION，进行链接！</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                trail.nextWaiter = next;</span><br><span class="line">            <span class="comment">// next 为 null，表明遍历到条件队列尾部了，此时将 lastWaiter 指向 trail</span></span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            trail = t;</span><br><span class="line">        t = next;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<h3 id="2-1-2-完全释放独占锁"><a href="#2-1-2-完全释放独占锁" class="headerlink" title="2.1.2 完全释放独占锁"></a>2.1.2 完全释放独占锁</h3><p>在节点入队了之后，则调用下面的方法进行完全释放锁，为什么是完全释放呢？因为 ReentrantLock 是可以重入的。</p>
<p><code>saveState</code> 代表着什么意思呢？如果在 condition1.await() 之前，假设线程先执行了 2 次 lock() 操作，那么 state 为 2，我们理解为该线程持有 2 把锁，<u>这里 await() 方法必须将 state 设置为 0，然后再进入挂起状态，这样其他线程才能持有锁</u>。当它被唤醒的时候，它需要重新持有 2 把锁，才能继续下去。</p>
<p>举个简单的操作，我们在使用condition的过程中，先 <code>lock.lock()</code>，然后 <code>condition1.await()</code>，那么state的值就会发生变化，从1变成0，此时锁进行释放，并且<code>fullyRelease(Node node)</code>这个方法返回1，如果lock重入了n次，则<code>savedState = n</code>，但是如果这个方法失败，则会将节点设置为”取消”状态，并抛出异常 IllegalMonitorStateException</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 节点入队了之后，完全释放独占锁</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 获取同步状态值</span></span><br><span class="line">        <span class="keyword">int</span> savedState = getState();</span><br><span class="line">        <span class="comment">// 这里使用了当前的 state 作为 release 的参数，也就是完全释放掉锁，将 state 置为 0</span></span><br><span class="line">        <span class="keyword">if</span> (release(savedState))</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">        <span class="comment">// 设置状态为“取消”</span></span><br><span class="line">        node.waitStatus = Node.CANCELLED;</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其实上面这个方法也可以很好的解释一下，假如我的线程没有持有lock，直接调用condition的<code>await()</code>方法，那会怎样？</p>
<p>如果一个线程在不持有 lock 的基础上，就去调用 <code>condition.await()</code> 方法，它能进入条件队列，但是在上面的这个方法中，由于它不持有锁，<code>release(savedState)</code> 这个方法肯定要返回 false，进入到异常分支，然后进入 finally 块设置 <code>node.waitStatus = Node.CANCELLED</code>，这个已经入队的节点之后会被后继的节点”请出去“。</p>
<h3 id="2-1-3-判断节点node是否处于同步队列上"><a href="#2-1-3-判断节点node是否处于同步队列上" class="headerlink" title="2.1.3 判断节点node是否处于同步队列上"></a>2.1.3 判断节点node是否处于同步队列上</h3><p>经过上面的完全释放锁之后，会走到下面的这一条代码块，会通过<code>isOnSyncQueue(Node node)</code>方法，会进行一个自旋判断自己是否在同步队列中，如果不在同步队列上的话，将当前线程挂起，等待被转移到同步队列中。</p>
<p>里面其实分为三种方法进行判断节点node是否处于同步队列上：</p>
<ol>
<li>节点状态为CONDITION一定是不在同步队列，或者如果prev为null也一定是不在同步队列。</li>
<li>如果节点的next不为null,则其一定是在同步队列的。</li>
<li>上面两种方法都不奏效，进行同步队列的遍历查找。</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 判断节点是否在同步队列上</span></span><br><span class="line"><span class="comment">// 在节点入条件队列的时候，初始化时设置了 waitStatus = Node.CONDITION</span></span><br><span class="line"><span class="comment">// 而signal 的时候需要将节点从条件队列移到同步队列，这个方法就是判断 node 是否已经移动到同步队列了</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>{</span><br><span class="line">    <span class="comment">/* 节点在同步队列上时，其状态可能为 0、SIGNAL、PROPAGATE 和 CANCELLED 其中之一，但不会为 CONDITION</span></span><br><span class="line"><span class="comment">     * 如果在条件队列中，waitStatus 为Node.CONDITION（-2）</span></span><br><span class="line"><span class="comment">     * 如果在同步队列中，waitStatus 会置为0</span></span><br><span class="line"><span class="comment">     * 如果节点在同步队列上，node.prev 一定不会为 null</span></span><br><span class="line"><span class="comment">     *     因为同步队列里的节点prev为null只可能是获取到锁后调用setHead清为null</span></span><br><span class="line"><span class="comment">     *     新入队的节点prev值是不会为null的</span></span><br><span class="line"><span class="comment">     * 另外,条件队列里节点是用nextWaiter来维护的，不用next和prev。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果节点的next不为null,则其一定是在同步队列的。</span></span><br><span class="line"><span class="comment">     * 因为条件队列使用的是 nextWaiter 指向后继节点的，条件队列上节点的 next 指针均为 null。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 为什么上面先判断node.next既可以了，还需要上面判断node.prev 呢？</span></span><br><span class="line"><span class="comment">     * 因为节点在入队过程中，是先设置 node.prev，后设置 node.next。</span></span><br><span class="line"><span class="comment">     * 如果设置完 node.prev 后，线程被切换了，此时 node.next 仍然为 null</span></span><br><span class="line"><span class="comment">     * 但此时 node 确实已经在同步队列上了，所以这里还需要进行判断。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这里值得一提的是在AQS的cancelAcquire方法中,会使用：node.next = node</span></span><br><span class="line"><span class="comment">     * 一个节点将自己移除出队列的时候会把自己的next域指向自己。</span></span><br><span class="line"><span class="comment">     * 从GC效果上来看node.next = node和node.next = null无异,</span></span><br><span class="line"><span class="comment">     * 但是这对此处next不为null一定在同步队列上来说,</span></span><br><span class="line"><span class="comment">     * 这样可以将节点在同步队列上被取消的情况与普通情况归一化判断。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) <span class="comment">// If has successor, it must be on queue</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 上面的两种判断都不奏效，于是只有进行遍历了</span></span><br><span class="line">    <span class="comment">// 在同步队列上，从后向前查找 node 节点</span></span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于同步队列上的的节点 prev 引用不会为空，所以这里从后向前查找 node 节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">findNodeFromTail</span><span class="params">(Node node)</span> </span>{</span><br><span class="line">    <span class="comment">// We check for node first, since it's likely to be at or near tail.</span></span><br><span class="line">    <span class="comment">// tail is known to be non-null, so we could re-order to "save"</span></span><br><span class="line">    <span class="comment">// one null check, but we leave it this way to help the VM.</span></span><br><span class="line">    <span class="keyword">for</span> (Node p = tail;;) {</span><br><span class="line">        <span class="keyword">if</span> (p == node)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        p = p.prev;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="2-1-4-检测线程等待期间是否中断"><a href="#2-1-4-检测线程等待期间是否中断" class="headerlink" title="2.1.4 检测线程等待期间是否中断"></a>2.1.4 检测线程等待期间是否中断</h3><p>就是因为<code>await()</code>方法支持中断，所以我们需要对其中断进行细致考虑，我认为主要了解的有以下三点：</p>
<ol>
<li>线程是否发生了中断？</li>
<li>线程发生中断是否能够成功进入同步队列？</li>
<li>线程中断发生的时机是在节点转移到同步队列之前发生？还是发生在节点转移到同步队列期间或之后发生？</li>
</ol>
<p>如果理清上面这三个问题，其实中断唤醒这一块就能够很好理解了。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 检测线程在等待期间是否发生了中断 </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> </span>{</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 1. 线程未中断返回0</span></span><br><span class="line"><span class="comment">     * 2. 线程中断且入同步队列成功,返回THROW_IE表示后续要抛出InterruptedException。</span></span><br><span class="line"><span class="comment">     * 3. 线程中断且未能入同步队列(由于被signal方法唤醒),则返回REINTERRUPT表示后续重新中断。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">    <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面表示判断中断发生的时机，分为两种：</span></span><br><span class="line"><span class="comment">// 1. 中断在节点被转移到同步队列前发生，此时返回 true</span></span><br><span class="line"><span class="comment">// 2. 中断在节点被转移到同步队列期间或之后发生，此时返回 false</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferAfterCancelledWait</span><span class="params">(Node node)</span> </span>{</span><br><span class="line">    <span class="comment">// 中断在节点被转移到同步队列前发生，此时自行将节点转移到同步队列上，并返回 true</span></span><br><span class="line">    <span class="keyword">if</span> (node.compareAndSetWaitStatus(Node.CONDITION, <span class="number">0</span>)) {</span><br><span class="line">        <span class="comment">// 调用 enq 将节点转移到同步队列中</span></span><br><span class="line">        <span class="comment">// enq(node): 自旋进入同步队列的队尾</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果上面的CAS失败，则说明已经有线程调用signal/signalAll 方法,状态已经被抢先更新了。</span></span><br><span class="line"><span class="comment">     * signal/signalAll 方法会先将节点等待状态由 CONDITION 设置为 0 后，再调用 enq 方法转移节点。</span></span><br><span class="line"><span class="comment">     * 而下面判断节点是否已经在同步队列上的原因是，signal/signalAll 方法可能仅设置了等待状态，</span></span><br><span class="line"><span class="comment">     * 还没来得及转移节点就被切换走了。所以这里用自旋的方式判断 signal/signalAll 是否已经完成了转移操作。</span></span><br><span class="line"><span class="comment">     * 以上这种中断情况发生在节点被转移到同步队列期间。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node))</span><br><span class="line">        Thread.yield();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 中断在节点被转移到同步队列期间或之后发生，返回 false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="2-1-5-重新获取同步状态"><a href="#2-1-5-重新获取同步状态" class="headerlink" title="2.1.5 重新获取同步状态"></a>2.1.5 重新获取同步状态</h3><p>while 循环出来以后，下面是这段代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">    interruptMode = REINTERRUPT;</span><br></pre></td></tr></tbody></table></figure>

<p>由于 while 出来后，我们确定节点已经进入了同步队列，准备获取锁。</p>
<p>此处的<code>acquireQueued(node, savedState)</code>方法中的第一个参数node，之前已经通过方法<code>enq(node)</code> 进入了队列，而这个参数 savedState 是之前释放锁前的 state，这个方法返回的时候，代表当前线程获取了锁，而且 <code>state == savedState</code>了。</p>
<p>关于中断，需要明白的一点是：<strong>不管有没有发生中断，都会进入到同步队列</strong>，而 <code>acquireQueued(node, savedState)</code> 的返回值就是<strong>代表线程是否被中断</strong>。</p>
<ol>
<li>如果返回 true，说明被中断了，而且 <code>interruptMode != THROW_IE</code>，说明在 signal 之前就发生中断了，这里将 interruptMode 设置为 REINTERRUPT，用于待会重新中断。</li>
<li>如果上面的 while 循环没有产生中断，则 interruptMode = 0。</li>
</ol>
<p>关于<code>acquireQueued()</code>方法，在AQS中已经有提及到了，这里附上相对于的知识所在：<a href="https://dongxiem.github.io/2020/03/31/java-bing-fa-aqs-kuang-jia-fen-xi/#acquireQueued-Node-int">AQS分析：acquireQueued</a>。该方法是一个自旋的过程，当前线程（Node）进入同步队列后，就会进入一个自旋的过程，每个节点都会自省地观察，当条件满足，获取到同步状态后，就可以从这个自旋过程中退出，否则会一直执行下去。</p>
<h3 id="2-1-6-根据中断类型进行不同处理"><a href="#2-1-6-根据中断类型进行不同处理" class="headerlink" title="2.1.6 根据中断类型进行不同处理"></a>2.1.6 根据中断类型进行不同处理</h3><p>以下方法主要是根据不同的中断模式进行不同的处理 ，较为简单，需要清楚的是如果中断模式为：REINTERRUPT，则重新中断当前线程</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 根据不同的中断模式进行不同的处理 </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportInterruptAfterWait</span><span class="params">(<span class="keyword">int</span> interruptMode)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    <span class="comment">// 中断模式为：THROW_IE，则抛出 InterruptedException 异常</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode == THROW_IE)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 中断模式为：REINTERRUPT，则重新中断当前线程。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT)</span><br><span class="line">        selfInterrupt();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断线程</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>{</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<hr>
<h2 id="2-2-通知"><a href="#2-2-通知" class="headerlink" title="2.2 通知"></a>2.2 通知</h2><h3 id="2-2-1-signal"><a href="#2-2-1-signal" class="headerlink" title="2.2.1  signal"></a>2.2.1  signal</h3><p><code>signal()</code> 主要的作用就是将条件队列中的头结点转移到同步队列中！他会唤醒等待最久的线程，将这个线程对应的node从条件队列转移到同步队列中去。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 检查线程是否获取了独占锁，未获取独占锁调用 signal 方法是不允许的</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">// 取头部的节点</span></span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 将头结点转移到同步队列中</span></span><br><span class="line">        doSignal(first);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 从条件队列中从头向后进行遍历，找到第一个需要转移的node</span></span><br><span class="line"><span class="comment">// 因为有些线程会取消排队，但是可能还在队列中！</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>{</span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        <span class="comment">// 将 firstWaiter 指向 first 节点后面的第一个，因为 first 节点马上要离开了</span></span><br><span class="line">        <span class="comment">// 如果将 first 移除后，后面没有节点在等待了，那么需要将 lastWaiter 置为 null</span></span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 断开连接，即将头结点从条件队列中进行移除</span></span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 调用transferForSignal 将节点转移到同步队列中</span></span><br><span class="line">        <span class="comment">// 如果first 节点转移不成功，则选择first 后面的第一个节点进行转移，以此类推</span></span><br><span class="line">    } <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个方法用于将条件队列中的节点转移到同步队列中</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果将节点的等待状态由CONDITION转为0失败，则表明节点被取消了。</span></span><br><span class="line">    <span class="comment">// 肯定节点被取消是因为transferForSignal 中不存在线程竞争的问题</span></span><br><span class="line">    <span class="comment">// 所以下面CAS失败的唯一原因是节点的等待状态为 CANCELLED</span></span><br><span class="line">    <span class="keyword">if</span> (!node.compareAndSetWaitStatus(Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 调用 enq 方法将 node 转移到同步队列中，并返回 node 的前驱节点 p</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="comment">// 获取前驱节点p的等待状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="comment">/* 如果前驱节点p的等待状态大于0，说明node 在同步队列中的前驱节点取消了等待锁，直接唤醒node 对应的线程。</span></span><br><span class="line"><span class="comment">     * 如果ws &lt;= 0，则CASwaitStatus 将会被调用！如果 CAS 设置失败，则应直接唤醒 node 节点对应的线程。</span></span><br><span class="line"><span class="comment">     * 以免因 node 没有被唤醒导致同步队列挂掉。</span></span><br><span class="line"><span class="comment">     * 在AQS框架分析中，已经了解到了结点入队后，需要将前驱节点的状态设为：Node.SIGNAL</span></span><br><span class="line"><span class="comment">     * 如果将前驱状态切到SIGNAL了,则由相应线程在释放锁之后唤醒node节点对应线程。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !p.compareAndSetWaitStatus(ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上的流程大概就是：</p>
<ol>
<li>首先先去判断当前线程是否已经持有独占锁了，未获取则直接抛出异常。</li>
<li>如果线程已经获取了锁，则将唤醒条件队列的首节点（首节点不合适的话就从头向后查找合适的节点）。</li>
<li>唤醒首节点是先将条件队列中的头结点移除，然后调用AQS的<code>enq(Node node)</code>方法将其安全地移到同步队列中。</li>
<li>最后判断该节点的前驱节点等待状态是否为CANCELLED，或者修改前驱节点状态为Signal失败时候，则直接唤醒。</li>
</ol>
<hr>
<h3 id="2-2-2-signalAll"><a href="#2-2-2-signalAll" class="headerlink" title="2.2.2 signalAll"></a>2.2.2 signalAll</h3><p>了解完了sginal，再来了解一下signalAll方法，其源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 和上面同样道理，需要持有锁</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 调用的是这个方法</span></span><br><span class="line">        doSignalAll(first);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignalAll</span><span class="params">(Node first)</span> </span>{</span><br><span class="line">    lastWaiter = firstWaiter = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        Node next = first.nextWaiter;</span><br><span class="line">        <span class="comment">// 将first节点移除</span></span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 转移first节点到同步队列中</span></span><br><span class="line">        transferForSignal(first);</span><br><span class="line">        <span class="comment">// 指向下一个节点</span></span><br><span class="line">        first = next;</span><br><span class="line">    } <span class="keyword">while</span> (first != <span class="keyword">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<hr>
<h1 id="3-一些对比"><a href="#3-一些对比" class="headerlink" title="3.一些对比"></a>3.一些对比</h1><h2 id="3-1-Condition与Object监视器的对比"><a href="#3-1-Condition与Object监视器的对比" class="headerlink" title="3.1 Condition与Object监视器的对比"></a>3.1 Condition与Object监视器的对比</h2><p>每个对象都可以用继承自<code>Object</code>的<strong>wait/notify</strong>方法来实现<strong>等待/通知机制</strong>。而Condition接口也提供了类似Object监视器的方法，通过与<strong>Lock</strong>配合来实现等待/通知模式。</p>
<p>那为什么既然有Object的监视器方法了，还要用Condition呢？这里有一个二者简单的对比：</p>
<table>
<thead>
<tr>
<th>对比项</th>
<th>Object监视器</th>
<th>Condition</th>
</tr>
</thead>
<tbody><tr>
<td>前置条件</td>
<td>获取对象的锁</td>
<td>调用Lock.lock获取锁，调用Lock.newCondition获取Condition对象</td>
</tr>
<tr>
<td>调用方式</td>
<td>直接调用，比如object.notify()</td>
<td>直接调用，比如condition.await()</td>
</tr>
<tr>
<td>等待队列的个数</td>
<td>一个</td>
<td>多个</td>
</tr>
<tr>
<td>当前线程释放锁进入等待状态</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>当前线程释放锁进入等待状态，在等待状态中不中断</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>当前线程释放锁并进入超时等待状态</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>当前线程释放锁并进入等待状态直到将来的某个时间</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>唤醒等待队列中的一个线程</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>唤醒等待队列中的全部线程</td>
<td>支持</td>
<td>支持</td>
</tr>
</tbody></table>
<p>Condition和Object的wait/notify基本相似。其中，Condition的await方法对应的是Object的wait方法，而Condition的<strong>signal/signalAll</strong>方法则对应Object的notify/notifyAll()。但Condition类似于Object的等待/通知机制的加强版。</p>
<hr>
<h1 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h1><p>其实Condition 的大概流程就是：一个线程获取锁后，通过调用Condition的<code>await()</code>方法，会将当前线程先加入到条件队列中，然后释放锁，最后通过<code>isOnSyncQueue(Node node)</code>方法不断自检看节点是否已经在同步队列了，如果是则尝试获取锁，也即重新获取同步状态，否则将一直挂起。当线程调用<code>signal()</code>方法后，程序首先检查当前线程是否获取了锁，然后通过<code>doSignal(Node first)</code>方法唤醒CLH同步队列的首节点。被唤醒的线程，将从<code>await()</code>方法中的while循环中退出来，然后调用<code>acquireQueued()</code>方法竞争同步状态。</p>
<p>用了一两天的时间分析了Condition的原理，其实他与AbstractQueuedSynchronizer 的关系很密切的，要先了解到了AbstractQueuedSynchronizer 相关的内容再来了解Condition 则会发现会有一些融会贯通了，了解其原理是为了能够更好的使用，如果知道整个底层的流程是如何，我想在开发的过程中可以减少一些为什么的这样的问题。总的来说还是很有收获的，自从一系列的分析过来，总感觉之前的学习就像是走马观花，只有深入的去了解了一下发现又一些新的收获，Condition 也还好，不算是很难，主要就是等待和通知两个方面的内容，知道条件队列和同步队列这玩意是什么，问题解决一大半了，对Condition的了解到此结束，以后要做的是记录发现的问题，然后再进行Blog的记录，相信这样的学习效果可以更好的。</p>
<hr>
<p>以上参考：</p>
<ol>
<li><a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer-2#toc_0" target="_blank" rel="noopener">一行一行源码分析清楚 AbstractQueuedSynchronizer (二)</a></li>
<li><a href="http://www.tianxiaobo.com/2018/05/04/AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-Condition-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">AbstractQueuedSynchronizer 原理分析 - Condition 实现原理</a></li>
<li><a href="http://cmsblogs.com/?p=2222" target="_blank" rel="noopener">【死磕Java并发】—–J.U.C之Condition</a></li>
<li><a href="https://www.cnblogs.com/micrari/p/7219751.html" target="_blank" rel="noopener">AbstractQueuedSynchronizer源码解读–续篇之Condition</a></li>
<li>Java并发编程的艺术</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - 多线程：如何停止一个线程</title>
    <url>/2020/03/31/java-bing-fa-duo-xian-cheng-ru-he-ting-zhi-yi-ge-xian-cheng/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h1><p>对于一个线程要如何去停止呢？还有不同情况下的线程要如何停止呢？停止一个线程是什么意思？就是让这个线程在它进行任务处理的时候进行停止，停掉当前的操作，之前有学习到一个<code>Thread.stop()</code>方法，好像已经被废弃了，是不安全的一个方法，那么除了这个方法，还有其他什么办法吗？</p>
<p>总的来说，Java有如下几种方法去停止线程：</p>
<ol>
<li>使用stop方法强行终止，但是不推荐这个方法，因为stop是过期作废的方法<ul>
<li>stop()方法作废的原因：如果强制让线程停止有可能使一些清理性的工作得不到完成。另外一个情况就是对锁定的对象进行了解锁，导致数据得不到同步的处理，出现数据不一致的问题</li>
</ul>
</li>
<li>使用<strong>interrupt方法中断线程</strong>：<ul>
<li>停止不了的线程，interrupt()方法的使用效果并不像for+break语句那样，马上就停止循环。调用interrupt方法是<strong>在当前线程中打了一个停止标志，并不是真的停止线程</strong></li>
<li>可以用查看线程是否中断，并抛出异常的方式来停止执行线程中的函数</li>
<li>如果线程在<code>sleep()</code>函数的时间范围内被interrupted就会中断线程，置状态位为false并抛出sleep interrupted异常。</li>
</ul>
</li>
<li>使用<strong>退出标志</strong>，使线程正常退出，也就是当run方法完成后线程终止<ul>
<li>使用return，配合interrupt标志可以直接中断线程</li>
<li>但是还是建议使用异常中断线程，因为可以使用catch向上抛出异常，从而使线程停止事件得以传播</li>
</ul>
</li>
<li>线程池使用<strong>shutDownAll()</strong>；</li>
<li>Looper的<strong>quit方法或quitSafely方法</strong></li>
</ol>
<a id="more"></a>



<hr>
<h1 id="2-总体方法详细介绍"><a href="#2-总体方法详细介绍" class="headerlink" title="2 总体方法详细介绍"></a>2 总体方法详细介绍</h1><h2 id="2-1-interrupt的特性"><a href="#2-1-interrupt的特性" class="headerlink" title="2.1 interrupt的特性"></a>2.1 interrupt的特性</h2><p>interrupt的特性是什么？interrupt()方法的使用效果并不像for+break语句那样，马上就停止循环。调用interrupt方法是<strong>在当前线程中打了一个停止标志，并不是真的停止线程</strong></p>
<p>那样的话会带来什么后果呢？看一下下面的Demo的运行：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="comment">// 线程不断的进行打印</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">500000</span>; i++){</span><br><span class="line">            System.out.println(<span class="string">"i="</span>+(i+<span class="number">1</span>));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>{</span><br><span class="line">        Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="comment">// 注意我这里使用了interrupt方法了！</span></span><br><span class="line">            thread.interrupt();</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>打印输出如下：</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">..</span>.</span><br><span class="line"><span class="attribute">i</span>=499994</span><br><span class="line"><span class="attribute">i</span>=499995</span><br><span class="line"><span class="attribute">i</span>=499996</span><br><span class="line"><span class="attribute">i</span>=499997</span><br><span class="line"><span class="attribute">i</span>=499998</span><br><span class="line"><span class="attribute">i</span>=499999</span><br><span class="line"><span class="attribute">i</span>=500000</span><br></pre></td></tr></tbody></table></figure>



<p>你会发现他会不停的打印输出，并没有停止，我用了<code>interrupt</code>方法了啊？哪里出问题了？？</p>
<p>其实原理上面都已经讲了，只是在当前线程中打了一个停止标志，没有真的停止线程！</p>
<p>那我要这interrupt有何用？？？冷静，还是有用的，配合其他方法使用不就可以了吗？</p>
<p>打出两套组合拳：</p>
<ol>
<li>使用interrupt+状态停止判断+抛异常</li>
<li>使用interrupt+状态停止判断+退出标志（例如：return）</li>
</ol>
<p>具体组合拳如何打法如以下两个小点所示。</p>
<hr>
<h2 id="2-2-停止状态判断"><a href="#2-2-停止状态判断" class="headerlink" title="2.2 停止状态判断"></a>2.2 停止状态判断</h2><p>线程与状态是密不可分的，即我们要去停止一个线程，我们也要去判断当前是什么状态，执行了想要的停止操作之后，线程是否马上就变为停止状态了，所以如何去判断线程是否为中断状态是很关键的一点，<code>Thread.java</code>类中提供了两种方法：</p>
<ol>
<li><code>this.interrupted()</code>: 测试当前线程是否已经中断，同时线程的中断状态由该方法清除；</li>
<li><code>this.isInterrupted()</code>: 测试线程是否已经中断，同时不会清除标志位；</li>
</ol>
<p>两种方法都能用？那这两种方法的区别在哪里？这也是我的一个疑问了。</p>
<p>其实主要的区别有两个：</p>
<ol>
<li><code>this.interrupted()</code> 测试的是<strong>当前线程</strong>，当前线程指的是什么？就是指运行<code>this.interrupted()</code>方法的线程。</li>
<li>连续调用两次<code>this.interrupted()</code> 会进行<strong>状态清除</strong>，而连续调用多次<code>this.isInterrupted()</code>不会发生状态清除。</li>
</ol>
<p>先讲讲第一个区别，当前线程具体是如何的当前！</p>
<p>验证Demo如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 通过继承Thread 方式实现一个线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">500000</span>; i++){</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>{</span><br><span class="line">    <span class="comment">// main 主线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>{</span><br><span class="line">        Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="comment">// 此处就调用了interrupt 方法试图去停止线程了</span></span><br><span class="line">            thread.interrupt();</span><br><span class="line">            <span class="comment">// 注意此处调用了两次 interrupted</span></span><br><span class="line">            System.out.println(<span class="string">"stop 1??"</span> + thread.interrupted());</span><br><span class="line">            System.out.println(<span class="string">"stop 2??"</span> + thread.interrupted());</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果如下所示：</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="code"><pre><span class="line">stop <span class="number">1</span>??<span class="literal">false</span></span><br><span class="line">stop <span class="number">2</span>??<span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure>

<p>在上面的代码中我们可以看见，我们thread 对象上进行调用了<code>thread.interrupt();</code>，接着又连续使用了两次的<code>thread.interrupted());</code> 去进行thread对象所代表的线程是否已经停止了，但是结果验证发现thread对象所代表的线程是未停止的，也就是不生效？？？</p>
<p>其实是<code>thread.interrupt();</code>是有对Thread对象生效的，但是<code>thread.interrupted());</code> 并不是针对thread 对象的，其实他所针对的是main，当前线程是main！这就是为什么打印了两个false，因为当前线程main从未中断过。</p>
<p>如何让thread线程进行<code>thread.interrupt();</code>的生效呢？我的想法就是在MyThread里面进行使用<code>this.interrupted()</code>，则能够进行判断了。</p>
<p>那么如何让main线程产生中断效果？答案就是使用：<code>Thread.currentThread().interrupt();</code></p>
<h3 id="interrupted-的验证"><a href="#interrupted-的验证" class="headerlink" title="interrupted 的验证"></a>interrupted 的验证</h3><p>查阅相关资料，发现这个方法的解释为：官方帮助文档中对<code>interrupted</code>方法的解释：<strong>测试当前线程是否已经中断。线程的中断状态由该方法清除。</strong> 换句话说，如果连续两次调用该方法，则第二次调用返回false。</p>
<p>注意：当前线程！！！</p>
<p>以下为<code>interrupted</code>方法的测试Demo：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterrruptedTest</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>{</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">        System.out.println(<span class="string">"stop 1??"</span> + Thread.interrupted());</span><br><span class="line">        System.out.println(<span class="string">"stop 2??"</span> + Thread.interrupted());</span><br><span class="line">        System.out.println(<span class="string">"End"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">stop <span class="number">1</span>??<span class="keyword">true</span></span><br><span class="line">stop <span class="number">2</span>??<span class="keyword">false</span></span><br><span class="line">End</span><br></pre></td></tr></tbody></table></figure>

<p>方法interrupted()的确判断出当前线程是否是停止状态。但为什么第2个布尔值是false呢？官方帮助文档中对interrupted方法的解释：<strong>测试当前线程是否已经中断。线程的中断状态由该方法清除。</strong> 换句话说，如果连续两次调用该方法，则第二次调用返回false。</p>
<h3 id="isInterrupted-的验证"><a href="#isInterrupted-的验证" class="headerlink" title="isInterrupted 的验证"></a>isInterrupted 的验证</h3><p>主要验证的就是<code>isInterrupted</code>这个方法不会去清除状态，就算是连续多次调用都不会清除状态。</p>
<p>测试Demo如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsInterruptedTest</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>{</span><br><span class="line">        Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">// 此处调用了interrupt</span></span><br><span class="line">        thread.interrupt();</span><br><span class="line">        <span class="comment">// 使用isInterrupted 进行验证线程是否为停止状态</span></span><br><span class="line">        System.out.println(<span class="string">"stop 1??"</span> + thread.isInterrupted());</span><br><span class="line">        System.out.println(<span class="string">"stop 2??"</span> + thread.isInterrupted());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>打印结果如下：</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="code"><pre><span class="line">stop <span class="number">1</span>??<span class="literal">true</span></span><br><span class="line">stop <span class="number">2</span>??<span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure>

<p>可以看见<code>isInterrupted</code> 不会像<code>interrupted</code> 去清除状态，于是便打印了两个true。</p>
<hr>
<h2 id="2-3-使用抛异常的方法停止线程"><a href="#2-3-使用抛异常的方法停止线程" class="headerlink" title="2.3 使用抛异常的方法停止线程"></a>2.3 使用抛异常的方法停止线程</h2><p>在使用抛异常的方法来停止线程之前，可以看看如果不使用抛异常的方法来停止线程会产生什么后果？我们前面知道了，可以使用<code>thread.interrupt()</code> 方法去进行停止线程，然后再联系<code>Thread.interrupted</code> 方法区判断是否为停止状态，那么我们需要的就是是如果是停止状态，后面的代码不再运行就可以了。</p>
<p>验证Demo如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="comment">// for循环进行打印</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">500000</span>; i++){</span><br><span class="line">            <span class="comment">// 判断是否为中断状态</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.interrupted()) {</span><br><span class="line">                System.out.println(<span class="string">"线程已经终止， for循环不再执行"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 否则进行打印输出</span></span><br><span class="line">            System.out.println(<span class="string">"i="</span>+(i+<span class="number">1</span>));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>{</span><br><span class="line">        <span class="comment">// 申请线程并且开启线程</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            thread.interrupt();</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>打印输出如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">...</span><br><span class="line">i=<span class="number">202053</span></span><br><span class="line">i=<span class="number">202054</span></span><br><span class="line">i=<span class="number">202055</span></span><br><span class="line">i=<span class="number">202056</span></span><br><span class="line">线程已经终止， <span class="keyword">for</span>循环不再执行</span><br></pre></td></tr></tbody></table></figure>



<p>上面的示例虽然停止了线程，但如果for语句下面还有语句，还是会继续运行的。看下面的例子：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">500000</span>; i++){</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.interrupted()) {</span><br><span class="line">                System.out.println(<span class="string">"线程已经终止， for循环不再执行"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            System.out.println(<span class="string">"i="</span>+(i+<span class="number">1</span>));</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 这里再来一句，按道理我是不想这里被执行到的</span></span><br><span class="line">        System.out.println(<span class="string">"这是for循环外面的语句，也会被执行"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>打印输出结果如下：</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">..</span>.</span><br><span class="line"><span class="attribute">i</span>=180136</span><br><span class="line"><span class="attribute">i</span>=180137</span><br><span class="line"><span class="attribute">i</span>=180138</span><br><span class="line"><span class="attribute">i</span>=180139</span><br><span class="line">线程已经终止， <span class="keyword">for</span>循环不再执行</span><br><span class="line">这是<span class="keyword">for</span>循环外面的语句，也会被执行</span><br></pre></td></tr></tbody></table></figure>

<p>但是很不幸的是，并没有达到我们的目的，我们完成的仅仅只是for循环里面的结束而已，只是在for里面进行了一个判断中断标志位，并进行break而已，没有中断到我们的线程，那么我们该怎么做呢？</p>
<p>此时有一个好办法，就是使用抛异常的方法来解决：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">500000</span>; i++){</span><br><span class="line">                <span class="comment">// 如果判断当前线程是为interrupt状态，则抛出一个中断异常</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.interrupted()) {</span><br><span class="line">                    System.out.println(<span class="string">"线程已经终止， for循环不再执行"</span>);</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">                }</span><br><span class="line">                System.out.println(<span class="string">"i="</span>+(i+<span class="number">1</span>));</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 我们不希望这一句被执行到</span></span><br><span class="line">            System.out.println(<span class="string">"这是for循环外面的语句，也会被执行"</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            <span class="comment">// 使用catch进行异常捕获，如果捕获到异常，打印输出下面的话</span></span><br><span class="line">            System.out.println(<span class="string">"进入MyThread.java类中的catch了。。。"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出如下：</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">..</span>.</span><br><span class="line"><span class="attribute">i</span>=203798</span><br><span class="line"><span class="attribute">i</span>=203799</span><br><span class="line"><span class="attribute">i</span>=203800</span><br><span class="line">线程已经终止， <span class="keyword">for</span>循环不再执行</span><br><span class="line">进入MyThread.java类中的catch了。。。</span><br><span class="line">java.lang.InterruptedException at thread.MyThread.<span class="builtin-name">run</span>(MyThread.java:13)</span><br></pre></td></tr></tbody></table></figure>

<p>这样一来，发现其实我们想要的目的已经达到了，所以这个方案可行。</p>
<hr>
<h2 id="2-4-使用return-停止线程"><a href="#2-4-使用return-停止线程" class="headerlink" title="2.4 使用return 停止线程"></a>2.4 使用return 停止线程</h2><p>将方法interrupt()与return结合使用也能实现停止线程的效果：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>){</span><br><span class="line">            <span class="comment">// 如果判断是线程停止状态，则调用return;</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isInterrupted()){</span><br><span class="line">                System.out.println(<span class="string">"线程被停止了！"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 否则打印输出当前时间</span></span><br><span class="line">            System.out.println(<span class="string">"Time: "</span> + System.currentTimeMillis());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="comment">// 此处调用了 interrupt 方法</span></span><br><span class="line">        thread.interrupt();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>打印如下：</p>
<figure class="highlight subunit"><table><tbody><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">Time:</span> 1467072288503</span><br><span class="line"><span class="keyword">Time:</span> 1467072288503</span><br><span class="line"><span class="keyword">Time:</span> 1467072288503</span><br><span class="line">线程被停止了！</span><br></pre></td></tr></tbody></table></figure>

<p>不过还是建议使用“抛异常”的方法来实现线程的停止，因为在catch块中还可以将异常向上抛，使线程停止事件得以传播。</p>
<hr>
<h2 id="2-5-sleep状态下如何停止线程"><a href="#2-5-sleep状态下如何停止线程" class="headerlink" title="2.5 sleep状态下如何停止线程"></a>2.5 sleep状态下如何停止线程</h2><p>如果一个线程处于sleep()状态，我们去停止该线程，会发生什么？</p>
<p>以下我们进行了开启了一个线程，并且start了之后瞬间进入sleep()，然后我们再在主线程中进行一个<code>thread.interrupt();</code>看看会发生什么事情？</p>
<p>看看一下的测试Demo：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(<span class="string">"线程开始。。。"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">200000</span>);</span><br><span class="line">            System.out.println(<span class="string">"线程结束。"</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            System.out.println(<span class="string">"在沉睡中被停止, 进入catch， 调用isInterrupted()方法的结果是："</span> + <span class="keyword">this</span>.isInterrupted());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">run</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果如下：</p>
<figure class="highlight oxygene"><table><tbody><tr><td class="code"><pre><span class="line">线程开始。。。</span><br><span class="line">在沉睡中被停止, 进入catch， 调用isInterrupted()方法的结果是：<span class="keyword">false</span></span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line"> at java.lang.Thread.sleep(Native <span class="function"><span class="keyword">Method</span>)</span></span><br><span class="line"><span class="function"> <span class="title">at</span> <span class="title">thread</span>.<span class="title">MyThread</span>.<span class="title">run</span><span class="params">(MyThread.java:12)</span></span></span><br></pre></td></tr></tbody></table></figure>



<p>从打印的结果来看， <strong>如果在sleep状态下停止某一线程，会进入catch语句，并且清除停止状态值，使之变为false</strong>。</p>
<p>那么，换一种方式！前面是先进入<code>sleep()</code>，然后再<code>interrupt</code>。</p>
<p>如果我们让线程开始了之后，立马就使用<code>interrupt</code>方法，然后再进入<code>sleep()</code>，会发生什么？</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(<span class="string">"线程开始。。。"</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++){</span><br><span class="line">                System.out.println(<span class="string">"i="</span> + i);</span><br><span class="line">            }</span><br><span class="line">            Thread.sleep(<span class="number">200000</span>);</span><br><span class="line">            System.out.println(<span class="string">"线程结束。"</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            System.out.println(<span class="string">"先停止，再遇到sleep，进入catch异常"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>{</span><br><span class="line">        Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">// 注意在start之后就进行interrupt了！</span></span><br><span class="line">        thread.interrupt();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果：</p>
<figure class="highlight oxygene"><table><tbody><tr><td class="code"><pre><span class="line">i=<span class="number">9998</span></span><br><span class="line">i=<span class="number">9999</span></span><br><span class="line">先停止，再遇到sleep，进入catch异常</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line"> at java.lang.Thread.sleep(Native <span class="function"><span class="keyword">Method</span>)</span></span><br><span class="line"><span class="function"> <span class="title">at</span> <span class="title">thread</span>.<span class="title">MyThread</span>.<span class="title">run</span><span class="params">(MyThread.java:15)</span></span></span><br></pre></td></tr></tbody></table></figure>



<p>直观感觉就是，使用interrupt 之后，遇到了sleep还是一样会进入异常！可以得出的结果就是：<u>如果线程在<code>sleep()</code>函数的时间范围内被interrupted就会中断线程，置状态位为false并抛出sleep interrupted异常</u></p>
<hr>
<h2 id="2-6-关于stop的几句唠叨"><a href="#2-6-关于stop的几句唠叨" class="headerlink" title="2.6 关于stop的几句唠叨"></a>2.6 关于stop的几句唠叨</h2><h3 id="2-6-1-stop的暴力"><a href="#2-6-1-stop的暴力" class="headerlink" title="2.6.1 stop的暴力"></a>2.6.1 stop的暴力</h3><p>使用stop方法非常暴力，直接粗暴！</p>
<p>Demo测试如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>){</span><br><span class="line">                System.out.println(<span class="string">"i="</span> + i);</span><br><span class="line">                i++;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        thread.stop();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>测试结果如下：</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attribute">i</span>=0</span><br><span class="line"><span class="attribute">i</span>=1</span><br><span class="line"><span class="attribute">i</span>=2</span><br><span class="line"><span class="attribute">i</span>=3</span><br><span class="line"><span class="attribute">i</span>=4</span><br><span class="line"><span class="attribute">i</span>=5</span><br><span class="line"><span class="attribute">i</span>=6</span><br><span class="line"><span class="attribute">i</span>=7</span><br><span class="line"><span class="attribute">i</span>=8</span><br><span class="line"><span class="attribute">i</span>=9</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></tbody></table></figure>



<h3 id="2-6-2-stop与异常"><a href="#2-6-2-stop与异常" class="headerlink" title="2.6.2 stop与异常"></a>2.6.2 stop与异常</h3><p>调用stop()方法时会抛出java.lang.ThreadDeath异常，但是通常情况下，此异常不需要显示地捕捉。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>{</span><br><span class="line">            <span class="keyword">super</span>.run();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 使用了stop</span></span><br><span class="line">                <span class="keyword">this</span>.stop();</span><br><span class="line">            } <span class="keyword">catch</span> (ThreadDeath e) { <span class="comment">// 进行了异常捕获</span></span><br><span class="line">                System.out.println(<span class="string">"进入异常catch"</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">        Thread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        myThread.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>打印输出如下：</p>
<figure class="highlight reasonml"><table><tbody><tr><td class="code"><pre><span class="line">进入异常catch</span><br><span class="line">java.lang.ThreadDeath</span><br><span class="line">	at java.lang.<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>stop(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>java:<span class="number">853</span>)</span><br><span class="line">	at stopTest.<span class="module-access"><span class="module"><span class="identifier">Test$MyThread</span>.</span></span>run(<span class="module-access"><span class="module"><span class="identifier">Test</span>.</span></span>java:<span class="number">13</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>stop()方法为什么要作废？就是因为如果强制让线程停止有可能使一些清理性的工作得不到完成。</p>
<h3 id="2-6-3-stop与锁"><a href="#2-6-3-stop与锁" class="headerlink" title="2.6.3 stop与锁"></a>2.6.3 stop与锁</h3><p>使用stop()释放锁将会给数据造成不一致性的结果。如果出现这样的情况，程序处理的数据就有可能遭到破坏，最终导致程序执行的流程错误，一定要特别注意：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedObject</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"a"</span>;</span><br><span class="line">    <span class="keyword">private</span> String password = <span class="string">"aa"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">printString</span><span class="params">(String name, String password)</span></span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            Thread.sleep(<span class="number">100000</span>);</span><br><span class="line">            <span class="keyword">this</span>.password = password;</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 隐藏get和set</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">---------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> SynchronizedObject synchronizedObject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(SynchronizedObject synchronizedObject)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.synchronizedObject = synchronizedObject;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">// 调用该方法，想要加锁对象存入name为b替代已有的a，存入password为b替换已有的aa</span></span><br><span class="line">        synchronizedObject.printString(<span class="string">"b"</span>, <span class="string">"bb"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        SynchronizedObject synchronizedObject = <span class="keyword">new</span> SynchronizedObject();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> MyThread(synchronizedObject);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        thread.stop();</span><br><span class="line">        System.out.println(synchronizedObject.getName() + <span class="string">"  "</span> + synchronizedObject.getPassword());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<figure class="highlight armasm"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">b </span> aa</span><br></pre></td></tr></tbody></table></figure>

<p>由于突如其来的刹车，使用了stop()暴力释放了锁，使得本应该输出 b bb 的，被拦腰斩了一半，只得到b aa了！</p>
<p>由于stop()方法以及在JDK中被标明为“过期/作废”的方法，显然它在功能上具有缺陷，所以不建议在程序张使用stop()方法。</p>
<hr>
<h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h1><p>以上总结了一些如何去停止线程的方法，最重要的就是使用<code>interrupt</code>打出的那两套组合拳，还讲了<code>interrupted</code> 和 <code>isinterrupted</code>的区别，还讲了一下sleep()方法下进行线程停止会发生什么，最后再浅显的讲解了一下stop方法带来的不好，还是有很多东西需要深入理解的。</p>
<p>以上参考书籍及文章：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 集合框架 - HashMap 认识与理解</title>
    <url>/2020/03/31/java-ji-he-kuang-jia-hashmap-ren-shi-yu-li-jie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>关于HashMap 其实还是有很多困惑的，学习了这么长时间，一边记录遇到的一些问题，一边整理笔记，如下所示。</p>
<h1 id="2-主要一些知识点"><a href="#2-主要一些知识点" class="headerlink" title="2.主要一些知识点"></a>2.主要一些知识点</h1><h2 id="2-1-HashMap-底层结构的一些问题与解答"><a href="#2-1-HashMap-底层结构的一些问题与解答" class="headerlink" title="2.1 HashMap 底层结构的一些问题与解答"></a>2.1 HashMap 底层结构的一些问题与解答</h2><p>关于HashMap 的底层数据结构，我有以下这么几个疑问，当时也是查看书籍和百度谷歌了好一会儿，然后连带着寻找到其他的一些问题，如下。</p>
<hr>
<h3 id="数组与链表相关"><a href="#数组与链表相关" class="headerlink" title="数组与链表相关"></a>数组与链表相关</h3><p>关于底层数据结构为什么采用 数组+链表 这么一种组合的几个问题：</p>
<h4 id="1-为什么用数组-链表？"><a href="#1-为什么用数组-链表？" class="headerlink" title="1.为什么用数组+链表？"></a><strong>1.为什么用数组+链表？</strong></h4><ul>
<li>我认为数组是用来确定桶的位置，利用元素的key的hash值对数组长度取模得到.</li>
<li>链表是用来解决hash冲突问题，当出现hash值一样的情形，就在数组上的对应位置形成一条链表。</li>
<li>注：这里的hash值并不是指hashcode，而是将hashcode高低十六位异或过的。</li>
</ul>
<h4 id="2-那使用LinkedList代替数组结构可以么？"><a href="#2-那使用LinkedList代替数组结构可以么？" class="headerlink" title="2.那使用LinkedList代替数组结构可以么？"></a><strong>2.那使用LinkedList代替数组结构可以么？</strong></h4><ul>
<li>这里的意思是，源码中是这样的：<code>Entry[] table = new Entry[capacity];</code><ul>
<li>ps：Entry就是一个链表节点。</li>
</ul>
</li>
<li>那我用下面这样表示：<ul>
<li><code>List&lt;Entry&gt; table = new LinkedList&lt;Entry&gt;();</code></li>
</ul>
</li>
<li>所以没毛病是可以使用LinkedList代替数组结构</li>
</ul>
<h4 id="3-那既然是可以的，为什么HashMap不用LinkedList，而选用数组"><a href="#3-那既然是可以的，为什么HashMap不用LinkedList，而选用数组" class="headerlink" title="3.那既然是可以的，为什么HashMap不用LinkedList，而选用数组?"></a><strong>3.那既然是可以的，为什么HashMap不用LinkedList，而选用数组?</strong></h4><ul>
<li>因为用数组效率最高！在HashMap中，定位桶的位置是利用元素的key的哈希值对数组长度取模得到。此时，我们已得到桶的位置。显然数组的查找效率比LinkedList大。</li>
</ul>
<h4 id="4-继续挖一下，那ArrayList，底层也是数组，查找也快啊，为什么不用ArrayList"><a href="#4-继续挖一下，那ArrayList，底层也是数组，查找也快啊，为什么不用ArrayList" class="headerlink" title="4.继续挖一下，那ArrayList，底层也是数组，查找也快啊，为什么不用ArrayList?"></a><strong>4.继续挖一下，那ArrayList，底层也是数组，查找也快啊，为什么不用ArrayList?</strong></h4><ul>
<li>因为采用基本数组结构，扩容机制可以自己定义，HashMap中数组扩容刚好是2的次幂，在做取模运算的效率高。而ArrayList的扩容机制是1.5倍扩容。</li>
<li>而为什么需要两倍扩容，现在此处存疑，在下面我会进行展开分析一下。</li>
</ul>
<a id="more"></a>

<hr>
<h3 id="红黑树相关"><a href="#红黑树相关" class="headerlink" title="红黑树相关"></a>红黑树相关</h3><p>关于树化为什么采用红黑树、及红黑树的一些特性的一些问题、：</p>
<h4 id="1-如果进行树化了，为什么是红黑树？别的树不可以吗？"><a href="#1-如果进行树化了，为什么是红黑树？别的树不可以吗？" class="headerlink" title="1.如果进行树化了，为什么是红黑树？别的树不可以吗？"></a><strong>1.如果进行树化了，为什么是红黑树？别的树不可以吗？</strong></h4><ul>
<li>比如二叉查找树，是可以的。但是二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。</li>
<li>AVL树中，根到任何叶子的最短路径和最长路径之间的差异最多为1，而红黑树可以是两倍，虽然红黑树放弃了一定的平衡，但是当进行查找时AVL树可能需要O（Logn）次旋转，而红黑树只需要最多两次，红黑树更加适合插入修改密集型任务</li>
</ul>
<h4 id="2-为什么在解决hash冲突的时候，不直接用红黑树-而选择先用链表，再转红黑树"><a href="#2-为什么在解决hash冲突的时候，不直接用红黑树-而选择先用链表，再转红黑树" class="headerlink" title="2.为什么在解决hash冲突的时候，不直接用红黑树?而选择先用链表，再转红黑树?"></a><strong>2.为什么在解决hash冲突的时候，不直接用红黑树?而选择先用链表，再转红黑树?</strong></h4><ul>
<li><strong>因为红黑树需要进行</strong>左旋，右旋，变色这些操作来保持平衡，而单链表不需要。当元素小于8个当时候，此时做查询操作，链表结构已经能保证查询性能。当元素大于8个的时候，此时需要红黑树来加快查询速度，但是新增节点的效率变慢了。因此，如果一开始就用红黑树结构，元素太少，新增效率又比较慢，无疑这是浪费性能的。</li>
</ul>
<h4 id="3-当链表转为红黑树后，什么时候退化为链表"><a href="#3-当链表转为红黑树后，什么时候退化为链表" class="headerlink" title="3.当链表转为红黑树后，什么时候退化为链表?"></a><strong>3.当链表转为红黑树后，什么时候退化为链表?</strong></h4><ul>
<li>为6的时候退转为链表。中间有个差值7可以防止链表和树之间频繁的转换。假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。</li>
</ul>
<h4 id="4其实这样引出了一个问题：为什么链化阈值是-6-，树化阈值是-8（为什么8的时候树化，4不可以吗？）？"><a href="#4其实这样引出了一个问题：为什么链化阈值是-6-，树化阈值是-8（为什么8的时候树化，4不可以吗？）？" class="headerlink" title="4其实这样引出了一个问题：为什么链化阈值是 6 ，树化阈值是 8（为什么8的时候树化，4不可以吗？）？"></a><strong>4其实这样引出了一个问题：为什么链化阈值是 6 ，树化阈值是 8（为什么8的时候树化，4不可以吗？）？</strong></h4><ul>
<li>8树化，是经测试，冲突链表个数符合<u>泊松分布</u>，为8时概率零点几，为6而不是7退化，是为了避免7 8来回变引入不可变开销。线程数其实在考cpu密集型和io密集型。</li>
</ul>
<hr>
<h3 id="哈希相关"><a href="#哈希相关" class="headerlink" title="哈希相关"></a>哈希相关</h3><p>还有HashMap 中的哈希的一些问题</p>
<h4 id="1-HashMap-中哈希方法，为什么要选择31？？？"><a href="#1-HashMap-中哈希方法，为什么要选择31？？？" class="headerlink" title="1.HashMap 中哈希方法，为什么要选择31？？？"></a><strong>1.HashMap 中哈希方法，为什么要选择31？？？</strong></h4><p>首先看下String hashcode 的方法是如何实现的：</p>
<p><img src="https://i.loli.net/2020/04/02/gCVO9duskcUS1TP.png" alt="image.png"></p>
<p>我们可以由上面的 for 循环推导出一个计算公式，hashCode 方法注释中已经给出。如下：</p>
<p><img src="https://i.loli.net/2020/04/02/GtJUCvLyr19lIHj.png" alt="image.png"></p>
<p>这里说明一下，上面的 s 数组即源码中的 val 数组，是 String 内部维护的一个 char 类型数组。这里我来简单推导一下这个公式：</p>
<p><img src="https://i.loli.net/2020/04/02/6lyFtYu9bM5pz81.png" alt="image.png"></p>
<p>上面的公式包括公式的推导并不是本文的重点，大家了解了解即可。接下来来说说本文的重点，即选择31的理由。从网上的资料来看，一般有如下两个原因：</p>
<ol>
<li>第一，31是一个不大不小的质数，是作为 hashCode 乘子的优选质数之一。另外一些相近的质数，比如37、41、43等等，也都是不错的选择。那么为啥偏偏选中了31呢？请看第二个原因。<ul>
<li><strong>第一点解释一下：31是一个不大不小的质数，是优选乘子。那为啥同是质数的2和101（或者更大的质数）就不是优选乘子呢？</strong></li>
<li>这里先分析质数2。首先，假设 n = 6，然后把质数2和 n 带入上面的计算公式。并仅计算公式中次数最高的那一项，结果是2^5 = 32，是不是很小。所以这里可以断定，当字符串长度不是很长时，用质数2做为乘子算出的哈希值，数值不会很大。也就是说，哈希值会分布在一个较小的数值区间内，分布性不佳，最终可能会导致冲突率上升。</li>
<li>那么如果用一个较大的大质数101会产生什么样的结果呢？根据上面的分析，我想大家应该可以猜出结果了。就是不用再担心哈希值会分布在一个小的区间内了，因为101^5 = 10,510,100,501。但是要注意的是，这个计算结果太大了。如果用 int 类型表示哈希值，结果会溢出，最终导致数值信息丢失。尽管数值信息丢失并不一定会导致冲突率上升，但是我们暂且先认为质数101（或者更大的质数）也不是很好的选择。</li>
<li>最后，我们再来看看质数31的计算结果： 31^5 = 28629151，结果值相对于32和10,510,100,501来说。是不是很nice，不大不小。</li>
<li>总的来说，是100以内的比较好的奇质数（既要是奇数，又要是质数的数）</li>
</ul>
</li>
<li>第二、31可以被 JVM 优化，31 * i = (i &lt;&lt; 5) - i。</li>
</ol>
<p>Stack Overflow 上关于这个问题的讨论：Why does Java’s hashCode() in String use 31 as a multiplier?</p>
<p>其中排名第一的答案引用了《Effective Java》中的一段话，这里也引用一下：</p>
<blockquote>
<p>The value 31 was chosen because it is an odd prime. If it were even and the multiplication overflowed, information would be lost, as multiplication by 2 is equivalent to shifting. The advantage of using a prime is less clear, but it is traditional. A nice property of 31 is that the multiplication can be replaced by a shift and a subtraction for better performance: 31 * i == (i &lt;&lt; 5) - i`. Modern VMs do this sort of optimization automatically.</p>
</blockquote>
<p>翻译过来是这么说的：</p>
<ul>
<li>选择数字31是因为它是一个奇质数，如果选择一个偶数会在乘法运算中产生溢出，导致数值信息丢失，因为乘二相当于移位运算。</li>
<li>选择质数的优势并不是特别的明显，但这是一个传统。</li>
<li>同时，数字31有一个很好的特性，即乘法运算可以被移位和减法运算取代，来获取更好的性能：31 * i == (i &lt;&lt; 5) - i，现代的 Java 虚拟机可以自动的完成这个优化。</li>
</ul>
<p>排名第二的答案是这样说的：</p>
<blockquote>
<p>As Goodrich and Tamassia point out, If you take over 50,000 English words (formed as the union of the word lists provided in two variants of Unix), using the constants 31, 33, 37, 39, and 41 will produce less than 7 collisions in each case. Knowing this, it should come as no surprise that many Java implementations choose one of these constants.</p>
</blockquote>
<p>翻译过来是这样的：</p>
<ul>
<li>正如 Goodrich 和 Tamassia 指出的那样，如果你对超过 50,000 个英文单词（由两个不同版本的 Unix 字典合并而成）进行 hash code 运算，并使用常数 31, 33, 37, 39 和 41 作为乘子，每个常数算出的哈希值冲突数都小于7个，所以在上面几个常数中，常数 31 被 Java 实现所选用也就不足为奇了。</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 集合框架 - HashMap 分析</title>
    <url>/2020/03/29/java-ji-he-kuang-jia-hashmap-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-HashMap实现原理"><a href="#1-HashMap实现原理" class="headerlink" title="1.HashMap实现原理"></a>1.HashMap实现原理</h1><p><strong>简述HashMap的工作原理：</strong></p>
<p>HashMap是<strong>基于散列法（又称哈希法）的原理</strong>，使用<code>put(key, value)</code>存储对象到HashMap中，使用<code>get(key)</code>从HashMap中获取对象。使用HashMap进行查询和修改的速度都很快，平均时间复杂度O(1)。HashMap非线程安全，如果需要考虑并发，则需要使用ConcurrentHashMap，且HashMap不保证存储元素的序列；</p>
<a id="more"></a>

<hr>
<h1 id="2-HashMap的底层结构"><a href="#2-HashMap的底层结构" class="headerlink" title="2.HashMap的底层结构"></a>2.HashMap的底层结构</h1><p>JDK18之前：数组+链表</p>
<p>JDK1.8之后：数组+链表+红黑树</p>
<p>特点是HashMap采用Entry数组来存储key-value对，每一个键值对组成了一个Entry实体，Entry类实际上是一个单向的链表结构，它具有Next指针，可以连接下一个Entry实体。只是在JDK1.8中，链表长度大于8的时候，链表会转成红黑树！</p>
<p>在添加元素时，会根据hash值算出元素在数组中的位置，如果该位置没有元素，则直接把元素放置在此处，如果该位置有元素了，则把元素以链表的形式放置在链表的尾部。</p>
<p>数组的查询效率为O(1)，链表的查询效率是O(k)，红黑树的查询效率是O(log k)，k为桶中的元素个数，所以当元素数量非常多的时候，转化为红黑树能极大地提高效率。</p>
<p>底层结构具体如下所示：</p>
<ol>
<li><p>关于红黑树相关的知识：</p>
</li>
</ol>
<ul>
<li>可以看这篇文章：    </li>
</ul>
<hr>
<h1 id="3-源码阅读"><a href="#3-源码阅读" class="headerlink" title="3.源码阅读"></a>3.源码阅读</h1><h2 id="3-1-HashMap的继承与实现"><a href="#3-1-HashMap的继承与实现" class="headerlink" title="3.1.HashMap的继承与实现"></a>3.1.HashMap的继承与实现</h2><ul>
<li>HashMap实现了Cloneable，可以被克隆。</li>
<li>HashMap实现了Serializable，可以被序列化。</li>
<li>HashMap继承自AbstractMap，实现了Map接口，具有Map的所有功能。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>{}</span><br></pre></td></tr></tbody></table></figure>

<p>具体继承如下所示：</p>
<p><img src="https://i.loli.net/2020/04/02/fZVderRq2NO81Sc.png" alt="HashMap.png"></p>
<h2 id="3-2-HashMap的基本属性及内部类"><a href="#3-2-HashMap的基本属性及内部类" class="headerlink" title="3.2.HashMap的基本属性及内部类"></a>3.2.HashMap的基本属性及内部类</h2><h3 id="3-2-1-基本属性"><a href="#3-2-1-基本属性" class="headerlink" title="3.2.1 基本属性"></a>3.2.1 基本属性</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 哈希数组初始容量</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 哈希数组最大容量</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * HashMap默认装载因子（负载因子）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 当前 HashMap 所能容纳键值对数量的最大值，超过这个值，则需扩容</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 哈希槽（链）上的红黑树上的元素数量减少到此值时，将红黑树转换为链表</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 当桶的个数达到64的时候才进行树化</span></span><br><span class="line"><span class="comment">  * 即是说当桶数组容量小于该值时，优先进行扩容，而不是树化</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 哈希数组</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * entry集合</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * HashMap的元素数量</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *  HashMap结构的修改次数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * (The javadoc description is true upon serialization.</span></span><br><span class="line"><span class="comment">  * Additionally, if the table array has not been allocated, this</span></span><br><span class="line"><span class="comment">  * field holds the initial array capacity, or zero signifying</span></span><br><span class="line"><span class="comment">  * DEFAULT_INITIAL_CAPACITY.)</span></span><br><span class="line"><span class="comment">  * HashMap扩容阈值，并没有默认阈值，原因是阈值可由容量乘上负载因子计算而来（注释中有说明）</span></span><br><span class="line"><span class="comment">  * 计算公式：threshold = capacity * loadFactor</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * HashMap当前使用的装载因子</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></tbody></table></figure>

<p>上面举例了一些HashMap的属性字段，比较有意思的是羡慕几个属性字段，在接下来中会单拎出来进行详细讲解。：</p>
<ul>
<li>哈希数组的初始容量：DEFAULT_INITIAL_CAPACITY</li>
<li>负载因子：loadFactor</li>
<li>链表树化与树化链表的两个阈值：UNTREEIFY_THRESHOLD 和TREEIFY_THRESHOLD</li>
</ul>
<h3 id="3-2-2-Node内部类"><a href="#3-2-2-Node内部类" class="headerlink" title="3.2.2 Node内部类"></a>3.2.2 Node内部类</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>{</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>HashMap采用Entry数组来存储key-value对，每一个键值对组成了一个Entry实体，Entry类实际上是一个单向的链表结构，它具有Next指针，可以连接下一个Entry实体。只是在JDK1.8中，链表长度大于8的时候，链表会转成红黑树！</p>
<h3 id="3-2-3-TreeNode内部类"><a href="#3-2-3-TreeNode内部类" class="headerlink" title="3.2.3 TreeNode内部类"></a>3.2.3 TreeNode内部类</h3><p>TreeNode是一个典型的树型节点，其中，prev是链表中的节点，用于在删除元素的时候可以快速找到它的前置节点。</p>
<figure class="highlight scala"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 位于HashMap中</span></span><br><span class="line">static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode&lt;K</span>,<span class="title">V&gt;</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry&lt;K</span>,<span class="title">V&gt;</span> </span>{</span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; left;</span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; right;</span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    boolean red;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位于LinkedHashMap中，典型的双向链表节点</span></span><br><span class="line">static <span class="class"><span class="keyword">class</span> <span class="title">Entry&lt;K</span>,<span class="title">V&gt;</span> <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node&lt;K</span>,<span class="title">V&gt;</span> </span>{</span><br><span class="line">    <span class="type">Entry</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; before, after;</span><br><span class="line">    <span class="type">Entry</span>(int hash, <span class="type">K</span> key, <span class="type">V</span> value, <span class="type">Node</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; next) {</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<hr>
<h2 id="3-3-HashMap的四种构造及参数分析"><a href="#3-3-HashMap的四种构造及参数分析" class="headerlink" title="3.3.HashMap的四种构造及参数分析"></a>3.3.HashMap的四种构造及参数分析</h2><ol>
<li>无参构造，初始化一个哈希数组容量为16，装载因子为0.75的HashMap</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty {<span class="doctag">@code</span> HashMap} with the default initial capacity</span></span><br><span class="line"><span class="comment"> * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>初始化一个哈希数组容量为initialCapacity，装载因子为0.75的HashMap</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty {<span class="doctag">@code</span> HashMap} with the specified initial</span></span><br><span class="line"><span class="comment"> * capacity and the default load factor (0.75).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity the initial capacity.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li>初始化一个哈希数组容量为initialCapacity，装载因子为loadFactor的HashMap</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Constructs an empty {<span class="doctag">@code</span> HashMap} with the specified initial</span></span><br><span class="line"><span class="comment">   * capacity and load factor.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment">   *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>{</span><br><span class="line">      <span class="comment">// 检查传入的初始容量是否合法</span></span><br><span class="line">      <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                             initialCapacity);</span><br><span class="line">      <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">          initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">      <span class="comment">// 检查装载因子是否合法</span></span><br><span class="line">      <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                             loadFactor);</span><br><span class="line">      <span class="comment">// 初始化装载因子</span></span><br><span class="line">      <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">      <span class="comment">// 用初始容量信息来计算扩容门槛</span></span><br><span class="line">      <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<ol start="4">
<li>使用指定的HashMap中的元素来初始化一个新的HashMap</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new {<span class="doctag">@code</span> HashMap} with the same mappings as the</span></span><br><span class="line"><span class="comment"> * specified {<span class="doctag">@code</span> Map}.  The {<span class="doctag">@code</span> HashMap} is created with</span></span><br><span class="line"><span class="comment"> * default load factor (0.75) and an initial capacity sufficient to</span></span><br><span class="line"><span class="comment"> * hold the mappings in the specified {<span class="doctag">@code</span> Map}.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   m the map whose mappings are to be placed in this map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    <span class="comment">// 将指定HashMap中的元素存入到当前HashMap（允许覆盖）</span></span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们这这里对几个字段进行解释一下：</p>
<h2 id="3-4-查询"><a href="#3-4-查询" class="headerlink" title="3.4.查询"></a>3.4.查询</h2><h3 id="3-4-1-查询HashMap大小"><a href="#3-4-1-查询HashMap大小" class="headerlink" title="3.4.1.查询HashMap大小"></a>3.4.1.查询HashMap大小</h3><p>该方法返回HashMap的大小，键值对的数目：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-4-2-查询HashMap是否为空"><a href="#3-4-2-查询HashMap是否为空" class="headerlink" title="3.4.2 查询HashMap是否为空"></a>3.4.2 查询HashMap是否为空</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-4-3-查询HashMap是否存在指定key"><a href="#3-4-3-查询HashMap是否存在指定key" class="headerlink" title="3.4.3.查询HashMap是否存在指定key"></a>3.4.3.查询HashMap是否存在指定key</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> getNode(hash(key), key) != <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-4-4-查询HashMap中是否存在指定value的元素"><a href="#3-4-4-查询HashMap中是否存在指定value的元素" class="headerlink" title="3.4.4.查询HashMap中是否存在指定value的元素"></a>3.4.4.查询HashMap中是否存在指定value的元素</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>{</span><br><span class="line">    Node&lt;K,V&gt;[] tab; V v;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 进行循环遍历查找value</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; e : tab) {</span><br><span class="line">            <span class="keyword">for</span> (; e != <span class="keyword">null</span>; e = e.next) {</span><br><span class="line">                <span class="keyword">if</span> ((v = e.value) == value ||</span><br><span class="line">                    (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="3-5-取值"><a href="#3-5-取值" class="headerlink" title="3.5.取值"></a>3.5.取值</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>{</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>它调用了<code>getNode(int hash, Object key)</code>方法，详细代码如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>{</span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">      <span class="comment">// 如果桶的数量大于0，并且所查找的key所在的桶的第一个元素不为空</span></span><br><span class="line">      <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">          (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) {</span><br><span class="line">          <span class="comment">// 检查第一个元素是不是要查的元素，如果是则直接返回</span></span><br><span class="line">          <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">              ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">              <span class="keyword">return</span> first;</span><br><span class="line">          <span class="comment">// 如果不止一个元素，则继续寻找</span></span><br><span class="line">          <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) {</span><br><span class="line">              <span class="comment">// 如果第一个元素是树节点，则按树的方式查找</span></span><br><span class="line">              <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                  <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">              <span class="keyword">do</span> {</span><br><span class="line">                  <span class="comment">// 否则就遍历整个链表查找该元素</span></span><br><span class="line">                  <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                      ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                      <span class="keyword">return</span> e;</span><br><span class="line">              } <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">          }</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-6-添加"><a href="#3-6-添加" class="headerlink" title="3.6.添加"></a>3.6.添加</h2><h3 id="3-6-1-HashMap的添加过程"><a href="#3-6-1-HashMap的添加过程" class="headerlink" title="3.6.1.HashMap的添加过程"></a>3.6.1.HashMap的添加过程</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>实际上它调用了<code>putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict)</code>方法，详细代码如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 向当前Map中存入新的元素，并返回旧元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * hash         key的哈希值</span></span><br><span class="line"><span class="comment"> * onlyIfAbsent 是否需要维持原状（不覆盖旧值）</span></span><br><span class="line"><span class="comment"> * evict        如果为false，则表处于创建模式。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回同位元素的旧值（在当前Map中占据相同位置的元素）</span></span><br><span class="line"><span class="comment"> * 如果不存在同位元素，即插入了新元素，则返回null</span></span><br><span class="line"><span class="comment"> * 如果存在同位元素，但同位元素的旧值为null，那么也返回null</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>{</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 如果桶的长度为0，未初始化，则进行初始化并得到长度n</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 调用resize进行初始化</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 如果桶中还没有元素，则将要插入的key和value放到第一位</span></span><br><span class="line">    <span class="comment">// 使用(n - 1) &amp; hash 计算元素在哪个桶中</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> {  <span class="comment">// 桶中此时已存在元素</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 如果待插入的元素的hash值和key值与第一个元素的哈希值和key相同，保存到e用于后续修改value值</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 如果桶的第一个元素为树节点，则调用树节点的putTreeVal方法插入元素</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 遍历这个桶对应的链表，binCount用于存储链表中元素的个数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) {</span><br><span class="line">                <span class="comment">// 遍历整个链表，没有相同哈希值和key的元素，则在链表最后插入该key和value结点</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) {</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 如果插入结点之后的长度大于等于8，则树化</span></span><br><span class="line">                    <span class="comment">// 这里-1的解释为：因为第一个元素没有加到binCount中，所以这里-1</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">// 进行树化</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 假如待插入的key在链表中找到，则退出循环</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 找到了对应key的元素</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) { <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;   <span class="comment">// 记录旧值</span></span><br><span class="line">            <span class="comment">// 判断是否需要替换旧值</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;    <span class="comment">// 替换旧值为新值</span></span><br><span class="line">            <span class="comment">// 在节点被访问后做点什么事，在LinkedHashMap中用到</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 到了此处证明没有找到元素，即添加了新元素，修改次数加1</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 如果哈希数组的容量已超过阈值，则需要对哈希数组扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 在节点插入后做点什么事，在LinkedHashMap中用到</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>添加方法除了可以单个key-value键值对的添加，还可以将指定HashMap中的元素存入到当前HashMap中（允许覆盖），详细代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 如果当前HashMap的哈希数组还未初始化</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) { <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">// 根据HashMap中的元素数量反推哈希数组的最低容量要求</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;  <span class="comment">// 注意这里!!!!</span></span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">// 如果大于需要扩容的阈值，则重新计算扩容阈值</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// Because of linked-list bucket constraints, we cannot</span></span><br><span class="line">            <span class="comment">// expand all at once, but can reduce total resize</span></span><br><span class="line">            <span class="comment">// effort by repeated doubling now vs later</span></span><br><span class="line">            <span class="comment">// 由于链表存储桶的限制，我们无法一次全部扩展</span></span><br><span class="line">            <span class="comment">// 但可以通过立即加倍与以后加倍来减少总的调整工作量</span></span><br><span class="line">            <span class="comment">// 初始化哈希数组，或者对哈希数组扩容，并返回新的哈希数组</span></span><br><span class="line">            <span class="keyword">while</span> (s &gt; threshold &amp;&amp; table.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                resize();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 循环遍历进行添加，允许覆盖</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) {</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-6-2-HashMap的扩容过程"><a href="#3-6-2-HashMap的扩容过程" class="headerlink" title="3.6.2.HashMap的扩容过程"></a>3.6.2.HashMap的扩容过程</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 扩容机制：在初始化时、对哈希数组扩容时两种情况下调用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() {</span><br><span class="line">    <span class="comment">// 旧数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 旧容量，或者未初始化时的容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">// 旧扩容阈值</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="comment">// 新容量、新扩容阈值</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果哈希数组已经初始化，不是首次进入</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 如果旧容量大于最大容量，则不再扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) {</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果旧容量的两倍（左移一位）小于最大容量，并且大于默认初始容量（16）</span></span><br><span class="line">        <span class="comment">// 则新容量扩大为旧容量的两倍，扩容阈值也扩大为旧阈值的两倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果哈希数组还未初始化（首次进来）并且实例化HashMap的时候指定了初始容量</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        <span class="comment">// 则将哈希数组的当前容量初始化为与旧阈值一样大（传入初始容量时候会调用tableSizeFor()方法）</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">// 如果哈希数组还未初始化（首次进来）并且实例化HashMap的时候没有指定了初始容量</span></span><br><span class="line">    <span class="keyword">else</span> {               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">// 则使用默认的初始容量（16）和默认公式计算的阈值</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果新扩容阈值为0，则使用公式计算得到新的扩容阈值，并且不可超过最大容量</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 赋值扩容阈值为新扩容阈值</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">// 根据新扩容容量建立一个新容量的数组</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>({<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>})</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    <span class="comment">// 将桶赋值为新数组</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">// 旧数组不为空，则搬移元素</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 遍历旧数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) {</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">// 如果桶中的第一个元素不为空，则赋值给e</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="comment">// 清空旧桶，帮助GC</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 如果桶中只有一个元素，进行新桶的位置定位，并搬迁</span></span><br><span class="line">                <span class="comment">// 注意：只有第一个元素才可以这样，因为每次扩容都是两倍</span></span><br><span class="line">                <span class="comment">//       则第一个元素搬移到新桶的时候肯定还没有元素</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 如果该哈希槽上链接了不止一个元素，且该元素是TreeNode类型</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 如果第一个元素是树节点，则把这颗树打散成两颗树插入到新桶中去</span></span><br><span class="line">                    <span class="comment">// 拆分红黑树</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> { <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 如果这个链表不止一个元素且不是一颗树</span></span><br><span class="line">                    <span class="comment">// 则进行分化成两个链表插到新的桶中</span></span><br><span class="line">                    <span class="comment">// 举例：假如原来容量为4，3、7、11、15这四个元素都在三号桶中</span></span><br><span class="line">                    <span class="comment">// 现在扩容到8，则3和11还是在三号桶，7和15要搬移到七号桶中去</span></span><br><span class="line">                    <span class="comment">// 也就是分化成了两个链表</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> {</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// (e.hash &amp; oldCap) == 0的元素放在低位链表中</span></span><br><span class="line">                        <span class="comment">// 比如，3 &amp; 4 == 0</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) {</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">else</span> {</span><br><span class="line">                            <span class="comment">// (e.hash &amp; oldCap) != 0的元素放在高位链表中</span></span><br><span class="line">                            <span class="comment">// 比如，7 &amp; 4 != 0</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        }</span><br><span class="line">                    } <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 遍历完成得到两个链表</span></span><br><span class="line">                    <span class="comment">// 低位链表在新桶的位置与旧桶一样（即3和11还在三号桶中）</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) {</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">// 高位链表在新桶中的位置正好是原来的位置加上旧容量（即7和15搬移到七号桶了）</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) {</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-6-3-HashMap扩容的思考"><a href="#3-6-3-HashMap扩容的思考" class="headerlink" title="3.6.3.HashMap扩容的思考"></a>3.6.3.HashMap扩容的思考</h3><h3 id="3-6-4-树化与链化过程"><a href="#3-6-4-树化与链化过程" class="headerlink" title="3.6.4.树化与链化过程"></a>3.6.4.树化与链化过程</h3><h2 id="3-7-移除"><a href="#3-7-移除" class="headerlink" title="3.7.移除"></a>3.7.移除</h2><figure class="highlight processing"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据传入的key进行数据移除元素，并返回刚刚移除的元素的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> V remove(<span class="keyword">Object</span> <span class="built_in">key</span>) {</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(<span class="built_in">key</span>), <span class="built_in">key</span>, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>实际上它调用了<code>removeNode(int hash, Object key, Object value,boolean matchValue, boolean movable)</code>方法，详细代码如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 从HashMap中移除指定的元素，并返回刚刚移除的元素（移除失败返回null）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * matchValue 移除元素时是否需要考虑value的匹配问题</span></span><br><span class="line"><span class="comment"> * movable    移除元素后如果红黑树根结点发生了变化，那么是否需要改变结点在链表上的顺序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>{</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">// 如果桶的数量大于0（不空）且待删除的元素所在的桶的第一个元素不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) {</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">// 如果键的值与链表第一个节点相等，则将 node 指向该节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 如果该Tab的第一个元素是树节点，则以树的方式进行寻找</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 否则，就以链表的形式进行遍历寻找</span></span><br><span class="line">                <span class="keyword">do</span> {</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) {</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                    p = e;</span><br><span class="line">                } <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果找到了该元素，则进行值比对</span></span><br><span class="line">        <span class="comment">// 根据传递进来的matchValue判断是否需要匹配</span></span><br><span class="line">        <span class="comment">// 如果不需要匹配直接删除，如果需要匹配看是否与传入的value相等</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) {</span><br><span class="line">            <span class="comment">// 如果是树结点，则调用树的删除方法；</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="comment">// 如果待删除的元素是第一个元素，则将第二个元素移到到第一个元素的位置</span></span><br><span class="line">            <span class="comment">// 注意：上面的代码可知，node==p的情况只有待删除元素node是第一个结点才会发生</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="comment">// 如果待删除的元素不是第一个元素，则将中间结点连接断开（单向链表）</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            <span class="comment">// 修改次数＋1</span></span><br><span class="line">            ++modCount;</span><br><span class="line">            <span class="comment">// size-1</span></span><br><span class="line">            --size;</span><br><span class="line">            <span class="comment">// 删除结点之后应处理的事情</span></span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<hr>
<h1 id="4-HashMap的其他问题思考"><a href="#4-HashMap的其他问题思考" class="headerlink" title="4.HashMap的其他问题思考"></a>4.HashMap的其他问题思考</h1><hr>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h1><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
</search>

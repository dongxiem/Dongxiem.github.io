<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java 并发 - AQS：自定义同步工具</title>
    <url>/2020/04/14/java-bing-fa-aqs-zi-ding-yi-tong-bu-gong-ju/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>通过前面的AQS的基本原理了解:之后：<a href="https://dongxiem.github.io/2020/03/31/java-bing-fa-aqs-kuang-jia-fen-xi/">Java 并发 - AQS：框架分析</a>，我了解了大概的AQS的一整个流程，也明白了大部分的同步工具都是基于AQS来实现的，好像比较重要的就是重写tryAcquire 和 tryRelease 两个方法而已，那么我借鉴了其他同步工具的写法，试了试尝试自己实现一个基于AQS的同步工具，看看能不能正常跑起来。</p>
<p>以下是基于独占式的写法，并不是共享式的，所以实现的也是<code>tryAcquire</code>和<code>tryRelease</code>。主要想做的事情就是同一个时刻只能让一个线程一直抱有资源做一件事情，直到这件事情做完了之后，才可以让其他线程去做一些事情，这不就是同步的概念嘛！</p>
<h1 id="2-自定义工具"><a href="#2-自定义工具" class="headerlink" title="2.自定义工具"></a>2.自定义工具</h1><p>实现自定义同步器需要实现<code>tryAcquire</code>和<code>tryRelease</code>，这里再重新提及一下state状态的意思，他代表当前锁的状态，0代表没有被占用，大于 0 代表有线程持有当前锁。</p>
<p>具体Demo如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockBaseAQS</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现内部类继承AQS</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>{</span><br><span class="line">        <span class="comment">// 重写tryAcquire方法</span></span><br><span class="line">        <span class="comment">// 返回1则代表获取锁成功，返回0则代表获取锁失败</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span> <span class="params">(<span class="keyword">int</span> arg)</span></span>{</span><br><span class="line">            <span class="comment">// 省略了this，AQS中state默认为0</span></span><br><span class="line">            <span class="keyword">return</span> compareAndSetState(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 重写tryRelease方法</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span> <span class="params">(<span class="keyword">int</span> arg)</span></span>{</span><br><span class="line">            <span class="comment">// 将状态设置为0</span></span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 并返回1，代表该锁没有被任何线程持有</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该线程是否正在独占资源</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="comment">// 如果state为1，代表资源正在被线程占有，否则没有</span></span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现给用户上锁的api：lock</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>{</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现给用户解锁的api：unLock</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unLock</span><span class="params">()</span> </span>{</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>这里我想还是把acquire和release的源码放出来，比较容易理解：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="comment">// 上面实现了这个tryAcquire！</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="comment">// 我们上面就实现了这个tryRelease！</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) {</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>







<hr>
<h1 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h1><p>编写了一个测试Demo如下，我们创建两个线程，然后启动这两个线程，让两个线程各自从0打印10000000，看结果会不会统一。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> MyLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> LockBaseAQS myLock = <span class="keyword">new</span> LockBaseAQS();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="comment">// 进行上锁，同一时间，只允许一个线程创建累加计数</span></span><br><span class="line">                    <span class="comment">// 这块代码同一时间只能有一个线程进来(获取到锁的线程)</span></span><br><span class="line">                    <span class="comment">// 其他的线程在lock()方法上阻塞，等待获取到锁，再进来</span></span><br><span class="line">                    myLock.lock();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) {</span><br><span class="line">                        count++;</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    <span class="comment">// 解锁</span></span><br><span class="line">                    myLock.unLock();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样一来每次都会打印出：</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">20000000</span></span><br></pre></td></tr></tbody></table></figure>



<p>假如将同步方法给屏蔽了之后，会发现每次都打印出不一样的数字！</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - AQS：LockSupport阻塞唤醒线程</title>
    <url>/2020/04/11/java-bing-fa-aqs-locksupport-zu-sai-huan-xing-xian-cheng/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>LockSupport在AQS中经常被调用，可以经常看到LockSupport的出现，看了很久也不清楚大概是个什么作用，总结了一些，它大概就是AQS用来实现线程的阻塞和唤醒的，分别通过<code>LockSupport .park()</code>和 <code>LockSupport .unpark()</code>进行实现的。</p>
<p>使用LockSupport的线程会与一个许可关联，其实就像是一个二元信号量（意思就是只有一个许可证可以使用），如果这个许可没有被占用，那么当前线程可以获得许可并继续执行，如果许可以已经被占用，则当前线程就会被阻塞，然后等待许可的获取。注意：<strong>许可默认是被占用的！</strong></p>
<p>可以看看如下的一个小的测试：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">     Thread thread = Thread.currentThread();</span><br><span class="line">     LockSupport.unpark(thread);<span class="comment">//释放许可</span></span><br><span class="line">     LockSupport.park();<span class="comment">// 获取许可</span></span><br><span class="line">     System.out.println(<span class="string">"b"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样一来先释放许可，再获取许可，主线程是能够正常打印出字符的，但是如果没有先释放许可的话，就会被阻塞了：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">     LockSupport.park();</span><br><span class="line">     System.out.println(<span class="string">"block."</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行该代码，可以发现主线程一直处于阻塞状态。因为 <strong>许可默认是被占用的</strong> ，调用park()时获取不到许可，所以进入阻塞状态。</p>
<p>还需要注意的是<strong>LockSupport是不可重入</strong> 的，如果一个线程连续2次调用 LockSupport .park()，那么该线程一定会一直阻塞下去。</p>
<p>LockSupport定义了一系列以park开头的方法来阻塞当前线程，unpark(Thread thread)方法来唤醒一个被阻塞的线程。如下：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/11/eIlXKaFYn2rdcgh.jpg"  alt="LockSupport的几个方法"></p>
<hr>
<h1 id="2-源码"><a href="#2-源码" class="headerlink" title="2.源码"></a>2.源码</h1><h2 id="2-1-park"><a href="#2-1-park" class="headerlink" title="2.1 park"></a>2.1 park</h2><p>park(Object blocker)方法的blocker参数，主要是用来标识当前线程在等待的对象，该对象主要用于问题排查和系统监控。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>{</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    setBlocker(t, blocker);</span><br><span class="line">    U.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>setBlocker主要完成的也就是设置屏障，其源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setBlocker</span><span class="params">(Thread t, Object arg)</span> </span>{</span><br><span class="line">    <span class="comment">// Even though volatile, hotspot doesn't need a write barrier here.</span></span><br><span class="line">    U.putReference(t, PARKBLOCKER, arg);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>需要注意的是：park方法和unpark(Thread thread)都是成对出现的，同时unpark必须要在park执行之后执行，当然并不是说没有不调用unpark线程就会一直阻塞，park有一个方法，它带了时间戳（parkNanos(long nanos)：为了线程调度禁用当前线程，最多等待指定的等待时间，除非许可可用）。</p>
<hr>
<h2 id="2-2-unpark"><a href="#2-2-unpark" class="headerlink" title="2.2 unpark"></a>2.2 unpark</h2><p>unpark(Thread thread)方法源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">        U.unpark(thread);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>U是什么？查看源码可以发现一系列UNSAFE相关的方法：</p>
<figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Hotspot implementation via intrinsics API</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe U = Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> PARKBLOCKER = U.objectFieldOffset</span><br><span class="line">        (Thread.class, "parkBlocker");</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SECONDARY = U.objectFieldOffset</span><br><span class="line">        (Thread.class, "threadLocalRandomSecondarySeed");</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TID = U.objectFieldOffset</span><br><span class="line">        (Thread.class, "tid");</span><br></pre></td></tr></tbody></table></figure>



<p>可以发现park和unpark其内部都是通过UNSAFE（sun.misc.Unsafe UNSAFE）来实现的，其定义如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> var1, <span class="keyword">long</span> var2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Object var1)</span></span>;</span><br></pre></td></tr></tbody></table></figure>



<p>关于Unusafe，我想后面还是要去了解一下，Unusafe是一个比较危险的类，主要是用于执行低级别、不安全的方法集合。</p>
<hr>
<h1 id="3-官方案例"><a href="#3-官方案例" class="headerlink" title="3.官方案例"></a>3.官方案例</h1><p>JDK源码给了一个案例，理解一下其具体操作，如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FIFOMutex</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean locked = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Thread&gt; waiters = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上锁操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">boolean</span> wasInterrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// publish current thread for unparkers</span></span><br><span class="line">        waiters.add(Thread.currentThread());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Block while not first in queue or cannot acquire lock</span></span><br><span class="line">        <span class="keyword">while</span> (waiters.peek() != Thread.currentThread() ||</span><br><span class="line">               !locked.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) {</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// ignore interrupts while waiting</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                wasInterrupted = <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        waiters.remove();</span><br><span class="line">        <span class="comment">// ensure correct interrupt status on return</span></span><br><span class="line">        <span class="keyword">if</span> (wasInterrupted)</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>{</span><br><span class="line">        locked.set(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        LockSupport.unpark(waiters.peek());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        <span class="comment">// Reduce the risk of "lost unpark" due to classloading</span></span><br><span class="line">        Class&lt;?&gt; ensureLoaded = LockSupport<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<hr>
<p>参考文章：</p>
<ol>
<li><a href="http://cmsblogs.com/?p=2205" target="_blank" rel="noopener">【死磕Java并发】—–J.U.C之AQS：阻塞和唤醒线程</a></li>
<li><a href="https://www.tuicool.com/articles/MveUNzF" target="_blank" rel="noopener">LockSupport的park和unpark的基本使用,以及对线程中断的响应性</a></li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - FutureTask源码分析</title>
    <url>/2020/04/10/java-bing-fa-futuretask-yuan-ma-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-什么是FutureTask？"><a href="#1-什么是FutureTask？" class="headerlink" title="1. 什么是FutureTask？"></a>1. 什么是FutureTask？</h1><p>前面的Blog介绍了<u><code>Future</code>接口。这个接口有一个实现类叫<code>FutureTask</code></u>。<code>FutureTask</code>类有什么用？为什么要有一个<code>FutureTask</code>类？前面说到了<code>Future</code>只是一个接口，而它里面的<code>cancel</code>，<code>get</code>，<code>isDone</code>等方法要自己实现起来都是<strong>非常复杂</strong>的。所以JDK提供了一个<code>FutureTask</code>类来供我们使用。</p>
<p>意思就是FutureTask是Future的具体实现，且实现了Runnable接口，即FutureTask满足了Task的行为，是一个可以被用来执行的Future。FutureTask是JCU提供的线程池实现用到的任务基本单元，线程池主要接收两种对象：一个是Runnable任务，一种是Callable任务。按照ExecutorService接口定义的行为，可以将Runnable或Callable任务提交到线程池执行，而被提交的Runnable或Callable任务都会被包装成FutureTask，由线程池的工作线程去执行。</p>
<p><code>FutureTask</code>是实现的<code>RunnableFuture</code>接口的，而<code>RunnableFuture</code>接口同时继承了<code>Runnable</code>接口和<code>Future</code>接口。因此，<code>FutureTask</code>可以交给Executor执行，也可以由调用线程直接执行（<code>FutureTask.run()</code>）。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 片段一</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets this Future to the result of its computation</span></span><br><span class="line"><span class="comment">     * unless it has been cancelled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 片段二</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>{</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>FutureTask</code>还是可以研究一下的，我将里面实现的一个方法一点一点进行分析。</p>
<hr>
<h1 id="2-FutureTask源码分析"><a href="#2-FutureTask源码分析" class="headerlink" title="2.FutureTask源码分析"></a>2.FutureTask源码分析</h1><h2 id="2-1-FutureTask的几个状态"><a href="#2-1-FutureTask的几个状态" class="headerlink" title="2.1 FutureTask的几个状态"></a>2.1 FutureTask的几个状态</h2><p>根据<code>FutureTask.run()</code>方法被执行的时机，FutureTask可以处于下面3种状态（图源：Java并发编程的艺术）。</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/10/NcqZ1HBFIQuvwbt.png"  alt="几种状态"></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The run state of this task, initially NEW.  The run state</span></span><br><span class="line"><span class="comment"> * transitions to a terminal state only in methods set,</span></span><br><span class="line"><span class="comment"> * setException, and cancel.  During completion, state may take on</span></span><br><span class="line"><span class="comment"> * transient values of COMPLETING (while outcome is being set) or</span></span><br><span class="line"><span class="comment"> * INTERRUPTING (only while interrupting the runner to satisfy a</span></span><br><span class="line"><span class="comment"> * cancel(true)). Transitions from these intermediate to final</span></span><br><span class="line"><span class="comment"> * states use cheaper ordered/lazy writes because values are unique</span></span><br><span class="line"><span class="comment"> * and cannot be further modified.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Possible state transitions:</span></span><br><span class="line"><span class="comment"> * NEW -&gt; COMPLETING -&gt; NORMAL</span></span><br><span class="line"><span class="comment"> * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span></span><br><span class="line"><span class="comment"> * NEW -&gt; CANCELLED</span></span><br><span class="line"><span class="comment"> * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="comment">// 初始创建时的状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 当任务执行完毕，FutureTask会将执行结果设置给outcome属性，在设置之前会将FutureTask的状态修改为COMPLETING。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 当任务执行完毕，FutureTask会将执行结果设置给outcome属性，在设置之后会将FutureTask的状态修改为NORMAL。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 当任务在执行的过程中抛了异常，FutureTask会将异常信息设置给outcome属性，</span></span><br><span class="line"><span class="comment">// 在设置之前会将FutureTask的状态修改为COMPLETING，在设置之后将状态修改为EXCEPTIONAL。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 当外部想要取消任务，而又不允许当任务正在执行的时候被取消时会将FutureTask的状态修改为CANCELLED。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 当外部想要取消任务，同时允许当任务正在执行的时候被取消时，会先将FutureTask的状态设置为INTERRUPTING，</span></span><br><span class="line"><span class="comment">// 然后设置执行任务的线程的中断标记位。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 当外部想要取消任务，同时允许当任务正在执行的时候被取消时，会先将FutureTask的状态设置为INTERRUPTING，</span></span><br><span class="line"><span class="comment">// 然后设置执行任务的线程的中断标记位，最后将Future的状态设置为INTERRUPTED。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>FutureTask的状态流转可能流程：</p>
<ul>
<li>NEW—&gt;COMPLETING—&gt;NORMAL（任务执行正常）</li>
<li>NEW—&gt;COMPLETING—&gt;EXCEPTIONAL（任务执行异常）</li>
<li>NEW—&gt;CANCELLED（不允许执行中的取消）</li>
<li>NEW—&gt;INTERRUPTING—&gt;INTERRUPTED（允许执行中的取消）</li>
</ul>
<p>需要注意的是：FutureTask中使用<u>CAS操作</u>更新state来表示任务完成，极大地降低了使用加锁进行同步控制的性能开销。</p>
<h2 id="2-2-Treiber-堆"><a href="#2-2-Treiber-堆" class="headerlink" title="2.2 Treiber 堆"></a>2.2 Treiber 堆</h2><p>FutureTask中使用简单的Treiber堆栈来保存等待线程，Treiber堆是非阻塞的，使用CAS操作来实现节点的出栈和入栈操作。FutureTask中使用WaitNode来表示等待节点，源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/** Treiber stack of waiting threads */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Simple linked list nodes to record waiting threads in a Treiber</span></span><br><span class="line"><span class="comment"> * stack.  See other classes such as Phaser and SynchronousQueue</span></span><br><span class="line"><span class="comment"> * for more detailed explanation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNode</span> </span>{</span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="keyword">volatile</span> WaitNode next;</span><br><span class="line">    WaitNode() { thread = Thread.currentThread(); }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<hr>
<h2 id="2-3-构造方法"><a href="#2-3-构造方法" class="headerlink" title="2.3 构造方法"></a>2.3 构造方法</h2><p>可以发现<code>FutureTask</code>的参数可以有<code>Callable</code>或者<code>Runnable</code>和<code>result</code>，<code>FutureTask</code>的构造方法将提交的<code>Runnable</code>或<code>Callable</code>任务都会被包装成<code>FutureTask</code>。源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a {<span class="doctag">@code</span> FutureTask} that will, upon running, execute the</span></span><br><span class="line"><span class="comment"> * given {<span class="doctag">@code</span> Callable}.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  callable the callable task</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the callable is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.callable = callable;</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a {<span class="doctag">@code</span> FutureTask} that will, upon running, execute the</span></span><br><span class="line"><span class="comment"> * given {<span class="doctag">@code</span> Runnable}, and arrange that {<span class="doctag">@code</span> get} will return the</span></span><br><span class="line"><span class="comment"> * given result on successful completion.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> runnable the runnable task</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> result the result to return on successful completion. If</span></span><br><span class="line"><span class="comment"> * you don't need a particular result, consider using</span></span><br><span class="line"><span class="comment"> * constructions of the form:</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@code</span> Future&lt;?&gt; f = new FutureTask&lt;Void&gt;(runnable, null)}</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the runnable is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>{</span><br><span class="line">    <span class="comment">// 返回的还是一个callable</span></span><br><span class="line">    <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>查看<code>Executors.callable(runnable, result);</code> 源码如下，会发现其实<code>FutureTask</code>最终将<code>Runnabl</code>转化为<code>Callable</code>，而且这里还使用了一种模式：适配器模式。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a {<span class="doctag">@link</span> Callable} object that, when</span></span><br><span class="line"><span class="comment"> * called, runs the given task and returns the given result.  This</span></span><br><span class="line"><span class="comment"> * can be useful when applying methods requiring a</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@code</span> Callable} to an otherwise resultless action.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task the task to run</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> result the result to return</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of the result</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a callable object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if task null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 返回这么RunnableAdapter一个对象，其实现了Callable接口</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(task, result);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>其中<code>RunnableAdapter</code>的源码如下所示，你会发现兜兜转转，还是实现了<code>Callable</code>，这就很有意思了。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A callable that runs given task and returns given result.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable task;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T result;</span><br><span class="line">    <span class="comment">// 构造函数，上面就是根据传递进来的task和result构建了这么一个对象然后返回</span></span><br><span class="line">    RunnableAdapter(Runnable task, T result) {</span><br><span class="line">        <span class="keyword">this</span>.task = task;</span><br><span class="line">        <span class="keyword">this</span>.result = result;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> </span>{</span><br><span class="line">        task.run();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString() + <span class="string">"[Wrapped task = "</span> + task + <span class="string">"]"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<hr>
<h2 id="2-4-运行任务"><a href="#2-4-运行任务" class="headerlink" title="2.4 运行任务"></a>2.4 运行任务</h2><p><code>FutureTask</code>中使用run方法来执行任务，源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 如果当前状态不为NEW，而且没有其他线程运行当前任务</span></span><br><span class="line">    <span class="comment">// 否则直接return;</span></span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !RUNNER.compareAndSet(<span class="keyword">this</span>, <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="comment">// callable不为null，且在此判断状态</span></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) {</span><br><span class="line">            V result;</span><br><span class="line">            <span class="keyword">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 进行执行任务</span></span><br><span class="line">                <span class="comment">// 发现FutureTask的run的方法调用的就是Callable的call方法</span></span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            } <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">                ran = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 修改状态为EXCEPTIONAL，并且记录异常</span></span><br><span class="line">                setException(ex);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                <span class="comment">// 修改状态，set方法会将状态state设置为NORMAL</span></span><br><span class="line">                set(result);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">        <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">        <span class="comment">// 在设置状态state前runner必须非空，防止并发调用run()方法</span></span><br><span class="line">        <span class="comment">// 而且将runner置空，主要是使后续等待线程可继续执行</span></span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">        <span class="comment">// leaked interrupts</span></span><br><span class="line">        <span class="comment">// runner置为null后，必须重新读取state以防止有中断发生</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="comment">// 如果state被其他线程调用cancel（true）修改为INTERRUPTING</span></span><br><span class="line">        <span class="comment">// 这表示有中断事件发生，那就要调用下面的方法进行暂停了</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            <span class="comment">// 这里主要就是调用Thread.yield()让出CPU，保证线程能够成功暂停。</span></span><br><span class="line">            <span class="comment">// 注意：执行yield()的线程有可能在进入到暂停状态后马上又被执行。</span></span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>以上的过程大概如此：</p>
<ol>
<li>运行任务之前必须要保证其状态是NEW，并且没有其他线程在执行当前任务。然后调用<code>c.call();</code>执行任务并接收返回值，然后修改状态。</li>
<li>任务运行中如果发生了异常则调用<code>setException(ex);</code>进行异常处理；</li>
<li>任务正常完成时，将调用set方法修改state，最后将runner置空。同时判断是否有中断事件发生，有的话进行线程暂停，释放资源。</li>
</ol>
<p>其实就是上面蕴含了两条状态变化的线路：</p>
<ol>
<li>NEW—&gt;COMPLETING—&gt;EXCEPTIONAL（任务执行异常）</li>
<li>NEW—&gt;COMPLETING—&gt;NORMAL（任务执行正常）</li>
</ol>
<p>可以看看<code>setException</code>方法做了一些什么：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Causes this future to report an {<span class="doctag">@link</span> ExecutionException}</span></span><br><span class="line"><span class="comment"> * with the given throwable as its cause, unless this future has</span></span><br><span class="line"><span class="comment"> * already been set or has been cancelled.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is invoked internally by the {<span class="doctag">@link</span> #run} method</span></span><br><span class="line"><span class="comment"> * upon failure of the computation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> t the cause of failure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setException</span><span class="params">(Throwable t)</span> </span>{</span><br><span class="line">    <span class="comment">// 将状态由NEW修改为COMPLETING </span></span><br><span class="line">    <span class="keyword">if</span> (STATE.compareAndSet(<span class="keyword">this</span>, NEW, COMPLETING)) {</span><br><span class="line">        <span class="comment">// 并且记录异常</span></span><br><span class="line">        outcome = t;</span><br><span class="line">        <span class="comment">// 设置状态为EXCEPTIONAL</span></span><br><span class="line">        STATE.setRelease(<span class="keyword">this</span>, EXCEPTIONAL); <span class="comment">// final state</span></span><br><span class="line">        <span class="comment">// 唤醒等待队列中的所有后续线程（若有）</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p><code>finishCompletion</code>做了一些什么？<code>finishCompletion</code>用于唤醒等待队列中的所有后续线程（若有）。当任务未完成时，调用get()方法会被加入等待队列并阻塞。<code>FutureTask</code>中done()什么也不做，该方法主要用于子类个性化定制，如<code>ExecutorCompletionService</code>中<code>QueueingFuture</code>实现<code>FutureTask</code>，实现done()以达到任务完成自动将Future加入结果队列。</p>
<p>可以查看一下他的源码，如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes and signals all waiting threads, invokes done(), and</span></span><br><span class="line"><span class="comment"> * nulls out callable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// assert state &gt; COMPLETING;</span></span><br><span class="line">    <span class="comment">// 遍历所有的等待线程</span></span><br><span class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) {</span><br><span class="line">        <span class="comment">// 将waiters设置为null</span></span><br><span class="line">        <span class="keyword">if</span> (WAITERS.weakCompareAndSet(<span class="keyword">this</span>, q, <span class="keyword">null</span>)) {</span><br><span class="line">            <span class="comment">// 如果上面的设置成功，则进入一个死循环等待</span></span><br><span class="line">            <span class="keyword">for</span> (;;) {</span><br><span class="line">                Thread t = q.thread;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) {</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 进行线程的唤醒</span></span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 下一个等待线程</span></span><br><span class="line">                WaitNode next = q.next;</span><br><span class="line">                <span class="comment">// 如果没有下一个等待线程，则结束</span></span><br><span class="line">                <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                q = next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    done();</span><br><span class="line">    callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>i</p>
<hr>
<h2 id="2-6-取消任务"><a href="#2-6-取消任务" class="headerlink" title="2.6 取消任务"></a>2.6 取消任务</h2><p>我们根据状态的变化来捋一下取消任务的主要流程，其主要有两条线路：</p>
<ol>
<li>NEW—&gt;INTERRUPTING—&gt;INTERRUPTED（允许执行中的取消）</li>
<li>NEW—&gt;CANCELLED（不允许执行中的取消）</li>
</ol>
<p>就是当外部想要取消任务的时候，看看当前任务是否能够允许被取消。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>{</span><br><span class="line">    <span class="comment">// 当前状态为NEW，并且且判断当前线程运行时候时候能够中断</span></span><br><span class="line">    <span class="comment">// 可以的话将状态设置为INTERRUPTING，否则设置为CANCELLED并返回false</span></span><br><span class="line">    <span class="keyword">if</span> (!(state == NEW &amp;&amp; STATE.compareAndSet</span><br><span class="line">          (<span class="keyword">this</span>, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> {    <span class="comment">// in case call to interrupt throws exception</span></span><br><span class="line">        <span class="keyword">if</span> (mayInterruptIfRunning) { <span class="comment">// 判断是否允许在运行时候进行中断</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 保存当前运行的线程</span></span><br><span class="line">                Thread t = runner;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 进行中断</span></span><br><span class="line">                    t.interrupt();</span><br><span class="line">            } <span class="keyword">finally</span> { <span class="comment">// final state</span></span><br><span class="line">                <span class="comment">// 将当前执行线程状态state设置成为INTERRUPTED</span></span><br><span class="line">                STATE.setRelease(<span class="keyword">this</span>, INTERRUPTED);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        finishCompletion();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<hr>
<h2 id="2-7-获取任务结果"><a href="#2-7-获取任务结果" class="headerlink" title="2.7 获取任务结果"></a>2.7 获取任务结果</h2><p>get操作主要用于计算完成后获取结果，还可以使用带等待时间的get方法，其源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> CancellationException {<span class="doctag">@inheritDoc</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>{</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> CancellationException {<span class="doctag">@inheritDoc</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>{</span><br><span class="line">    <span class="keyword">if</span> (unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING &amp;&amp;</span><br><span class="line">        (s = awaitDone(<span class="keyword">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>其中report方法的实现如下，主要完成的是：返回一个结果，或者抛出异常。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns result or throws exception for completed task.</span></span><br><span class="line"><span class="comment"> * 对于已经完成的任务，返回一个结果，或者抛出一个异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s completed state value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>{</span><br><span class="line">    <span class="comment">// 记录该outcome</span></span><br><span class="line">    Object x = outcome;</span><br><span class="line">    <span class="comment">// 如果线程状态state为NORMAL时，则返回一个结果</span></span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">        <span class="keyword">return</span> (V)x;</span><br><span class="line">    <span class="comment">// 如果线程状态state为CANCELLED、INTERRUPTING、INTERRUPTED，则抛出一个异常</span></span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode - 算法思想 - 回溯</title>
    <url>/2020/04/09/leetcode-suan-fa-si-xiang-hui-su/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-开篇"><a href="#1-开篇" class="headerlink" title="1.开篇"></a>1.开篇</h1><p><strong>解决一个回溯问题，实际上就是一个决策树的遍历过程</strong>。你只需要思考 3 个问题：</p>
<ol>
<li>路径：也就是已经做出的选择。</li>
<li>选择列表：也就是你当前可以做的选择。</li>
<li>结束条件：也就是到达决策树底层，无法再做选择的条件。</li>
</ol>
<p>代码方面，回溯算法的框架：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(路径, 选择列表)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></tbody></table></figure>

<p><strong>其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」</strong>，特别简单。</p>
<hr>
<h1 id="2-拉开序幕"><a href="#2-拉开序幕" class="headerlink" title="2.拉开序幕"></a>2.拉开序幕</h1><h2 id="2-1-全排列"><a href="#2-1-全排列" class="headerlink" title="2.1 全排列"></a>2.1 全排列</h2><h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>LeetCode：<a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">46. 全排列</a></p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p>
<p><strong>示例:</strong></p>
<figure class="highlight angelscript"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>



<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>具体可以看如下这篇文章：<a href="[https://github.com/labuladong/fucking-algorithm/blob/master/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%BF%AE%E8%AE%A2%E7%89%88.md](https://github.com/labuladong/fucking-algorithm/blob/master/算法思维系列/回溯算法详解修订版.md)">回溯算法详解</a></p>
<p>怎么穷举全排列的呢？比方说给三个数 <code>[1,2,3]</code>，一般是这样：先固定第一位为 1，然后第二位可以是 2，那么第三位只能是 3；然后可以把第二位变成 3，第三位就只能是 2 了；然后就只能变化第一位，变成 2，然后再穷举后两位……</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/10/xoQV94KgOn1WL6m.png"  alt="穷举全排列"></p>
<p>只要从根遍历这棵树，记录路径上的数字，其实就是所有的全排列。<strong>我们不妨把这棵树称为回溯算法的「决策树」</strong>。</p>
<p>我们理解全排列的这棵树可称为回溯算法的「决策树」<strong>，因为你在每个节点上其实都在做决策</strong>。比如说你站在下图的红色节点上：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/10/M8W9VOyakEdQNHG.png"  alt="类似决策树"></p>
<p>你现在就在做决策，可以选择 1 那条树枝，也可以选择 3 那条树枝。为啥只能在 1 和 3 之中选择呢？因为 2 这个树枝在你身后，这个选择你之前做过了，而全排列是不允许重复使用数字的。</p>
<p>可以解答开头的几个名词：<code>[2]</code> 就是「路径」，记录你已经做过的选择；<code>[1,3]</code> 就是「选择列表」，表示你当前可以做出的选择；「结束条件」就是遍历到树的底层，在这里就是选择列表为空的时候。</p>
<p><strong>可以把「路径」和「选择」列表作为决策树上每个节点的属性</strong>，比如下图列出了几个节点的属性：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/10/jD4zbWMJ5xRrwIZ.png"  alt="选择列表与路径"></p>
<p><strong>我们定义的 <code>backtrack</code> 函数其实就像一个指针，在这棵树上游走，同时要正确维护每个节点的属性，每当走到树的底层，其「路径」就是一个全排列</strong>。</p>
<p>再进一步，如何遍历一棵树？这个应该不难吧。回忆一下之前「学习数据结构的框架思维」写过，各种搜索问题其实都是树的遍历问题，而多叉树的遍历框架就是这样：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (TreeNode child : root.childern)</span><br><span class="line">        <span class="comment">// 前序遍历需要的操作</span></span><br><span class="line">        traverse(child);</span><br><span class="line">        <span class="comment">// 后序遍历需要的操作</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>而所谓的前序遍历和后序遍历，他们只是两个很有用的时间点，我给你画张图你就明白了：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/10/EDJIC8ofb65pLGe.png"  alt="前序遍历与后序遍历"></p>
<p><strong>前序遍历的代码在进入某一个节点之前的那个时间点执行，后序遍历代码在离开某个节点之后的那个时间点执行</strong>。</p>
<p>回想我们刚才说的，「路径」和「选择」是每个节点的属性，函数在树上游走要正确维护节点的属性，那么就要在这两个特殊时间点搞点动作：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/10/vm6YjPpehVToSng.png"  alt="选择与撤销的过程"></p>
<p><strong>所以回溯的核心框架</strong>：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 选择 in 选择列表:</span><br><span class="line">    # 做选择</span><br><span class="line">    将该选择从选择列表移除</span><br><span class="line">    路径.add(选择)</span><br><span class="line">    backtrack(路径, 选择列表)</span><br><span class="line">    # 撤销选择</span><br><span class="line">    路径.remove(选择)</span><br><span class="line">    将该选择再加入选择列表</span><br></pre></td></tr></tbody></table></figure>

<p><u>这个框架要结合上面的那个前序遍历与后序遍历来理解！非常重要！！！</u></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 主函数，输入一组不重复的数字，返回它们的全排列 */</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) {</span><br><span class="line">    <span class="comment">// 记录「路径」</span></span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backtrack(nums, track);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径：记录在 track 中</span></span><br><span class="line"><span class="comment">// 选择列表：nums 中不存在于 track 的那些元素</span></span><br><span class="line"><span class="comment">// 结束条件：nums 中的元素全都在 track 中出现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track)</span> </span>{</span><br><span class="line">    <span class="comment">// 触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (track.size() == nums.length) {</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">        <span class="comment">// 排除不合法的选择</span></span><br><span class="line">        <span class="keyword">if</span> (track.contains(nums[i]))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.add(nums[i]);</span><br><span class="line">        <span class="comment">// 进入下一层决策树</span></span><br><span class="line">        backtrack(nums, track);</span><br><span class="line">        <span class="comment">// 取消选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里稍微做了些变通，没有显式记录「选择列表」，而是通过 <code>nums</code> 和 <code>track</code> 推导出当前的选择列表：</p>
<p><img src="/" class="lazyload" data-src="https://github.com/labuladong/fucking-algorithm/raw/master/pictures/backtracking/6.jpg"  alt="选择图"></p>
<p>但是必须说明的是，不管怎么优化，都符合回溯框架，而且时间复杂度都不可能低于 O(N!)，因为穷举整棵决策树是无法避免的。<strong>这也是回溯算法的一个特点，不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高</strong>。</p>
<hr>
<h2 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h2><h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h1><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - 锁相关：ReadWriteLock接口分析</title>
    <url>/2020/04/09/java-bing-fa-suo-xiang-guan-readwritelock-jie-kou-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>AQS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - 锁相关：Lock接口分析</title>
    <url>/2020/04/09/java-bing-fa-suo-xiang-guan-lock-jie-kou-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>AQS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - Volatile 分析</title>
    <url>/2020/04/09/java-bing-fa-volatile-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - 锁相关：锁的几种基本分类</title>
    <url>/2020/04/09/java-bing-fa-suo-xiang-guan-suo-de-ji-chong-ji-ben-fen-lei/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-可重入锁与非可重入锁"><a href="#1-可重入锁与非可重入锁" class="headerlink" title="1.可重入锁与非可重入锁"></a>1.可重入锁与非可重入锁</h1><h1 id="2-公平锁与非公平锁"><a href="#2-公平锁与非公平锁" class="headerlink" title="2.公平锁与非公平锁"></a>2.公平锁与非公平锁</h1><h1 id="3-读写锁与排他锁"><a href="#3-读写锁与排他锁" class="headerlink" title="3.读写锁与排他锁"></a>3.读写锁与排他锁</h1><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>AQS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - 锁相关：ReentrantLock 分析</title>
    <url>/2020/04/09/java-bing-fa-suo-xiang-guan-reentrantlock-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fair version of tryAcquire.  Don't grant access unless</span></span><br><span class="line"><span class="comment"> * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 尝试直接获取锁，返回值是boolean，代表是否获取到锁</span></span><br><span class="line"><span class="comment">// 返回true：1.没有线程在等待锁；2.重入锁，线程本来就持有锁，也就可以理所当然可以直接获取</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// state == 0 此时此刻没有线程持有锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 虽然此时此刻锁是可以用的，但是这是公平锁，既然是公平，就得讲究先来后到，</span></span><br><span class="line">        <span class="comment">// 看看有没有别人在队列中等了半天了</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            <span class="comment">// 如果没有线程在等待，那就用CAS尝试一下，成功了就获取到锁了，</span></span><br><span class="line">            <span class="comment">// 不成功的话，只能说明一个问题，就在刚刚几乎同一时刻有个线程抢先了 =_=</span></span><br><span class="line">            <span class="comment">// 因为刚刚还没人的，我判断过了</span></span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) {</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 到这里就是获取到锁了，标记一下，告诉大家，现在是我占用了锁</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 会进入这个else if分支，说明是重入了，需要操作：state=state+1</span></span><br><span class="line">    <span class="comment">// 这里不存在并发问题</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) {</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果到这里，说明前面的if和else if都没有返回true，说明没有获取到锁</span></span><br><span class="line">    <span class="comment">// 回到上面一个外层调用方法继续看:</span></span><br><span class="line">    <span class="comment">// if (!tryAcquire(arg) </span></span><br><span class="line">    <span class="comment">//        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) </span></span><br><span class="line">    <span class="comment">//     selfInterrupt();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>AQS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - 上下文切换的理解</title>
    <url>/2020/04/09/java-bing-fa-shang-xia-wen-qie-huan-de-li-jie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-什么是多线程的上下文切换？"><a href="#1-什么是多线程的上下文切换？" class="headerlink" title="1.什么是多线程的上下文切换？"></a>1.什么是多线程的上下文切换？</h1><p>多线程会共同使用一组计算机上的 CPU ，而线程数大于给程序分配的 CPU 数量时，为了让各个线程都有执行的机会，就需要轮转使用 CPU 。</p>
<p>不同的线程切换使用 CPU 发生的切换数据等，就是上下文切换。</p>
<ul>
<li>在上下文切换过程中，CPU 会停止处理当前运行的程序，并保存当前程序运行的具体位置以便之后继续运行。从这个角度来看，上下文切换有点像我们同时阅读几本书，在来回切换书本的同时我们需要记住每本书当前读到的页码。在程序中，上下文切换过程中的“页码”信息是保存在进程控制块（PCB）中的。PCB还经常被称作“切换桢”（switchframe）。“页码”信息会一直保存到CPU的内存中，直到他们被再次使用。</li>
<li>上下文切换是存储和恢复 CPU 状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。</li>
</ul>
<p><strong>以下取自：Java并发编程的艺术：</strong></p>
<ul>
<li>即使是单核处理器也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停地切换线程执行，让我们感觉多个线程是同时执行的，时间片一般是几十毫秒（ms）。</li>
<li>CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。</li>
<li>这就像我们同时读两本书，当我们在读一本英文的技术书时，发现某个单词不认识，于是便打开中英文字典，但是在放下英文技术书之前，大脑必须先记住这本书读到了多少页的第多少行，等查完单词之后，能够继续读这本书。这样的切换是会影响读书效率的，同样上下文切换也会影响多线程的执行速度。</li>
</ul>
<hr>
<h1 id="2-如何减少上下文切换？"><a href="#2-如何减少上下文切换？" class="headerlink" title="2.如何减少上下文切换？"></a>2.如何减少上下文切换？</h1><p>减少上下文切换的方法有<strong>无锁并发编程、CAS算法、使用最少线程和使用协程。</strong></p>
<ol>
<li>无锁并发编程：多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。</li>
<li>CAS算法：Java的Atomic包使用CAS算法来更新数据，而不需要加锁。</li>
<li>使用最少线程：避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。</li>
<li>协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换</li>
</ol>
<hr>
<h1 id="3-上下文切换相关问题"><a href="#3-上下文切换相关问题" class="headerlink" title="3.上下文切换相关问题"></a>3.上下文切换相关问题</h1><h2 id="3-1-多线程一定快吗？"><a href="#3-1-多线程一定快吗？" class="headerlink" title="3.1 多线程一定快吗？"></a>3.1 多线程一定快吗？</h2><p>答案是“不一定”</p>
<p>当并发执行累加操作不超过百万次时，速度会比串行执行累加操作要慢。那么，为什么并发执行的速度会比串行慢呢？这是因为线程有创建和上下文切换的开销。</p>
<hr>
<p>以上引用的博客和文章：</p>
<ol>
<li>书籍：并发编程的艺术</li>
<li>书籍：深入浅出Java多线程</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - 线程池的使用</title>
    <url>/2020/04/08/java-bing-fa-xian-cheng-chi-de-shi-yong/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-如何配置线程池"><a href="#1-如何配置线程池" class="headerlink" title="1 如何配置线程池"></a>1 如何配置线程池</h1><p>如果我们设置的线程池数量太小的话，如果同一时间有大量任务/请求需要处理，可能会导致大量的请求/任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务/请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。这样很明显是有问题的！ CPU 根本没有得到充分利用。</p>
<p>但是，如果我们设置线程数量太大，大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。</p>
<p>注：上下文切换的解释</p>
<ul>
<li>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。</li>
<li><strong>上下文切换通常是计算密集型的</strong>。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</li>
<li>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</li>
</ul>
<p>需要肯定的一点是：线程池肯定是不是越大越好。</p>
<p>通常我们是需要根据这批任务执行的性质来确定的。</p>
<ul>
<li><strong>CPU 密集型任务(N+1)</strong>： 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了<strong>防止线程偶发的缺页中断</strong>，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li>
<li><strong>I/O 密集型任务(2N)</strong>： 由于IO密集型任务的线程并不是一直在执行任务，则应配置尽可能多的线程，如CPU核数 * 2。</li>
</ul>
<p>这里还有一种参考的IO 密集型的线程池大小设置方式：IO密集型，即任务需要大量的IO，即大量的阻塞。在单线程上运行IO密集型的任务会导致浪费大量的CPU运算能力浪费在等待。所以在IO密集型任务中使用多线程可以大大的加速程序运行。故需要·多配置线程数：参考公式：</p>
<ul>
<li><code>CPU核数/（1-阻塞系数 ）</code> 阻塞系数在（0.8-0.9）之间</li>
<li>比如8核CPU：<code>8/（1-0.9） = 80</code>个线程数</li>
</ul>
<p>举个简单的实例如下：</p>
<p><strong>假如一分钟内要写 1 万个 1M 的文件到磁盘，core 和 maximum 怎么设？</strong></p>
<ul>
<li>这个是IO密集型的任务，如果是四核，core 和 maximum 就设置为8个；</li>
</ul>
<p><strong>要对一个数 0 加到一亿，要怎么设 core 和 maxim？</strong></p>
<ul>
<li>加法操作，CPU利用率高，这是CPU密集型的任务，如果是四核，则core 和 maximum 就设置为5个；</li>
<li>如果按照阻塞系数的方程来解决的话：四核CPU，则：4 / (1 - 0.9) = 40，则core 和 maximum 需要设置为40；</li>
</ul>
<hr>
<h1 id="2-如何优雅的关闭线程池"><a href="#2-如何优雅的关闭线程池" class="headerlink" title="2 如何优雅的关闭线程池"></a>2 如何优雅的关闭线程池</h1><p>如果线程池需要执行的任务完成了之后，我们也应该着手一下进行关闭线程池，那么有一些什么办法呢？无非就两种方法：<code>shutdown()/shutdownNow()</code></p>
<p>那么这两者的区别是什么呢？</p>
<ul>
<li><code>shutdown()</code> ：执行后停止接受新任务，会把队列的任务执行完毕。</li>
<li><code>shutdownNow()</code> ：也是停止接受新任务，但会中断所有的任务，将线程池状态变为 stop。</li>
</ul>
<p>两个方法都会中断线程，用户可自行判断是否需要响应中断。</p>
<p><code>shutdownNow()</code> 要更简单粗暴，可以根据实际场景选择不同的方法。</p>
<p>这里借鉴一个方法，可以采取以下的方法关闭线程池：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++) {</span><br><span class="line">    pool.execute(<span class="keyword">new</span> Job());</span><br><span class="line">}</span><br><span class="line">pool.shutdown();</span><br><span class="line"><span class="keyword">while</span> (!pool.awaitTermination(<span class="number">1</span>, TimeUnit.SECONDS)) {</span><br><span class="line">    LOGGER.info(<span class="string">"线程还在执行。。。"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">LOGGER.info(<span class="string">"一共处理了【{}】"</span>, (end - start));</span><br></pre></td></tr></tbody></table></figure>

<p><code>pool.awaitTermination(1, TimeUnit.SECONDS)</code> 会每隔一秒钟检查一次是否执行完毕（状态为 <code>TERMINATED</code>），当从 while 循环退出时就表明线程池已经完全终止了。</p>
<hr>
<h1 id="3-线程池使用的两个Demo"><a href="#3-线程池使用的两个Demo" class="headerlink" title="3 线程池使用的两个Demo"></a>3 线程池使用的两个Demo</h1><p>为了更好的理解线程池的参数的设置与如何使用，这里有两个Demo：</p>
<h2 id="3-1-Runnable-ThreadPoolExecutor"><a href="#3-1-Runnable-ThreadPoolExecutor" class="headerlink" title="3.1 Runnable+ThreadPoolExecutor"></a>3.1 Runnable+ThreadPoolExecutor</h2><p>首先创建一个 Runnable 接口的实现类</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。 </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@author</span> shuang.kou </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String command;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRunnable</span><span class="params">(String s)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.command = s;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" Start. Time = "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        processCommand();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" End. Time = "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processCommand</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写toString方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.command;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>编写测试程序，我们这里以阿里巴巴推荐的使用 ThreadPoolExecutor 构造函数自定义参数的方式来创建线程池。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">5</span>;    <span class="comment">// 核心线程为5</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">10</span>;    <span class="comment">// 最大线程数为10</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUEUE_CAPACITY = <span class="number">100</span>;    <span class="comment">// 队列数为100</span></span><br><span class="line">    <span class="comment">// 只有当线程池中的线程数大于corePoolSize时，这个参数才会起作用。</span></span><br><span class="line">    <span class="comment">// 当线程数大于corePoolSize时，终止前多余的空闲线程等待新任务的最长时间,等待时间为 1L。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long KEEP_ALIVE_TIME = <span class="number">1L</span>;    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class="line">        <span class="comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                CORE_POOL_SIZE,</span><br><span class="line">                MAX_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,    </span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY),    <span class="comment">// 任务队列为 ArrayBlockingQueue，并且容量为 100;</span></span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());    <span class="comment">// 饱和策略为 CallerRunsPolicy</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">            <span class="comment">//创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span></span><br><span class="line">            Runnable worker = <span class="keyword">new</span> MyRunnable(<span class="string">""</span> + i);</span><br><span class="line">            <span class="comment">//执行Runnable</span></span><br><span class="line">            executor.execute(worker);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//终止线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executor.isTerminated()) {</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"Finished all threads"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="3-2-Callable-ThreadPoolExecutor"><a href="#3-2-Callable-ThreadPoolExecutor" class="headerlink" title="3.2 Callable+ThreadPoolExecutor"></a>3.2 Callable+ThreadPoolExecutor</h2><p>首先创建一个 Callable 接口的实现类</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//返回执行当前 Callable 的线程名字</span></span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>编写测试程序，我们这里以阿里巴巴推荐的使用 ThreadPoolExecutor 构造函数自定义参数的方式来创建线程池。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUEUE_CAPACITY = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long KEEP_ALIVE_TIME = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class="line">        <span class="comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                CORE_POOL_SIZE,</span><br><span class="line">                MAX_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 申请一个List，用来装返回的数据</span></span><br><span class="line">        List&lt;Future&lt;String&gt;&gt; futureList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 开始进行实例的创建</span></span><br><span class="line">        Callable&lt;String&gt; callable = <span class="keyword">new</span> MyCallable();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">            <span class="comment">//提交任务到线程池</span></span><br><span class="line">            Future&lt;String&gt; future = executor.submit(callable);</span><br><span class="line">            <span class="comment">//将返回值 future 添加到 list，我们可以通过 future 获得 执行 Callable 得到的返回值</span></span><br><span class="line">            futureList.add(future);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 进行返回数据的遍历输出</span></span><br><span class="line">        <span class="keyword">for</span> (Future&lt;String&gt; fut : futureList) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 使用fut.get()得到数据</span></span><br><span class="line">                System.out.println(<span class="keyword">new</span> Date() + <span class="string">"::"</span> + fut.get());</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException | ExecutionException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode - 算法思想 - 海量数据</title>
    <url>/2020/04/08/leetcode-suan-fa-si-xiang-hai-liang-shu-ju/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-开篇"><a href="#1-开篇" class="headerlink" title="1.开篇"></a>1.开篇</h1><ol>
<li>一个100g的大文件，如何进行排序。内存只有4g（哈啰）</li>
<li>一道大数据量的题目，A文件有3T，里面放的是uid+uname，B文件2T，里面放的是uid+unage，找出相同的uid并写成uid+uname+uage的样子，限制内存2G。</li>
<li>16G的文件储存的是一个数组，要求只用1G内存把他们排好序。（腾讯）</li>
<li>1亿个手机号码，判断重复（阿里）</li>
<li>4G内存，2T硬盘，有1T数据。这1T数据是一行一个字符串，字符串里面有字母数字符号；求出现频率最高的10个字符串。（阿里）</li>
<li>现在有一个40万条的合法URL集合，你设计一个过滤器，过滤掉非法的URL访问……如果大量访问并发，你怎么处理？</li>
<li>10G 数据，1G 内存，如何快速找到重复出现的数据？（字节跳动）</li>
<li>10G 数据，1G 内存，如何快速找到重复出现次数最多的数据？（字节跳动）</li>
<li>10亿个数，如何快速筛选出Top100个大数？（菜鸟网络）</li>
<li>TOP K问题 1亿个数据找1000个最大值的时间复杂度（腾讯）</li>
<li>大量电话号码，寻找指定的电话用什么数据结构，复杂度（美团）</li>
</ol>
<h1 id="2-拉开序幕"><a href="#2-拉开序幕" class="headerlink" title="2.拉开序幕"></a>2.拉开序幕</h1><h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h1><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode - 算法思想 - 递推</title>
    <url>/2020/04/08/leetcode-suan-fa-si-xiang-di-tui/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-开篇"><a href="#1-开篇" class="headerlink" title="1.开篇"></a>1.开篇</h1><ol>
<li>走台阶</li>
<li>断钢筋</li>
</ol>
<h1 id="2-拉开序幕"><a href="#2-拉开序幕" class="headerlink" title="2.拉开序幕"></a>2.拉开序幕</h1><h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h1><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode - 算法思想 - 查找</title>
    <url>/2020/04/08/leetcode-suan-fa-si-xiang-cha-zhao/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-开篇"><a href="#1-开篇" class="headerlink" title="1.开篇"></a>1.开篇</h1><ol>
<li>数组中重复的数字（LC 3）</li>
<li>二维数组的查找（LC 4）</li>
<li>词频统计</li>
<li>统计次数</li>
<li>一个数组，数字可能会有重复，找出所有两数相加为k的组合（猫眼）</li>
<li>在一个旋转数组中查找一个数，要求时间复杂度为O(log(N))（字节跳动）</li>
<li>有两个整数数组，计算两个数组的交集。（阿里）</li>
<li>求第一个间断数</li>
<li>求数组的最长连续递增数列 （LC 128）</li>
</ol>
<h1 id="2-拉开序幕"><a href="#2-拉开序幕" class="headerlink" title="2.拉开序幕"></a>2.拉开序幕</h1><h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h1><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode - 数据结构 - 栈和队列</title>
    <url>/2020/04/07/leetcode-shu-ju-jie-gou-zhan-he-dui-lie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-开篇"><a href="#1-开篇" class="headerlink" title="1.开篇"></a>1.开篇</h1><ol>
<li>用栈实现队列</li>
<li>用队列实现栈</li>
<li>最小值栈</li>
<li>用栈实现括号匹配</li>
<li>数组中元素与下一个比它大的元素之间的距离</li>
<li>循环数组中比当前元素大的下一个元素</li>
<li>实现一个队列，大小定长（字节跳动）</li>
<li>实现一个阻塞队列，考虑到多线程并发的情况，要求有<code>put,get,isEmpty, isFull</code>方法。（字节跳动）</li>
<li>优先级队列怎么实现（头条）</li>
</ol>
<h1 id="2-拉开序幕"><a href="#2-拉开序幕" class="headerlink" title="2.拉开序幕"></a>2.拉开序幕</h1><h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h1><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode - 数据结构 - 字符串</title>
    <url>/2020/04/07/leetcode-shu-ju-jie-gou-zi-fu-chuan/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol>
<li>字符串循环移位包含</li>
<li>字符串循环移位</li>
<li>字符串中单词的翻转</li>
<li>两个字符串包含的字符是否完全相同</li>
<li>计算一组字符集合可以组成的回文字符串的最大长度</li>
<li>字符串同构</li>
<li>回文子字符串个数</li>
<li>判断一个整数是否是回文数</li>
<li>统计二进制字符串中连续 1 和连续 0 数量相同的子字符串个数</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode - 数据结构 - 哈希表</title>
    <url>/2020/04/07/leetcode-shu-ju-jie-gou-ha-xi-biao/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol>
<li>数组中两个数的和为给定值</li>
<li>判断数组是否含有重复元素</li>
<li>最长和谐序列</li>
<li>最长连续序列</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode - 数据结构 - 数组和矩阵</title>
    <url>/2020/04/07/leetcode-shu-ju-jie-gou-shu-zu-he-ju-zhen/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode - 数据结构 - 图</title>
    <url>/2020/04/07/leetcode-shu-ju-jie-gou-tu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="2-1-二分图"><a href="#2-1-二分图" class="headerlink" title="2.1 二分图"></a>2.1 二分图</h3><ol>
<li>判断是否为二分图</li>
</ol>
<h3 id="2-2-拓扑排序"><a href="#2-2-拓扑排序" class="headerlink" title="2.2 拓扑排序"></a>2.2 拓扑排序</h3><ol>
<li>课程安排的合法性</li>
<li>课程安排的顺序</li>
</ol>
<h3 id="2-3-并查集"><a href="#2-3-并查集" class="headerlink" title="2.3 并查集"></a>2.3 并查集</h3><ol>
<li>冗余连接</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode - 数据结构 - 位运算</title>
    <url>/2020/04/07/leetcode-shu-ju-jie-gou-wei-yun-suan/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode - 数据结构 - 树</title>
    <url>/2020/04/07/leetcode-shu-ju-jie-gou-shu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-开篇"><a href="#1-开篇" class="headerlink" title="1.开篇"></a>1.开篇</h1><p><strong>递归</strong></p>
<ol>
<li>树的高度（LC 104）</li>
<li>平衡树（LC 110）</li>
<li>两节点的最长路径（LC 543）</li>
<li>翻转树（LC 226）</li>
<li>归并两棵树（LC 617）</li>
<li>判断路径和是否等于一个数（LC 112）</li>
<li>统计路径和等于一个数的路径数量（LC 437）</li>
<li>子树（LC 572）</li>
<li>树的对称（LC 101）</li>
<li>最小路径（LC 111）</li>
<li>统计左叶子节点的和（LC 404）</li>
<li>相同节点值的最大路径长度（LC 687 ）</li>
<li>间隔遍历（LC 337）</li>
<li>找出二叉树中第二小的节点（LC 671）</li>
<li>二叉树中和为某一值的路径（字节跳动）</li>
</ol>
<p><strong>层次遍历</strong></p>
<ol>
<li>一棵树每层节点的平均数（LC 637）</li>
<li>得到左下角的节点（LC 513）</li>
</ol>
<p><strong>前中后序遍历</strong></p>
<ol>
<li>递归实现的前中后序遍历</li>
<li>非递归实现二叉树的前序遍历（LC 144）</li>
<li>非递归实现二叉树的后序遍历（LC 145）</li>
<li>非递归实现二叉树的中序遍历（LC 94）</li>
</ol>
<p><strong>BST</strong></p>
<ol>
<li>修剪二叉查找树（LC 669）</li>
<li>寻找二叉查找树的第 k 个元素（LC 230）</li>
<li>把二叉查找树每个节点的值都加上比它大的节点的值（LC ）</li>
<li>二叉查找树的最近公共祖先（LC 235）</li>
<li>二叉树的最近公共祖先（LC 236）</li>
<li>二叉树的公共祖先（不用递归怎么做，写出找出路径的算法）（字节跳动）</li>
<li>从有序数组中构造二叉查找树（LC 108）</li>
<li>根据有序链表构造平衡的二叉查找树（LC 109）</li>
<li>在二叉查找树中寻找两个节点，使它们的和为一个给定值（LC 653）</li>
<li>在二叉查找树中查找两个节点之差的最小绝对值（LC 530）</li>
<li>寻找二叉查找树中出现次数最多的值（LC 501）</li>
</ol>
<p><strong>Trie</strong></p>
<ol>
<li>实现一个 Trie（LC 208）</li>
<li>实现一个 Trie，用来求前缀和（LC 677）</li>
</ol>
<h1 id="2-拉开序幕"><a href="#2-拉开序幕" class="headerlink" title="2.拉开序幕"></a>2.拉开序幕</h1><h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h1><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode - 数据结构 - 链表</title>
    <url>/2020/04/07/leetcode-shu-ju-jie-gou-lian-biao/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-开篇"><a href="#1-开篇" class="headerlink" title="1.开篇"></a>1.开篇</h1><ol>
<li>相交链表（LC 160）</li>
<li>链表反转（LC 206）</li>
<li>有序链表的合并（字节跳动）（LC 21）</li>
<li>从有序链表中删除重复节点（LC 83）</li>
<li>删除排序链表中的重复元素 II（LC 82）</li>
<li>删除链表的倒数第 n 个节点（LC 19）</li>
<li>交换链表中的相邻结点（LC 24）</li>
<li>链表求和（LC 445）</li>
<li>回文链表（LC 234）</li>
<li>分割链表（LC 725）</li>
<li>奇偶链表（LC 328）</li>
<li>单链表的回文判断要求O1空间（字节跳动实习）</li>
<li>单链表每k个翻转（字节跳动）/反转链表按k（字节跳动）（ LC 25）</li>
<li>链表判环（入环点、环的长度）（京东）</li>
<li>有序链表合并的升级版，合并n多和有序链表，并计算时间复杂度（字节跳动）</li>
</ol>
<hr>
<h1 id="2-拉开序幕"><a href="#2-拉开序幕" class="headerlink" title="2.拉开序幕"></a>2.拉开序幕</h1><h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><hr>
<h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h1><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode - 算法思想 - 数学</title>
    <url>/2020/04/07/leetcode-suan-fa-si-xiang-shu-xue/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-开篇"><a href="#1-开篇" class="headerlink" title="1.开篇"></a>1.开篇</h1><h3 id="素数分解及整除"><a href="#素数分解及整除" class="headerlink" title="素数分解及整除"></a>素数分解及整除</h3><ol>
<li>素数分解</li>
<li>整除</li>
</ol>
<h3 id="最大公约数最小公倍数"><a href="#最大公约数最小公倍数" class="headerlink" title="最大公约数最小公倍数"></a>最大公约数最小公倍数</h3><ol>
<li>生成素数序列</li>
<li>最大公约数</li>
<li>使用位操作和减法求解最大公约数</li>
</ol>
<h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><ol>
<li>7 进制</li>
<li>16 进制</li>
<li>26 进制</li>
</ol>
<h3 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h3><ol>
<li><p>统计阶乘尾部有多少个 0<br>字符串加法减法</p>
</li>
<li><p>二进制加法</p>
</li>
<li><p>字符串加法</p>
</li>
</ol>
<h3 id="相遇问题"><a href="#相遇问题" class="headerlink" title="相遇问题"></a>相遇问题</h3><ol>
<li>改变数组元素使所有的数组元素都相等<br>多数投票问题</li>
<li>数组中出现次数多于 n / 2 的元素</li>
</ol>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ol>
<li>平方数</li>
<li>3 的 n 次方</li>
<li>乘积数组</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode - 算法思想 - 动态规划</title>
    <url>/2020/04/07/leetcode-suan-fa-si-xiang-dong-tai-gui-hua/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-开篇"><a href="#1-开篇" class="headerlink" title="1.开篇"></a>1.开篇</h1><h1 id="2-拉开序幕"><a href="#2-拉开序幕" class="headerlink" title="2.拉开序幕"></a>2.拉开序幕</h1><h2 id="2-1-零钱兑换"><a href="#2-1-零钱兑换" class="headerlink" title="2.1 零钱兑换"></a>2.1 零钱兑换</h2><h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>LeetCode：<a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. 零钱兑换</a></p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tbody><tr><td class="code"><pre><span class="line">输入: coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], amount = <span class="number">11</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: <span class="number">11</span> = <span class="number">5</span> + <span class="number">5</span> + <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight angelscript"><table><tbody><tr><td class="code"><pre><span class="line">输入: coins = [<span class="number">2</span>], amount = <span class="number">3</span></span><br><span class="line">输出: <span class="number">-1</span></span><br></pre></td></tr></tbody></table></figure>



<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>使用以自底向上使用 dp table 来消除重叠子问题，<code>dp</code> 数组的定义：<strong><code>dp[i] = x</code> 表示，当目标金额为 <code>i</code> 时，至少需要 <code>x</code> 枚硬币</strong>。</p>
<p>其实替换到现实的话估计会好理解一些：面值分别为 1，2，5，总金额 <code>amount = 11</code>。那么最少需要 3 枚硬币凑出，即 11 = 5 + 5 + 1。</p>
<p>那么11要怎么凑出来呢，由下面一步一步往上凑，等到11的时候，就有条件支撑了。</p>
<p><img src="/" class="lazyload" data-src="https://github.com/labuladong/fucking-algorithm/raw/master/pictures/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6/6.jpg"  alt="图解dp结构"></p>
<p>代码中为啥 <code>dp</code> 数组初始化为 <code>amount + 1</code> 呢？</p>
<p>因为凑成 <code>amount</code> 金额的硬币数最多只可能等于 <code>amount</code>（全用 1 元面值的硬币），所以初始化为 <code>amount + 1</code> 就相当于初始化为正无穷，便于后续取最小值。</p>
<p>具体可以看以下这篇文章：<a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6.md" target="_blank" rel="noopener">动态规划详解</a></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>{</span><br><span class="line">		<span class="comment">// 定义一个dp数组</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 数组填充，将dp数组中的所有元素都登记为amout + 1</span></span><br><span class="line">        Arrays.fill(dp, amount + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 因为这些数组的下标代表着金钱，0就是不可以算了</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 自底向上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++){</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.length; j++){</span><br><span class="line">                <span class="comment">// 用i去减每个conis里面的成员，但凡其中有一个大于i，都不能继续下去</span></span><br><span class="line">                <span class="keyword">if</span> (i - coins[j] &gt;= <span class="number">0</span>)   </span><br><span class="line">                    <span class="comment">// 通过比较得出最小的那个组成</span></span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 看是否大于amount，是的话就无法分解（比如3、4、5和1），不是的话返回dp[amount]</span></span><br><span class="line">        <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>







<hr>
<h1 id="3-记录面经试题"><a href="#3-记录面经试题" class="headerlink" title="3.记录面经试题"></a>3.记录面经试题</h1><ol>
<li>最大子序和 （LC 53）</li>
<li>爬楼梯 （ LC 70）</li>
<li>打家劫舍 （ LC 198）</li>
<li>打家劫舍II（ LC 213）</li>
<li>买卖股票的最佳时机 （LC 121）</li>
<li>接雨水（字节跳动）（LC 42）</li>
<li>求数组的最长连续递增数列，（LC 128）</li>
<li>松鼠捡豆 </li>
<li>最长不重复子序列长度（字节跳动）</li>
<li>二维方格，从第一个到最后一个的多少路径 dp动态规划问题（字节跳动）</li>
</ol>
<h1 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h1><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode - 算法思想 - 搜索</title>
    <url>/2020/04/07/leetcode-suan-fa-si-xiang-sou-suo/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-开篇"><a href="#1-开篇" class="headerlink" title="1.开篇"></a>1.开篇</h1><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><ol>
<li>计算在网格中从原点到特定点的最短路径长度</li>
<li>组成整数的最小平方数数量</li>
<li>最短单词路径</li>
</ol>
<h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><ol>
<li>查找最大的连通面积</li>
<li>矩阵中的连通分量数目</li>
<li>好友关系的连通分量数目</li>
<li>填充封闭区域</li>
<li>能到达的太平洋和大西洋的区域</li>
</ol>
<h3 id="Backtracking"><a href="#Backtracking" class="headerlink" title="Backtracking"></a>Backtracking</h3><ol>
<li>数字键盘组合</li>
<li>IP 地址划分</li>
<li>在矩阵中寻找字符串</li>
<li>输出二叉树中所有从根到叶子的路径</li>
<li>排列</li>
<li>含有相同元素求排列</li>
<li>组合</li>
<li>组合求和</li>
<li>含有相同元素的组合求和</li>
<li>1-9 数字的组合求和</li>
<li>子集</li>
<li>含有相同元素求子集</li>
<li>分割字符串使得每个部分都是回文数</li>
<li>数独</li>
<li>N 皇后</li>
</ol>
<h1 id="2-拉开序幕"><a href="#2-拉开序幕" class="headerlink" title="2.拉开序幕"></a>2.拉开序幕</h1><h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h1><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode - 算法思想 - 贪心思想</title>
    <url>/2020/04/07/leetcode-suan-fa-si-xiang-tan-xin-si-xiang/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-开篇"><a href="#1-开篇" class="headerlink" title="1.开篇"></a>1.开篇</h1><ol>
<li>覆盖问题</li>
<li>时间问题</li>
</ol>
<h1 id="2-拉开序幕"><a href="#2-拉开序幕" class="headerlink" title="2.拉开序幕"></a>2.拉开序幕</h1><h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h1><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode - 算法思想 - 分治</title>
    <url>/2020/04/07/leetcode-suan-fa-si-xiang-fen-zhi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-开篇"><a href="#1-开篇" class="headerlink" title="1.开篇"></a>1.开篇</h1><h1 id="2-拉开序幕"><a href="#2-拉开序幕" class="headerlink" title="2.拉开序幕"></a>2.拉开序幕</h1><h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h1><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode - 算法思想 - 二分查找</title>
    <url>/2020/04/07/leetcode-suan-fa-si-xiang-er-fen-cha-zhao/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-开篇"><a href="#1-开篇" class="headerlink" title="1.开篇"></a>1.开篇</h1><ol>
<li>求开方</li>
<li>大于给定元素的最小元素</li>
<li>有序数组的 Single Element</li>
<li>第一个错误的版本</li>
<li>旋转数组的最小数字</li>
<li>查找区间</li>
<li>写一个二分查找（字节跳动）</li>
<li>有一个IP地址库，假设有几十万条ip，如何判断某个ip地址是否在这个库中？（字节跳动）</li>
</ol>
<h1 id="2-拉开序幕"><a href="#2-拉开序幕" class="headerlink" title="2.拉开序幕"></a>2.拉开序幕</h1><h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h1><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode - 算法思想 - 排序</title>
    <url>/2020/04/07/leetcode-suan-fa-si-xiang-pai-xu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-开篇"><a href="#1-开篇" class="headerlink" title="1.开篇"></a>1.开篇</h1><p><strong>未分类</strong></p>
<ol>
<li>将数组中数字组合成最小的数（字节跳动）</li>
<li>将数组中所有的零都放到数组末尾（字节跳动）</li>
<li>洗牌算法</li>
<li>一个数组，将大于0的数字排在数组前面，相对顺序不要求（字节跳动）</li>
<li>把数组排成最小的数（剑指offer）（猫眼）</li>
<li>不重复数组，列举出它的全排列（字节跳动）（面试官说：DFS递归）</li>
</ol>
<p><strong>快速排序</strong></p>
<ol>
<li>讲一下快排的思想， 在最好的情况下快排的时间复杂度是多少呢？ 快排是如何选择切分元素的？（阿里）</li>
<li>为什么快排比堆排快（字节跳动）</li>
<li>快排优化（百度）</li>
<li>快速排序的原理、时间复杂度、空间复杂度（腾讯）</li>
</ol>
<p><strong>归并排序</strong></p>
<ol>
<li>归并排序过程、时空复杂度（字节跳动）</li>
</ol>
<p><strong>堆排序</strong></p>
<ol>
<li>场景算法：最快5匹马，就是最小堆（字节跳动）</li>
<li>如何实现一个堆</li>
<li>Kth Element</li>
</ol>
<p><strong>桶排序</strong></p>
<ol>
<li>出现频率最多的 k 个元素</li>
<li>按照字符出现次数对字符串排序</li>
<li>有一个无序整型数组，如何求出该数组排序后的任意两个相邻元素的最大差值？（桶排序，尽量分散，桶的数量为 （最大 - 最小）/ 元素个数）（京东）</li>
</ol>
<p><strong>荷兰国旗问题</strong></p>
<ol>
<li>按颜色进行排序</li>
</ol>
<hr>
<h1 id="2-拉开序幕"><a href="#2-拉开序幕" class="headerlink" title="2.拉开序幕"></a>2.拉开序幕</h1><h2 id="2-1-未分类"><a href="#2-1-未分类" class="headerlink" title="2.1 未分类"></a>2.1 未分类</h2><h3 id="2-1-1-将数组中数字组合成最小的数（字节跳动）"><a href="#2-1-1-将数组中数字组合成最小的数（字节跳动）" class="headerlink" title="2.1.1 将数组中数字组合成最小的数（字节跳动）"></a>2.1.1 将数组中数字组合成最小的数（字节跳动）</h3><ol start="2">
<li>将数组中所有的零都放到数组末尾（字节跳动）</li>
<li>洗牌算法</li>
<li>一个数组，将大于0的数字排在数组前面，相对顺序不要求（字节跳动）</li>
<li>把数组排成最小的数（剑指offer）（猫眼）</li>
<li>不重复数组，列举出它的全排列（字节跳动）（面试官说：DFS递归）</li>
</ol>
<h2 id="2-2-快速排序"><a href="#2-2-快速排序" class="headerlink" title="2.2 快速排序"></a>2.2 快速排序</h2><ol>
<li>讲一下快排的思想， 在最好的情况下快排的时间复杂度是多少呢？ 快排是如何选择切分元素的？（阿里）</li>
<li>为什么快排比堆排快（字节跳动）</li>
<li>快排优化（百度）</li>
<li>快速排序的原理、时间复杂度、空间复杂度（腾讯）</li>
</ol>
<h2 id="2-3-归并排序"><a href="#2-3-归并排序" class="headerlink" title="2.3 归并排序"></a>2.3 归并排序</h2><ol>
<li>归并排序过程、时空复杂度（字节跳动）</li>
</ol>
<h2 id="2-4-堆排序"><a href="#2-4-堆排序" class="headerlink" title="2.4 堆排序"></a>2.4 堆排序</h2><ol>
<li>场景算法：最快5匹马，就是最小堆（字节跳动）</li>
<li>如何实现一个堆</li>
<li>Kth Element</li>
</ol>
<h2 id="2-5-桶排序"><a href="#2-5-桶排序" class="headerlink" title="2.5 桶排序"></a>2.5 桶排序</h2><ol>
<li>出现频率最多的 k 个元素</li>
<li>按照字符出现次数对字符串排序</li>
<li>有一个无序整型数组，如何求出该数组排序后的任意两个相邻元素的最大差值？（桶排序，尽量分散，桶的数量为 （最大 - 最小）/ 元素个数）（京东）</li>
</ol>
<h2 id="2-6-荷兰国旗问题"><a href="#2-6-荷兰国旗问题" class="headerlink" title="2.6 荷兰国旗问题"></a>2.6 荷兰国旗问题</h2><ol>
<li>按颜色进行排序</li>
</ol>
<h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h1><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode - 算法思想 - 双指针</title>
    <url>/2020/04/07/leetcode-suan-fa-si-xiang-shuang-zhi-zhen/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-开篇"><a href="#1-开篇" class="headerlink" title="1.开篇"></a>1.开篇</h1><ol>
<li>有序数组的 Two Sum</li>
<li>两数平方和</li>
<li>反转字符串中的元音字符</li>
<li>回文字符串</li>
<li>归并两个有序数组</li>
<li>判断链表是否存在环</li>
<li>最长子序列</li>
</ol>
<hr>
<h1 id="2-拉开序幕"><a href="#2-拉开序幕" class="headerlink" title="2.拉开序幕"></a>2.拉开序幕</h1><h2 id="2-1-有序数组的-Two-Sum"><a href="#2-1-有序数组的-Two-Sum" class="headerlink" title="2.1 有序数组的 Two Sum"></a>2.1 有序数组的 Two Sum</h2><h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">167. 两数之和 II - 输入有序数组</a></p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><hr>
<h2 id="2-2-两数平方和"><a href="#2-2-两数平方和" class="headerlink" title="2.2 两数平方和"></a>2.2 两数平方和</h2><h3 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://leetcode-cn.com/problems/sum-of-square-numbers/" target="_blank" rel="noopener">633. 平方数之和</a></p>
<h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><hr>
<h2 id="2-3-反转字符串中的元音字符"><a href="#2-3-反转字符串中的元音字符" class="headerlink" title="2.3 反转字符串中的元音字符"></a>2.3 反转字符串中的元音字符</h2><h3 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/" target="_blank" rel="noopener">345. 反转字符串中的元音字母</a></p>
<h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><hr>
<h2 id="2-4-回文字符串"><a href="#2-4-回文字符串" class="headerlink" title="2.4 回文字符串"></a>2.4 回文字符串</h2><h3 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://leetcode-cn.com/problems/valid-palindrome-ii/" target="_blank" rel="noopener">680. 验证回文字符串 Ⅱ</a></p>
<h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><hr>
<h2 id="2-5-归并两个有序数组"><a href="#2-5-归并两个有序数组" class="headerlink" title="2.5 归并两个有序数组"></a>2.5 归并两个有序数组</h2><h3 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">88. 合并两个有序数组</a></p>
<h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><hr>
<h2 id="2-6-判断链表是否存在环"><a href="#2-6-判断链表是否存在环" class="headerlink" title="2.6 判断链表是否存在环"></a>2.6 判断链表是否存在环</h2><h3 id="题目链接-5"><a href="#题目链接-5" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">141. 环形链表</a></p>
<h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><hr>
<h2 id="2-7-最长子序列"><a href="#2-7-最长子序列" class="headerlink" title="2.7 最长子序列"></a>2.7 最长子序列</h2><h3 id="题目链接-6"><a href="#题目链接-6" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/" target="_blank" rel="noopener">524. 通过删除字母匹配到字典里最长单词</a></p>
<h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><hr>
<h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h1><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis 框架分析（2） - 基于注解方式的简单Demo</title>
    <url>/2020/04/06/mybatis-kuang-jia-fen-xi-2-ji-yu-zhu-jie-fang-shi-de-jian-dan-demo/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 65 - 矩阵中的路径</title>
    <url>/2020/04/02/jian-zhi-offer-65-ju-zhen-zhong-de-lu-jing/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 64 - 滑动窗口的最大值</title>
    <url>/2020/04/02/jian-zhi-offer-64-hua-dong-chuang-kou-de-zui-da-zhi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 63 - 数据流中的中位数</title>
    <url>/2020/04/02/jian-zhi-offer-63-shu-ju-liu-zhong-de-zhong-wei-shu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 66 - 机器人的运动范围</title>
    <url>/2020/04/02/jian-zhi-offer-66-ji-qi-ren-de-yun-dong-fan-wei/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 61 - 序列化二叉树</title>
    <url>/2020/04/02/jian-zhi-offer-61-xu-lie-hua-er-cha-shu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 60 - 把二叉树打印成多行</title>
    <url>/2020/04/02/jian-zhi-offer-60-ba-er-cha-shu-da-yin-cheng-duo-xing/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 59 - 按之字形顺序打印二叉树</title>
    <url>/2020/04/02/jian-zhi-offer-59-an-zhi-zi-xing-shun-xu-da-yin-er-cha-shu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 58 - 对称的二叉树</title>
    <url>/2020/04/02/jian-zhi-offer-58-dui-cheng-de-er-cha-shu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 57 - 二叉树的下一个结点</title>
    <url>/2020/04/02/jian-zhi-offer-57-er-cha-shu-de-xia-yi-ge-jie-dian/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 62 - 二叉搜索树的第k个结点</title>
    <url>/2020/04/02/jian-zhi-offer-62-er-cha-sou-suo-shu-de-di-k-ge-jie-dian/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 55 - 链表中环的入口结点</title>
    <url>/2020/04/02/jian-zhi-offer-55-lian-biao-zhong-huan-de-ru-kou-jie-dian/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 54 - 字符流中第一个不重复的字符</title>
    <url>/2020/04/02/jian-zhi-offer-54-zi-fu-liu-zhong-di-yi-ge-bu-chong-fu-de-zi-fu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 53 - 表示数值的字符串</title>
    <url>/2020/04/02/jian-zhi-offer-53-biao-shi-shu-zhi-de-zi-fu-chuan/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 52 - 正则表达式匹配</title>
    <url>/2020/04/02/jian-zhi-offer-52-zheng-ze-biao-da-shi-pi-pei/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 51 - 构建乘积数组</title>
    <url>/2020/04/02/jian-zhi-offer-51-gou-jian-cheng-ji-shu-zu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 50 - 数组中重复的数字 - 副本</title>
    <url>/2020/04/02/jian-zhi-offer-50-shu-zu-zhong-chong-fu-de-shu-zi-fu-ben/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 49 - 把字符串转换成整数</title>
    <url>/2020/04/02/jian-zhi-offer-49-ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 48 - 不用加减乘除做加法</title>
    <url>/2020/04/02/jian-zhi-offer-48-bu-yong-jia-jian-cheng-chu-zuo-jia-fa/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 47 - 求1+2+3+...+n</title>
    <url>/2020/04/02/jian-zhi-offer-47-qiu-1-2-3...n/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 46 - 孩子们的游戏(圆圈中最后剩下的数)(约瑟夫环)</title>
    <url>/2020/04/02/jian-zhi-offer-46-hai-zi-men-de-you-xi-yuan-quan-zhong-zui-hou-sheng-xia-de-shu-yue-se-fu-huan/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 45 - 扑克牌顺子</title>
    <url>/2020/04/02/jian-zhi-offer-45-bu-ke-pai-shun-zi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 44 - 翻转单词顺序列</title>
    <url>/2020/04/02/jian-zhi-offer-44-fan-zhuan-dan-ci-shun-xu-lie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 41 - 和为S的连续正数序列</title>
    <url>/2020/04/02/jian-zhi-offer-41-he-wei-s-de-lian-xu-zheng-shu-xu-lie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 40 - 数组中只出现一次的数字</title>
    <url>/2020/04/02/jian-zhi-offer-40-shu-zu-zhong-zhi-chu-xian-yi-ci-de-shu-zi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 39 - 平衡二叉树</title>
    <url>/2020/04/02/jian-zhi-offer-39-ping-heng-er-cha-shu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 38 - 二叉树的深度</title>
    <url>/2020/04/02/jian-zhi-offer-38-er-cha-shu-de-shen-du/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 37 - 数字在排序数组中出现的次数</title>
    <url>/2020/04/02/jian-zhi-offer-37-shu-zi-zai-pai-xu-shu-zu-zhong-chu-xian-de-ci-shu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 36 - 两个链表的第一个公共结点</title>
    <url>/2020/04/02/jian-zhi-offer-36-liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 35 - 数组中的逆序对</title>
    <url>/2020/04/02/jian-zhi-offer-35-shu-zu-zhong-de-ni-xu-dui/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 32 - 把数组排成最小的数</title>
    <url>/2020/04/02/jian-zhi-offer-32-ba-shu-zu-pai-cheng-zui-xiao-de-shu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 42 - 和为S的两个数字(排序数组)</title>
    <url>/2020/04/02/jian-zhi-offer-42-he-wei-s-de-liang-ge-shu-zi-pai-xu-shu-zu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 31 - 整数中1出现的次数（从1到n整数中1出现的次数）</title>
    <url>/2020/04/02/jian-zhi-offer-31-zheng-shu-zhong-1-chu-xian-de-ci-shu-cong-1-dao-n-zheng-shu-zhong-1-chu-xian-de-ci-shu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 30 - 连续子数组的最大和</title>
    <url>/2020/04/02/jian-zhi-offer-30-lian-xu-zi-shu-zu-de-zui-da-he/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 29 - 最小的K个数</title>
    <url>/2020/04/02/jian-zhi-offer-29-zui-xiao-de-k-ge-shu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 28 - 数组中出现次数超过一半的数字</title>
    <url>/2020/04/02/jian-zhi-offer-28-shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 27 - 字符串的排列</title>
    <url>/2020/04/02/jian-zhi-offer-27-zi-fu-chuan-de-pai-lie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 26 - 二叉搜索树与双向链表</title>
    <url>/2020/04/02/jian-zhi-offer-26-er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 25 - 复杂链表的复制</title>
    <url>/2020/04/02/jian-zhi-offer-25-fu-za-lian-biao-de-fu-zhi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 22 - 从上往下打印二叉树</title>
    <url>/2020/04/02/jian-zhi-offer-22-cong-shang-wang-xia-da-yin-er-cha-shu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 33 - 丑数</title>
    <url>/2020/04/02/jian-zhi-offer-33-chou-shu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 21 - 栈的压入、弹出序列</title>
    <url>/2020/04/02/jian-zhi-offer-21-zhan-de-ya-ru-dan-chu-xu-lie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 20 - 包含min函数的栈</title>
    <url>/2020/04/02/jian-zhi-offer-20-bao-han-min-han-shu-de-zhan/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 19 - 顺时针打印矩阵</title>
    <url>/2020/04/02/jian-zhi-offer-19-shun-shi-zhen-da-yin-ju-zhen/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 18 - 二叉树的镜像</title>
    <url>/2020/04/02/jian-zhi-offer-18-er-cha-shu-de-jing-xiang/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 17 - 树的子结构</title>
    <url>/2020/04/02/jian-zhi-offer-17-shu-de-zi-jie-gou/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 16 - 合并两个排序的链表</title>
    <url>/2020/04/02/jian-zhi-offer-16-he-bing-liang-ge-pai-xu-de-lian-biao/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 15 - 反转链表</title>
    <url>/2020/04/02/jian-zhi-offer-15-fan-zhuan-lian-biao/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 14 - 链表中倒数第k个结点</title>
    <url>/2020/04/02/jian-zhi-offer-14-lian-biao-zhong-dao-shu-di-k-ge-jie-dian/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 12 - 数值的整数次方</title>
    <url>/2020/04/02/jian-zhi-offer-12-shu-zhi-de-zheng-shu-ci-fang/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 11 - 二进制中1的个数</title>
    <url>/2020/04/02/jian-zhi-offer-11-er-jin-zhi-zhong-1-de-ge-shu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 10 - 矩形覆盖</title>
    <url>/2020/04/02/jian-zhi-offer-10-ju-xing-fu-gai/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 09 - 变态跳台阶</title>
    <url>/2020/04/02/jian-zhi-offer-09-bian-tai-tiao-tai-jie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 08 - 跳台阶</title>
    <url>/2020/04/02/jian-zhi-offer-08-tiao-tai-jie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 07 - 斐波那契数列</title>
    <url>/2020/04/02/jian-zhi-offer-07-fei-bo-na-qi-shu-lie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 06 - 旋转数组的最小数字</title>
    <url>/2020/04/02/jian-zhi-offer-06-xuan-zhuan-shu-zu-de-zui-xiao-shu-zi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 05 - 用两个栈实现一个队列</title>
    <url>/2020/04/02/jian-zhi-offer-05-yong-liang-ge-zhan-shi-xian-yi-ge-dui-lie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 04 - 重建二叉树</title>
    <url>/2020/04/02/jian-zhi-offer-04-chong-jian-er-cha-shu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 03 - 从尾到头打印链表</title>
    <url>/2020/04/02/jian-zhi-offer-03-cong-wei-dao-tou-da-yin-lian-biao/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-题目链接"><a href="#1-题目链接" class="headerlink" title="1.题目链接"></a>1.题目链接</h1><p>LeetCode：<a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/" target="_blank" rel="noopener">从尾到头打印链表</a></p>
<h1 id="2-题目描述"><a href="#2-题目描述" class="headerlink" title="2.题目描述"></a>2.题目描述</h1><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight angelscript"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br></pre></td></tr></tbody></table></figure>

<p><strong>限制：</strong></p>
<figure class="highlight basic"><table><tbody><tr><td class="code"><pre><span class="line"><span class="symbol">0 </span>&lt;= 链表长度 &lt;= <span class="number">10000</span></span><br></pre></td></tr></tbody></table></figure>



<h1 id="3-解题思路"><a href="#3-解题思路" class="headerlink" title="3.解题思路"></a>3.解题思路</h1><p>像这种倒来倒去的可以使用辅助栈法</p>
<blockquote>
<p><strong>链表特点：</strong> 只能从前至后访问每个节点。<br><strong>题目要求：</strong> 倒序输出节点值。<br>这种 <strong>先入后出</strong> 的需求可以借助 <strong>栈</strong> 来实现。</p>
</blockquote>
<p><strong>算法流程</strong>：</p>
<ol>
<li>入栈： 遍历链表，将各节点值 push 入栈。（Java借助 <code>LinkedList</code> 的<code>addLast()</code>方法）。</li>
<li>出栈： 将各节点值 pop 出栈，存储于数组并返回。（Java 新建一个数组，通过 <code>popLast()</code> 方法将各元素存入数组，实现倒序输出）。</li>
</ol>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(N)： 入栈和出栈共使用 O(N) 时间。</li>
<li>空间复杂度 O(N)： 辅助栈 stack 和数组 res 共使用 O(N) 的额外空间。</li>
</ul>
<h1 id="4-代码"><a href="#4-代码" class="headerlink" title="4.代码"></a>4.代码</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) {</span><br><span class="line">        <span class="comment">// 常用LinkedList 来作为stack栈使用</span></span><br><span class="line">        LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">// 遍历 逐个进栈</span></span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>) {</span><br><span class="line">            stack.addLast(head.val);</span><br><span class="line">            head = head.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 新建一个数组</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[stack.size()];</span><br><span class="line">        <span class="comment">// 遍历 逐个出栈</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.length; i++)</span><br><span class="line">            res[i] = stack.removeLast();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>









<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 02 - 替换空格</title>
    <url>/2020/04/02/jian-zhi-offer-02-ti-huan-kong-ge/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-题目链接"><a href="#1-题目链接" class="headerlink" title="1.题目链接"></a>1.题目链接</h1><p>LeetCode：<a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/" target="_blank" rel="noopener">替换空格</a></p>
<h1 id="2-题目描述"><a href="#2-题目描述" class="headerlink" title="2.题目描述"></a>2.题目描述</h1><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p>
<p>示例：</p>
<figure class="highlight perl"><table><tbody><tr><td class="code"><pre><span class="line">输入：<span class="keyword">s</span> = <span class="string">"We are happy."</span></span><br><span class="line">输出：<span class="string">"We%20are%20happy."</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>限制：</strong></p>
<p><code>0 &lt;= s 的长度 &lt;= 10000</code></p>
<h1 id="3-解题思路"><a href="#3-解题思路" class="headerlink" title="3.解题思路"></a>3.解题思路</h1><h2 id="3-1-解决思路（一）"><a href="#3-1-解决思路（一）" class="headerlink" title="3.1 解决思路（一）"></a>3.1 解决思路（一）</h2><p>其实这题说简单的话一行代码便可以解决：<code>return s.replace(" ","%20");</code> 使用Java的String类下的replace方法，真香。</p>
<h2 id="3-2-解决思路（二）"><a href="#3-2-解决思路（二）" class="headerlink" title="3.2 解决思路（二）"></a>3.2 解决思路（二）</h2><p>还可以使用的是，<code>StringBuilder</code>的<code>append</code>方法如下：</p>
<ol>
<li>初始化一个 StringBuilder ，记为 res ；</li>
<li>遍历字符串 s 中的每个字符 c ：<ul>
<li>当 c 为空格时：向 res 后添加字符串 “%20”；</li>
<li>当 c 不为空格时：向 res 后添加字符 c ；</li>
</ul>
</li>
<li>将 res 转化为 String 类型并返回。</li>
</ol>
<p>具体代码如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>{</span><br><span class="line">        <span class="comment">// 申请一个辅助的StringBuilder</span></span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">// 讲s的每个字符都转换成数组进行遍历</span></span><br><span class="line">        <span class="keyword">for</span>(Character c : s.toCharArray())</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">' '</span>) res.append(<span class="string">"%20"</span>);</span><br><span class="line">            <span class="keyword">else</span> res.append(c);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="3-3-解决思路（三）"><a href="#3-3-解决思路（三）" class="headerlink" title="3.3 解决思路（三）"></a>3.3 解决思路（三）</h2><p>由于每次替换从 1 个字符变成 3 个字符，使用字符数组可方便地进行替换。建立字符数组地长度为 s 的长度的 3 倍，这样可保证字符数组可以容纳所有替换后的字符。</p>
<p>具体流程如下：</p>
<ul>
<li>获得 s 的长度 length</li>
<li>创建字符数组 array，其长度为 length * 3</li>
<li>初始化 size 为 0，size 表示替换后的字符串的长度</li>
<li>从左到右遍历字符串 s<ul>
<li>获得 s 的当前字符 c</li>
<li>如果字符 c 是空格，则令 array[size] = ‘%’，array[size + 1] = ‘2’，array[size + 2] = ‘0’，并将 size 的值加 3</li>
<li>如果字符 c 不是空格，则令 array[size] = c，并将 size 的值加 1</li>
</ul>
</li>
<li>遍历结束之后，size 的值等于替换后的字符串的长度，从 array 的前 size 个字符创建新字符串，并返回新字符串</li>
</ul>
<p><strong>复杂性分析</strong></p>
<ul>
<li>时间复杂度：O(n)。遍历字符串 <code>s</code> 一遍。</li>
<li>空间复杂度：O(n)。额外创建字符数组，长度为 <code>s</code> 的长度的 3 倍。</li>
</ul>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="comment">// 申请一个新的字符数组中，长度为原来传进来的数组长度的三倍</span></span><br><span class="line">        <span class="keyword">char</span>[] array = <span class="keyword">new</span> <span class="keyword">char</span>[length * <span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 对原数组的逐个字符进行遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            <span class="comment">// 此时需要进行每个字符的转换</span></span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">' '</span>) {</span><br><span class="line">                array[size++] = <span class="string">'%'</span>;</span><br><span class="line">                array[size++] = <span class="string">'2'</span>;</span><br><span class="line">                array[size++] = <span class="string">'0'</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                array[size++] = c;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 最后使用这个字符还有累加的size，申请一个新的字符串并返回</span></span><br><span class="line">        String newStr = <span class="keyword">new</span> String(array, <span class="number">0</span>, size);</span><br><span class="line">        <span class="keyword">return</span> newStr;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 13 - 调增数组顺序使奇数位于偶数前面</title>
    <url>/2020/04/02/jian-zhi-offer-13-diao-zeng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 23 - 二叉搜索树的后序遍历序列</title>
    <url>/2020/04/02/jian-zhi-offer-23-er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 34 - 第一个只出现一次的字符</title>
    <url>/2020/04/02/jian-zhi-offer-34-di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 43 - 左旋转字符串</title>
    <url>/2020/04/02/jian-zhi-offer-43-zuo-xuan-zhuan-zi-fu-chuan/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 50 - 数组中重复的数字</title>
    <url>/2020/04/02/jian-zhi-offer-50-shu-zu-zhong-chong-fu-de-shu-zi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 01 - 二维数组中的查找</title>
    <url>/2020/04/02/jian-zhi-offer-01-er-wei-shu-zu-zhong-de-cha-zhao/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-题目链接"><a href="#1-题目链接" class="headerlink" title="1.题目链接"></a>1.题目链接</h1><p>LeetCode链接：<a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/" target="_blank" rel="noopener">二维数组中的查找</a></p>
<h1 id="2-题目描述"><a href="#2-题目描述" class="headerlink" title="2.题目描述"></a>2.题目描述</h1><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p><strong>示例 1：</strong></p>
<p>现有矩阵 matrix 如下：</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,   <span class="number">4</span>,  <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>],</span><br><span class="line">  [<span class="number">2</span>,   <span class="number">5</span>,  <span class="number">8</span>, <span class="number">12</span>, <span class="number">19</span>],</span><br><span class="line">  [<span class="number">3</span>,   <span class="number">6</span>,  <span class="number">9</span>, <span class="number">16</span>, <span class="number">22</span>],</span><br><span class="line">  [<span class="number">10</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">17</span>, <span class="number">24</span>],</span><br><span class="line">  [<span class="number">18</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">26</span>, <span class="number">30</span>]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>

<p>给定 target = <code>5</code>，返回 <code>true</code>。</p>
<p>给定 target = <code>20</code>，返回 <code>false</code>。</p>
<p><strong>限制：</strong></p>
<p><code>0 &lt;= n &lt;= 1000</code><br><code>0 &lt;= m &lt;= 1000</code></p>
<h1 id="3-解题思路"><a href="#3-解题思路" class="headerlink" title="3.解题思路"></a>3.解题思路</h1><p><strong>标志数引入</strong>： 此类矩阵中左下角和右上角元素有特殊性，称为标志数。</p>
<ul>
<li>左下角元素： 为所在列最大元素，所在行最小元素。</li>
<li>右上角元素： 为所在行最大元素，所在列最小元素。</li>
</ul>
<p><strong>标志数性质：</strong> 将 <code>matrix</code> 中的<strong>左下角元素</strong>（标志数）记作 <code>flag</code> ，则有：</p>
<ol>
<li>若 flag &gt; target ，则 target 一定在 flag 所在行的上方，即 flag 所在行可被消去。</li>
<li>若 flag &lt; target ，则 target 一定在 flag 所在列的右方，即 flag 所在列可被消去。</li>
</ol>
<ul>
<li>本题解以左下角元素为例，同理，<strong>右上角元素</strong> 也具有行（列）消去的性质。</li>
</ul>
<p><strong>算法流程：</strong> 根据以上性质，设计算法在每轮对比时消去一行（列）元素，以降低时间复杂度。</p>
<ol>
<li>从矩阵 matrix 左下角元素（索引设为 (i, j) ）开始遍历，并与目标值对比：<ul>
<li>当 matrix[i][j] &gt; target 时： 行索引向上移动一格（即 i–），即消去矩阵第 i 行元素；</li>
<li>当 matrix[i][j] &lt; target 时： 列索引向右移动一格（即 j++），即消去矩阵第 j 列元素；</li>
<li>当 matrix[i][j] == target 时： 返回 truetrue 。</li>
</ul>
</li>
<li>若行索引或列索引越界，则代表矩阵中无目标值，返回 false。</li>
</ol>
<p><strong>时空复杂度</strong></p>
<ul>
<li>时间复杂度：O(n+m)。访问到的下标的行最多增加 n 次，列最多减少 m 次，因此循环体最多执行 n + m 次。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h1 id="4-具体代码"><a href="#4-具体代码" class="headerlink" title="4.具体代码"></a>4.具体代码</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">    	<span class="comment">// 设定标志位</span></span><br><span class="line">        <span class="keyword">int</span> i = matrix.length - <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 利用从上到下递增、从左到右递增的特点</span></span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &lt; matrix[<span class="number">0</span>].length)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] &gt; target) i--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] &lt; target) j++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>











<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 - 什么是跳跃表</title>
    <url>/2020/04/01/shu-ju-jie-gou-shi-me-shi-tiao-yue-biao/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 - 什么是B+树？</title>
    <url>/2020/04/01/shu-ju-jie-gou-shi-me-shi-b-shu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis 源码分析（1） - 配置文件解析过程</title>
    <url>/2020/04/01/mybatis-yuan-ma-fen-xi-1-pei-zhi-wen-jian-jie-xi-guo-cheng/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis 源码分析（2） - 映射文件解析过程</title>
    <url>/2020/04/01/mybatis-yuan-ma-fen-xi-2-ying-she-wen-jian-jie-xi-guo-cheng/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis 源码分析（3） - SQL执行过程</title>
    <url>/2020/04/01/mybatis-yuan-ma-fen-xi-3-sql-zhi-xing-guo-cheng/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis 框架分析（5） - 连接池管理机制</title>
    <url>/2020/04/01/mybatis-kuang-jia-fen-xi-5-lian-jie-chi-guan-li-ji-zhi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis 框架分析（6） - 缓存机制</title>
    <url>/2020/04/01/mybatis-kuang-jia-fen-xi-6-huan-cun-ji-zhi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis 框架分析（4） - 事务管理机制</title>
    <url>/2020/04/01/mybatis-kuang-jia-fen-xi-4-shi-wu-guan-li-ji-zhi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis 框架分析（3） - 使用Mybatis进行CRUD</title>
    <url>/2020/04/01/mybatis-kuang-jia-fen-xi-3-shi-yong-mybatis-jin-xing-crud/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis 框架分析（2） - 基于XML配置文件的方式的简单Demo</title>
    <url>/2020/04/01/mybatis-kuang-jia-fen-xi-2-ji-yu-xml-pei-zhi-wen-jian-de-fang-shi-de-jian-dan-demo/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>目的：使用Mybatis 去查询数据库的表，并且打印出来</p>
<p>IDEA：IDEA 2019.2.3</p>
<p>MySql：Mysql 5.7.22</p>
<p>MyBatis：MyBatis 3.4.5</p>
<p>Maven：Maven 3.5.2</p>
<h1 id="2-使用Mybatis查询数据库内容"><a href="#2-使用Mybatis查询数据库内容" class="headerlink" title="2.使用Mybatis查询数据库内容"></a>2.使用Mybatis查询数据库内容</h1><h2 id="2-1-New-一个新的Project，Maven项目："><a href="#2-1-New-一个新的Project，Maven项目：" class="headerlink" title="2.1 New 一个新的Project，Maven项目："></a>2.1 New 一个新的Project，Maven项目：</h2><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/01/hcSMWl7FdIkVAr4.png"  alt="image.png"></p>
<p>接着进行Project 的信息填写如下：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/01/ATzZGfEcrIjKp5x.png"  alt="image.png"></p>
<p>新创建之后的Project如下：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/01/Rq2hcEUbnyJjx5m.png"  alt="image.png"></p>
<h2 id="2-2-进行一些准备工作"><a href="#2-2-进行一些准备工作" class="headerlink" title="2.2 进行一些准备工作"></a>2.2 进行一些准备工作</h2><h3 id="2-2-1-填充Mysql数据："><a href="#2-2-1-填充Mysql数据：" class="headerlink" title="2.2.1 填充Mysql数据："></a>2.2.1 填充Mysql数据：</h3><p>进行如下数据的填充，方面接下来的Demo的一些操作：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">CREATE DATABASE mybatis_demo;</span><br><span class="line">use mybatis_demo;</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">CREATE TABLE USER(</span><br><span class="line">	ID INT(20) not null PRIMARY KEY,</span><br><span class="line">	NAME VARCHAR(30) DEFAULT NULL,</span><br><span class="line">	PWD VARCHAR(30) DEFAULT NULL</span><br><span class="line">)ENGINE=INNODB, CHARSET=utf8;</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">INSERT INTO USER (ID, NAME, PWD) VALUES (1,'cici',123),(2,'pipi',456),(3,'gigi',789);</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到数据库已经有如下数据了：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/01/Dgi7x1dmFUu8zQV.png"  alt="image.png"></p>
<h3 id="2-2-2-调整一些Project目录"><a href="#2-2-2-调整一些Project目录" class="headerlink" title="2.2.2 调整一些Project目录"></a>2.2.2 调整一些Project目录</h3><p>首先删除src，然后创建新的子模块，因为我们会在这个项目里建立多个子项目，这样可以节省创建新项目的时间。</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/01/lT78fDtNyJVSWYL.png"  alt="image.png"></p>
<p>创建新的子模块如下：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/01/YZmC1HD6sjoKF8W.png"  alt="image.png"></p>
<p>创建完成如下：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/01/lFzIarxZVQWRc3s.png"  alt="image.png"></p>
<h3 id="2-2-3-配置Pom-xml"><a href="#2-2-3-配置Pom-xml" class="headerlink" title="2.2.3 配置Pom.xml"></a>2.2.3 配置Pom.xml</h3><p>进行Pom.xml 的配置，主要就是一些dependecy的填充。</p>
<ol>
<li>mybatis的dependency可以在官网中找到<ul>
<li><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/01/NGRMBp5n4O87SDT.png"  alt="image.png"></li>
</ul>
</li>
<li>junit 是单元测试</li>
<li>mysql 的依赖一样需要添加</li>
<li>log4j 是日志，添加上。</li>
</ol>
<p>pom.xml 详细配置如下：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 父工程 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis_demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.garmen<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis_demo01<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>



<p>同时将log4j 的配置文件添加到src下面，如下所示：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/01/5w4Ue2HoJCPpNrf.png"  alt="image.png"></p>
<p>lo4j 内容如下：</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Set root category priority to INFO and its only appender to CONSOLE.</span></span><br><span class="line"><span class="comment">#log4j.rootCategory=INFO, CONSOLE            debug   info   warn error fatal</span></span><br><span class="line">log4j.<span class="attribute">rootCategory</span>=debug, CONSOLE, LOGFILE</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the enterprise logger category to FATAL and its only appender to CONSOLE.</span></span><br><span class="line">log4j.logger.org.apache.axis.<span class="attribute">enterprise</span>=FATAL, CONSOLE</span><br><span class="line"></span><br><span class="line"><span class="comment"># CONSOLE is set to be a ConsoleAppender using a PatternLayout.</span></span><br><span class="line">log4j.appender.<span class="attribute">CONSOLE</span>=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.CONSOLE.<span class="attribute">layout</span>=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.CONSOLE.layout.<span class="attribute">ConversionPattern</span>=%d{ISO8601} %-6r [%15.15t] %-5p %30.30c %x - %m\n</span><br><span class="line"></span><br><span class="line"><span class="comment"># LOGFILE is set to be a File appender using a PatternLayout.</span></span><br><span class="line">log4j.appender.<span class="attribute">LOGFILE</span>=org.apache.log4j.FileAppender</span><br><span class="line">log4j.appender.LOGFILE.<span class="attribute">File</span>=d:\axis.log</span><br><span class="line">log4j.appender.LOGFILE.<span class="attribute">Append</span>=<span class="literal">true</span></span><br><span class="line">log4j.appender.LOGFILE.<span class="attribute">layout</span>=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.LOGFILE.layout.<span class="attribute">ConversionPattern</span>=%d{ISO8601} %-6r [%15.15t] %-5p %30.30c %x - %m\n</span><br></pre></td></tr></tbody></table></figure>



<hr>
<h2 id="2-3-配置-Mybatis-核心配置文件"><a href="#2-3-配置-Mybatis-核心配置文件" class="headerlink" title="2.3 配置 Mybatis 核心配置文件"></a>2.3 配置 Mybatis 核心配置文件</h2><p>我们使用官网提供的方法，官网中说明有两种方式可以构建 SqlSessionFactory，一种是使用XML，一种是不使用XML，<strong>这个Demo暂定选择使用XML来进行构建SqlSessionFactory</strong>。</p>
<p>官网所给建议截图如下：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/01/HOkQoJGInL41vE6.png"  alt="image.png"></p>
<p>于是我们创建并编写 SqlMapConfig.xml 配置文件。</p>
<ul>
<li>注意：这个XML 配置文件，包含了对 MyBatis 系统的核心设置，包括获取数据库连接实例的数据源（DataSource）以及决定事务作用域和控制方式的事务管理器 （TransactionManager）。</li>
<li>其实主要的就是你机子里面的数据库信息，就是配置环境。</li>
</ul>
<p>需要注意的是，这个头部是通用的，我们可以先保存下来：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span>  </span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span>  </span></span><br><span class="line"><span class="meta">  <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>进行扩充之后如下：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">&lt;!-- mybaits的主配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置环境 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置Mysql的环境 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--  配置事物的类型 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 配置数据源（连接池） --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 配置连接数据库的4个基本信息 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/mybatis_demo"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>截图如下所示：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/01/LIOaz32UtsfQjbd.png"  alt="image.png"></p>
<hr>
<h2 id="2-4-编写实体类"><a href="#2-4-编写实体类" class="headerlink" title="2.4 编写实体类"></a><strong>2.4 编写实体类</strong></h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.garmen.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ID;</span><br><span class="line">    <span class="keyword">private</span> String NAME;</span><br><span class="line">    <span class="keyword">private</span> String PWD;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> ID, String NAME, String PWD)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.ID = ID;</span><br><span class="line">        <span class="keyword">this</span>.NAME = NAME;</span><br><span class="line">        <span class="keyword">this</span>.PWD = PWD;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 隐藏geter、seter、toString</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<hr>
<h2 id="2-5-编写持久层相关"><a href="#2-5-编写持久层相关" class="headerlink" title="2.5 编写持久层相关"></a><strong>2.5 编写持久层相关</strong></h2><p>其实这一步就是创建持久层Dao接口并且创建其映射文件，并在总的配置文件中进行绑定即可。</p>
<ul>
<li>此处有需要注意的一点就是：持久层接口 必须要和 持久层接口的映射文件的名称保持一致，下面便是一个很好的示范！</li>
</ul>
<h3 id="2-5-1-编写持久层接口-UserDao"><a href="#2-5-1-编写持久层接口-UserDao" class="headerlink" title="2.5.1 编写持久层接口 UserDao"></a><strong>2.5.1 编写持久层接口 UserDao</strong></h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="2-5-2-编程持久层接口的映射文件-UserDao-xml"><a href="#2-5-2-编程持久层接口的映射文件-UserDao-xml" class="headerlink" title="2.5.2 编程持久层接口的映射文件 UserDao.xml"></a><strong>2.5.2 编程持久层接口的映射文件 UserDao.xml</strong></h3><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.garmen.dao.UserDao"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置查询所有 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultType</span>=<span class="string">"com.garmen.domain.User"</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>需要注意的如下：</p>
<ol>
<li>namespace的路径需要绑定到对应的接口</li>
<li>select标签代表的就是查询语句</li>
<li>select中的id需要和接口中的方法名称相同！！！</li>
<li>resultType代表着返回结果类型，我们要获取所有的User，所以此处为garmen包中的User类。</li>
<li>resultType 需要指定，这个标签不可以不写，不然会报错。</li>
<li>select标签中，填写我们相应的语句。</li>
</ol>
<p>此时目录概括如下：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/01/LnhbTOKlB2FCmso.png"  alt="目录概括.png"></p>
<h3 id="2-5-3-进行接口的绑定"><a href="#2-5-3-进行接口的绑定" class="headerlink" title="2.5.3 进行接口的绑定"></a><strong>2.5.3 进行接口的绑定</strong></h3><p>有一个问题就是，我们刚刚配置完的UserDao.xml添加到哪里呢？</p>
<ul>
<li>添加到SqlMapConfig.xml中，告诉它有这个UserDao.xml 东西！</li>
</ul>
<p>即在SqlMapConfig.xml，进行添加mappers映射，和上面已经填写完成之后的SqlMapConfig.xml 文件进行扩充之后如下：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- mybaits的主配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置环境 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置Mysql的环境 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--  配置事物的类型 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 配置数据源（连接池） --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 配置连接数据库的4个基本信息 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/mybatis_demo"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"com/garmen/dao/UserDao.xml"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>



<hr>
<h2 id="2-6-创建测试文件"><a href="#2-6-创建测试文件" class="headerlink" title="2.6 创建测试文件"></a>2.6 创建测试文件</h2><p>根据官网提供给的工具，我们可以进行代码的编写了</p>
<p>其实官网提供的也就是：从XML中构建了 SqlSessionFactory</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/01/NHB5j29XtcOirPY.png"  alt="image.png"></p>
<p>然后从已经构建了的 SqlSessionFactory 中获取 SqlSession 的实例。SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/01/SvPAdH63NkQLjME.png"  alt="image.png"></p>
<p>在Test目录下创建测试文件，并进行代码填写：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/01/oXKZYSgDGItnsHd.png"  alt="image.png"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisTest</span> </span>{</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        <span class="comment">//1、读取配置文件</span></span><br><span class="line">        InputStream in = Resources.getResourceAsStream(<span class="string">"SqlMapConfig.xml"</span>);</span><br><span class="line">        <span class="comment">//2、创建SqlSessionFactory工厂</span></span><br><span class="line">        SqlSessionFactoryBuilder builder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">        SqlSessionFactory factory = builder.build(in);</span><br><span class="line">        <span class="comment">//3、使用工厂生产SqlSeesion对象</span></span><br><span class="line">        SqlSession session = factory.openSession();</span><br><span class="line">        <span class="comment">//4、使用SqlSession创建Dao接口的代理对象</span></span><br><span class="line">        UserDao userDao = session.getMapper(UserDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//5、使用代理对象执行方法</span></span><br><span class="line">        List&lt;User&gt; users = userDao.findAll();</span><br><span class="line">        <span class="keyword">for</span> (User user : users) {</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//6、释放资源</span></span><br><span class="line">        session.close();</span><br><span class="line">        in.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>对于上面的几个看起来怪怪的东西，其实官网都已经给出了解释：</p>
<p><strong>SqlSessionFactoryBuilder</strong>：这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。 你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但最好还是不要一直保留着它，以保证所有的 XML 解析资源可以被释放给更重要的事情。</p>
<p><strong>SqlSessionFactory</strong>：SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏习惯”。因此 SqlSessionFactory 的最佳作用域是应用作用域。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</p>
<p><strong>SqlSession</strong>：每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。 如果你现在正在使用一种 Web 框架，考虑将 SqlSession 放在一个和 HTTP 请求相似的作用域中。 换句话说，每次收到 HTTP 请求，就可以打开一个 SqlSession，返回一个响应后，就关闭它。 这个关闭操作很重要，为了确保每次都能执行关闭操作，你应该把这个关闭操作放到 finally 块中。 下面的示例就是一个确保 SqlSession 关闭的标准模式：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) {</span><br><span class="line">  <span class="comment">// 你的应用逻辑代码</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>还有上面的那个mapper 其实是映射器的原理，这是一个映射器示例，关于映射器是什么意思？官网也很会，他给出的解释如下：</p>
<p><u>映射器是一些绑定映射语句的接口</u>。映射器接口的实例是从 SqlSession 中获得的。虽然从技术层面上来讲，任何映射器实例的最大作用域与请求它们的 SqlSession 相同。但方法作用域才是映射器实例的最合适的作用域。 也就是说，映射器实例应该在调用它们的方法中被获取，使用完毕之后即可丢弃。 映射器实例并不需要被显式地关闭。尽管在整个请求作用域保留映射器实例不会有什么问题，但是你很快会发现，在这个作用域上管理太多像 SqlSession 的资源会让你忙不过来。 因此，最好将映射器放在方法作用域内。就像下面的例子一样：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) {</span><br><span class="line">  BlogMapper mapper = session.getMapper(BlogMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  <span class="comment">// 你的应用逻辑代码</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>这些东西当然在后面我会进行深入解释一下的。</p>
<h2 id="2-7-结果显示如下"><a href="#2-7-结果显示如下" class="headerlink" title="2.7 结果显示如下"></a>2.7 结果显示如下</h2><p>Test 所获得的结果如下所示：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/01/DjIO3RpSJv2zWqi.png"  alt="image.png"></p>
<hr>
<h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h1><p>只要遵循上面的这个做法，程序是可以跑起来并且去查询到我们数据库相关的信息的，这只是一个小Demo，主要是我们可以了解到了Mybatis 原来作用是这样，让Mybatis工作的方式还有很多种，这只是其中一种，关于Demo的展示我应该写得更加细致一点，因为这样比较方便我们进行重新观看的时候一头雾水：我写的究竟是什么东西？？？当然上面也了解到了一些零碎的知识，不理解的东西还有很多，需要接下来一点点展开深入了解一下其内部的机制流程，在接下来的几章会详细展开。</p>
<p>关于这个Demo相关的内容已上传Github：<a href="https://github.com/dongxiem/Mybatis-Study" target="_blank" rel="noopener">https://github.com/dongxiem/Mybatis-Study</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis 框架分析（1） - 总体概述</title>
    <url>/2020/04/01/mybatis-kuang-jia-fen-xi-1-zong-ti-gai-shu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-MyBatis-认识与了解"><a href="#1-MyBatis-认识与了解" class="headerlink" title="1. MyBatis 认识与了解"></a>1. MyBatis 认识与了解</h1><h2 id="1-1-Jdbc的一些认识"><a href="#1-1-Jdbc的一些认识" class="headerlink" title="1.1 Jdbc的一些认识"></a>1.1 Jdbc的一些认识</h2><p>通过 JDBC 来操作数据库，需要以下几个<code>步骤</code>：</p>
<ol>
<li>加载数据库驱动</li>
<li>创建并获取数据库链接</li>
<li>创建 jdbc statement 对象</li>
<li>编写 sql 语句</li>
<li>设置 sql 语句中的参数(使用 <code>preparedStatement</code>)</li>
<li>通过 statement 执行 sql 并获取结果</li>
<li>对 sql 执行结果进行解析处理</li>
<li>释放资源(<code>resultSet</code>、<code>preparedstatement</code>、<code>connection</code>)</li>
</ol>
<p>给出使用JDBC的Demo如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<p>为了解决这么麻烦的一系列步骤，有人就提出来了MyBatis这个框架了！</p>
<hr>
<h2 id="1-2-MyBatis的大概介绍及其特点"><a href="#1-2-MyBatis的大概介绍及其特点" class="headerlink" title="1.2 MyBatis的大概介绍及其特点"></a>1.2 MyBatis的大概介绍及其特点</h2><p>Mybatis 是 JAVA 的一个<code>持久层框架</code>，什么是持久层？持久层就是能够长期保存数据的一层，例如我们的数据写在硬盘上，这说明我们的数据是持久的，如果写在内存当中，我们的数据就是不持久的。</p>
<p>根据官方文档的介绍，MyBatis大概如下：</p>
<ul>
<li>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</li>
</ul>
<p>百度百科总结的挺好，详细讲述了MyBatis的特点，如下：</p>
<ul>
<li>简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个 jar 文件+配置几个 sql 映射文件易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。</li>
<li>灵活：mybatis 不会对应用程序或者数据库的现有设计强加任何影响。sql 写在 xml 里，便于统一管理和优化。通过 sql 语句可以满足操作数据库的所有需求。</li>
<li>解除 sql 与程序代码的耦合：通过提供 DAO 层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql 和代码的分离，提高了可维护性。</li>
<li>提供映射标签，支持对象与数据库的 orm 字段关系映射</li>
<li>提供对象关系映射标签，支持对象关系组建维护</li>
<li>提供 xml 标签，支持编写动态 sql。</li>
</ul>
<hr>
<h1 id="2-Mybatis-总体框架"><a href="#2-Mybatis-总体框架" class="headerlink" title="2.Mybatis 总体框架"></a>2.Mybatis 总体框架</h1><p>MyBatis的总体框架大体如下（图源文末注明出处）：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/01/duibL3NkmMJGc27.png"  alt="MyBatis的总体框架.png"></p>
<p>其实了解Mybatis，可以了解其大体框架就知道它在做什么事情了。</p>
<p>总体流程：</p>
<p><strong>(1)加载配置并初始化</strong></p>
<ul>
<li><strong>触发条件：</strong>加载配置文件</li>
<li>配置来源于两个地方，一处是配置文件，一处是Java代码的注解，将SQL的配置信息加载成为一个个MappedStatement对象（包括了传入参数映射配置、执行的SQL语句、结果映射配置），存储在内存中。</li>
</ul>
<p><strong>(2)接收调用请求</strong></p>
<ul>
<li><strong>触发条件：</strong>调用Mybatis提供的API</li>
<li><strong>传入参数</strong>：为SQL的ID和传入参数对象</li>
<li><strong>处理过程：</strong>将请求传递给下层的数据处理层进行处理。</li>
</ul>
<p><strong>(3)处理操作请求</strong></p>
<ul>
<li><strong>触发条件：</strong>API接口层传递请求过来</li>
<li><strong>传入参数</strong>：为SQL的ID和传入参数对象</li>
<li><strong>处理过程：</strong><ol>
<li>根据SQL的ID查找对应的MappedStatement对象。</li>
<li>根据传入参数对象解析MappedStatement对象，得到最终要执行的SQL和执行传入参数。</li>
<li>获取数据库连接，根据得到的最终SQL语句和执行传入参数到数据库执行，并得到执行结果。</li>
<li>根据MappedStatement对象中的结果映射配置对得到的执行结果进行转换处理，并得到最终的处理结果。</li>
<li>释放连接资源。</li>
</ol>
</li>
</ul>
<p><strong>(4)返回处理结果</strong></p>
<ul>
<li>将最终的处理结果返回。</li>
</ul>
<hr>
<h2 id="2-1-接口层"><a href="#2-1-接口层" class="headerlink" title="2.1 接口层"></a>2.1 接口层</h2><p>所谓的接口层，就是MyBatis和数据库的交互，而MyBatis和数据库的交互大体上有两种方式，分别如下：</p>
<ol>
<li>使用传统的MyBatis提供的API；</li>
<li>使用Mapper接口</li>
</ol>
<h3 id="2-1-1-使用传统的MyBatis提供的API"><a href="#2-1-1-使用传统的MyBatis提供的API" class="headerlink" title="2.1.1 使用传统的MyBatis提供的API"></a>2.1.1 使用传统的MyBatis提供的API</h3><p>这是传统的传递Statement Id 和查询参数给 SqlSession 对象，使用 SqlSession对象完成和数据库的交互；MyBatis 提供了非常方便和简单的API，供用户实现对数据库的增删改查数据操作，以及对数据库连接信息和MyBatis 自身配置信息的维护操作。</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/02/YnPoiOGlMk1Lg53.png"  alt="image.png"></p>
<p>上述使用MyBatis 的方法，是创建一个和数据库打交道的SqlSession对象，然后根据Statement Id 和参数来操作数据库，这种方式固然很简单和实用，但是它不符合面向对象语言的概念和面向接口编程的编程习惯。由于面向接口的编程是面向对象的大趋势，MyBatis 为了适应这一趋势，增加了第二种使用MyBatis 支持接口（Interface）调用方式。</p>
<h3 id="2-1-2-使用Mapper接口"><a href="#2-1-2-使用Mapper接口" class="headerlink" title="2.1.2 使用Mapper接口"></a>2.1.2 使用Mapper接口</h3><p>MyBatis 将配置文件中的每一个<code>&lt;mapper&gt;</code> 节点抽象为一个 Mapper 接口，而这个接口中声明的方法和跟<mapper> 节点中的<code>&lt;select|update|delete|insert&gt;</code> 节点项对应，即<code>&lt;select|update|delete|insert&gt;</code> 节点的id值为Mapper 接口中的方法名称，<code>parameterType</code> 值表示Mapper 对应方法的入参类型，而<code>resultMap</code> 值则对应了Mapper 接口表示的返回值类型或者返回结果集的元素类型。</mapper></p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/02/OjXWJ6Pw7gySeYU.png"  alt="Mapper接口机制.png"></p>
<p>根据<strong>MyBatis</strong> 的配置规范配置好后，通过<code>SqlSession.getMapper(XXXMapper.class)</code> 方法，MyBatis 会根据相应的接口声明的方法信息，通过<strong>动态代理机制</strong>生成一个Mapper 实例，我们使用Mapper 接口的某一个方法时，MyBatis 会根据这个方法的方法名和参数类型，确定Statement Id，底层还是通过<code>SqlSession.select("statementId",parameterObject);</code>或者<code>SqlSession.update("statementId",parameterObject);</code> 等等来实现对数据库的操作<br>MyBatis 引用Mapper 接口这种调用方式，纯粹是为了满足面向接口编程的需要。（其实还有一个原因是在于，面向接口的编程，使得用户在接口上可以使用注解来配置SQL语句，<strong>这样就可以脱离XML配置文件，实现“0配置”</strong>）。</p>
<hr>
<h2 id="2-2-数据处理层"><a href="#2-2-数据处理层" class="headerlink" title="2.2 数据处理层"></a>2.2 数据处理层</h2><p>数据处理层可以说是<strong>MyBatis</strong> 的核心，从大的方面上讲，它要完成两个功能：</p>
<ol>
<li><em>通过传入参数构建动态SQL语句；</em></li>
<li><em>SQL语句的执行以及封装查询结果集成List</em></li>
</ol>
<h3 id="2-2-1-参数映射和动态SQL语句生成"><a href="#2-2-1-参数映射和动态SQL语句生成" class="headerlink" title="2.2.1 参数映射和动态SQL语句生成"></a>2.2.1 <strong>参数映射和动态SQL语句生成</strong></h3><p>动态语句生成可以说是MyBatis框架非常优雅的一个设计，MyBatis通过传入的参数值，使用 <strong>Ognl</strong> 来动态地构造SQL语句，使得MyBatis有很强的灵活性和扩展性。</p>
<p>参数映射指的是对于java 数据类型和jdbc数据类型之间的转换：这里有包括两个过程：</p>
<ul>
<li>查询阶段，我们要将java类型的数据，转换成jdbc类型的数据，通过 preparedStatement.setXXX() 来设值；</li>
<li>另一个就是对resultset查询结果集的jdbcType 数据转换成java 数据类型。</li>
</ul>
<h3 id="2-2-2-SQL语句的执行以及封装查询结果集成List"><a href="#2-2-2-SQL语句的执行以及封装查询结果集成List" class="headerlink" title="2.2.2 SQL语句的执行以及封装查询结果集成List"></a>2.2.2 <strong>SQL语句的执行以及封装查询结果集成List</strong></h3><p>动态SQL语句生成之后，MyBatis 将执行SQL语句，并将可能返回的结果集转换成List 列表。MyBatis 在对结果集的处理中，<strong>支持结果集关系一对多和多对一的转换</strong>，并且有两种支持方式，<strong>一种为嵌套查询语句的查询，还有一种是嵌套结果集的查询</strong>。</p>
<hr>
<h2 id="2-3-框架支撑层"><a href="#2-3-框架支撑层" class="headerlink" title="2.3 框架支撑层"></a>2.3 框架支撑层</h2><p>如上图所示，主要有四种机制，我想接下来可以一一对这些机制进行展开认识一下，都是挺重要的一些机制了。</p>
<h3 id="2-3-1-事务管理机制"><a href="#2-3-1-事务管理机制" class="headerlink" title="2.3.1 事务管理机制"></a>2.3.1 <strong>事务管理机制</strong></h3><p>了解数据库之后，应该都很清楚事务是一个什么东西，对于数据库，事务管理是其非常重要的一个方面，所以Mybatis 也相对应的给出了这个方面的机制。</p>
<p>MyBatis的事务管理分为两种形式：</p>
<ol>
<li><strong>使用JDBC的事务管理机制</strong>：即利用java.sql.Connection对象完成对事务的提交（commit()）、回滚（rollback()）、关闭（close()）等</li>
<li><strong>使用MANAGED的事务管理机制：</strong>这种机制MyBatis自身不会去实现事务管理，而是让程序的容器如（JBOSS，Weblogic）来实现对事务的管理</li>
</ol>
<p>具体查看分析：</p>
<h3 id="2-3-2-连接池管理机制"><a href="#2-3-2-连接池管理机制" class="headerlink" title="2.3.2 连接池管理机制"></a>2.3.2 <strong>连接池管理机制</strong></h3><p>有个疑惑：<strong>为什么要使用连接池？</strong></p>
<p>这是因为创建一个java.sql.Connection对象的代价是如此巨大，创建一个Connection对象的过程，在底层就相当于和数据库建立的通信连接，在建立通信连接的过程，消耗了这么多的时间，而往往我们建立连接后（即创建Connection对象后），就执行一个简单的SQL语句，然后就要抛弃掉，这是一个非常大的资源浪费！</p>
<p>所以聪明的大叔们认为对于需要频繁地跟数据库交互的应用程序，可以在创建了Connection对象，并操作完数据库后，可以不释放掉资源，而是将它放到内存中，当下次需要操作数据库时，可以直接从内存中取出Connection对象，不需要再创建了，这样就极大地节省了创建Connection对象的资源消耗。由于内存也是有限和宝贵的，这又对我们对内存中的Connection对象怎么有效地维护提出了很高的要求。我们将在内存中存放Connection对象的容器称之为 连接池（Connection Pool）。</p>
<p>具体查看分析：</p>
<h3 id="2-3-3-缓存机制"><a href="#2-3-3-缓存机制" class="headerlink" title="2.3.3 缓存机制"></a>2.3.3 <strong>缓存机制</strong></h3><p>所以还是说，计算机的很多方面都是相同的，缓存机制，特别是对于需要查询的一些相关操作，能节省时间尽量节省时间，也就是说为了提高数据利用率和减小服务器和数据库的压力，研究MyBatis 的大叔们会对于一些查询提供会话级别的数据缓存，会将对某一次查询，放置到<strong>SqlSession</strong> 中，在允许的时间间隔内，对于完全相同的查询，MyBatis 会直接将缓存结果返回给用户，而不用再到数据库中查找。</p>
<p>具体查看分析：</p>
<h3 id="2-3-4-SQL语句的配置方式"><a href="#2-3-4-SQL语句的配置方式" class="headerlink" title="2.3.4 SQL语句的配置方式"></a>2.3.4 SQL语句的配置方式</h3><p>传统的MyBatis 配置SQL 语句方式就是使用XML文件进行配置的，但是这种方式不能很好地支持面向接口编程的理念，为了支持面向接口的编程，<strong>MyBatis 引入了Mapper接口的概念</strong>，面向接口的引入，对使用注解来配置SQL 语句成为可能，用户只需要在接口上添加必要的注解即可，不用再去配置XML文件了，但是，目前的MyBatis 只是对注解配置SQL 语句提供了有限的支持，某些高级功能还是要依赖XML配置文件配置SQL 语句。</p>
<hr>
<h2 id="2-4-引导层"><a href="#2-4-引导层" class="headerlink" title="2.4 引导层"></a>2.4 引导层</h2><p><strong>引导层是配置和启动MyBatis 配置信息的方式</strong>。MyBatis 提供两种方式来引导MyBatis ：</p>
<ol>
<li>基于XML配置文件的方式</li>
<li>基于Java API 的方式</li>
</ol>
<hr>
<h1 id="3-主要深入方面"><a href="#3-主要深入方面" class="headerlink" title="3.主要深入方面"></a>3.主要深入方面</h1><p>对于Mybatis 的主要运行方式，给出两种Demo：</p>
<ul>
<li>Mybatis 基于DAO的传统开发方式</li>
<li>Mybatis 基于注解的开发方式</li>
</ul>
<p>再给出Mybatis 完成CRUD 的一个Demo：</p>
<ul>
<li>Mybatis 完成CRUD操作</li>
</ul>
<p>对于Mybatis 框架的整体学习，我主要进行深入了解的是以下几个方面：</p>
<ul>
<li>事务管理机制</li>
<li>连接池管理机制</li>
<li>缓存机制</li>
</ul>
<p>而对于源码的剖析，主要涉及到的是以下几个方面：</p>
<ul>
<li>映射文件的解析过程</li>
<li>配置文件的解析过程</li>
<li>SQL 的执行过程</li>
<li>缓存原理</li>
</ul>
<h1 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h1><p>我想通过这么一个流程系列下来，我对Mybatis 的整个流程机制已经有一定的认识了，但是可能还是有些地方不够深入，还是要多去探究一下，Mybatis 对于开发来说是很重要的一个部分，希望自己在犯错的路上可以少走一些，借助前人的经验才能走得更加长远。</p>
<p>以上参考文章：</p>
<ul>
<li><a href="https://blog.csdn.net/luanlouis/article/details/40422941" target="_blank" rel="noopener">《深入理解mybatis原理》 MyBatis的架构设计以及实例分析</a></li>
<li><a href="https://www.iteye.com/blog/chenjc-it-1460990" target="_blank" rel="noopener">原理分析之二：框架整体设计</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/index.html" target="_blank" rel="noopener">Mybatis 官方文档</a></li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>导页</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - 线程创建的几种方式</title>
    <url>/2020/04/01/java-bing-fa-xian-cheng-chuang-jian-de-ji-chong-fang-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>在这阶段的学习过程中我会先抛出一系列：线程如何创建？这是一个很关键的问题，并发的关键在于多线程，那么如何创建线程呢？大概有几种方式呢？这几种方式的区别是什么？什么情况下应该使用这种创建方式？什么时候又不应该呢？那么具体的过程应该是如何呢？是否应该给出一两个例子会更好的说明一下？</p>
<p>问题太多，搞得自己都乱了，最主要的还是要一点点的去了解，最后串成一根线，才能更好对知识的进行掌握。</p>
<p>我想应该将这几种方式联系起来做一个对比，这样才能更好的理解这些创建线程方式的优点与缺点。</p>
<p>按照现有的认识，总的来说有两种实现线程的方式：</p>
<ol>
<li><strong>实现Runnable接口</strong></li>
<li><strong>继承Thread类</strong></li>
</ol>
<p>其实按照我的理解的话，详细分一下的话可以分为三种，就是继承Thread类，实现Runnable接口，实现Callable接口（虽然其内部也是实现Runnable接口），主要就是实现Runnable接口没有返回值，而实现Callable接口可以有返回值，所以也可以按照这三种方式去思考实际开发过程中到底需要哪种创建方式。</p>
<hr>
<h1 id="2-几种实现方式详解"><a href="#2-几种实现方式详解" class="headerlink" title="2.几种实现方式详解"></a>2.几种实现方式详解</h1><h2 id="2-1-继承Thread类"><a href="#2-1-继承Thread类" class="headerlink" title="2.1 继承Thread类"></a>2.1 继承Thread类</h2><p>实现：</p>
<ol>
<li>需要实现 run() 方法，因为 Thread 类也实现了 <code>Runable</code> 接口。</li>
<li>当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。</li>
</ol>
<p>Demo如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>{</span><br><span class="line">    <span class="comment">// 注意就是这里extend 进行继承了Thread</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">        <span class="comment">// 重写run方法，需要线程做的事情在这里进行编辑！</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>{</span><br><span class="line">            System.out.printl(<span class="string">"MyThread"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">        Thread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        myThread.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>关于start()方法需要注意的有两点：</p>
<ol>
<li>我们在程序里面调用了start()方法后，虚拟机会先为我们创建一个线程，然后等到这个线程第一次得到时间片时再调用run()方法。</li>
<li>注意<strong>不可多次调用start()方法</strong>。在第一次调用start()方法后，再次调用start()方法会抛出异常。</li>
</ol>
<p>此处我有两个疑惑，根据平时的积累之后给出了答案，问题如下：</p>
<ol>
<li><p><strong>start()方法和run()方法的区别？</strong></p>
<ul>
<li>只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。</li>
</ul>
</li>
<li><p><strong>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</strong></p>
<ul>
<li>new 一个 Thread，线程进入了新建状态；<u>调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了</u>。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 <u>而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行</u>，并不会在某个线程中执行它，所以这并不是多线程工作。</li>
<li>总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="2-2-实现Runnable接口"><a href="#2-2-实现Runnable接口" class="headerlink" title="2.2 实现Runnable接口"></a>2.2 实现Runnable接口</h2><p>实现：</p>
<ol>
<li>传统实现接口方式<ul>
<li>需要实现接口中的 run() 方法。</li>
<li>使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 run() 方法来启动线程。</li>
</ul>
</li>
<li>函数式编程实现方式(<code>JDK 1.8 +</code>)<ul>
<li>可以使用函数式编程：<code>new Thread(() -&gt; { .... }).start();</code>方便快捷！</li>
</ul>
</li>
</ol>
<p><code>Runnable</code>是一个函数式接口，这意味着我们可以使用<strong>Java 8的函数式编程</strong>来简化代码。</p>
<p>首先还是来认识一下函数式编程是个什么东西吧？</p>
<p>函数式编程这是在Java 8 之后才有的，它的声明是<u>通过一个注解</u>来实现的，可以查看Runnable 的接口实现便可知道</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Demo如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>{</span><br><span class="line">            System.out.println(<span class="string">"MyThread"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">        <span class="comment">// 需要注意的是这里是run而不是start！</span></span><br><span class="line">        <span class="keyword">new</span> MyThread().run();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Java 8 之后的函数式编程如下</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            Ststem.out.println(<span class="string">"Java 8 匿名内部类"</span>);</span><br><span class="line">        }).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出如下：</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="code"><pre><span class="line">MyThread</span><br><span class="line">Java <span class="number">8</span> 匿名内部类</span><br></pre></td></tr></tbody></table></figure>

<p>需要注意的是实现了Runnable接口(<code>implements Runnable</code>)要进行使用的时候是使用<code>new MyThread().run();</code>而不是<code>new Thread().start();</code></p>
<p>所以实现Runnable接口，我们有两种方式可以去实现创建线程，总的来说，使用匿名内部类的函数式编程会比较方便一点，不用那么多操作，那当然什么方便使用什么了~</p>
<hr>
<h2 id="2-3-实现-Callable接口"><a href="#2-3-实现-Callable接口" class="headerlink" title="2.3 实现 Callable接口"></a>2.3 实现 Callable接口</h2><h3 id="2-3-1-Callable接口"><a href="#2-3-1-Callable接口" class="headerlink" title="2.3.1 Callable接口"></a>2.3.1 Callable接口</h3><p>实现：</p>
<ol>
<li>其实也算是实现Runnable接口！</li>
<li><code>Callable</code>与<code>Runnable</code>类似，同样是只有一个抽象方法的函数式接口。不同的是，<code>Callable</code>提供的方法是<strong>有返回值</strong>的，而且支持<strong>泛型</strong>。</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>{</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>那一般是怎么使用<code>Callable</code>的呢？<u><code>Callable</code>一般是配合线程池工具<code>ExecutorService</code>来使用的。</u></p>
<p><code>ExecutorService</code>可以使用<code>submit</code>方法来让一个<code>Callable</code>接口执行。它会返回一个<code>Future</code>，我们后续的程序可以通过这个<code>Future</code>的<code>get</code>方法得到结果。但是！需要注意的是下面是通过<code>new Task ();</code>然后将这个Task使用线程池的<code>submit</code>进行提交的，<code>submit</code>是有返回值的，然后使用一个<code>Future&lt;&gt;</code>进行接收，再在下面我讲到了<code>FutureTask</code>之后，发现我们使用<code>FutureTask</code>或者更加方便一些，应该将这两者结合起来，就能更明白<code>FutureTask</code>的作用了。</p>
<p>简单Demo如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义Callable</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">// 模拟计算需要一秒</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>{</span><br><span class="line">        <span class="comment">// 申请线程池</span></span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">// 新建一个Task</span></span><br><span class="line">        Task task = <span class="keyword">new</span> Task();</span><br><span class="line">        <span class="comment">// 使用submit方法进行任务的提交，注意此处的是Future！</span></span><br><span class="line">        Future&lt;Integer&gt; result = executor.submit(task);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注意调用get方法会阻塞当前线程，直到得到结果。</span></span><br><span class="line">        <span class="comment">// 所以实际编码中建议使用可以设置超时时间的重载get方法。</span></span><br><span class="line">        System.out.println(result.get()); </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></tbody></table></figure>

<p>在线程池中的使用，可以具体看看我之前写的博客中的一个Demo：<a href="https://dongxiem.github.io/2020/04/08/java-bing-fa-xian-cheng-chi-de-shi-yong/#3-2-Callable-ThreadPoolExecutor">Callable+ThreadPoolExecutor</a>，可以申请一个List，用来装返回的数据：<code>List&lt;Future&lt;String&gt;&gt; futureList = new ArrayList&lt;&gt;();</code>，然后可以对这个<code>futureList</code>进行遍历输出。</p>
<hr>
<h3 id="2-3-2-Future接口"><a href="#2-3-2-Future接口" class="headerlink" title="2.3.2 Future接口"></a>2.3.2 Future接口</h3><p><code>Future</code>接口只有几个比较简单的方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> paramBoolean)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> V <span class="title">get</span><span class="params">(<span class="keyword">long</span> paramLong, TimeUnit paramTimeUnit)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p><code>cancel</code>方法是试图取消一个线程的执行，但是并不一定能够成功，因为任务可能已完成、已取消、或者一些其它因素不能取消，存在取消失败的可能。<code>boolean</code>类型的返回值是“是否取消成功”的意思。参数<code>paramBoolean</code>表示是否采用中断的方式取消线程执行。</p>
<p>所以有时候，<u>为了让任务有能够取消的功能，就使用<code>Callable</code>来代替<code>Runnable</code></u>。如果为了可取消性而使用 <code>Future</code>但又不提供可用的结果，则可以声明 <code>Future</code>形式类型、并返回 <code>null</code>作为底层任务的结果。</p>
<hr>
<h3 id="2-3-3-FutureTask类"><a href="#2-3-3-FutureTask类" class="headerlink" title="2.3.3 FutureTask类"></a>2.3.3 FutureTask类</h3><p>关于FutureTask的源码分析，我在这篇文章进行了分析：<a href="https://dongxiem.github.io/2020/04/10/java-bing-fa-futuretask-yuan-ma-fen-xi/#2-6-取消任务">Java 并发 - FutureTask源码分析</a>。可以查看一下。</p>
<h4 id="FutureTask的使用"><a href="#FutureTask的使用" class="headerlink" title="FutureTask的使用"></a>FutureTask的使用</h4><p>示例Demo：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义Callable，与上面一样</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">// 模拟计算需要一秒</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>{</span><br><span class="line">        <span class="comment">// 申请线程池</span></span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">// 注意，这里是申请了一个FutureTask，将上面的Task传入</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Task());</span><br><span class="line">        <span class="comment">// 提交这个FutureTask，注意submit没有返回值</span></span><br><span class="line">        executor.submit(futureTask);</span><br><span class="line">        <span class="comment">// 使用的是FutureTask的一些方法</span></span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>使用上与第一个Demo有一点小的区别。首先，调用<code>submit</code>方法是没有返回值的。这里实际上是调用的<code>submit(Runnable task)</code>方法，而上面的Demo，调用的是<code>submit(Callable task)</code>方法。</p>
<p>然后，这里是使用<code>FutureTask</code>直接取<code>get</code>取值，而上面的Demo是通过<code>submit</code>方法返回的<code>Future</code>去取值。</p>
<p>在很多高并发的环境下，有可能Callable和FutureTask会创建多次。FutureTask能够在高并发环境下<strong>确保任务只执行一次</strong>。</p>
<hr>
<h2 id="2-4-其他实现线程的方法"><a href="#2-4-其他实现线程的方法" class="headerlink" title="2.4 其他实现线程的方法"></a>2.4 其他实现线程的方法</h2><p>Java5 之后的<code>Executors</code>，<code>Executors</code>工具类可以用来创建线程池。</p>
<p><code>Executors</code>工具类是用来创建线程池的，这个线程池可以指定线程个数，也可以不指定，也可以指定定时器的线程池，它有如下常用的方法：</p>
<figure class="highlight reasonml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">new</span><span class="constructor">FixedThreadPool(<span class="params">int</span> <span class="params">nThreads</span>)</span>：创建固定数量的线程池</span><br><span class="line"><span class="keyword">new</span><span class="constructor">CachedThreadPool()</span>：创建缓存线程池</span><br><span class="line"><span class="keyword">new</span><span class="constructor">SingleThreadExecutor()</span>：创建单个线程</span><br><span class="line"><span class="keyword">new</span><span class="constructor">ScheduledThreadPool(<span class="params">int</span> <span class="params">corePoolSize</span>)</span>：创建定时器线程池</span><br></pre></td></tr></tbody></table></figure>



<p>这就涉及线程池的概念了，关于线程池的一些可以查看之前的文章：<a href="https://dongxiem.github.io/2020/03/31/java-bing-fa-shen-ru-xian-cheng-chi-yuan-li/">Java 并发 - 深入线程池原理</a></p>
<hr>
<h1 id="3-深入理解Thread类"><a href="#3-深入理解Thread类" class="headerlink" title="3.深入理解Thread类"></a>3.深入理解Thread类</h1><h2 id="3-1-Thread类构造方法"><a href="#3-1-Thread类构造方法" class="headerlink" title="3.1 Thread类构造方法"></a>3.1 Thread类构造方法</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Thread的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Thread</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>{</span><br><span class="line">    <span class="comment">// 如果名字为空则抛出异常，线程名字不可为空</span></span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name cannot be null"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 名字</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程的父线程为当前线程</span></span><br><span class="line">    Thread parent = currentThread();</span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果线程组为空</span></span><br><span class="line">    <span class="keyword">if</span> (g == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">/* Determine if it's an applet or not */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果安全管理security不为空，则使用安全管理security获取一个线程组</span></span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) {</span><br><span class="line">            g = security.getThreadGroup();</span><br><span class="line">        }</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 如果没有安全管理security没有设置线程组，则使用父线程组</span></span><br><span class="line">        <span class="keyword">if</span> (g == <span class="keyword">null</span>) {</span><br><span class="line">            g = parent.getThreadGroup();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 无论是否显式传入threadgroup，都可以进行checkAccess</span></span><br><span class="line">    g.checkAccess();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 权限检查</span></span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (isCCLOverridden(getClass())) {</span><br><span class="line">            security.checkPermission(</span><br><span class="line">                SecurityConstants.SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里会使用synchronized去同步线程组，然后进行一个nUnstartedThreads++;</span></span><br><span class="line">    g.addUnstarted();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.group = g;</span><br><span class="line">    <span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">    <span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line">    <span class="keyword">if</span> (security == <span class="keyword">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">    <span class="comment">// 初始化AccessControlContext类型的私有属性</span></span><br><span class="line">    <span class="keyword">this</span>.inheritedAccessControlContext =</span><br><span class="line">        acc != <span class="keyword">null</span> ? acc : AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    <span class="comment">// 设置线程优先级</span></span><br><span class="line">    setPriority(priority);</span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 两个对用于支持ThreadLocal的私有属性</span></span><br><span class="line">        <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">        ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    <span class="comment">// 保存指定的栈堆大小</span></span><br><span class="line">    <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程ID</span></span><br><span class="line">    <span class="keyword">this</span>.tid = nextThreadID();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>Thread类有很多构造方法，不过都是以上面这个构造方法为基准进行改造的，所以总的来说了解上面这个构造方法就可以了。比如有以下这么几个：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 无参构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带Runnable的构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, target, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带ThreadGroup和Runnable的构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(ThreadGroup group, Runnable target)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(group, target, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带名字参数的构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(String name)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">null</span>, name, <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们大多调用下面两个构造方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Thread(Runnable target)</span><br><span class="line">Thread(Runnable target, String name)</span><br></pre></td></tr></tbody></table></figure>

<p>Thread的构造方法主要有以下的几个参数：</p>
<ol>
<li><p>g：线程组，指定这个线程是在哪个线程组下；</p>
</li>
<li><p>target：指定要执行的任务；</p>
</li>
<li><p>name：线程的名字，多个线程的名字是可以重复的。如果不指定名字，见片段2；</p>
</li>
<li><p>acc：用于初始化私有变量<code>inheritedAccessControlContext</code>。</p>
<blockquote>
<p>它是一个私有变量，但是在<code>Thread</code>类里只有<code>init</code>方法对它进行初始化，在<code>exit</code>方法把它设为<code>null</code>。其它没有任何地方使用它。一般我们是不会使用它的，那什么时候会使用到这个变量呢？可以参考这个stackoverflow的问题：<a href="https://stackoverflow.com/questions/13516766/restrict-permissions-to-threads-which-execute-third-party-software" target="_blank" rel="noopener">Restrict permissions to threads which execute third party software</a>；</p>
</blockquote>
</li>
<li><p>inheritThreadLocals：可继承的<code>ThreadLocal</code>，<code>Thread</code>类里面有两个私有属性来支持`ThreadLocal。</p>
</li>
</ol>
<hr>
<h2 id="3-2-Thread类的几个常用方法"><a href="#3-2-Thread类的几个常用方法" class="headerlink" title="3.2 Thread类的几个常用方法"></a>3.2 Thread类的几个常用方法</h2><h3 id="3-2-1-currentThread"><a href="#3-2-1-currentThread" class="headerlink" title="3.2.1 currentThread"></a>3.2.1 currentThread</h3><p><code>currentThread()</code>：静态方法，返回对当前正在执行的线程对象的引用；</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a reference to the currently executing thread object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  the currently executing thread.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> Thread <span class="title">currentThread</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p>像获取当前线程的名字，一般就可以这么使用了：<code>Thread.currentThread().getName();</code></p>
<h3 id="3-2-2-start"><a href="#3-2-2-start" class="headerlink" title="3.2.2 start"></a>3.2.2 start</h3><p><code>start()</code>：<u>开始执行线程的方法，java虚拟机会调用线程内的run()方法；</u></p>
<p>需要注意的是：不可以多次启动线程，而且线程一旦完成执行，就不可以再次启动。意思就是同一个线程多次调用<code>start()</code>就会出现问题了！</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 线程被执行，JVM调用run方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is not invoked for the main method thread or "system"</span></span><br><span class="line"><span class="comment">     * group threads created/set up by the VM. Any new functionality added</span></span><br><span class="line"><span class="comment">     * to this method in the future may have to also be added to the VM.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * A zero status value corresponds to state "NEW".</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)<span class="comment">// 状态校验  0：NEW 新建状态</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment">     * so that it can be added to the group's list of threads</span></span><br><span class="line"><span class="comment">     * and the group's unstarted count can be decremented. */</span></span><br><span class="line">    group.add(<span class="keyword">this</span>); <span class="comment">// 添加进线程组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        start0(); <span class="comment">// 调用native方法执行线程run方法</span></span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">if</span> (!started) {</span><br><span class="line">                group.threadStartFailed(<span class="keyword">this</span>); <span class="comment">// 启动失败，从线程组中移除当前前程。</span></span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable ignore) {</span><br><span class="line">            <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">              it will be passed up the call stack */</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure>





<h3 id="3-2-3-yield"><a href="#3-2-3-yield" class="headerlink" title="3.2.3 yield"></a>3.2.3 yield</h3><p><code>yield()</code>：<code>yield()</code>指的是当前线程愿意让出对当前处理器的占用。这里需要注意的是，就算当前线程调用<code>了yield()</code>方法，程序在调度的时候，也还有可能继续运行这个线程的；</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure>





<h3 id="3-2-4-sleep"><a href="#3-2-4-sleep" class="headerlink" title="3.2.4 sleep"></a>3.2.4 sleep</h3><p><code>sleep()</code>：静态方法，使当前线程睡眠一段时间；</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 进行睡眠 线程不会失去任何监视器的所有权。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></tbody></table></figure>





<h3 id="3-2-5-join"><a href="#3-2-5-join" class="headerlink" title="3.2.5 join"></a>3.2.5 join</h3><p><code>join()</code>：使当前线程等待另一个线程执行完毕之后再继续执行，内部调用的是Object类的wait方法实现的；</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 最多等待millis毫秒，使此线程死亡。如果参数为0则意味着永远等待。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    <span class="keyword">if</span> (millis &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 测试此线程是否处于活动状态。如果线程已启动但尚未死亡，则它是活动的。</span></span><br><span class="line">        <span class="keyword">if</span> (isAlive()) {</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">            <span class="comment">// 等待多长时间</span></span><br><span class="line">            <span class="keyword">long</span> delay = millis;</span><br><span class="line">            <span class="keyword">do</span> {</span><br><span class="line">                wait(delay);</span><br><span class="line">            } <span class="keyword">while</span> (isAlive() &amp;&amp; (delay = millis -</span><br><span class="line">                    TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime)) &gt; <span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (millis == <span class="number">0</span>) { <span class="comment">// millis为0，则进行永远等待</span></span><br><span class="line">        <span class="keyword">while</span> (isAlive()) {</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<hr>
<h1 id="4-几种比较"><a href="#4-几种比较" class="headerlink" title="4. 几种比较"></a>4. 几种比较</h1><h2 id="4-1-实现接口-VS-继承Thread"><a href="#4-1-实现接口-VS-继承Thread" class="headerlink" title="4.1 实现接口 VS 继承Thread"></a>4.1 <strong>实现接口 VS 继承Thread</strong></h2><p>这里再稍微总结一下线程创建的两种方式：</p>
<ol>
<li>继承Thread类，并重写run()方法</li>
<li>实现Runnable接口，覆盖接口中的run()方法，并把Runnable接口的实现扔给Thread。</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    <span class="comment">// 第一种</span></span><br><span class="line">    MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">    myThread.start();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第二种</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"自己实现的run-2"</span>)).start();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种继承Thread方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"自己实现的run-1"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>这里抛出一个问题：<strong>写的两种创建线程的方式，都涉及到了<code>run()</code>方法，那么<code>Thread</code>里的<code>run()</code>方法具体是怎么实现的吗？</strong></p>
<p><code>Thread</code> 中的<code>run()</code>方法里东西很少，就一个 if 判断：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) {</span><br><span class="line">        target.run();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>有个<code>target</code>对象，判断该变量是否为null，非空的时候，去执行<code>target</code>对象中的<code>run()</code>方法，否则啥也不干。<u>而这个<code>target</code>对象，就是我们说的<code>Runnable</code></u>：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* What will be run. */</span></span><br><span class="line"><span class="keyword">private</span> Runnable target;</span><br></pre></td></tr></tbody></table></figure>



<p><code>Runnable</code>类很简单，就一个抽象方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    <span class="comment">// run方法是抽象的！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个抽象方法也是<code>run()</code>！如果我们使用<code>Runnable</code>，就需要实现这个方法，由于这个<code>Runnable</code>类上面标了<code>@FunctionalInterface</code>注解，所以可以使用函数式编程。</p>
<p>这样一来：</p>
<ol>
<li>假如我用第一种方式：继承了<code>Thread</code>类，然后重写了<code>run()</code>方法，那么它就不会去执行上面这个默认的<code>run()</code>方法了（即不会去判断<code>target</code>），会执行我重写的<code>run()</code>方法逻辑。</li>
<li>假如我是用的第二种方式：实现<code>Runnable</code>接口的方式，那么它会执行默认的<code>run()</code>方法，然后判断<code>target</code>不为空，再去执行我在<code>Runnable</code>接口中实现的<code>run()</code>方法。</li>
</ol>
<p>还有个问题：如果我既继承了<code>Thread</code>类，同时我又实现了<code>Runnable</code>接口，比如这样，最后会打印什么信息出来呢？</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"runnable run"</span>)) <span class="comment">// 实现Runnable接口的写法</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 继承Thread的写法</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            System.out.println(<span class="string">"Thread run"</span>);</span><br><span class="line">        }</span><br><span class="line">    }.start();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出：</p>
<figure class="highlight dockerfile"><table><tbody><tr><td class="code"><pre><span class="line">Thread <span class="keyword">run</span></span><br></pre></td></tr></tbody></table></figure>

<p>其实这个答案很简单，我们来分析一下代码便知：其实是 new 了一个对象（子对象）继承了<code>Thread</code>对象（父对象），在子对象里重写了父类的<code>run()</code>方法；然后父对象里面扔了个<code>Runnable</code>进去，父对象中的<code>run()</code>方法就是最初那个带有 if 判断的<code>run()</code>方法。</p>
<p>现在执行<code>start()</code>后，肯定先在子类中找<code>run()</code>方法，找到了，父类的<code>run()</code>方法自然就被干掉了，所以会打印出：Thread run。</p>
<p>如果我们现在假设子类中没有重写<code>run()</code>方法，那么必然要去父类找<code>run()</code>方法，父类的<code>run()</code>方法中就得判断是否有<code>Runnable</code>传进来，现在有一个，所以执行<code>Runnable</code>中的<code>run()</code>方法，那么就会打印：Runnable run 出来。</p>
<p>说白了，就是 Java 语言本身的父子继承关系，会优先执行子类重写的方法而已！</p>
<p>我理解的实现接口会更好一些，因为：</p>
<ol>
<li>Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；</li>
<li>类可能只要求可执行就行，继承整个 Thread 类开销过大，如果使用线程时不需要使用Thread类的诸多方法，显然使用<code>Runnable</code> 接口更为轻量。</li>
<li><code>Runnable</code> 接口出现更符合面向对象，将线程单独进行对象的封装。</li>
<li><code>Runnable</code> 接口出现，降低了线程对象和线程任务的耦合性。</li>
</ol>
<p>所以总的来说，还是优先使用实现<code>Runnable</code> 接口方式进行线程的实现较为友好。</p>
<hr>
<h2 id="4-2-Runnable接口-VS-Callable接口"><a href="#4-2-Runnable接口-VS-Callable接口" class="headerlink" title="4.2 Runnable接口 VS Callable接口"></a>4.2 Runnable接口 VS Callable接口</h2><p>总得来说有两个不一样的地方：</p>
<ol>
<li>Runnable 接口不会返回结果或抛出检查异常，但是Callable 接口可以</li>
<li>Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</li>
<li>如果想任务有能够取消的功能，就使用<code>Callable</code>来代替<code>Runnable</code></li>
</ol>
<p>Runnable自Java 1.0以来一直存在，但Callable仅在Java 1.5中引入,目的就是为了来处理Runnable不支持的用例。<strong>Runnable 接口不会返回结果或抛出检查异常，但是Callable 接口可以</strong>。所以，如果任务不需要返回结果或抛出异常推荐使用 Runnable 接口，这样代码看起来会更加简洁。</p>
<p>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    <span class="comment">// 被线程执行，没有返回值也无法抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>Callable接口中的<strong>call()方法是有返回值的，是一个泛型</strong>，和Future、FutureTask配合可以用来获取异步执行的结果。</p>
<p>这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为<strong>多线程充满着未知性</strong>，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>{</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 计算结果，或者在无法这样做的时候抛出异常</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 计算得出的结果</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> 如果无法计算结果，则抛出异常</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注意：</p>
<ul>
<li><strong>工具类 Executors 可以实现 Runnable 对象和 Callable 对象之间的相互转换</strong>。（<code>Executors.callable（Runnable task）</code>或 <code>Executors.callable（Runnable task，Object resule）</code>）。</li>
</ul>
<hr>
<h1 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h1><p>自上面整个流程分析下来，可以很清楚的对几种创建线程方式的理解了，总的来说还是实现Runnable接口比继承Thread更好一些，所以对于我来说比较偏向于使用继承接口，在继承接口有两种可供选择，一种是有返回值的callable，一种是没有返回值的Runnable接口，这就要具体情况具体分析了，看看实际过程中需要使用哪种，对于Thread类也更清晰了，Thread类的几个常用方法也有了一定的理解，总得来说学习过程也更清晰了，还是很开心的。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - 关于指令重排序的几个疑问</title>
    <url>/2020/03/31/java-bing-fa-guan-yu-zhi-ling-chong-pai-xu-de-ji-ge-yi-wen/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-指令重排序"><a href="#1-指令重排序" class="headerlink" title="1.指令重排序"></a>1.指令重排序</h1><p>计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排。</p>
<p>指令重排一般分为以下三种：</p>
<ol>
<li>编译器优化重排：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序</li>
<li>指令并行重排：现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性(即后一个执行的语句无需依赖前面执行的语句的结果)，处理器可以改变语句对应的机器指令的执行顺序。</li>
<li>内存系统重排： 由于处理器使用缓存和读写缓存冲区，这使得加载(load)和存储(store)操作看上去可能是在乱序执行，因为三级缓存的存在，导致内存与缓存的数据同步存在时间差。</li>
</ol>
<h1 id="2-关于指令重排序的几个问题"><a href="#2-关于指令重排序的几个问题" class="headerlink" title="2.关于指令重排序的几个问题"></a>2.关于指令重排序的几个问题</h1><h3 id="为什么指令重排序可以提高性能？"><a href="#为什么指令重排序可以提高性能？" class="headerlink" title="为什么指令重排序可以提高性能？"></a>为什么指令重排序可以提高性能？</h3><p>简单地说，每一个指令都会包含多个步骤，每个步骤可能使用不同的硬件。因此，流水线技术产生了，它的原理是指令1还没有执行完，就可以开始执行指令2，而不用等到指令1执行结束之后再执行指令2，这样就大大提高了效率。</p>
<ul>
<li><p>举个例子：</p>
<ul>
<li><pre class=" language-java"><code class="language-java">a <span class="token operator">=</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>
d <span class="token operator">=</span> e <span class="token operator">-</span> f<span class="token punctuation">;</span>    </code></pre>
</li>
</ul>
</li>
<li><p>先加载b、c（注意，即有可能先加载b，也有可能先加载c），但是在执行add(b,c)的时候，需要等待b、c装载结束才能继续执行，也就是增加了停顿，那么后面的指令也会依次有停顿,这降低了计算机的执行效率。</p>
</li>
<li><p>为了减少这个停顿，我们可以先加载e和f，然后再去加载add(b,c)，这样做对程序（串行）是没有影响的，但却减少了停顿。既然add(b,c)需要停顿，那还不如去做些有意义的事情。</p>
</li>
</ul>
<p>综上所述，指令重排对于提高CPU处理性能十分必要。虽然由此带来了乱序的问题，但是这点牺牲是值得的。</p>
<h3 id="那么为什么指令重排会出现问题呢？"><a href="#那么为什么指令重排会出现问题呢？" class="headerlink" title="那么为什么指令重排会出现问题呢？"></a>那么为什么指令重排会出现问题呢？</h3><p>指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致。所以在多线程下，指令重排序可能会导致一些问题。</p>
<hr>
<h1 id="3-指令重排序的解决方法"><a href="#3-指令重排序的解决方法" class="headerlink" title="3.指令重排序的解决方法"></a>3.指令重排序的解决方法</h1><p>所以，由此引出了<code>Volatile</code>，在一个知识体系中，进行知识的串联是尤为重要的，这就是有些东西的存在必定存在其相对的意义，知其然，知其所以然，才能更好的进行运用。对于Volatile相关的知识，查看后面的内容。</p>
<hr>
<p>以上引用的博客和文章：</p>
<ol>
<li>书籍：并发编程的艺术</li>
<li>书籍：深入浅出Java多线程</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - Synchronized 与其他一些锁机制的对比</title>
    <url>/2020/03/31/java-bing-fa-synchronized-yu-qi-ta-yi-xie-suo-ji-zhi-de-dui-bi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>我们前面已经 Synchronized 在JDK1.6 进行哪一些方面的优化，通过这些底层的优化之后Synchronized  变得好用了很多，那么它究竟和其他锁机制有什么差别？换种方式说，我在进行编程的过程中，究竟要如何进行选择？什么时候应该选择Synchronized？而什么时候不选用Synchronized而选用其他的锁机制。</p>
<p>总感觉学习了Synchronized之后，对于其内部原理熟悉了，不知道有没有其他人跟我一样困惑，我究竟该何时进行使用它呢？在哪个场景下我该第一时间想到这货？我觉得进行选择还应该先进行对比，将和我们之前学习到的一些同步机制进行联系起来，有对比才有总结，尽量多进行比较，多点思考，才有更深入的理解与认识。</p>
<hr>
<h1 id="2-区别分析"><a href="#2-区别分析" class="headerlink" title="2.区别分析"></a>2.区别分析</h1><h2 id="2-1-Synchronized-和-Reentrantlock（可重入锁）的联系与区别："><a href="#2-1-Synchronized-和-Reentrantlock（可重入锁）的联系与区别：" class="headerlink" title="2.1 Synchronized 和 Reentrantlock（可重入锁）的联系与区别："></a>2.1 Synchronized 和 Reentrantlock（可重入锁）的联系与区别：</h2><ul>
<li><p><strong>总体而言</strong>：Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。</p>
<ul>
<li>注意：ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。</li>
</ul>
</li>
<li><p><strong>联系</strong>：</p>
<ul>
<li><strong>两者都是可重入锁</strong><ul>
<li>“可重入锁”  概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>区别</strong>：</p>
<ul>
<li><strong>锁的实现：</strong>synchronized 依赖于 JVM ，而 ReentrantLock 依赖于 API。<ul>
<li>synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</li>
</ul>
</li>
<li><strong>性能：</strong>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。 性能已不是选择标准。</li>
<li><strong>ReentrantLock 比 synchronized 增加了一些高级功能：</strong><ol>
<li><strong>等待可中断：</strong>ReentrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li>
<li><strong>公平锁：</strong>ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。 ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的ReentrantLock(boolean fair)构造方法来制定是否是公平的。</li>
<li><strong>锁绑定多个条件：</strong>synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知”，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>使用选择</strong>：<u>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized</u>。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p>
</li>
</ul>
<hr>
<h2 id="2-2-Synchronized-和-lock-的联系与区别："><a href="#2-2-Synchronized-和-lock-的联系与区别：" class="headerlink" title="2.2 Synchronized 和 lock 的联系与区别："></a>2.2 Synchronized 和 lock 的联系与区别：</h2><ul>
<li><strong>总的来说：</strong>Synchronized是 Java 内置关键字在 Jvm 层面，Lock是个 Java 类。Lock有比 Synchronized 更精确的线程语义和更好的性能。Lock的锁定是通过代码实现的，而Synchronized是在 JVM 层面上实现的。</li>
<li><strong>区别</strong>：<ul>
<li>是否可以获得锁状态：<ul>
<li>synchronized无法判断是否获取锁的状态；</li>
<li>Lock可以判断是否获取到锁，并且可以主动尝试去获取锁。</li>
</ul>
</li>
<li>是否自动释放锁：<ul>
<li>synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)；</li>
<li>Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁。</li>
</ul>
</li>
<li>是否阻塞：<ul>
<li>用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去；</li>
<li>而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了。它的tryLock方法可以非阻塞方式去拿锁。</li>
</ul>
</li>
<li>范围：<ul>
<li>Lock锁的范围有局限性，块范围；</li>
<li>而synchronized可以锁住块、对象、类。</li>
</ul>
</li>
</ul>
</li>
<li><strong>区别小结：</strong>synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）</li>
<li><strong>适用场景：</strong><u>Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题</u>。</li>
</ul>
<hr>
<h2 id="2-3-Synchronized-和-CAS-联系与区别？"><a href="#2-3-Synchronized-和-CAS-联系与区别？" class="headerlink" title="2.3 Synchronized 和 CAS 联系与区别？"></a>2.3 <strong>Synchronized 和 CAS 联系与区别？</strong></h2><ul>
<li><strong>总括：</strong><u>简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）。</u></li>
<li><strong>使用场景选择</strong>：<ul>
<li>对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</li>
<li>对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</li>
</ul>
</li>
<li><strong>补充</strong>： Java并发编程这个领域中synchronized关键字一直都是元老级的角色，很久之前很多人都会称它为 “重量级锁” 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 偏向锁 和 轻量级锁 以及其它各种优化之后变得在某些情况下并不是那么重了。synchronized的底层实现主要依靠 Lock-Free 的队列，基本思路是 自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - Synchronized 几种使用方式</title>
    <url>/2020/03/31/java-bing-fa-synchronized-ji-chong-shi-yong-fang-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-概括"><a href="#1-概括" class="headerlink" title="1.概括"></a>1.概括</h1><p>Synchronized 可以有几种修饰方法，总体使用如下图所示：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/03/31/HiZIwJm32rGoFPv.png"  alt="image.png"></p>
<h1 id="2-具体使用"><a href="#2-具体使用" class="headerlink" title="2.具体使用"></a>2.具体使用</h1><h2 id="2-1-修饰代码块"><a href="#2-1-修饰代码块" class="headerlink" title="2.1 修饰代码块"></a>2.1 <strong>修饰代码块</strong></h2><p>指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</p>
<ul>
<li>注意：<u>它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步</u>。和 synchronized 方法一样，synchronized(this)代码块也是锁定当前对象的。synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。这里再提一下：synchronized关键字加到非 static 静态方法上是给对象实例上锁。另外需要注意的是：尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓冲功能！</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<h2 id="2-2-修饰实例方法"><a href="#2-2-修饰实例方法" class="headerlink" title="2.2 修饰实例方法"></a>2.2 <strong>修饰实例方法</strong></h2><ul>
<li>作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁。</li>
<li>注意：它和同步代码块一样，作用于同一个对象。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="2-3-同步一个类"><a href="#2-3-同步一个类" class="headerlink" title="2.3 同步一个类"></a>2.3 <strong>同步一个类</strong></h2><ul>
<li>注意：作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">synchronized</span> (SynchronizedExample<span class="class">.<span class="keyword">class</span>)</span>{</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="2-4-修饰静态方法"><a href="#2-4-修饰静态方法" class="headerlink" title="2.4 修饰静态方法"></a>2.4 <strong>修饰静态方法</strong></h2><p>作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁 。</p>
<ul>
<li>注意：作用于整个类。也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份，所以对该类的所有对象都加了锁）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> synchronzied <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span> <span class="params">()</span></span>{</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Synchronized 修饰静态方法相当于如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>{</span><br><span class="line">    <span class="comment">// 修饰静态方法</span></span><br><span class="line">    <span class="keyword">synchronized</span>(X<span class="class">.<span class="keyword">class</span>) <span class="title">static</span> <span class="title">void</span> <span class="title">bar</span>()</span>{</span><br><span class="line">        <span class="comment">// 临界区</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - Synchronized 原理分析</title>
    <url>/2020/03/31/java-bing-fa-synchronized-yuan-li-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><p>JDK1.6 之后 Synchronized  的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。</p>
<p>Java中的<code>synchronized</code> 的偏向锁、轻量级锁、重量级锁三种形式，分别对应了锁只被一个线程持有、不同线程交替持有锁、多线程竞争锁三种情况。当条件不满足时，锁会按偏向锁-&gt;轻量级锁-&gt;重量级锁 的顺序升级。JVM种的锁也是能降级的，只不过条件很苛刻，可以相当于没有了，策略是为了提高获得锁和释放锁的效率。</p>
<p>所以对Synchronized 的重点分析应该是其升级流程，以前是我觉得So easy，不就这几个状态升上去而已，不过在某天看了 <a href="https://github.com/farmerjohngit/myblog/issues/12" target="_blank" rel="noopener">死磕Synchronized底层实现</a> 之后，发现我还是太嫩了，这才是真正的深入，也许对知识的求知就该如此不断的进行深入，对于Synchronized 还是有很多值得发现的知识，以下记录了学习到的一些笔记，大概对一整个锁的升级流程有了一些认识和了解。</p>
<ul>
<li>锁升级的过程可以具体看该图，大致的流程框架图很清晰（文末已注明出处）</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/03/31/nCGAmlfKqzhjdv1.png"  alt="Synchronized锁升级流程图"></p>
<hr>
<h1 id="2-Synchronized-锁升级流程分析"><a href="#2-Synchronized-锁升级流程分析" class="headerlink" title="2.Synchronized 锁升级流程分析"></a>2.Synchronized 锁升级流程分析</h1><h2 id="2-1-偏向锁"><a href="#2-1-偏向锁" class="headerlink" title="2.1 偏向锁"></a>2.1 <strong>偏向锁</strong></h2><ul>
<li><p><strong>目的：</strong>引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径。但是不同是：轻量级锁在无竞争的情况下使用 <code>CAS</code> 操作去代替使用互斥量，而偏向锁在无竞争的情况下会把整个同步都消除掉。那么偏向锁是如何来减少不必要的<code>CAS</code>操作呢？我们可以查看<code>Mark work</code>的结构就明白了。只需要检查是否为偏向锁、锁标识为以及<code>ThreadID</code>即可。</p>
</li>
<li><ul>
<li>注意：Java并发编程的艺术中是这么讲的：HotSpot[1]的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。</li>
</ul>
</li>
<li><p><strong>定义：</strong>偏向锁的“偏”就是偏心的偏，它的意思是会偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步！关于偏向锁的原理可以查看《深入理解Java虚拟机：JVM高级特性与最佳实践》第二版的13章第三节锁优化。当<code>JVM</code>启用了偏向锁模式（<code>JDK6</code>以上默认开启），新创建对象的Mark Word中的<code>Thread Id</code>为0，说明此时处于可偏向但未偏向任何线程，也叫<strong>做匿名偏向状态(anonymously biased)。</strong></p>
</li>
<li><p><strong>适用场合：</strong>但是对于锁竞争比较激烈的场合，偏向锁就失效了，<strong>因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失</strong>，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。</p>
</li>
<li><p><strong>关闭偏向锁：</strong>偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用<code>JVM</code>参数来关闭延迟：<code>-XX:BiasedLockingStartupDelay</code>=0。如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过<code>JVM</code>参数关闭偏向锁：<code>-XX:-UseBiasedLocking</code>=false，那么程序默认会进入轻量级锁状态。</p>
</li>
</ul>
<h3 id="2-1-1-Mark-Work-结构"><a href="#2-1-1-Mark-Work-结构" class="headerlink" title="2.1.1 Mark Work 结构"></a>2.1.1 Mark Work 结构</h3><p>关于<code>Mark work</code>结构，可以在任何一本关于Java内存结构的书中了解到很详细了，我们主要关注的是下面的几个字段：<code>thread id</code>、lock flag、biased lock flag。</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/03/31/tBr7NFPumz63acj.png"  alt="image.png"></p>
<h3 id="2-1-2-对象创建"><a href="#2-1-2-对象创建" class="headerlink" title="2.1.2 对象创建"></a>2.1.2 对象创建</h3><p>当 <code>JVM</code> 启用了偏向锁模式（1.6以上默认开启），当新创建一个对象的时候，如果该对象所属的class没有关闭偏向锁模式（默认所有class的偏向模式都是是开启的），那新创建对象的<code>mark word</code>将是可偏向状态，此时mark word中的thread id（参见上文偏向状态下的<code>mark word</code>格式）为0，表示未偏向任何线程，也叫做<u>匿名偏向(anonymously biased)</u>。</p>
<h3 id="2-1-3-偏向锁加锁"><a href="#2-1-3-偏向锁加锁" class="headerlink" title="2.1.3 偏向锁加锁"></a>2.1.3 偏向锁加锁</h3><p>对于偏向锁的加锁，主要分为三种不同情况来看：</p>
<ul>
<li><code>case 1</code>：当该对象第一次被线程获得锁的时候，发现是匿名偏向状态（可偏向未锁定），则会用CAS指令，将<code>mark word</code>中的<code>thread id</code>由0改成当前线程Id。如果成功，则代表获得了偏向锁，继续执行同步块中的代码。否则，即<code>CAS</code>竞争锁失败，对象锁已经被其他线程占用，证明当前存在多线程竞争情况，当到达全局安全点（即为<code>safepoint</code>，<code>safepoint</code>是什么可以具体参考这篇文章：<a href="https://blog.csdn.net/iter_zc/article/details/41847887" target="_blank" rel="noopener">聊聊JVM（六）理解JVM的safepoint</a>），将偏向锁撤销，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块；</li>
<li><code>case 2</code>：当被偏向的线程再次进入同步块时，发现锁对象偏向的就是当前线程（对象头Mark Word中Thread Id是当前线程ID），在通过一些额外的检查后（细节见后面的文章），会往当前线程的栈中添加一条Displaced Mark Word为空的Lock Record中，用来统计重入的次数（如图为当对象所处于偏向锁时，当前线程重入3次，线程栈帧中Lock Record记录）。然后继续执行同步块的代码，因为操纵的是线程私有的栈，因此不需要用到CAS指令；由此可见偏向锁模式下，当被偏向的线程再次尝试获得锁时，仅仅进行几个简单的操作就可以了，在这种情况下，synchronized关键字带来的性能开销基本可以忽略。<ul>
<li><img src="/" class="lazyload" data-src="https://i.loli.net/2020/03/31/AtEPUg6GSiOurk3.png"  alt="线程栈帧"></li>
</ul>
</li>
<li>case 3.当其他线程进入同步块时，发现已经有偏向的线程了，则会进入到撤销偏向锁的逻辑里，一般来说，会在<code>safepoint</code>中去查看偏向的线程是否还存活，如果存活且还在同步块中则将锁升级为轻量级锁，原偏向的线程继续拥有锁，当前线程则走入到锁升级的逻辑里；如果偏向的线程已经不存活或者不在同步块中，则将对象头的<code>mark word</code>改为无锁状态（<code>unlocked</code>），之后再升级为轻量级锁。</li>
</ul>
<p>由此可见，偏向锁升级的时机为：当锁已经发生偏向后，只要有另一个线程尝试获得偏向锁，则该偏向锁就会升级成轻量级锁。当然这个说法不绝对，因为还有批量重偏向这一机制。</p>
<h3 id="2-1-4-偏向锁解锁"><a href="#2-1-4-偏向锁解锁" class="headerlink" title="2.1.4 偏向锁解锁"></a>2.1.4 偏向锁解锁</h3><p>当有其他线程尝试获得锁时，是根据遍历偏向线程的<code>lock record</code>来确定该线程是否还在执行同步块中的代码。因此偏向锁的解锁很简单，仅仅将栈中的最近一条<code>lock record</code>的obj字段设置为null。需要注意的是，偏向锁的解锁步骤中并不会修改对象头中的<code>thread id</code>。</p>
<h3 id="2-1-5-偏向锁获取锁"><a href="#2-1-5-偏向锁获取锁" class="headerlink" title="2.1.5 偏向锁获取锁"></a>2.1.5 偏向锁获取锁</h3><p><strong>取自Java并发编程的艺术：</strong></p>
<ol>
<li>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行<code>CAS</code>操作来加锁和解锁，只需简单地测试一下对象头的<code>Mark Word</code>里是否存储着指向当前线程的偏向锁。</li>
<li>如果测试成功，表示线程已经获得了锁。</li>
<li>如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS<code>竞争</code>锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程</li>
</ol>
<p>网上参考了很多文章，发现说辞不一，十分混乱，大部分都各持己见，这让我看得很晕乎，于是还是更相信底层代码的逻辑，查看官方提供给的 JVM 底层C++代码： <a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/interpreter/bytecodeInterpreter.cpp#l1816" target="_blank" rel="noopener">bytecodeInterpreter.cpp#1816</a>，结合 <a href="https://github.com/farmerjohngit/myblog" target="_blank" rel="noopener">farmerjohngit</a> 大佬所给的一些解释，可以对整个底层实现有更加深刻的理解。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">CASE(_monitorenter): {</span><br><span class="line">  <span class="comment">// lockee 就是锁对象</span></span><br><span class="line">  oop lockee = STACK_OBJECT(<span class="number">-1</span>);</span><br><span class="line">  <span class="comment">// derefing's lockee ought to provoke implicit null check</span></span><br><span class="line">  CHECK_NULL(lockee);</span><br><span class="line">  <span class="comment">// code 1：找到一个空闲的Lock Record</span></span><br><span class="line">  BasicObjectLock* limit = istate-&gt;monitor_base();</span><br><span class="line">  BasicObjectLock* most_recent = (BasicObjectLock*) istate-&gt;stack_base();</span><br><span class="line">  BasicObjectLock* entry = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">while</span> (most_recent != limit ) {</span><br><span class="line">    <span class="keyword">if</span> (most_recent-&gt;obj() == <span class="literal">NULL</span>) entry = most_recent;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (most_recent-&gt;obj() == lockee) <span class="keyword">break</span>;</span><br><span class="line">    most_recent++;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">//entry不为null，代表还有空闲的Lock Record</span></span><br><span class="line">  <span class="keyword">if</span> (entry != <span class="literal">NULL</span>) {</span><br><span class="line">    <span class="comment">// code 2：将Lock Record的obj指针指向锁对象</span></span><br><span class="line">    entry-&gt;set_obj(lockee);</span><br><span class="line">    <span class="keyword">int</span> success = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">uintptr_t</span> epoch_mask_in_place = (<span class="keyword">uintptr_t</span>)markOopDesc::epoch_mask_in_place;</span><br><span class="line">	<span class="comment">// markoop即对象头的mark word</span></span><br><span class="line">    markOop mark = lockee-&gt;mark();</span><br><span class="line">    <span class="keyword">intptr_t</span> hash = (<span class="keyword">intptr_t</span>) markOopDesc::no_hash;</span><br><span class="line">    <span class="comment">// code 3：如果锁对象的mark word的状态是偏向模式</span></span><br><span class="line">    <span class="keyword">if</span> (mark-&gt;has_bias_pattern()) {</span><br><span class="line">      <span class="keyword">uintptr_t</span> thread_ident;</span><br><span class="line">      <span class="keyword">uintptr_t</span> anticipated_bias_locking_value;</span><br><span class="line">      thread_ident = (<span class="keyword">uintptr_t</span>)istate-&gt;thread();</span><br><span class="line">     <span class="comment">// code 4：这里有几步操作，下文分析</span></span><br><span class="line">      anticipated_bias_locking_value =</span><br><span class="line">        (((<span class="keyword">uintptr_t</span>)lockee-&gt;klass()-&gt;prototype_header() | thread_ident) ^ (<span class="keyword">uintptr_t</span>)mark) &amp;</span><br><span class="line">        ~((<span class="keyword">uintptr_t</span>) markOopDesc::age_mask_in_place);</span><br><span class="line">	 <span class="comment">// code 5：如果偏向的线程是自己且epoch等于class的epoch</span></span><br><span class="line">      <span class="keyword">if</span>  (anticipated_bias_locking_value == <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// already biased towards this thread, nothing to do</span></span><br><span class="line">        <span class="keyword">if</span> (PrintBiasedLockingStatistics) {</span><br><span class="line">          (* BiasedLocking::biased_lock_entry_count_addr())++;</span><br><span class="line">        }</span><br><span class="line">        success = <span class="literal">true</span>;</span><br><span class="line">      }</span><br><span class="line">       <span class="comment">// code 6：如果偏向模式关闭，则尝试撤销偏向锁</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((anticipated_bias_locking_value &amp; markOopDesc::biased_lock_mask_in_place) != <span class="number">0</span>) {</span><br><span class="line">        markOop header = lockee-&gt;klass()-&gt;prototype_header();</span><br><span class="line">        <span class="keyword">if</span> (hash != markOopDesc::no_hash) {</span><br><span class="line">          header = header-&gt;copy_set_hash(hash);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 利用CAS操作将mark word替换为class中的mark word</span></span><br><span class="line">        <span class="keyword">if</span> (Atomic::cmpxchg_ptr(header, lockee-&gt;mark_addr(), mark) == mark) {</span><br><span class="line">          <span class="keyword">if</span> (PrintBiasedLockingStatistics)</span><br><span class="line">            (*BiasedLocking::revoked_lock_entry_count_addr())++;</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">         <span class="comment">// code 7：如果epoch不等于class中的epoch，则尝试重偏向</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((anticipated_bias_locking_value &amp; epoch_mask_in_place) !=<span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 构造一个偏向当前线程的mark word</span></span><br><span class="line">        markOop new_header = (markOop) ( (<span class="keyword">intptr_t</span>) lockee-&gt;klass()-&gt;prototype_header() | thread_ident);</span><br><span class="line">        <span class="keyword">if</span> (hash != markOopDesc::no_hash) {</span><br><span class="line">          new_header = new_header-&gt;copy_set_hash(hash);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// CAS替换对象头的mark word  </span></span><br><span class="line">        <span class="keyword">if</span> (Atomic::cmpxchg_ptr((<span class="keyword">void</span>*)new_header, lockee-&gt;mark_addr(), mark) == mark) {</span><br><span class="line">          <span class="keyword">if</span> (PrintBiasedLockingStatistics)</span><br><span class="line">            (* BiasedLocking::rebiased_lock_entry_count_addr())++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">          <span class="comment">// 重偏向失败，代表存在多线程竞争，则调用monitorenter方法进行锁升级</span></span><br><span class="line">          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);</span><br><span class="line">        }</span><br><span class="line">        success = <span class="literal">true</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span> {</span><br><span class="line">         <span class="comment">// 走到这里说明当前要么偏向别的线程，要么是匿名偏向（即没有偏向任何线程）</span></span><br><span class="line">       	<span class="comment">// code 8：下面构建一个匿名偏向的mark word，尝试用CAS指令替换掉锁对象的mark word</span></span><br><span class="line">        markOop header = (markOop) ((<span class="keyword">uintptr_t</span>) mark &amp; ((<span class="keyword">uintptr_t</span>)markOopDesc::biased_lock_mask_in_place |(<span class="keyword">uintptr_t</span>)markOopDesc::age_mask_in_place |epoch_mask_in_place));</span><br><span class="line">        <span class="keyword">if</span> (hash != markOopDesc::no_hash) {</span><br><span class="line">          header = header-&gt;copy_set_hash(hash);</span><br><span class="line">        }</span><br><span class="line">        markOop new_header = (markOop) ((<span class="keyword">uintptr_t</span>) header | thread_ident);</span><br><span class="line">        <span class="comment">// debugging hint</span></span><br><span class="line">        DEBUG_ONLY(entry-&gt;lock()-&gt;set_displaced_header((markOop) (<span class="keyword">uintptr_t</span>) <span class="number">0xdeaddead</span>);)</span><br><span class="line">        <span class="keyword">if</span> (Atomic::cmpxchg_ptr((<span class="keyword">void</span>*)new_header, lockee-&gt;mark_addr(), header) == header) {</span><br><span class="line">           <span class="comment">// CAS修改成功</span></span><br><span class="line">          <span class="keyword">if</span> (PrintBiasedLockingStatistics)</span><br><span class="line">            (* BiasedLocking::anonymously_biased_lock_entry_count_addr())++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">          <span class="comment">// 如果修改失败说明存在多线程竞争，所以进入monitorenter方法</span></span><br><span class="line">          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);</span><br><span class="line">        }</span><br><span class="line">        success = <span class="literal">true</span>;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果偏向线程不是当前线程或没有开启偏向模式等原因都会导致success==false</span></span><br><span class="line">    <span class="keyword">if</span> (!success) {</span><br><span class="line">      <span class="comment">// 轻量级锁的逻辑</span></span><br><span class="line">      <span class="comment">//code 9: 构造一个无锁状态的Displaced Mark Word，并将Lock Record的lock指向它</span></span><br><span class="line">      markOop displaced = lockee-&gt;mark()-&gt;set_unlocked();</span><br><span class="line">      entry-&gt;lock()-&gt;set_displaced_header(displaced);</span><br><span class="line">      <span class="comment">//如果指定了-XX:+UseHeavyMonitors，则call_vm=true，代表禁用偏向锁和轻量级锁</span></span><br><span class="line">      <span class="keyword">bool</span> call_vm = UseHeavyMonitors;</span><br><span class="line">      <span class="comment">// 利用CAS将对象头的mark word替换为指向Lock Record的指针</span></span><br><span class="line">      <span class="keyword">if</span> (call_vm || Atomic::cmpxchg_ptr(entry, lockee-&gt;mark_addr(), displaced) != displaced) {</span><br><span class="line">        <span class="comment">// 判断是不是锁重入</span></span><br><span class="line">        <span class="keyword">if</span> (!call_vm &amp;&amp; THREAD-&gt;is_lock_owned((address) displaced-&gt;clear_lock_bits())) {		<span class="comment">//code 10: 如果是锁重入，则直接将Displaced Mark Word设置为null</span></span><br><span class="line">          entry-&gt;lock()-&gt;set_displaced_header(<span class="literal">NULL</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    UPDATE_PC_AND_TOS_AND_CONTINUE(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">// lock record不够，重新执行</span></span><br><span class="line">    istate-&gt;set_msg(more_monitors);</span><br><span class="line">    UPDATE_PC_AND_RETURN(<span class="number">0</span>); <span class="comment">// Re-execute</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>JVM中的每个类也有一个类似mark word的prototype_header，用来标记该class的epoch和偏向开关等信息。上面的代码中<code>lockee-&gt;klass()-&gt;prototype_header()</code>即获取class的prototype_header。</p>
<p><code>code 1</code></p>
<ul>
<li>从当前线程的栈中找到一个空闲的<code>Lock Record</code>（<strong>即代码中的BasicObjectLock，下文都用Lock Record代指</strong>），判断<code>Lock Record</code>是否空闲的依据是其obj字段 是否为null。注意这里是按内存地址从低往高找到最后一个可用的<code>Lock Record</code>，换而言之，就是找到内存地址最高的可用<code>Lock Record</code>。</li>
</ul>
<p><code>code 2</code></p>
<ul>
<li>获取到<code>Lock Record</code>后，首先要做的就是为其obj字段赋值。</li>
</ul>
<p><code>code 3</code></p>
<ul>
<li>判断锁对象的<code>mark word</code>是否是偏向模式，即低3位是否为101。</li>
</ul>
<p><code>code 4</code></p>
<ul>
<li>这里有几步位运算的操作<code>anticipated_bias_locking_value = (((uintptr_t)lockee-&gt;klass()-&gt;prototype_header() | thread_ident) ^ (uintptr_t)mark) &amp;  ~((uintptr_t) markOopDesc::age_mask_in_place);</code> 这个位运算可以分为3个部分。<ul>
<li>第一部分<code>((uintptr_t)lockee-&gt;klass()-&gt;prototype_header() | thread_ident)</code> 将当前线程id和类的prototype_header相或，这样得到的值为（当前线程id + prototype_header中的（epoch + 分代年龄 + 偏向锁标志 + 锁标志位）），注意prototype_header的分代年龄那4个字节为0</li>
<li>第二部分 <code>^ (uintptr_t)mark</code> 将上面计算得到的结果与锁对象的markOop进行异或，相等的位全部被置为0，只剩下不相等的位。</li>
<li>第三部分 <code>&amp; ~((uintptr_t) markOopDesc::age_mask_in_place)</code> markOopDesc::age_mask_in_place为…0001111000,取反后，变成了…1110000111,除了分代年龄那4位，其他位全为1；将取反后的结果再与上面的结果相与，将上面异或得到的结果中分代年龄给忽略掉。</li>
</ul>
</li>
</ul>
<p><code>code 5</code></p>
<ul>
<li><code>anticipated_bias_locking_value==0</code>代表偏向的线程是当前线程且<code>mark word</code>的epoch等于class的epoch，这种情况下什么都不用做。</li>
</ul>
<p><code>code 6</code></p>
<ul>
<li><p><code>(anticipated_bias_locking_value &amp; markOopDesc::biased_lock_mask_in_place) != 0</code>代表class的prototype_header或对象的<code>mark word</code>中偏向模式是关闭的，又因为能走到这已经通过了<code>mark-&gt;has_bias_pattern()</code>判断，即对象的<code>mark word</code>中偏向模式是开启的，那也就是说class的prototype_header不是偏向模式。</p>
</li>
<li><p>然后利用<code>CAS</code>指令<code>Atomic::cmpxchg_ptr(header, lockee-&gt;mark_addr(), mark) == mark</code>撤销偏向锁，我们知道<code>CAS</code>会有几个参数，1是预期的原值，2是预期修改后的值 ，3是要修改的对象，与之对应，<code>cmpxchg_ptr</code>方法第一个参数是预期修改后的值，第2个参数是修改的对象，第3个参数是预期原值，方法返回实际原值，如果等于预期原值则说明修改成功。</p>
</li>
</ul>
<p><code>code 7</code></p>
<ul>
<li>如果epoch已过期，则需要重偏向，利用CAS指令将锁对象的<code>mark word</code>替换为一个偏向当前线程且epoch为类的epoch的新的<code>mark word</code>。</li>
</ul>
<p><code>code 8</code></p>
<ul>
<li>CAS将偏向线程改为当前线程，如果当前是匿名偏向则能修改成功，否则进入锁升级的逻辑。</li>
</ul>
<p><code>code 9</code></p>
<ul>
<li>这一步已经是轻量级锁的逻辑了。从上图的<code>mark word</code>的格式可以看到，轻量级锁中<code>mark word</code>存的是指向<code>Lock Record</code>的指针。这里构造一个无锁状态的<code>mark word</code>，然后存储到<code>Lock Record</code>（<code>Lock Record</code>的格式可以看第一篇文章）。设置<code>mark word</code>是无锁状态的原因是：轻量级锁解锁时是将对象头的<code>mark word</code>设置为<code>Lock Record</code>中的<code>Displaced Mark Word</code>，所以创建时设置为无锁状态，解锁时直接用CAS替换就好了。</li>
</ul>
<p><code>code 10</code></p>
<ul>
<li>如果是锁重入，则将<code>Lock Record</code>的<code>Displaced Mark Word</code>设置为null，起到一个锁重入计数的作用。</li>
</ul>
<p>通过这部分代码，其实可以对偏向锁加锁的流程（包括部分轻量级锁的加锁流程）有一定的认识了，如果当前锁已偏向其他线程||epoch值过期||偏向模式关闭||获取偏向锁的过程中存在并发冲突，都会进入到<code>InterpreterRuntime::monitorenter</code>方法， 在该方法中会对偏向锁撤销和升级。</p>
<h3 id="2-1-6-偏向锁释放"><a href="#2-1-6-偏向锁释放" class="headerlink" title="2.1.6 偏向锁释放"></a>2.1.6 偏向锁释放</h3><p>偏向锁的释放入口：<a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/interpreter/bytecodeInterpreter.cpp#l1923" target="_blank" rel="noopener">bytecodeInterpreter.cpp#1923</a></p>
<p>上面的代码结合注释理解起来应该不难，偏向锁的释放很简单，只要将对应Lock Record释放就好了，而轻量级锁则需要将Displaced Mark Word替换到对象头的mark word中。如果CAS失败或者是重量级锁则进入到<code>InterpreterRuntime::monitorexit</code>方法中。</p>
<ul>
<li>注意：撤销是指在获取偏向锁的过程因为不满足条件导致要将锁对象改为非偏向锁状态；释放是指退出同步块时的过程</li>
</ul>
<h3 id="2-1-7-偏向锁撤销"><a href="#2-1-7-偏向锁撤销" class="headerlink" title="2.1.7 偏向锁撤销"></a>2.1.7 偏向锁撤销</h3><p>偏向锁的撤销采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）。其步骤如下：</p>
<ol>
<li>暂停拥有偏向锁的线程，检查持有偏向锁的线程状态（遍历当前<code>JVM</code>的所有线程，如果能找到，则说明偏向的线程还存活）；<code>JVM</code>维护了一个集合存放所有存活的线程，通过遍历该集合判断某个线程是否存活。</li>
<li>如果线程还存活，则检查线程是否在执行同步代码块中的代码，如果是，则升级为轻量级锁，进行CAS竞争锁；<ul>
<li>注：每次进入同步块（即执行<code>monitorenter</code>）的时候都会以从高往低的顺序在栈中找到第一个可用的<code>Lock Record</code>，并设置偏向线程ID；每次解锁（即执行<code>monitorexit</code>）的时候都会从最低的一个<code>Lock Record</code>移除。所以如果能找到对应的Lock Record说明偏向的线程还在执行同步代码块中的代码。</li>
</ul>
</li>
<li>如果持有偏向锁的线程未存活，或者持有偏向锁的线程未在执行同步代码块中的代码，则进行校验是否允许重偏向：<ul>
<li>如果不允许重偏向，则撤销偏向锁，将<code>Mark Word</code>设置为无锁状态（未锁定不可偏向状态），然后升级为轻量级锁，进行CAS<code>竞争</code>锁；</li>
<li>如果允许重偏向，设置为匿名偏向锁状态,<code>CAS</code>将偏向锁重新指向线程A（在对象头和线程栈帧的锁记录中存储当前线程ID）；</li>
</ul>
</li>
<li>唤醒暂停的线程，从安全点继续执行代码。</li>
</ol>
<p>偏向锁撤销的具体流程如下所示：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/03/31/EUIOaiTgNluLqzw.png"  alt="偏向锁撤销流程图"></p>
<p>偏向锁撤销的具体底层代码分析如下：</p>
<h3 id="2-1-8-批量重偏向与撤销"><a href="#2-1-8-批量重偏向与撤销" class="headerlink" title="2.1.8 批量重偏向与撤销"></a>2.1.8 批量重偏向与撤销</h3><p>JVM中还增加了一种批量重偏向/撤销的机制，主要是解决如下两种情况：</p>
<ol>
<li>重偏向（<code>bulk rebias</code>）机制解决的场景：一个线程创建了大量对象并执行了初始的同步操作，之后在另一个线程中将这些对象作为锁进行之后的操作。这种case下，会导致大量的偏向锁撤销操作。</li>
<li>批量撤销（<code>bulk revoke</code>）解决的场景：存在明显多线程竞争的场景下使用偏向锁是不合适的，例如生产者/消费者队列。</li>
</ol>
<hr>
<h2 id="2-2-轻量级锁"><a href="#2-2-轻量级锁" class="headerlink" title="2.2 轻量级锁"></a>2.2 轻量级锁</h2><ul>
<li><strong>描述：</strong>倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)。== 轻量级锁不是为了代替重量级锁，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量。== 另外，轻量级锁的加锁和解锁都用到了CAS操作。 关于轻量级锁的加锁和解锁的原理可以查看《深入理解Java虚拟机：JVM高级特性与最佳实践》第二版的13章第三节锁优化。</li>
<li><strong>轻量级锁能够提升程序同步性能的依据：</strong>“对于绝大部分锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用 <code>CAS</code> 操作避免了使用互斥操作的开销。但如果存在锁竞争，除了互斥量开销外，还会额外发生<code>CAS</code>操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁！</li>
</ul>
<h3 id="2-2-1-轻量级锁获取锁"><a href="#2-2-1-轻量级锁获取锁" class="headerlink" title="2.2.1 轻量级锁获取锁"></a>2.2.1 轻量级锁获取锁</h3><p>其获取锁步骤如下：</p>
<ol>
<li>判断当前对象是否处于无锁状态（<code>hashcode</code>、0、01），若是，则JVM首先将在当前线程的栈帧中建立一个名为锁记录（<code>Lock Record</code>）的空间，用于存储锁对象目前的Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即<code>Displaced Mark Word</code>）；否则执行步骤（3）；</li>
<li><code>JVM</code>利用<code>CAS</code>操作尝试将对象的<code>Mark Word</code>更新为指向<code>Lock Record</code>的指正，如果成功表示竞争到锁，则将锁标志位变成00（表示此对象处于轻量级锁状态），执行同步操作；如果失败则执行步骤（3）；</li>
<li>判断当前对象的<code>Mark Word</code>是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态；</li>
</ol>
<p>栈帧 与 <code>Mark Work</code> 关系图示如下：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/03/31/pKTxoGV4clYetOL.png"  alt="image.png"></p>
<p>整体流程图示如下：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/03/31/dCB5fQcuU49j3Pn.png"  alt="image.png"></p>
<p>轻量级锁的锁获取源码：</p>
<h3 id="2-2-2-轻量级锁释放锁"><a href="#2-2-2-轻量级锁释放锁" class="headerlink" title="2.2.2 轻量级锁释放锁"></a>2.2.2 轻量级锁释放锁</h3><p>其释放锁步骤如下（轻量级锁的释放也是通过CAS操作来进行的）：</p>
<ol>
<li>取出在获取轻量级锁保存在<code>Displaced Mark Word</code>中的数据；</li>
<li>用<code>CAS</code>操作将取出的数据替换当前对象的<code>Mark Word</code>中，如果成功，则说明释放锁成功，否则执行（3）；</li>
<li>如果<code>CAS</code>操作替换失败，说明有其他线程尝试获取该锁，则需要在释放锁的同时需要唤醒被挂起的线程。</li>
</ol>
<p>其过程流程图如下所示：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/03/31/8WLE1HjunDXfxJO.png"  alt="轻量级锁释放锁.png"></p>
<h3 id="2-2-3-轻量级锁膨胀"><a href="#2-2-3-轻量级锁膨胀" class="headerlink" title="2.2.3 轻量级锁膨胀"></a>2.2.3 轻量级锁膨胀</h3><p>其过程流程图如下所示</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/03/31/QZesVDEtJqmHl9C.png"  alt="轻量级锁膨胀.png"></p>
<ul>
<li><strong>一个问题：为什么在撤销轻量级锁的时候会有失败的可能？</strong><ul>
<li>假设<code>thread1</code>拥有了轻量级锁，Mark Word指向<code>thread1</code>栈帧，<code>thread2</code>请求锁的时候，就会膨胀初始化<code>ObjectMonitor</code>对象，将Mark Word更新为指向<code>ObjectMonitor</code>的指针，那么在thread1退出的时候，<code>CAS</code>操作会失败，因为Mark Word不再指向<code>thread1</code>的栈帧，这个时候<code>thread1</code>自旋等待<code>infalte</code>完毕，执行重量级锁的退出操作</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-3-自旋锁和自适应自旋"><a href="#2-3-自旋锁和自适应自旋" class="headerlink" title="2.3 自旋锁和自适应自旋"></a>2.3 <strong>自旋锁和自适应自旋</strong></h2><h3 id="2-3-1-自旋锁"><a href="#2-3-1-自旋锁" class="headerlink" title="2.3.1 自旋锁"></a>2.3.1 自旋锁</h3><ul>
<li><strong>描述：</strong>一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的。 所以，虚拟机的开发团队就这样去考虑：“我们能不能让后面来的请求获取锁的线程等待一会而不被挂起呢？看看持有锁的线程是否很快就会释放锁”。为了让一个线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就叫做自旋。<ul>
<li>百度百科对自旋锁的解释：何谓自旋锁？它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。</li>
</ul>
</li>
<li><strong>使用时机：</strong>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。<ul>
<li>互斥同步对性能最大的影响就是阻塞的实现，因为挂起线程/恢复线程的操作都需要转入内核态中完成（用户态转换到内核态会耗费时间）。</li>
</ul>
</li>
<li><strong>关闭与开启：</strong>自旋锁在 <code>JDK1.6</code> 之前其实就已经引入了，不过是默认关闭的，需要通过<code>--XX:+UseSpinning</code>参数来开启。<code>JDK1.6</code>及1.6之后，就改为默认开启的了。需要注意的是：自旋等待不能完全替代阻塞，因为它还是要占用处理器时间。如果锁被占用的时间短，那么效果当然就很好了！反之，相反！自旋等待的时间必须要有限度。如果自旋超过了限定次数任然没有获得锁，就应该挂起线程。自旋次数的默认值是10次，用户可以修改-<code>-XX:PreBlockSpin</code>来更改。</li>
</ul>
<h3 id="2-3-2-自适应自旋锁："><a href="#2-3-2-自适应自旋锁：" class="headerlink" title="2.3.2 自适应自旋锁："></a>2.3.2 <strong>自适应自旋锁：</strong></h3><ul>
<li>描述：在 JDK1.6 中引入了自适应的自旋锁。自适应的自旋锁带来的改进就是：自旋的时间不再固定了，而是和前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定，虚拟机变得越来越“聪明”了。</li>
<li>实现原理：它怎么做呢？线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。 有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测会越来越准确，虚拟机会变得越来越聪明。</li>
</ul>
<hr>
<h2 id="2-4-重量级锁"><a href="#2-4-重量级锁" class="headerlink" title="2.4 重量级锁"></a>2.4 重量级锁</h2><ul>
<li>描述：重量级锁通过对象内部的监视器（<code>monitor</code>）实现，其中<code>monitor</code>的本质是依赖于底层操作系统的<code>Mutex Lock</code>实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</li>
</ul>
<hr>
<h1 id="3-Synchronized-的其他细节问题"><a href="#3-Synchronized-的其他细节问题" class="headerlink" title="3.Synchronized 的其他细节问题"></a>3.Synchronized 的其他细节问题</h1><hr>
<h1 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h1><h2 id="4-1-总结锁的升级流程："><a href="#4-1-总结锁的升级流程：" class="headerlink" title="4.1 总结锁的升级流程："></a>4.1 总结锁的升级流程：</h2><p>每一个线程在准备获取共享资源时： </p>
<ol>
<li>第一步：检查<code>MarkWord</code>里面是不是放的自己的<code>ThreadId</code> ,如果是，表示当前线程是处于 “偏向锁” 。  </li>
<li>第二步：如果<code>MarkWord</code>不是自己的<code>ThreadId</code>，锁升级，这时候，使用<code>CAS</code>来执行切换，新的线程根据<code>MarkWord</code>里面现有的<code>ThreadId</code>，通知之前线程暂停，之前线程将<code>Markword</code>的内容置为空。</li>
<li>第三步：两个线程都把锁对象的<code>HashCode</code>复制到自己新建的用于存储锁的记录空间，接着开始通过<code>CAS</code>操作， 把锁对象的<code>MarKword</code>的内容修改为自己新建的记录空间的地址的方式竞争<code>MarkWord</code>。  </li>
<li>第四步：第三步中成功执行<code>CAS</code>的获得资源，失败的则进自旋 。</li>
<li>第五步：自旋的线程在自旋过程中，成功获得资源(即之前获的资源的线程执行完成并释放了共享资源)，则整个状态依然处于轻量级锁的状态，如果自旋失败进入第六步 。</li>
<li>第六步：进行重量级锁的状态，这个时候，自旋的线程进行阻塞，等待之前线程执行完成并唤醒自己。</li>
</ol>
<h2 id="4-2-几种锁的优缺点对比"><a href="#4-2-几种锁的优缺点对比" class="headerlink" title="4.2 几种锁的优缺点对比"></a>4.2 几种锁的优缺点对比</h2><p>下图摘自：并发编程的艺术</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/03/31/8U6mNSjGLeKMrEB.png"  alt="image.png"></p>
<p>以上参考文章：</p>
<ul>
<li><a href="https://blog.dreamtobe.cn/2015/11/13/java_synchronized/" target="_blank" rel="noopener">Java Synchronised机制</a></li>
<li><a href="https://github.com/farmerjohngit/myblog/issues/13" target="_blank" rel="noopener">死磕Synchronized底层实现–偏向锁</a></li>
<li><a href="https://blog.csdn.net/iter_zc/article/details/41847887" target="_blank" rel="noopener">聊聊JVM（六）理解JVM的safepoint</a></li>
<li><a href="http://cmsblogs.com/?p=2071" target="_blank" rel="noopener">【死磕Java并发】—–深入分析synchronized的实现原理</a></li>
<li>书籍：Java 并发编程的艺术</li>
<li>书籍：深入理解Java虚拟机：JVM高级特性与最佳实践</li>
<li>书籍：深入浅出Java 多线程</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础 - Static关键字的一些认识</title>
    <url>/2020/03/31/java-ji-chu-static-guan-jian-zi-de-yi-xie-ren-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java基础知识</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础 - 关于Object的一些认识</title>
    <url>/2020/03/31/java-ji-chu-guan-yu-object-de-yi-xie-ren-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java基础知识</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础 - Int和Integer的一些认识</title>
    <url>/2020/03/31/java-ji-chu-int-he-integer-de-yi-xie-ren-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java基础知识</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础 - String的一些认识</title>
    <url>/2020/03/31/java-ji-chu-string-de-yi-xie-ren-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java基础知识</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础 - Java8的一些认识</title>
    <url>/2020/03/31/java-ji-chu-java8-de-yi-xie-ren-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java基础知识</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础 - 关于序列化的一些认识</title>
    <url>/2020/03/31/java-ji-chu-guan-yu-xu-lie-hua-de-yi-xie-ren-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-Java序列化的框架"><a href="#1-Java序列化的框架" class="headerlink" title="1.Java序列化的框架"></a>1.Java序列化的框架</h1><ul>
<li>序列化：将对象写入到IO流中</li>
<li>反序列化：从IO流中恢复对象</li>
<li>意义：序列化机制允许将实现序列化的Java对象转换位字节序列，这些字节序列可以保存在磁盘上，或通过网络传输，以达到以后恢复成原来的对象。序列化机制使得对象可以脱离程序的运行而独立存在。</li>
<li>使用场景：所有可在网络上传输的对象都必须是可序列化的，比如RMI（remote method invoke,即远程方法调用），传入的参数或返回的对象都是可序列化的，否则会出错；所有需要保存到磁盘的java对象都必须是可序列化的。通常建议：程序创建的每个JavaBean类都实现Serializeable接口。</li>
</ul>
<p>如果需要将某个对象保存到磁盘上或者通过网络传输，那么这个类应该实现Serializable接口或者Externalizable接口之一。</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/08/543gzQLwXAWZ12I.png"  alt="两种接口"></p>
<p><strong>虽然Externalizable接口带来了一定的性能提升，但变成复杂度也提高了，所以一般通过实现Serializable接口进行序列化。</strong></p>
<hr>
<h1 id="2-Serializable序列化的几种方式"><a href="#2-Serializable序列化的几种方式" class="headerlink" title="2.Serializable序列化的几种方式"></a>2.Serializable序列化的几种方式</h1><h2 id="2-1-普通序列化"><a href="#2-1-普通序列化" class="headerlink" title="2.1 普通序列化"></a>2.1 普通序列化</h2><p>Serializable接口是一个标记接口，不用实现任何方法。一旦实现了此接口，该类的对象就是可序列化的。</p>
<h3 id="序列化步骤"><a href="#序列化步骤" class="headerlink" title="序列化步骤"></a>序列化步骤</h3><ol>
<li>步骤一：创建一个ObjectOutputStream输出流；</li>
<li>步骤二：调用ObjectOutputStream对象的writeObject输出可序列化对象。</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 不提供无参构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重写toString</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteObject</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            <span class="comment">// 创建一个ObjectOutputStream 输出流</span></span><br><span class="line">            ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"object.txt"</span>))) {</span><br><span class="line">            <span class="comment">// 将对象序列化到文件</span></span><br><span class="line">            Person person = <span class="keyword">new</span> Person(<span class="string">"嘻嘻"</span>, <span class="number">123</span>);</span><br><span class="line">            oos.writeObject(person);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="反序列化步骤"><a href="#反序列化步骤" class="headerlink" title="反序列化步骤"></a>反序列化步骤</h3><ol>
<li>步骤一：创建一个ObjectInputStream输入流；</li>
<li>步骤二：调用ObjectInputStream对象的readObject()得到序列化的对象。</li>
</ol>
<p>将上面序列化到person.txt的person对象反序列化回来</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 不提供无参构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"反序列化，你调用我了吗？"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 重写toString</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadObject</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            <span class="comment">// 创建一个ObjectInputStream输入流</span></span><br><span class="line">            ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"person.txt"</span>))) {</span><br><span class="line">            <span class="comment">// 进行一个强行转换</span></span><br><span class="line">            Person brady = (Person) ois.readObject();</span><br><span class="line">            <span class="comment">// 打印</span></span><br><span class="line">            System.out.println(brady);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line">Person{<span class="attribute">name</span>=<span class="string">'嘻嘻'</span>, <span class="attribute">age</span>=123}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>输出告诉我们，反序列化并不会调用构造方法。反序列的对象是由JVM自己生成的对象，不通过构造方法生成。</strong></p>
<hr>
<h2 id="2-2-成员是引用的序列化"><a href="#2-2-成员是引用的序列化" class="headerlink" title="2.2 成员是引用的序列化"></a>2.2 成员是引用的序列化</h2><p>如果一个可序列化的类的成员不是基本类型，也不是String类型，那这个引用类型也必须是可序列化的；否则，会导致此类不能序列化。</p>
<p>看例子，我们新增一个Teacher类。将Person去掉实现Serializable接口代码。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个Person类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>{</span><br><span class="line">    <span class="comment">//省略相关属性与方法</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个Teacher类，并且实现了序列化接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">(String name, Person person)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.person = person;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"teacher.txt"</span>))) {</span><br><span class="line">            Person person = <span class="keyword">new</span> Person(<span class="string">"乔布斯"</span>, <span class="number">20</span>);</span><br><span class="line">            Teacher teacher = <span class="keyword">new</span> Teacher(<span class="string">"雷布斯"</span>, person);</span><br><span class="line">            oos.writeObject(teacher);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>发现会报错：</p>
<p><img src="/" class="lazyload" data-src="https://img2018.cnblogs.com/blog/1603499/201905/1603499-20190521180304399-894547036.jpg"  alt="报错如上"></p>
<p>我们看到程序直接报错，因为Person类的对象是不可序列化的，这导致了Teacher的对象不可序列化</p>
<hr>
<h2 id="2-3-同一对象序列化多次的机制"><a href="#2-3-同一对象序列化多次的机制" class="headerlink" title="2.3 同一对象序列化多次的机制"></a>2.3 同一对象序列化多次的机制</h2><p>同一对象序列化多次，会将这个对象序列化多次吗？答案是否定的。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteTeacher</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"teacher.txt"</span>))) {</span><br><span class="line">            Person person = <span class="keyword">new</span> Person(<span class="string">"路飞"</span>, <span class="number">20</span>);</span><br><span class="line">            Teacher t1 = <span class="keyword">new</span> Teacher(<span class="string">"雷利"</span>, person);</span><br><span class="line">            Teacher t2 = <span class="keyword">new</span> Teacher(<span class="string">"红发香克斯"</span>, person);</span><br><span class="line">            <span class="comment">//依次将4个对象写入输入流</span></span><br><span class="line">            oos.writeObject(t1);</span><br><span class="line">            oos.writeObject(t2);</span><br><span class="line">            oos.writeObject(person);</span><br><span class="line">            oos.writeObject(t2);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上是依次将t1、t2、person、t2对象序列化到文件teacher.txt文件中。</p>
<p>注意：反序列化的顺序与序列化时的顺序一致。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadTeacher</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> (ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"teacher.txt"</span>))) {</span><br><span class="line">            Teacher t1 = (Teacher) ois.readObject();</span><br><span class="line">            Teacher t2 = (Teacher) ois.readObject();</span><br><span class="line">            Person p = (Person) ois.readObject();</span><br><span class="line">            Teacher t3 = (Teacher) ois.readObject();</span><br><span class="line">            System.out.println(t1 == t2);</span><br><span class="line">            System.out.println(t1.getPerson() == p);</span><br><span class="line">            System.out.println(t2.getPerson() == p);</span><br><span class="line">            System.out.println(t2 == t3);</span><br><span class="line">            System.out.println(t1.getPerson() == t2.getPerson());</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure>



<p>Java序列化算法</p>
<ol>
<li>所有保存到磁盘的对象都有一个序列化编码号</li>
<li>当程序试图序列化一个对象时，会先检查此对象是否已经序列化过，只有此对象从未（在此虚拟机）被序列化过，才会将此对象序列化为字节序列输出。</li>
<li>如果此对象已经序列化过，则直接输出编号即可。</li>
</ol>
<p><img src="/" class="lazyload" data-src="https://img2018.cnblogs.com/blog/1603499/201905/1603499-20190521180352659-740977206.jpg"  alt="上述序列化过程"></p>
<hr>
<h1 id="3-序列化自定义的几种方法"><a href="#3-序列化自定义的几种方法" class="headerlink" title="3.序列化自定义的几种方法"></a>3.序列化自定义的几种方法</h1><h2 id="3-1-使用transient"><a href="#3-1-使用transient" class="headerlink" title="3.1 使用transient"></a>3.1 使用transient</h2><p>有些时候，我们有这样的需求，某些属性不需要序列化。<strong>使用transient关键字选择不需要序列化的字段</strong>。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>{</span><br><span class="line">   <span class="comment">//不需要序列化名字与年龄</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> String name;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> age;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> height;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">boolean</span> singlehood;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>{</span><br><span class="line">       <span class="keyword">this</span>.name = name;</span><br><span class="line">       <span class="keyword">this</span>.age = age;</span><br><span class="line">   }</span><br><span class="line">   <span class="comment">//省略get,set方法</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransientTest</span> </span>{</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">       <span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"person.txt"</span>));</span><br><span class="line">            ObjectInputStream ios = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"person.txt"</span>))) {</span><br><span class="line">           Person person = <span class="keyword">new</span> Person(<span class="string">"9龙"</span>, <span class="number">23</span>);</span><br><span class="line">           person.setHeight(<span class="number">185</span>);</span><br><span class="line">           System.out.println(person);</span><br><span class="line">           oos.writeObject(person);</span><br><span class="line">           Person p1 = (Person)ios.readObject();</span><br><span class="line">           System.out.println(p1);</span><br><span class="line">       }</span><br><span class="line">   }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//Person{name='9龙', age=23', singlehood=true', height=185cm}</span></span><br><span class="line"><span class="comment">//Person{name='null', age=0', singlehood=false', height=185cm}</span></span><br></pre></td></tr></tbody></table></figure>



<p>从输出我们看到，使用transient修饰的属性，java序列化时，会忽略掉此字段，所以反序列化出的对象，被transient修饰的属性是默认值。对于引用类型，值是null；基本类型，值是0；boolean类型，值是false。</p>
<hr>
<h2 id="3-2-重写writeObject与readObject方法"><a href="#3-2-重写writeObject与readObject方法" class="headerlink" title="3.2 重写writeObject与readObject方法"></a>3.2 重写writeObject与readObject方法</h2><p>使用transient虽然简单，但将此属性完全隔离在了序列化之外。java提供了可选的自定义序列化。可以进行控制序列化的方式，或者对序列化数据进行编码加密等。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException；</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectIutputStream in)</span> <span class="keyword">throws</span> IOException,ClassNotFoundException</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObjectNoData</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>;</span><br></pre></td></tr></tbody></table></figure>

<p><strong>通过重写writeObject与readObject方法，可以自己选择哪些属性需要序列化， 哪些属性不需要</strong>。如果writeObject使用某种规则序列化，则相应的readObject需要相反的规则反序列化，以便能正确反序列化出对象。这里展示对名字进行反转加密。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>{</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">   <span class="comment">// 省略构造方法，get及set方法</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">       <span class="comment">// 将名字反转写入二进制流</span></span><br><span class="line">       out.writeObject(<span class="keyword">new</span> StringBuffer(<span class="keyword">this</span>.name).reverse());</span><br><span class="line">       out.writeInt(age);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream ins)</span> <span class="keyword">throws</span> IOException,ClassNotFoundException</span>{</span><br><span class="line">       <span class="comment">// 将读出的字符串反转恢复回来</span></span><br><span class="line">       <span class="keyword">this</span>.name = ((StringBuffer)ins.readObject()).reverse().toString();</span><br><span class="line">       <span class="keyword">this</span>.age = ins.readInt();</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当序列化流不完整时，readObjectNoData()方法可以用来正确地初始化反序列化的对象。例如，使用不同类接收反序列化对象，或者序列化流被篡改时，系统都会调用readObjectNoData()方法来初始化反序列化的对象。</p>
<p>注意：可能由此引出<strong>拷贝相关的问题！</strong></p>
<hr>
<h2 id="3-3-更彻底的自定义序列化"><a href="#3-3-更彻底的自定义序列化" class="headerlink" title="3.3 更彻底的自定义序列化"></a>3.3 更彻底的自定义序列化</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">ANY-ACCESS-<span class="function">MODIFIER Object <span class="title">writeReplace</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>;</span><br><span class="line">ANY-ACCESS-<span class="function">MODIFIER Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>writeReplace：在序列化时，会先调用此方法，再调用writeObject方法。此方法可将任意对象代替目标序列化对象</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略构造方法，get及set方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先调用此方法，再调用 writeObject方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">writeReplace</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>{</span><br><span class="line">        ArrayList&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="keyword">this</span>.name);</span><br><span class="line">        list.add(<span class="keyword">this</span>.age);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"person.txt"</span>));</span><br><span class="line">             ObjectInputStream ios = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"person.txt"</span>))) {</span><br><span class="line">            Person person = <span class="keyword">new</span> Person(<span class="string">"嘻嘻"</span>, <span class="number">123</span>);</span><br><span class="line">            <span class="comment">// 调用 oos.writeObject 进行写入</span></span><br><span class="line">            oos.writeObject(person);</span><br><span class="line">            <span class="comment">// 所以我们可以直接读出</span></span><br><span class="line">            ArrayList list = (ArrayList)ios.readObject();</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line">[嘻嘻, <span class="number">123</span>]</span><br></pre></td></tr></tbody></table></figure>



<p>readResolve：反序列化时替换反序列化出的对象，<strong>反序列化出来的对象被立即丢弃</strong>。此方法在readeObject后调用。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 省略构造方法，get及set方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意这里实现了 readResolve</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> (<span class="string">"brady"</span>, <span class="number">23</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"person.txt"</span>));</span><br><span class="line">             ObjectInputStream ios = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"person.txt"</span>))) {</span><br><span class="line">            Person person = <span class="keyword">new</span> Person(<span class="string">"嘻嘻"</span>, <span class="number">123</span>);</span><br><span class="line">            oos.writeObject(person);</span><br><span class="line">            <span class="comment">// 使用HashMap来接收</span></span><br><span class="line">            HashMap map = (HashMap)ios.readObject();</span><br><span class="line">            System.out.println(map);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line">{<span class="attribute">brady</span>=23}</span><br></pre></td></tr></tbody></table></figure>

<p>readResolve常用来反序列单例类，保证单例类的唯一性。</p>
<p>注意：readResolve与writeReplace的访问修饰符可以是private、protected、public，如果父类重写了这两个方法，子类都需要根据自身需求重写，这显然不是一个好的设计。通常建议对于final修饰的类重写readResolve方法没有问题；否则，重写readResolve使用private修饰。</p>
<hr>
<h1 id="4-序列化存在的问题"><a href="#4-序列化存在的问题" class="headerlink" title="4.序列化存在的问题"></a>4.序列化存在的问题</h1><p>由于java序利化算法不会重复序列化同一个对象，只会记录已序列化对象的编号。如果序列化一个可变对象（对象内的内容可更改）后，更改了对象内容，再次序列化，并不会再次将此对象转换为字节序列，而只是保存序列化编号。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteObject</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"person.txt"</span>));</span><br><span class="line">             ObjectInputStream ios = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"person.txt"</span>))) {</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 第一次序列化person</span></span><br><span class="line">            Person person = <span class="keyword">new</span> Person(<span class="string">"嘻嘻"</span>, <span class="number">23</span>);</span><br><span class="line">            oos.writeObject(person);</span><br><span class="line">            System.out.println(person);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//修改name</span></span><br><span class="line">            person.setName(<span class="string">"西瓜"</span>);</span><br><span class="line">            System.out.println(person);</span><br><span class="line">            <span class="comment">//第二次序列化person</span></span><br><span class="line">            oos.writeObject(person);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//依次反序列化出p1、p2</span></span><br><span class="line">            Person p1 = (Person) ios.readObject();</span><br><span class="line">            Person p2 = (Person) ios.readObject();</span><br><span class="line">            System.out.println(p1 == p2);</span><br><span class="line">            System.out.println(p1.getName().equals(p2.getName()));</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>输出结果：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Person{name=<span class="string">'嘻嘻'</span>, age=<span class="number">23</span>}</span><br><span class="line">Person{name=<span class="string">'西瓜'</span>, age=<span class="number">23</span>}</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></tbody></table></figure>



<p>两个名字居然可以equals，这就是很奇葩了吧！所以这个就是问题所在了？怎么解决呢？暂时还没想到，留意一下，后面再进行解决！</p>
<hr>
<h1 id="5-常见的序列化协议"><a href="#5-常见的序列化协议" class="headerlink" title="5.常见的序列化协议"></a>5.常见的序列化协议</h1><p>常见的有json和xml，后面补上详细的内容</p>
<hr>
<h1 id="6-其余问题"><a href="#6-其余问题" class="headerlink" title="6.其余问题"></a>6.其余问题</h1><h2 id="6-1-serializable的Id用处"><a href="#6-1-serializable的Id用处" class="headerlink" title="6.1 serializable的Id用处"></a>6.1 serializable的Id用处</h2><p><strong>摘录一：</strong></p>
<p>序列化ID起着关键的作用，java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。反序列化时，JVM会把传来的字节流中的serialVersionUID与本地实体类中的serialVersionUID进行比较，如果相同则认为是一致的，便可以进行反序列化，否则就会报序列化版本不一致的异常。</p>
<p><strong>摘录二：</strong></p>
<p>我们知道，反序列化必须拥有class文件，但随着项目的升级，class文件也会升级，<strong>序列化怎么保证升级前后的兼容性呢？</strong></p>
<p>java序列化提供了一个<code>private static final long serialVersionUID</code> 的序列化版本号，只有版本号相同，即使更改了序列化属性，对象也可以正确被反序列化回来。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>{</span><br><span class="line">    <span class="comment">//序列化版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1111013L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//省略构造方法及get,set</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果反序列化使用的<strong>class的版本号</strong>与序列化时使用的<strong>不一致</strong>，反序列化会<strong>报InvalidClassException异常</strong>。</p>
<p><img src="/" class="lazyload" data-src="https://img2018.cnblogs.com/blog/1603499/201905/1603499-20190521180432865-1645890598.jpg"  alt="InvalidClassException异常"></p>
<p>序列化版本号可自由指定，如果不指定，JVM会根据类信息自己计算一个版本号，这样随着class的升级，就无法正确反序列化；不指定版本号另一个明显隐患是，不利于jvm间的移植，可能class文件没有更改，但不同jvm可能计算的规则不一样，这样也会导致无法反序列化。</p>
<p><strong>那么什么情况下需要修改serialVersionUID呢？</strong></p>
<p>分三种情况：</p>
<ol>
<li>如果只是修改了方法，反序列化不容影响，则无需修改版本号；</li>
<li>如果只是修改了静态变量，瞬态变量（transient修饰的变量），反序列化不受影响，无需修改版本号；</li>
<li>如果修改了非瞬态变量，则可能导致反序列化失败。<strong>如果新类中实例变量的类型与序列化时类的类型不一致，则会反序列化失败，这时候需要更改serialVersionUID</strong>。如果只是新增了实例变量，则反序列化回来新增的是默认值；如果减少了实例变量，反序列化时会忽略掉减少的实例变量。</li>
</ol>
<hr>
<p>以上参考文章：</p>
<ol>
<li><a href="https://www.cnblogs.com/9dragon/p/10901448.html" target="_blank" rel="noopener">java序列化，看这篇就够了</a></li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java基础知识</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础 - 关于泛型的一些认识</title>
    <url>/2020/03/31/java-ji-chu-guan-yu-fan-xing-de-yi-xie-ren-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java基础知识</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础 - 关于反射的一些认识</title>
    <url>/2020/03/31/java-ji-chu-guan-yu-fan-she-de-yi-xie-ren-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java基础知识</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - 深入线程池原理</title>
    <url>/2020/03/31/java-bing-fa-shen-ru-xian-cheng-chi-yuan-li/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-线程池简介"><a href="#1-线程池简介" class="headerlink" title="1.线程池简介"></a>1.线程池简介</h1><h2 id="1-1-线程池是什么？"><a href="#1-1-线程池是什么？" class="headerlink" title="1.1 线程池是什么？"></a>1.1 线程池是什么？</h2><p>线程池（Thread Pool）是一种基于池化思想管理线程的工具，经常出现在多线程服务器中，如MySQL。</p>
<p>线程池可以简单看做是一组线程的集合，通过使用线程池，我们可以方便的复用线程，避免了频繁创建和销毁线程所带来的开销。在应用上，线程池可应用在后端相关服务中。比如 Web 服务器，数据库服务器等。以 Web 服务器为例，假如 Web 服务器会收到大量短时的 HTTP 请求，如果此时我们简单的为每个 HTTP 请求创建一个处理线程，那么服务器的资源将会很快被耗尽。当然我们也可以自己去管理并复用已创建的线程，以限制资源的消耗量，但这样会使用程序的逻辑变复杂。好在，幸运的是，我们不必那样做。在 JDK 1.5 中，官方已经提供了强大的线程池工具类。通过使用这些工具类，我们可以用低廉的代价使用多线程技术。</p>
<p>线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。线程池维护多个线程，等待监督管理者分配可并发执行的任务。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。</p>
<h2 id="1-2-为什么要使用线程池？"><a href="#1-2-为什么要使用线程池？" class="headerlink" title="1.2 为什么要使用线程池？"></a>1.2 为什么要使用线程池？</h2><p>使用线程池主要有以下三个原因：</p>
<ol>
<li><p>创建/销毁线程需要消耗系统资源，线程池可以<strong>复用已创建的线程</strong>。</p>
<blockquote>
<p>例如：</p>
<p>记创建线程消耗时间T1，执行任务消耗时间T2，销毁线程消耗时间T3</p>
<p>如果T1+T3&gt;T2，那么是不是说开启一个线程来执行这个任务太不划算了！</p>
<p>正好，线程池缓存线程，可用已有的闲置线程来执行新任务，避免了T1+T3带来的系统开销</p>
</blockquote>
</li>
<li><p><strong>控制并发的数量</strong>。并发数量过多，可能会导致资源消耗过多，从而造成服务器崩溃。（主要原因）</p>
<blockquote>
<p>我们知道线程能共享系统资源，如果同时执行的线程过多，就有可能导致系统资源不足而产生阻塞的情况</p>
<p>运用线程池能有效的控制线程最大并发数，避免以上的问题</p>
</blockquote>
</li>
<li><p><strong>可以对线程做统一管理</strong></p>
<blockquote>
<p>比如：延时执行、定时循环执行的策略等</p>
<p>运用线程池都能进行很好的实现</p>
</blockquote>
</li>
</ol>
<p>线程池带来的一系列好处：</p>
<ol>
<li><strong>降低资源消耗</strong>：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。</li>
<li><strong>提高响应速度</strong>：任务到达时，无需等待线程创建即可立即执行。</li>
<li><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。</li>
<li><strong>提供更多更强大的功能</strong>：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池<code>ScheduledThreadPoolExecutor</code>，就允许任务延期执行或定期执行。</li>
</ol>
<h2 id="1-3-线程池解决的问题是什么？"><a href="#1-3-线程池解决的问题是什么？" class="headerlink" title="1.3 线程池解决的问题是什么？"></a>1.3 线程池解决的问题是什么？</h2><p><strong>线程池解决的核心问题就是资源管理问题</strong>。在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入。这种不确定性将带来以下若干问题：</p>
<ol>
<li>频繁申请/销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。</li>
<li>对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。</li>
<li>系统无法合理管理内部的资源分布，会降低系统的稳定性。</li>
</ol>
<p>为解决资源分配这个问题，线程池采用了“池化”（Pooling）思想。池化，顾名思义，是为了最大化收益并最小化风险，而将资源统一在一起管理的一种思想。</p>
<blockquote>
<p>Pooling is the grouping together of resources (assets, equipment, personnel, effort, etc.) for the purposes of maximizing advantage or minimizing risk to the users. The term is used in finance, computing and equipment management.——wikipedia</p>
</blockquote>
<p>“池化”思想不仅仅能应用在计算机领域，在金融、设备、人员管理、工作管理等领域也有相关的应用。</p>
<p>在计算机领域中的表现为：统一管理IT资源，包括服务器、存储、和网络资源等等。通过共享资源，使用户在低投入中获益。除去线程池，还有其他比较典型的几种使用策略包括：</p>
<ol>
<li>内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。</li>
<li>连接池(Connection Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。</li>
<li>实例池(Object Pooling)：循环使用对象，减少资源在初始化和释放时的昂贵损耗。</li>
</ol>
<hr>
<h1 id="2-线程池核心设计与实现"><a href="#2-线程池核心设计与实现" class="headerlink" title="2.线程池核心设计与实现"></a>2.线程池核心设计与实现</h1><h2 id="2-1-线程池的总体设计"><a href="#2-1-线程池的总体设计" class="headerlink" title="2.1 线程池的总体设计"></a>2.1 线程池的总体设计</h2><p>Java中的线程池核心实现类是<code>ThreadPoolExecutor</code>，本章基于<code>JDK 1.8</code>的源码来分析Java线程池的核心设计与实现。我们首先来看一下<code>ThreadPoolExecutor</code>的UML类图，了解下<code>ThreadPoolExecutor</code>的继承关系。</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/03/GEHWRmfyZnB1u95.png"  alt="线程池UML图"></p>
<p><code>ThreadPoolExecutor</code> 实现的顶层接口是<code>Executor</code>，顶层接口<code>Executor</code>提供了一种思想：将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供<code>Runnable</code>对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。</p>
<p><code>ExecutorService</code> 接口增加了一些能力：</p>
<ol>
<li>扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法；</li>
<li>提供了管控线程池的方法，比如停止线程池的运行。</li>
</ol>
<p><code>AbstractExecutorService</code> 则是上层的抽象类，将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。最下层的实现类<code>ThreadPoolExecutor</code> 实现最复杂的运行部分，<code>ThreadPoolExecutor</code> 将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。</p>
<p><code>ThreadPoolExecutor</code> 是如何运行，如何同时维护线程和执行任务的呢？其运行机制如下图所示：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/03/jrgxYTBGiMvQOnb.png"  alt="ThreadPoolExecutor 机制"></p>
<hr>
<h2 id="2-2-线程池的生命周期管理"><a href="#2-2-线程池的生命周期管理" class="headerlink" title="2.2 线程池的生命周期管理"></a>2.2 线程池的生命周期管理</h2><p>此部分是尤为重要的一点，要了解内部是如何运作的，肯定要了解一些线程的状态是如何设定的。</p>
<p>下面介绍下线程池的运行状态. 线程池一共有五种状态, 分别是：</p>
<ol>
<li><p><strong>RUNNING</strong> ：能接受新提交的任务，并且也能处理阻塞队列中的任务；</p>
</li>
<li><p><strong>SHUTDOWN</strong>：关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。在线程池处于 RUNNING 状态时，调用 <code>shutdown()</code>方法会使线程池进入到该状态。（<code>finalize()</code> 方法在执行过程中也会调用<code>shutdown()</code>方法进入该状态）；</p>
</li>
<li><p><strong>STOP</strong>：不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 <code>shutdownNow()</code> 方法会使线程池进入到该状态；</p>
</li>
<li><p><strong>TIDYING</strong>：如果所有的任务都已终止了，<code>workerCount</code> (有效线程数) 为0，线程池进入该状态后会调用 <code>terminated()</code> 方法进入TERMINATED 状态。</p>
</li>
<li><p><strong>TERMINATED</strong>：在<code>terminated()</code> 方法执行完后进入该状态，默认<code>terminated()</code>方法中什么也没有做。</p>
<p>进入TERMINATED的条件如下：</p>
<ul>
<li>线程池不是RUNNING状态；</li>
<li>线程池状态不是TIDYING状态或TERMINATED状态；</li>
<li>如果线程池状态是SHUTDOWN并且<code>workerQueue</code>为空；</li>
<li><code>workerCount</code>为0；</li>
<li>设置TIDYING状态成功。</li>
</ul>
</li>
</ol>
<p>这五种状态如下所示：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/03/MKbLGHAohriWvJ2.png"  alt="五种运行状态"></p>
<p>下图为线程池的状态转换过程：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/03/nA6PoyfibGhe149.png"  alt="线程池状态转换"></p>
<hr>
<h2 id="2-3-线程池主要的任务执行机制"><a href="#2-3-线程池主要的任务执行机制" class="headerlink" title="2.3 线程池主要的任务执行机制"></a>2.3 线程池主要的任务执行机制</h2><p>主要分为四点进行解析：任务调度、任务缓存、任务申请、任务拒绝</p>
<h3 id="2-3-1-任务调度"><a href="#2-3-1-任务调度" class="headerlink" title="2.3.1 任务调度"></a>2.3.1 任务调度</h3><p>任务调度是线程池的主要入口，当用户提交了一个任务，接下来这个任务将如何执行都是由这个阶段决定的。了解这部分就相当于了解了线程池的核心运行机制。</p>
<p>首先，所有任务的调度都是由execute方法完成的（接下来会分析这个方法），这部分完成的工作是：检查现在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。其执行过程如下：</p>
<ol>
<li>首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。</li>
<li>如果<code>workerCount &lt; corePoolSize</code>，则创建并启动一个线程来执行新提交的任务。</li>
<li>如果<code>workerCount &gt;= corePoolSize</code>，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。</li>
<li>如果<code>workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize</code>，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。</li>
<li>如果<code>workerCount &gt;= maximumPoolSize</code>，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</li>
</ol>
<p>其执行流程如下图所示（参考的是美团团队所写的文章）：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/03/yUDvVaOl3RWfFgh.png"  alt="任务调度执行流程"></p>
<p>需要注意的是，看了很多博客的流程图都没有写有关于线程池状态监测是否为运行状态这一步，于是在上面很有必要补上，有一些博客的流程图画得也挺不错的，以下作为参考：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/03/VFNAwKU6zLSdhIv.png"  alt="线程池执行流程图"></p>
<h3 id="2-3-2-任务缓冲"><a href="#2-3-2-任务缓冲" class="headerlink" title="2.3.2 任务缓冲"></a>2.3.2 任务缓冲</h3><p>任务缓冲模块是线程池能够管理任务的核心部分。线程池的本质是对任务和线程的管理，而做到这一点最关键的思想就是将任务和线程两者解耦，不让两者直接关联，才可以做后续的分配工作。线程池中是以生产者消费者模式，通过一个阻塞队列来实现的。阻塞队列缓存任务，工作线程从阻塞队列中获取任务。</p>
<p>阻塞队列(<code>BlockingQueue</code>)是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p>
<p>阻塞队列作为一个线程池必须要的参数之一，对阻塞队列的一些类别需要认识清楚，比如有界队列和无界队列的区别在哪里？使用无界队列会带来什么影响？这些都是一些使用线程池时候重点的知识点所在。</p>
<p>下图中展示了线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/03/93vot42lDnyAcpN.png"  alt="阻塞队列"></p>
<p>关于阻塞队列的一些知识，接下来我也会进行一个解析，对这几个队列还是需要有所了解的，这里有一个简单的描述表格：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/03/fitBsSdm9EJQzqD.png"  alt="阻塞队列介绍"></p>
<p>线程池主要涉及到的是以下几种阻塞队列：</p>
<ol>
<li>LinkedBlockingQueue：链式阻塞队列，底层数据结构是链表，默认大小是<code>Integer.MAX_VALUE</code>，也可以指定大小。</li>
<li>ArrayBlockingQueue：数组阻塞队列，底层数据结构是数组，需要指定队列的大小。</li>
<li>SynchronousQueue：同步队列，内部容量为0，每个put操作必须等待一个take操作，反之亦然。</li>
<li>DelayQueue：延迟队列，该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素 。</li>
</ol>
<p>关于队列，这里还要BB多几句，线程池主要有以下几种处理方式:</p>
<ol>
<li><p><strong>直接切换</strong>：这种方式常用的队列是<code>SynchronousQueue</code>，但现在还没有研究过该队列，这里暂时还没法介绍；</p>
</li>
<li><p><strong>使用无界队列</strong>：一般使用基于链表的阻塞队列<code>LinkedBlockingQueue</code>。如果使用这种方式，那么线程池中能够创建的最大线程数就是<code>corePoolSize</code>，而<code>maximumPoolSize</code>就不会起作用了（后面也会说到）。当线程池中所有的核心线程都是RUNNING状态时，这时一个新的任务提交就会放入等待队列中。</p>
</li>
<li><p>使用有界队列</p>
<p><strong>使用有界队列</strong>：一般使用<code>ArrayBlockingQueue</code>。使用该方式可以将线程池的最大线程数量限制为<code>maximumPoolSize</code>，这样能够降低资源的消耗，但同时这种方式也使得线程池对线程的调度变得更困难，因为线程池和队列的容量都是有限的值，所以要想使线程池处理任务的吞吐率达到一个相对合理的范围，又想使线程调度相对简单，并且还要尽可能的降低线程池对资源的消耗，就需要合理的设置这两个数量。</p>
<ul>
<li>如果要想降低系统资源的消耗（包括CPU的使用率，操作系统资源的消耗，上下文环境切换的开销等）, 可以设置较大的队列容量和较小的线程池容量, 但这样也会降低线程处理任务的吞吐量。</li>
<li>如果提交的任务经常发生阻塞，那么可以考虑通过调用 <code>setMaximumPoolSize()</code> 方法来重新设定线程池的容量。</li>
<li>如果队列的容量设置的较小，通常需要将线程池的容量设置大一点，这样CPU的使用率会相对的高一些。但如果线程池的容量设置的过大，则在提交的任务数量太多的情况下，并发量会增加，那么线程之间的调度就是一个要考虑的问题，因为这样反而有可能降低处理任务的吞吐量。</li>
</ul>
</li>
</ol>
<p><strong>这里还是有一个疑惑：线程池中使用有限的阻塞队列和无限的阻塞队列的区别？</strong></p>
<p>经过多方面的资料和书籍查找，可以给出如下的答案：</p>
<p>JDK使用了无界队列<code>LinkedBlockingQueue</code>作为<code>WorkQueue</code>而不是有界队列<code>ArrayBlockingQueue</code>，尽管后者可以对资源进行控制，但是个人认为，使用有界队列相比无界队列有三个缺点：</p>
<ul>
<li><strong>性能问题：</strong>使用有界队列，<code>corePoolSize</code>、<code>maximumPoolSize</code>两个参数势必要根据实际场景不断调整以求达到一个最佳，这势必给开发带来极大的麻烦，必须经过大量的性能测试。所以干脆就使用无界队列，任务永远添加到队列中，不会溢出，自然<code>maximumPoolSize</code>也没什么用了，只需要根据系统处理能力调整<code>corePoolSize</code>就可以了；</li>
<li><strong>防止业务突刺：</strong>尤其是在Web应用中，某些时候突然大量请求的到来都是很正常的。这时候使用无界队列，不管早晚，至少保证所有任务都能被处理到。但是使用有界队列呢？那些超出<code>maximumPoolSize</code>的任务直接被丢掉了，处理地慢还可以忍受，但是任务直接就不处理了，这似乎有些糟糕；</li>
<li>不仅仅是<code>corePoolSize</code>和<code>maximumPoolSize</code>需要相互调整，有界队列的队列大小和<code>maximumPoolSize</code>也需要相互折衷，这也是一块比较难以控制和调整的方面。</li>
</ul>
<p>小结：当然，最后还是那句话，就像Java中的各种<code>Comparable</code>和<code>Comparator</code>的对比、<code>synchronized</code>和<code>ReentrantLock</code>对比，再到线程池这里的无界队列和有界队列的对比，看似都有一个的优点稍微突出一些，有些东西的存在一定有他的道理，需要适应的地方去使用，各有各的长处，只是要看处于何处。</p>
<h3 id="2-3-3-任务申请"><a href="#2-3-3-任务申请" class="headerlink" title="2.3.3 任务申请"></a>2.3.3 任务申请</h3><p>由上文的任务分配部分可知，任务的执行有两种可能：一种是任务直接由新创建的线程执行。另一种是线程从任务队列中获取任务然后执行，执行完任务的空闲线程会再次去从队列中申请任务再去执行。第一种情况仅出现在线程初始创建的时候，第二种是线程获取任务绝大多数的情况。</p>
<p>线程需要从任务缓存模块中不断地取任务执行，帮助线程从阻塞队列中获取任务，实现线程管理模块和任务管理模块之间的通信。这部分策略由<code>getTask</code>方法实现，其执行流程如下图所示：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/03/ZUc6LKwbjSNyuWl.png"  alt="任务申请流程图"></p>
<p><code>getTask</code>这部分进行了多次判断，为的是控制线程的数量，使其符合线程池的状态。如果线程池现在不应该持有那么多线程，则会返回null值。工作线程Worker会不断接收新任务去执行，而当工作线程Worker接收不到任务的时候，就会开始被回收。</p>
<p>下面对<code>getTask</code> 会再一次贴上源码，这里只是抛出了这么一个思路，主要是介绍整个任务机制。</p>
<h3 id="2-3-4-任务拒绝"><a href="#2-3-4-任务拒绝" class="headerlink" title="2.3.4 任务拒绝"></a>2.3.4 任务拒绝</h3><p>任务拒绝模块是线程池的保护部分，线程池有一个最大的容量，当线程池的任务缓存队列已满，并且线程池中的线程数目达到<code>maximumPoolSize</code>时，就需要拒绝掉该任务，采取任务拒绝策略，保护线程池。</p>
<p>拒绝策略其实就是一个接口，源码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RejectedExecutionHandler</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>用户可以通过实现这个接口去定制拒绝策略，也可以选择JDK提供的四种已有拒绝策略，其特点如下：</p>
<ul>
<li>hreadPoolExecutor.AbortPolicy：<strong>默认拒绝处理策略</strong>，丢弃任务并直接抛出<code>RejectedExecutionException</code>异常。</li>
<li>ThreadPoolExecutor.DiscardPolicy：丢弃新来的任务，但是不抛出异常。</li>
<li>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列头部（最旧的）的任务，然后重新尝试执行程序（如果再次失败，重复此过程）。</li>
<li>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务。</li>
</ul>
<hr>
<h2 id="2-4-Executor-框架"><a href="#2-4-Executor-框架" class="headerlink" title="2.4 Executor 框架"></a>2.4 Executor 框架</h2><h3 id="2-4-1-Executor-接口"><a href="#2-4-1-Executor-接口" class="headerlink" title="2.4.1 Executor 接口"></a>2.4.1 Executor 接口</h3><p>Java中的线程池顶层接口是Executor接口，<code>ThreadPoolExecutor</code>是这个接口的实现类。所以我们当然要先分析一下Executor 这个框架接口：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Executor接口只有一个execute方法，用来替代通常创建或启动线程的方法。例如，使用Thread来创建并启动线程的代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread();</span><br><span class="line">t.start();</span><br></pre></td></tr></tbody></table></figure>

<p>使用Executor来启动线程执行任务的代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread();</span><br><span class="line">executor.execute(t);</span><br></pre></td></tr></tbody></table></figure>

<p>对于不同的Executor实现，execute()方法可能是创建一个新线程并立即启动，也有可能是使用已有的工作线程来运行传入的任务，也可能是根据设置线程池的容量或者阻塞队列的容量来决定是否要将传入的线程放入阻塞队列中或者拒绝接收传入的线程。</p>
<h3 id="2-4-2-ExecutorService-接口"><a href="#2-4-2-ExecutorService-接口" class="headerlink" title="2.4.2 ExecutorService 接口"></a>2.4.2 ExecutorService 接口</h3><p><code>ExecutorService</code>接口继承自Executor接口，提供了管理终止的方法，以及可为跟踪一个或多个异步任务执行状况而生成 Future 的方法。增加了<code>shutDown()</code>，<code>shutDownNow()</code>，<code>invokeAll()</code>，<code>invokeAny()</code>和<code>submit()</code>等方法。如果需要支持即时关闭，也就是<code>shutDownNow()</code>方法，则任务需要正确处理中断。</p>
<h3 id="2-4-3-ScheduledExecutorService-接口"><a href="#2-4-3-ScheduledExecutorService-接口" class="headerlink" title="2.4.3 ScheduledExecutorService 接口"></a>2.4.3 ScheduledExecutorService 接口</h3><p><code>ScheduledExecutorService</code>扩展<code>ExecutorService</code>接口并增加了<code>schedule</code>方法。调用schedule方法可以在指定的延时后执行一个Runnable或者Callable任务。<code>ScheduledExecutorService</code>接口还定义了按照指定时间间隔定期执行任务的<code>scheduleAtFixedRate()</code>方法和<code>scheduleWithFixedDelay()</code>方法。</p>
<p>注意：记得对比 UML 图进行这几个接口的查看，就知道大概的一个流程了。</p>
<h3 id="2-4-4-Executor-框架详解"><a href="#2-4-4-Executor-框架详解" class="headerlink" title="2.4.4 Executor 框架详解"></a>2.4.4 Executor 框架详解</h3><p>Executor 框架结构(主要由三大部分组成：</p>
<p><strong>1. 任务(Runnable /Callable)</strong></p>
<p>执行任务需要实现的 Runnable 接口 或 Callable接口。Runnable 接口或 Callable 接口 实现类都可以被 <code>ThreadPoolExecutor</code> 或 <code>ScheduledThreadPoolExecutor</code> 执行。</p>
<p><strong>2. 任务的执行(Executor)</strong></p>
<p>上面已经提及到了任务执行机制的核心接口 <code>Executor</code> ，以及继承自 <code>Executor</code> 接口的 <code>ExecutorService</code> 接口。<code>ThreadPoolExecutor</code> 和 <code>ScheduledThreadPoolExecutor</code> 这两个关键类实现了 <code>ExecutorService</code> 接口。</p>
<p>这里提了很多底层的类关系，但是，实际上我们需要更多关注的是 <code>ThreadPoolExecutor</code> 这个类，这个类在我们实际使用线程池的过程中，使用频率还是非常高的，也是接下来重点分析的对象。</p>
<p><strong>3. 异步计算的结果(Future)</strong></p>
<p>Future 接口以及 Future 接口的实现类 <code>FutureTask</code> 类都可以代表异步计算的结果。当我们把 <code>Runnable</code>接口 或 <code>Callable</code> 接口 的实现类提交给 <code>ThreadPoolExecutor</code> 或 <code>ScheduledThreadPoolExecutor</code> 执行。（调用 <code>submit()</code> 方法时会返回一个 <code>FutureTask</code> 对象）</p>
<p><strong>Executor 框架的使用示意图</strong>（摘自 Java 并发编程的艺术）</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/03/IayJADbjuNfYGnx.png"  alt="Executor 框架的使用示意图"></p>
<p>其主要过程如下：</p>
<ol>
<li>主线程首先要创建实现 <code>Runnable</code> 或者 <code>Callable</code> 接口的任务对象。</li>
<li>把创建完成的实现 <code>Runnable/Callable</code>接口的对象直接交给 <code>ExecutorService</code> 执行: <code>ExecutorService.execute（Runnable command）</code>）或者也可以把 Runnable 对象或Callable 对象提交给 <code>ExecutorService</code> 执行（<code>ExecutorService.submit（Runnable task）</code>或 <code>ExecutorService.submit（Callable  task）</code>）。</li>
<li>如果执行 <code>ExecutorService.submit（…）</code>，<code>ExecutorService</code> 将返回一个实现Future接口的对象（我们刚刚也提到过了执行 <code>execute()</code>方法和 <code>submit()</code>方法的区别，<code>submit()</code>会返回一个 <code>FutureTask</code> 对象）。由于 <code>FutureTask</code> 实现了 <code>Runnable</code>，我们也可以创建 <code>FutureTask</code>，然后直接交给 <code>ExecutorService</code> 执行。</li>
<li>最后，主线程可以执行 <code>FutureTask.get()</code>方法来等待任务执行完成。主线程也可以执行 <code>FutureTask.cancel（boolean mayInterruptIfRunning）</code>来取消此任务的执行。</li>
</ol>
<p><strong>注意这里有一个问题：执行execute()方法和submit()方法的区别是什么呢？</strong></p>
<p><strong>1.execute()方法：</strong></p>
<ul>
<li>作用：<strong>用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</strong></li>
<li>在Executor中声明的方法，在ThreadPoolExecutor进行了具体的实现，这个方法是ThreadPoolExecutor的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。</li>
</ul>
<p><strong>2.submit()方法：</strong></p>
<ul>
<li>作用：<strong>用于提交需要返回值的任务</strong>。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功，并且可以通过 Future 的 get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 <code>get（long timeout，TimeUnit unit）</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li>
</ul>
<p>在<code>ExecutorService</code>中声明的方法，在<code>AbstractExecutorService</code>就已经有了具体的实现，在<code>ThreadPoolExecutor</code>中并没有对其进行重写，我们以<strong><code>AbstractExecutorService</code></strong>接口中的一个 submit 方法为例子来看看源代码：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/04/HWAp2dEvkRDntef.png"  alt="submit源码"></p>
<p>上面方法调用的 <code>newTaskFor</code> 方法返回了一个 <code>FutureTask</code> 对象。</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/04/9E6utLUh1bKcsp3.png"  alt="newTaskFor源码"></p>
<p><code>submit()</code>方法的实现，会发现它实际上还是调用的<code>execute()</code>方法，只不过它利用了Future来获取任务执行结果.</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/04/zTeBZmRNsYMJaco.png"  alt="FutureTask源码"></p>
<hr>
<h2 id="2-5-ThreadPoolExecutor-分析"><a href="#2-5-ThreadPoolExecutor-分析" class="headerlink" title="2.5 ThreadPoolExecutor 分析"></a>2.5 ThreadPoolExecutor 分析</h2><h3 id="2-5-1-几个重要字段"><a href="#2-5-1-几个重要字段" class="headerlink" title="2.5.1 几个重要字段"></a>2.5.1 几个重要字段</h3><p>线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，由内部来维护。线程池内部使用一个变量维护两个值：运行状态(<code>runState</code>)和线程数量 (<code>workerCount</code>)。在具体实现中，线程池将运行状态(<code>runState</code>)、线程数量 (<code>workerCount</code>)两个关键参数的维护放在了一起，如下代码所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></tbody></table></figure>

<p><code>ctl</code>这个<code>AtomicInteger</code>类型，是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它同时包含两部分的信息：线程池的运行状态 (<code>runState</code>) 和线程池内有效线程的数量 (<code>workerCount</code>)，高3位保存<code>runState</code>，低29位保存<code>workerCount</code>，两个变量之间互不干扰。<code>COUNT_BITS</code> 就是29，<code>CAPACITY</code>就是1左移29位减1（29个1），这个常量表示<code>workerCount</code>的上限值，大约是5亿。</p>
<p><strong>为什么仅仅使用一个变量去存两个值呢？不分开存储？</strong></p>
<p>用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，不必为了维护两者的一致，而占用锁资源。通过阅读线程池源代码也可以发现，经常出现要同时判断线程池运行状态和线程数量的情况。线程池也提供了若干方法去供用户获得线程池当前的运行状态、线程个数。这里都使用的是位运算的方式，相比于基本运算，速度也会快很多。</p>
<h3 id="2-5-2-ctl-相关方法"><a href="#2-5-2-ctl-相关方法" class="headerlink" title="2.5.2 ctl 相关方法"></a>2.5.2 ctl 相关方法</h3><p>关于内部封装的获取生命周期状态、获取线程池线程数量的计算方法如以下代码所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>{ <span class="keyword">return</span> c &amp; ~CAPACITY; }</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>{ <span class="keyword">return</span> c &amp; CAPACITY; }</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>{ <span class="keyword">return</span> rs | wc; }</span><br></pre></td></tr></tbody></table></figure>

<p>这几个方法的具体含义如下所示：</p>
<ul>
<li><strong>runStateOf</strong>：获取运行状态；</li>
<li><strong>workerCountOf</strong>：获取活动线程数；</li>
<li><strong>ctlOf</strong>：获取运行状态和活动线程数的值。</li>
</ul>
<hr>
<h3 id="2-5-3-ThreadPoolExecutor-的构造方法及核心参数"><a href="#2-5-3-ThreadPoolExecutor-的构造方法及核心参数" class="headerlink" title="2.5.3 ThreadPoolExecutor 的构造方法及核心参数"></a>2.5.3 ThreadPoolExecutor 的构造方法及核心参数</h3><h4 id="四种构造方法"><a href="#四种构造方法" class="headerlink" title="四种构造方法"></a>四种构造方法</h4><p><code>ThreadPoolExecutror</code> 一共有四个构造方法，一共如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 五个参数的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 六个参数的构造函数-1</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 六个参数的构造函数-2</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 七个参数的构造函数</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="7个核心参数的解析"><a href="#7个核心参数的解析" class="headerlink" title="7个核心参数的解析"></a>7个核心参数的解析</h4><p>涉及到5~7个参数，我们先看看必须的5个参数是什么意思：</p>
<ul>
<li><p><strong>int corePoolSize</strong>：该线程池中核心线程数最大值</p>
<p>核心线程：线程池中有两类线程，核心线程和非核心线程。核心线程默认情况下会一直存在于线程池中，即使这个核心线程什么都不干（铁饭碗），而非核心线程如果长时间的闲置，就会被销毁（临时工）。</p>
<p>在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务除非调用了<code>prestartAllCoreThreads()</code>（ 初始化一个核心线程）或者prestartCoreThread()（ 初始化一个核心线程）方法。从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。</p>
<p>默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；</p>
</li>
<li><p><strong>int maximumPoolSize</strong>：该线程池中线程总数最大值 。</p>
<p>该值等于核心线程数量 + 非核心线程数量。</p>
<p>描述：池中允许的最大线程数，这个参数表示了线程池中最多能创建的线程数量，当任务数量比corePoolSize大时，任务添加到workQueue，当workQueue满了，将继续创建线程以处理任务maximumPoolSize表示的就是wordQueue满了，线程池中最多可以创建的线程数量</p>
</li>
<li><p><strong>long keepAliveTime</strong>：非核心线程闲置超时时长。</p>
<p>非核心线程如果处于闲置状态超过该值，就会被销毁。如果设置allowCoreThreadTimeOut(true)，则会也作用于核心线程。</p>
</li>
<li><p><strong>TimeUnit unit</strong>：keepAliveTime 时间单位，有7种取值，在TimeUnit类中有7种静态属性：</p>
<ol>
<li>TimeUnit.DAYS; //天</li>
<li>TimeUnit.HOURS; //小时</li>
<li>TimeUnit.MINUTES; //分钟</li>
<li>TimeUnit.SECONDS; //秒</li>
<li>TimeUnit.MILLISECONDS; //毫秒</li>
<li>TimeUnit.MICROSECONDS; //微妙</li>
<li>TimeUnit.NANOSECONDS; //纳秒</li>
</ol>
</li>
<li><p><strong>BlockingQueue workQueue</strong>：阻塞队列，维护着等待执行的Runnable任务对象。一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，其具体的几种类型，在前面已经给出。</p>
</li>
</ul>
<p>介绍完5个必须的参数之后，还有两个非必须的参数。</p>
<ul>
<li><strong>ThreadFactory threadFactory</strong> ：创建线程的工厂 ，用于批量创建线程，统一在创建线程时设置一些参数，如是否守护线程、线程的优先级等。如果不指定，会新建一个默认的线程工厂。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>{</span><br><span class="line">    <span class="comment">// 省略属性</span></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    DefaultThreadFactory() {</span><br><span class="line">        SecurityManager s = System.getSecurityManager();</span><br><span class="line">        group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">        Thread.currentThread().getThreadGroup();</span><br><span class="line">        namePrefix = <span class="string">"pool-"</span> +</span><br><span class="line">            poolNumber.getAndIncrement() +</span><br><span class="line">            <span class="string">"-thread-"</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>RejectedExecutionHandler handler</strong>：<strong>拒绝处理策略</strong>，线程数量大于最大线程数就会采用拒绝处理策略，在上面我已经列出了详细的几种类型了。</li>
</ul>
<hr>
<h3 id="2-5-4-execute-方法"><a href="#2-5-4-execute-方法" class="headerlink" title="2.5.4 execute 方法"></a>2.5.4 execute 方法</h3><p>这个方法其实就是线程池任务调度的核心所在了！</p>
<p>下面有一个很重要的东西叫ctl，我在前面已经提及，我怕又忘了，这里再点名一下：<code>private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</code>，其中蕴含的就是运行状态(<code>runState</code>)和线程数量 (<code>workerCount</code>)。</p>
<p>下面有几个方法，前面已经提及，这里再补充一下：</p>
<ul>
<li><strong>runStateOf</strong>：获取运行状态；</li>
<li><strong>workerCountOf</strong>：获取活动线程数；</li>
<li><strong>ctlOf</strong>：获取运行状态和活动线程数的值。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * clt记录着runState和workerCount</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 第一步</span></span><br><span class="line"><span class="comment">     * workerCountOf方法取出低29位的值，表示当前活动的线程数；</span></span><br><span class="line"><span class="comment">     * 如果当前活动线程数小于corePoolSize，则新建一个线程放入线程池中；</span></span><br><span class="line"><span class="comment">     * 并把任务添加到该线程中。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * addWorker中的第二个参数表示限制添加线程的数量是根据corePoolSize来判断还是maximumPoolSize来判断；</span></span><br><span class="line"><span class="comment">         * 如果为true，根据corePoolSize来判断；</span></span><br><span class="line"><span class="comment">         * 如果为false，则根据maximumPoolSize来判断</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果上面直接return; 则表明添加Worker成功</span></span><br><span class="line"><span class="comment">         * 如果添加失败，则重新获取ctl值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 第二步</span></span><br><span class="line"><span class="comment">     * 上面判断不小于corePoolSize，则将任务添加到workQueue队列。</span></span><br><span class="line"><span class="comment">     * 则判断是否线程池是运行状态并且任务添加到队列成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) {</span><br><span class="line">        <span class="comment">// 重新获取ctl值</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 再次判断线程池的运行状态，如果不是运行状态，由于之前已经把command添加到workQueue中了，</span></span><br><span class="line">        <span class="comment">// 这时需要移除该command</span></span><br><span class="line">        <span class="comment">// 执行过后通过handler使用拒绝策略对该任务进行处理，整个方法返回</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 获取线程池中的有效线程数，如果数量是0，则执行addWorker方法</span></span><br><span class="line"><span class="comment">         * 这里传入的参数表示：</span></span><br><span class="line"><span class="comment">         * 1. 第一个参数为null，表示在线程池中创建一个线程，但不去启动；</span></span><br><span class="line"><span class="comment">         * 2. 第二个参数为false，将线程池的有限线程数量的上限设置为maximumPoolSize，添加线程时根据maximumPoolSize来判断；</span></span><br><span class="line"><span class="comment">         * 如果判断workerCount大于0，则直接返回，在workQueue中新增的command会在将来的某个时刻被执行。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 第三步</span></span><br><span class="line"><span class="comment">     * 如果执行到这里，有两种情况：</span></span><br><span class="line"><span class="comment">     * 1. 线程池已经不是RUNNING状态；</span></span><br><span class="line"><span class="comment">     * 2. 线程池是RUNNING状态，但 workerCount &gt;= corePoolSize并且workQueue已满。</span></span><br><span class="line"><span class="comment">     * 这时，再次调用addWorker方法，但第二个参数传入为false，将线程池的有限线程数量的上限设置为maximumPoolSize；</span></span><br><span class="line"><span class="comment">     * 如果这时创建非核心线程失败(当前线程总数不小于maximumPoolSize时)，就会执行拒绝策略。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>ctl.get()</code>是获取线程池状态，用<code>int</code>类型表示。第二步中，入队前进行了一次<code>isRunning</code>判断，入队之后，又进行了一次<code>isRunning</code>判断。</p>
<p>这里先抛出一个疑问：<strong>为什么要二次检查线程池的状态?</strong></p>
<ul>
<li>主要是因为在多线程的环境下，线程池的状态是时刻发生变化的。很有可能刚获取线程池状态后线程池状态就改变了。判断是否将<code>command</code>加入<code>workqueue</code>是线程池之前的状态。倘若没有二次检查，万一线程池处于非<strong>RUNNING</strong>状态（在多线程环境下很有可能发生），那么<code>command</code>永远不会执行。</li>
</ul>
<p>需要注意的是，需要进行判断是否为RUNNING状态，如果在执行execute()方法时如果状态一直是RUNNING时，的执行过程如下：</p>
<ol>
<li>如果<code>workerCount &lt; corePoolSize</code>，则创建并启动一个线程来执行新提交的任务；</li>
<li>如果<code>workerCount &gt;= corePoolSize</code>，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中；</li>
<li>如果<code>workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize</code>，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务；</li>
<li>如果<code>workerCount &gt;= maximumPoolSize</code>，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</li>
</ol>
<p>其流程图如下所示：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/03/4ZKr6ulWQMOTP3e.png"  alt="execute流程图"></p>
<hr>
<h3 id="2-5-5-addWorker-方法"><a href="#2-5-5-addWorker-方法" class="headerlink" title="2.5.5 addWorker 方法"></a>2.5.5 addWorker 方法</h3><p><code>addWorker</code>方法的主要工作是<strong>在线程池中创建一个新的线程并执行</strong>。增加线程是通过线程池中的addWorker方法，该方法的功能就是增加一个线程，该方法不考虑线程池是在哪个阶段增加的该线程，这个分配线程的策略是在上个步骤完成的，该步骤仅仅完成增加线程，并使它运行，最后返回是否成功这个结果。</p>
<p>其主要有两个参数：</p>
<ul>
<li><code>firstTask</code>参数 用于指定新增的线程执行的第一个任务</li>
<li>core参数为true表示在新增线程时会判断当前活动线程数是否少于<code>corePoolSize</code>，false表示新增线程前需要判断当前活动线程数是否少于<code>maximumPoolSize</code>。</li>
</ul>
<p>代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>{</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">// 获取运行状态</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 这个if判断</span></span><br><span class="line"><span class="comment">         * 如果rs &gt;= SHUTDOWN，则表示此时不再接收新任务；</span></span><br><span class="line"><span class="comment">         * 接着判断以下3个条件，只要有1个不满足，则返回false：</span></span><br><span class="line"><span class="comment">         * 1. rs == SHUTDOWN，这时表示关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务</span></span><br><span class="line"><span class="comment">         * 2. firsTask为空</span></span><br><span class="line"><span class="comment">         * 3. 阻塞队列不为空</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 首先考虑rs == SHUTDOWN的情况</span></span><br><span class="line"><span class="comment">         * 这种情况下不会接受新提交的任务，所以在firstTask不为空的时候会返回false；</span></span><br><span class="line"><span class="comment">         * 然后，如果firstTask为空，并且workQueue也为空，则返回false，</span></span><br><span class="line"><span class="comment">         * 因为队列中已经没有任务了，不需要再添加线程了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="comment">// 获取线程数</span></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">// 如果wc超过CAPACITY，也就是ctl的低29位的最大值（二进制是29个1），返回false；</span></span><br><span class="line">            <span class="comment">// 这里的core是addWorker方法的第二个参数，如果为true表示根据corePoolSize来比较，</span></span><br><span class="line">            <span class="comment">// 如果为false则根据maximumPoolSize来比较。        </span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 尝试增加workerCount，如果成功，则跳出第一个for循环</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            <span class="comment">// 如果增加workerCount失败，则重新获取ctl的值</span></span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">// 如果当前的运行状态不等于rs，说明状态已被改变，返回第一个for循环继续执行</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 根据firstTask来创建Worker对象</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="comment">// 每一个Worker对象都会创建一个线程</span></span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                <span class="comment">// rs &lt; SHUTDOWN表示是RUNNING状态；</span></span><br><span class="line">                <span class="comment">// 如果rs是RUNNING状态或者rs是SHUTDOWN状态并且firstTask为null，向线程池中添加线程。</span></span><br><span class="line">                <span class="comment">// 因为在SHUTDOWN时不会在添加新的任务，但还是会执行workQueue中的任务</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) {</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    <span class="comment">// workers是一个HashSet</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="comment">// largestPoolSize记录着线程池中出现过的最大线程数量</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) {</span><br><span class="line">                <span class="comment">// 启动线程</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其主要流程如下所示：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/03/RdTa4IpEtJ9ighf.png"  alt="addWork流程图"></p>
<hr>
<h3 id="2-5-6-Worker-类"><a href="#2-5-6-Worker-类" class="headerlink" title="2.5.6 Worker 类"></a>2.5.6 Worker 类</h3><p>线程池为了掌握线程的状态并维护线程的生命周期，设计了线程池内的工作线程Worker。线程池中的每一个线程被封装成一个Worker对象，<code>ThreadPool</code>维护的其实就是一组Worker对象，看一下Worker的定义：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This class will never be serialized, but we provide a</span></span><br><span class="line"><span class="comment">     * serialVersionUID to suppress a javac warning.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line">    <span class="comment">/** Thread this worker is running in.  Null if factory fails. */</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">/** Initial task to run.  Possibly null. */</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">/** Per-thread task counter */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates with given first task and thread from ThreadFactory.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstTask the first task (null if none)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Worker(Runnable firstTask) {</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// Lock methods</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The value 0 represents the unlocked state.</span></span><br><span class="line">    <span class="comment">// The value 1 represents the locked state.</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 注意次数的tryAcquire是不允许重入的，而ReentrantLock是允许重入的。</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) {</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>{</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>{ acquire(<span class="number">1</span>); }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>{ <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>{ release(<span class="number">1</span>); }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>{ <span class="keyword">return</span> isHeldExclusively(); }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>{</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                t.interrupt();</span><br><span class="line">            } <span class="keyword">catch</span> (SecurityException ignore) {</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过上面的代码我们可以知道，Worker类继承了<code>AbstractQueuedSynchronizer</code>，并实现了<code>Runnable</code>接口，注意其中的<code>firstTask</code>和<code>thread</code>属性：</p>
<ul>
<li><code>firstTask</code>用它来保存传入的任务；</li>
<li><code>thread</code>是在调用构造方法时通过<code>ThreadFactory</code>来创建的线程，是用来处理任务的线程。</li>
</ul>
<p>在调用构造方法时，需要把任务传入，这里通过<code>getThreadFactory().newThread(this);</code>来新建一个线程，<code>newThread</code>方法传入的参数是this，因为Worker本身继承了Runnable接口，也就是一个线程，所以一个Worker对象在启动的时候会调用Worker类中的run方法。</p>
<p>Worker执行任务的模型如下图所示：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/03/cXwlEDfIoe5pgF8.png"  alt="worker 执行任务模型"></p>
<p>Worker继承了<code>AbstractQueuedSynchronizer</code>，使用<code>AbstractQueuedSynchronizer</code>来实现独占锁的功能。为什么不使用<code>ReentrantLock</code>来实现呢？可以看到<code>tryAcquire</code>方法，它是不允许重入的，而<code>ReentrantLock</code>是允许重入的：</p>
<ol>
<li><p>lock方法一旦获取了独占锁，表示当前线程正在执行任务中；</p>
</li>
<li><p>如果正在执行任务，则不应该中断线程；</p>
</li>
<li><p>如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断；</p>
</li>
<li><p>线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；</p>
</li>
<li><p>之所以设置为不可重入，是因为我们不希望任务在调用像<code>setCorePoolSize</code>这样的线程池控制方法时重新获取锁。如果使用<code>ReentrantLock</code>，它是可重入的，这样如果在任务中调用了如<code>setCorePoolSize</code>这类线程池控制的方法，会中断正在运行的线程。</p>
<p>所以，Worker继承自<code>AbstractQueuedSynchronizer</code>，用于判断线程是否空闲以及是否可以被中断。</p>
</li>
</ol>
<p>在线程回收过程中就使用到了这种特性，回收过程如下图所示：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/03/aCo5DEI3pnYRN9Q.png"  alt="线程回收模型"></p>
<p>在构造方法中执行了<code>setState(-1);</code>，把state变量设置为-1，为什么这么做呢？</p>
<p>其实人家源码中的注解也已经说明了：<code>inhibit interrupts until runWorker</code></p>
<p>大概的原因是<code>AQS</code>中默认的state是0，如果刚创建了一个Worker对象，还没有执行任务时，这时就不应该被中断，查看上面的<code>tryAcquire</code>方法，发现其调用的是：<code>if (compareAndSetState(0, 1))</code>，其是根据state是否是0来判断的，所以，<code>setState(-1);</code>将state设置为-1是为了禁止在执行任务前对线程进行中断。</p>
<p>就是因为这个原因，在<code>runWorker</code>方法中会先调用Worker对象的unlock方法将state设置为0.</p>
<hr>
<h3 id="2-5-7-runWorker-方法"><a href="#2-5-7-runWorker-方法" class="headerlink" title="2.5.7 runWorker 方法"></a>2.5.7 runWorker 方法</h3><p>在Worker类中的run方法调用了runWorker方法来执行任务，runWorker方法的代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>{</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取第一个任务</span></span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 1.线程启动之后，通过unlock方法释放锁</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="comment">// 是否因为异常退出循环</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 2.Worker执行firstTask或从workQueue中获取任务，如果getTask方法不返回null,循环不退出</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 2.1进行加锁操作，保证thread不被其他线程中断（除非线程池被中断）</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="comment">// 此处英文注释容易懂，不容易懂下面有解释</span></span><br><span class="line">            <span class="comment">// 2.2检查线程池状态，倘若线程池处于中断状态，当前线程将中断。 </span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                <span class="comment">// 进行中断，然后再接着往下走</span></span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 2.3执行beforeExecute </span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="comment">// 2.4这里执行任务了</span></span><br><span class="line">                    task.run();</span><br><span class="line">                } <span class="keyword">catch</span> (RuntimeException x) {</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                } <span class="keyword">catch</span> (Error x) {</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                } <span class="keyword">catch</span> (Throwable x) {</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    <span class="comment">// 2.5执行afterExecute方法 </span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                <span class="comment">// 2.6解锁操作</span></span><br><span class="line">                w.unlock();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="comment">// 这里很有意思，如果一个线程发生了异常会走到这个方法</span></span><br><span class="line">        <span class="comment">// 注意completedAbruptly 为true 就代表了因为异常而退出循环了</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>第一个if判断，目的是：</p>
<ul>
<li>如果线程池正在停止，那么要保证当前线程是中断状态；</li>
<li>如果不是的话，则要保证当前线程不是中断状态；</li>
</ul>
<p>为什么要做这些判断呢？</p>
<p>这是因为考虑在执行该if语句期间可能也执行了<code>shutdownNow</code>方法，<code>shutdownNow</code>方法会把状态设置为STOP，回顾一下STOP状态：</p>
<blockquote>
<p>不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 <code>shutdownNow()</code> 方法会使线程池进入到该状态。</p>
</blockquote>
<p>STOP状态要中断线程池中的所有线程，而这里使用<code>Thread.interrupted()</code>来判断是否中断是为了确保在RUNNING或者SHUTDOWN状态时线程是非中断状态的，因为<code>Thread.interrupted()</code>方法会复位中断的状态。</p>
<p>其实整个流程下来，大概就是做了这么几件事：</p>
<ol>
<li>while循环不断地通过<code>getTask()</code>方法获取任务。</li>
<li><code>getTask()</code>方法从阻塞队列中取任务。</li>
<li>如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态。</li>
<li>调用<code>task.run()</code>执行任务；</li>
<li>如果task为null则跳出循环，执行processWorkerExit()方法；</li>
<li>runWorker方法执行完毕，也代表着Worker中的run方法执行完毕，销毁线程。</li>
</ol>
<p>这里的<code>beforeExecute</code>方法和<code>afterExecute</code>方法在<code>ThreadPoolExecutor</code>类中是空的，留给子类来实现。</p>
<p><code>completedAbruptly</code>变量来表示在执行任务过程中是否出现了异常，在<code>processWorkerExit</code>方法中会对该变量的值进行判断。</p>
<p>总结一下<code>runWorker</code>方法的执行过程如下图所示：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/03/YH9cdUgDVbnQN74.png"  alt="runWorker执行流程"></p>
<p>通过上图其实也可以看到<code>runWorker</code> 在线程复用是如何起作用的：</p>
<ul>
<li>首先去执行创建这个worker时就有的任务，当执行完这个任务后，worker的生命周期并没有结束，在<code>while</code>循环中，worker会不断地调用<code>getTask</code>方法从<strong>阻塞队列</strong>中获取任务然后调用<code>task.run()</code>执行任务,从而达到<strong>复用线程</strong>的目的。只要<code>getTask</code>方法不返回<code>null</code>,此线程就不会退出。</li>
<li>当然，核心线程池中创建的线程想要拿到阻塞队列中的任务，先要判断线程池的状态，如果<strong>STOP</strong>或者<strong>TERMINATED</strong>，返回<code>null</code>。</li>
</ul>
<hr>
<h3 id="2-5-8-getTask-方法"><a href="#2-5-8-getTask-方法" class="headerlink" title="2.5.8 getTask 方法"></a>2.5.8 getTask 方法</h3><p><code>getTask</code>方法用来从阻塞队列中取任务，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// timeOut变量的值表示上次从阻塞队列中取任务时是否超时</span></span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果线程池状态rs &gt;= SHUTDOWN，也就是非RUNNING状态，再进行以下判断：</span></span><br><span class="line"><span class="comment">         * 	a. rs &gt;= STOP，线程池是否正在stop；</span></span><br><span class="line"><span class="comment">         * 	b. 阻塞队列是否为空。</span></span><br><span class="line"><span class="comment">         * 如果以上条件满足，则将workerCount减1并返回null。</span></span><br><span class="line"><span class="comment">         * 因为如果当前线程池状态的值是SHUTDOWN或以上时，不允许再向阻塞队列中添加任务。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) {</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">        <span class="comment">// 1.</span></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="comment">// timed变量用于判断是否需要进行超时控制。</span></span><br><span class="line">        <span class="comment">// allowCoreThreadTimeOut变量默认是false,核心线程即使空闲也不会被销毁</span></span><br><span class="line">        <span class="comment">// 	如果为true,核心线程在keepAliveTime内仍空闲则会被销毁。 </span></span><br><span class="line">        <span class="comment">// wc &gt; corePoolSize，表示当前线程池中的线程数量大于核心线程数量；</span></span><br><span class="line">        <span class="comment">// 对于超过核心线程数量的这些线程，需要进行超时控制</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 2.</span></span><br><span class="line"><span class="comment">         * wc &gt; maximumPoolSize的情况是因为可能在此方法执行阶段同时执行了setMaximumPoolSize方法；</span></span><br><span class="line"><span class="comment">         * timed &amp;&amp; timedOut 如果为true，表示当前操作需要进行超时控制，并且上次从阻塞队列中获取任务发生了超时</span></span><br><span class="line"><span class="comment">         * 接下来判断，如果有效线程数量大于1，或者阻塞队列是空的，那么尝试将workerCount减1；</span></span><br><span class="line"><span class="comment">         * 如果减1失败，则返回重试。</span></span><br><span class="line"><span class="comment">         * 如果wc == 1时，也就说明当前线程是线程池中唯一的一个线程了。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) {</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 3.如果timed为true(想想哪些情况下timed为true),则会调用workQueue的poll方法获取任务.</span></span><br><span class="line">            <span class="comment">// 超时时间是keepAliveTime。如果超过keepAliveTime时长，</span></span><br><span class="line">            <span class="comment">// poll返回了null，上边提到的while循序就会退出，线程也就执行完了。</span></span><br><span class="line">            <span class="comment">// 如果timed为false（allowCoreThreadTimeOut为falsefalse</span></span><br><span class="line">            <span class="comment">// 且wc &gt; corePoolSize为false），则会调用workQueue的take方法阻塞在当前。</span></span><br><span class="line">            <span class="comment">// 队列中有任务加入时，线程被唤醒，take方法返回任务，并执行。</span></span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            <span class="comment">// 如果 r == null，说明已经超时，timedOut设置为true</span></span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException retry) {</span><br><span class="line">            <span class="comment">// 如果获取任务时当前线程发生了中断，则设置timedOut为false并返回循环重试</span></span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里是线程如何进行复用的核心代码所在：</p>
<ul>
<li>核心线程的会一直卡在<code>workQueue.take</code>方法，被阻塞并挂起，不会占用CPU资源，直到拿到<code>Runnable</code> 然后返回（当然如果<code>**allowCoreThreadTimeOut**</code>设置为<code>true</code>,那么核心线程就会去调用<code>poll</code>方法，因为<code>poll</code>可能会返回<code>null</code>,所以这时候核心线程满足超时条件也会被销毁）。</li>
<li>非核心线程会<code>workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)</code> ，如果超时还没有拿到，下一次循环判断<strong><code>compareAndDecrementWorkerCount</code></strong>就会返回<code>null</code>,Worker对象的<code>run()</code>方法循环体的判断为<code>null</code>,任务结束，然后线程被系统回收 。</li>
</ul>
<p>这里重要的地方是第二个if判断，目的是控制线程池的有效线程数量。由上文中的分析可以知道，在执行execute方法时，如果当前线程池的线程数量超过了<code>corePoolSize</code>且小于<code>maximumPoolSize</code>，并且<code>workQueue</code>已满时，则可以增加工作线程，但这时如果超时没有获取到任务，也就是<code>timedOut</code>为true的情况，说明<code>workQueue</code>已经为空了，也就说明了当前线程池中不需要那么多线程来执行任务了，可以把多于<code>corePoolSize</code>数量的线程销毁掉，保持线程数量在<code>corePoolSize</code>即可。</p>
<p>什么时候会销毁？当然是<code>runWorker</code>方法执行完之后，也就是Worker中的run方法执行完，由JVM自动回收。</p>
<p><code>getTask</code>方法返回null时，在<code>runWorker</code>方法中会跳出while循环，然后会执行<code>processWorkerExit</code>方法。</p>
<hr>
<h3 id="2-5-9-proccessWorkerExite-方法"><a href="#2-5-9-proccessWorkerExite-方法" class="headerlink" title="2.5.9 proccessWorkerExite 方法"></a>2.5.9 proccessWorkerExite 方法</h3><p>线程回收的工作是在processWorkerExit方法完成的，其源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>{</span><br><span class="line">    <span class="comment">// 如果completedAbruptly值为true，则说明线程执行时出现了异常，需要将workerCount减1；</span></span><br><span class="line">    <span class="comment">// 如果线程执行时没有出现异常，说明在getTask()方法中已经已经对workerCount进行了减1操作，这里就不必再减了。 </span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn't adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 统计完成的任务数</span></span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        <span class="comment">// 从workers中移除，也就表示着从线程池中移除了一个工作线程</span></span><br><span class="line">        workers.remove(w);</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 根据线程池状态进行判断是否结束线程池</span></span><br><span class="line">    <span class="comment">// 为什么需要判断呢？上面已经讲了。</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当线程池是RUNNING或SHUTDOWN状态时，如果worker是异常结束，那么会直接addWorker；</span></span><br><span class="line"><span class="comment">     * 	意思就是因为异常结束的话，会创建一个新的线程放到线程池中！</span></span><br><span class="line"><span class="comment">     * 如果allowCoreThreadTimeOut=true，并且等待队列有任务，至少保留一个worker；</span></span><br><span class="line"><span class="comment">     * 如果allowCoreThreadTimeOut=false，workerCount不少于corePoolSize。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) {</span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) {</span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        }</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上的代码流程图如下所示：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/03/SZVNJKE7Tn9LRBP.png"  alt="processWorkerExit执行流程"></p>
<p>其实在这个方法中，主要工作是<code>workers.remove(w)</code>将线程引用移出线程池就已经结束了线程销毁的部分。但我们还要去分析一下引起线程销毁的原因，分为几种情况，如果是异常结束的话，那么那么会直接<code>addWorker</code>，还有进行判断<code>allowCoreThreadTimeOut</code> ，根据不同情况，对线程进行一个重新的分配。</p>
<p>至此，<code>processWorkerExit</code>执行完之后，工作线程被销毁，以上就是整个工作线程的生命周期，从execute方法开始，Worker使用<code>ThreadFactory</code>创建新的工作线程，<code>runWorker</code>通过<code>getTask</code>获取任务，然后执行任务，如果<code>getTask</code>返回null，进入<code>processWorkerExit</code>方法，整个线程结束，如图所示：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/03/gulAMmVIwtQisC5.png"  alt="工作线程的整个生命周期"></p>
<hr>
<h3 id="2-5-10-tryTerminater-方法"><a href="#2-5-10-tryTerminater-方法" class="headerlink" title="2.5.10 tryTerminater 方法"></a>2.5.10 tryTerminater 方法</h3><p>这个方法的作用是根据线程池状态进行判断是否结束线程池，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 当前线程池的状态为以下几种情况时，直接返回：</span></span><br><span class="line"><span class="comment">         * 1. RUNNING，因为还在运行中，不能停止；</span></span><br><span class="line"><span class="comment">         * 2. TIDYING或TERMINATED，因为线程池中已经没有正在运行的线程了；</span></span><br><span class="line"><span class="comment">         * 3. SHUTDOWN并且等待队列非空，这时要执行完workQueue中的task；</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 如果线程数量不为0，则中断一个空闲的工作线程，并返回</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) { <span class="comment">// Eligible to terminate</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 这里尝试设置状态为TIDYING，如果设置成功，则调用terminated方法</span></span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="comment">// terminated方法默认什么都不做，留给子类实现</span></span><br><span class="line">                    terminated();</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    <span class="comment">// 设置状态为TERMINATED</span></span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// else retry on failed CAS</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>interruptIdleWorkers(ONLY_ONE);</code>的作用是因为在<code>getTask</code>方法中执行<code>workQueue.take()</code>时，如果不执行中断会一直阻塞。</p>
<p><code>processWorkerExite</code> 方法中会调用<code>tryTerminate</code>从而根据线程池状态进行判断是否结束线程池。</p>
<p>每次在工作线程结束时调用<code>tryTerminate</code>方法来尝试中断一个空闲工作线程，避免在队列为空时取任务一直阻塞的情况，这是因为在下面在的shutdown方法中，会中断所有空闲的工作线程，如果在执行shutdown时工作线程没有空闲，然后又去调用了<code>getTask</code>方法，这时如果<code>workQueue</code>中没有任务了，调用<code>workQueue.take()</code>时就会一直阻塞。</p>
<hr>
<h3 id="2-5-11-shutdown-方法"><a href="#2-5-11-shutdown-方法" class="headerlink" title="2.5.11 shutdown 方法"></a>2.5.11 shutdown 方法</h3><p>shutdown方法要将线程池切换到SHUTDOWN状态，并调用<code>interruptIdleWorkers</code>方法请求中断所有空闲的worker，最后调用<code>tryTerminate</code>尝试结束线程池。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 安全策略判断</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 切换状态为SHUTDOWN</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">// 中断空闲线程</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 尝试结束线程池</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里思考一个问题：在<code>runWorker</code>方法中，执行任务时对Worker对象w进行了lock操作，为什么要在执行任务的时候对每个工作线程都加锁呢？</p>
<p>分析如下：</p>
<ul>
<li>在getTask方法中，如果这时线程池的状态是SHUTDOWN并且workQueue为空，那么就应该返回null来结束这个工作线程，而使线程池进入SHUTDOWN状态需要调用shutdown方法；</li>
<li>shutdown方法会调用<code>interruptIdleWorkers</code>来中断空闲的线程，<code>interruptIdleWorkers</code>持有<code>mainLock</code>，会遍历workers来逐个判断工作线程是否空闲。但<code>getTask</code>方法中没有<code>mainLock</code>；</li>
<li>在<code>getTask</code>中，如果判断当前线程池状态是RUNNING，并且阻塞队列为空，那么会调用<code>workQueue.take()</code>进行阻塞；</li>
<li>如果在判断当前线程池状态是RUNNING后，这时调用了<code>shutdown</code>方法把状态改为了SHUTDOWN，这时如果不进行中断，那么当前的工作线程在调用了<code>workQueue.take()</code>后会一直阻塞而不会被销毁，因为在SHUTDOWN状态下不允许再有新的任务添加到<code>workQueue</code>中，这样一来线程池永远都关闭不了了；</li>
<li>由上可知，<code>shutdown</code>方法与<code>getTask</code>方法（从队列中获取任务时）存在竞态条件；</li>
<li>解决这一问题就需要用到线程的中断，也就是为什么要用interruptIdleWorkers方法。在调用<code>workQueue.take()</code>时，如果发现当前线程在执行之前或者执行期间是中断状态，则会抛出<code>InterruptedException</code>，解除阻塞的状态；</li>
<li>但是要中断工作线程，还要判断工作线程是否是空闲的，如果工作线程正在处理任务，就不应该发生中断；</li>
<li>所以Worker继承自<code>AQS</code>，在工作线程处理任务时会进行lock，<code>interruptIdleWorkers</code>在进行中断时会使用tryLock来判断该工作线程是否正在处理任务，如果<code>tryLock</code>返回true，说明该工作线程当前未执行任务，这时才可以被中断。</li>
</ul>
<hr>
<h3 id="2-5-12-interruptldleWorkers-方法"><a href="#2-5-12-interruptldleWorkers-方法" class="headerlink" title="2.5.12 interruptldleWorkers 方法"></a>2.5.12 interruptldleWorkers 方法</h3><p><code>interruptIdleWorkers</code>遍历<code>workers</code>中所有的工作线程，若线程没有被中断<code>tryLock</code>成功，就中断该线程。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">()</span> </span>{</span><br><span class="line">    interruptIdleWorkers(<span class="keyword">false</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>{</span><br><span class="line">    <span class="comment">// mainLock 是可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    <span class="comment">// 进行遍历之前先上锁</span></span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 遍历所有工作线程</span></span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) {</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                } <span class="keyword">catch</span> (SecurityException ignore) {</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    w.unlock();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>为什么需要持有<code>mainLock</code>？</p>
<ul>
<li>因为workers是<code>HashSet</code>类型的，不能保证线程安全。</li>
</ul>
<hr>
<h3 id="2-5-13-shutdownNow-方法"><a href="#2-5-13-shutdownNow-方法" class="headerlink" title="2.5.13 shutdownNow 方法"></a>2.5.13 shutdownNow 方法</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>{</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        <span class="comment">// 中断所有工作线程，无论是否空闲</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">        <span class="comment">// 取出队列中没有被执行的任务</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    }</span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>shutdownNow</code>方法与<code>shutdown</code>方法类似，不同的地方在于：</p>
<ol>
<li>设置状态为STOP；</li>
<li>中断所有工作线程，无论是否是空闲的；</li>
<li>取出阻塞队列中没有被执行的任务并返回</li>
</ol>
<p><code>shutdownNow</code>方法执行完之后调用<code>tryTerminate</code>方法，该方法在上文已经分析过了，目的就是使线程池的状态设置为TERMINATED。</p>
<hr>
<h2 id="2-6-ThreadPoolExecutor-如何做到线程复用的？"><a href="#2-6-ThreadPoolExecutor-如何做到线程复用的？" class="headerlink" title="2.6 ThreadPoolExecutor 如何做到线程复用的？"></a>2.6 ThreadPoolExecutor 如何做到线程复用的？</h2><p>我们知道，一个线程在创建的时候会指定一个线程任务，当执行完这个线程任务之后，线程自动销毁。但是线程池却可以复用线程，即一个线程执行完线程任务后不销毁，继续执行另外的线程任务。<strong>那么，线程池如何做到线程复用呢？</strong></p>
<p>原来，<code>ThreadPoolExecutor</code>在创建线程时，会将线程封装成<strong>工作线程worker</strong>,并放入<strong>工作线程组</strong>中，然后这个worker反复从阻塞队列中拿任务去执行。</p>
<p>在上面的源码我们已经进行了一个流程的分析了，大体过程就是:</p>
<p><code>execute</code> 方法会调用 <code>addWorker</code> 方法，<code>addWoker</code>方法会做些什么呢？</p>
<ul>
<li>在<code>addWorker</code> 方法中会创建<code>worker</code>对象，并初始化一个<code>Thread</code>对象，然后通过<code>thread.start()</code>启动这个线程对象，它会会触发<code>Worker</code>类的<code>run</code>方法被JVM调用。</li>
</ul>
<p><code>runWorker</code>方法会做些什么呢：</p>
<ul>
<li>首先去执行创建这个worker时就有的任务，当执行完这个任务后，worker的生命周期并没有结束，在<code>while</code>循环中，worker会不断地调用<code>getTask</code>方法从<strong>阻塞队列</strong>中获取任务然后调用<code>task.run()</code>执行任务,从而达到<strong>复用线程</strong>的目的。只要<code>getTask</code>方法不返回<code>null</code>,此线程就不会退出。</li>
<li>当然，核心线程池中创建的线程想要拿到阻塞队列中的任务，先要判断线程池的状态，如果<strong>STOP</strong>或者<strong>TERMINATED</strong>，返回<code>null</code>。</li>
</ul>
<p>而<code>getTask</code>方法也是一个核心：</p>
<ul>
<li>核心线程的会一直卡在<code>workQueue.take</code>方法，被阻塞并挂起，不会占用CPU资源，直到拿到<code>Runnable</code> 然后返回（当然如果<strong><code>allowCoreThreadTimeOut</code></strong>设置为<code>true</code>,那么核心线程就会去调用<code>poll</code>方法，因为<code>poll</code>可能会返回<code>null</code>,所以这时候核心线程满足超时条件也会被销毁）。</li>
<li>非核心线程会<code>workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)</code> ，如果超时还没有拿到，下一次循环判断<strong><code>compareAndDecrementWorkerCount</code></strong>就会返回<code>null</code>,Worker对象的<code>run()</code>方法循环体的判断为<code>null</code>,任务结束，然后线程被系统回收 。</li>
</ul>
<p>大概就是这么一个过程了。</p>
<hr>
<h2 id="2-7-一个线程池中的线程异常了，那么线程池会怎么处理这个线程"><a href="#2-7-一个线程池中的线程异常了，那么线程池会怎么处理这个线程" class="headerlink" title="2.7 一个线程池中的线程异常了，那么线程池会怎么处理这个线程?"></a>2.7 <strong>一个线程池中的线程异常了，那么线程池会怎么处理这个线程?</strong></h2><p>这个问题是出自Why 博客中的阿里的面试题，整个流程分析下来也挺有意思的，详细的分析过程可以查看这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=MzIxNTQ4MzE1NA==&amp;mid=2247483741&amp;idx=1&amp;sn=238fc933c3b9b19ab1754b23283ac6fd&amp;chksm=9796d720a0e15e364f4105c29de606e7329760a41607136a722dc97bb177f9362aeacd92f762&amp;mpshare=1&amp;scene=1&amp;srcid=0327sk1b22zCDOAxzazzEBon&amp;sharer_sharetime=1585311891544&amp;sharer_shareid=b9c5b20e14a5ec65e524cd503ba56884&amp;key=362c475b03eb9012c3a4814de16c542df00e00cb88ad625adda59fe05e00e41bf016bca7d19de52329538b9719e995fa2746837543243fdd9b9a8a873c4b7306ae9be2f34fc0a8f197397eec5bcf36d7&amp;ascene=1&amp;uin=MjkxODQzNTgxMg%3D%3D&amp;devicetype=Windows+7&amp;version=62080079&amp;lang=zh_TW&amp;exportkey=A7VoXZ0wFQgcHgODYeWgoNo%3D&amp;pass_ticket=cBjPmhH%2B5L9207Zh9fWCw5cVrpKDK%2B3yqD%2FHI0IlhthmyIKGfVv3OEP8DCmqTYVl" target="_blank" rel="noopener">有的线程它死了，于是它变成一道面试题</a>。这里大概讲解了最终的答案，具体分析过程可以点进去查看，不过源码还是上面的那一套。</p>
<p>当一个线程池里面的线程异常后:</p>
<ol>
<li>当执行方式是execute时，可以看到堆栈异常的输出。</li>
<li>当执行方式是submit时，堆栈异常没有输出。但是调用<code>Future.get()</code>方法时，可以捕获到异常。</li>
<li>不会影响线程池里面其他线程的正常执行。</li>
<li>线程池会把这个线程移除掉，并创建一个新的线程放到线程池中。</li>
</ol>
<p>主要的图示如下：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/04/MIUmeaZ5E4zBb7o.png"  alt="线程异常如何处理"></p>
<hr>
<h2 id="2-7-四种线程池"><a href="#2-7-四种线程池" class="headerlink" title="2.7 四种线程池"></a>2.7 四种线程池</h2><h3 id="2-7-1-newCachedThreadPool"><a href="#2-7-1-newCachedThreadPool" class="headerlink" title="2.7.1 newCachedThreadPool"></a>2.7.1 newCachedThreadPool</h3><p>介绍：<code>CachedThreadPool</code> 是<strong>一个会根据需要创建新线程的线程池</strong>。下面通过源码来看看 <code>CachedThreadPool</code> 的实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>CachedThreadPool</code> 的 <code>corePoolSize</code> 被设置为空（0），<code>maximumPoolSize</code> 被设置为 <code>Integer.MAX.VALUE</code>，即它是无界的，这也就意味着如果主线程提交任务的速度高于 <code>maximumPool</code> 中线程处理任务的速度时，<code>CachedThreadPool</code> 会不断创建新的线程。极端情况下，这样会导致耗尽 cpu 和内存资源。</p>
<p><strong><code>newCachedThreadPool</code> 执行任务过程介绍：</strong></p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/03/9dF5A1UfK4RN83m.png"  alt="newCachedThreadPool 执行任务模型"></p>
<p><code>CacheThreadPool</code>的<strong>运行流程</strong>如下：</p>
<ol>
<li>提交任务进线程池。</li>
<li>因为<strong><code>corePoolSize</code></strong>为0的关系，不创建核心线程，线程池最大为<code>Integer.MAX_VALUE</code>。</li>
<li>尝试将任务添加到<strong><code>SynchronousQueue</code></strong>队列。</li>
<li>如果<code>SynchronousQueue</code>入列成功，等待被当前运行的线程空闲后拉取执行。如果当前没有空闲线程，那么就创建一个非核心线程，然后从<code>SynchronousQueue</code>拉取任务并在当前线程执行。</li>
<li>如果<code>SynchronousQueue</code>已有任务在等待，入列操作将会阻塞。</li>
</ol>
<p>当需要执行很多<strong>短时间</strong>的任务时，<code>CacheThreadPool</code>的线程复用率比较高， 会显著的<strong>提高性能</strong>。而且线程60s后会回收，意味着即使没有任务进来，<code>CacheThreadPool</code>并不会占用很多资源。</p>
<p><strong>为什么不推荐使用<code>CachedThreadPool</code>？</strong></p>
<ul>
<li><code>CachedThreadPool</code>允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 OOM。</li>
</ul>
<hr>
<h3 id="2-7-2-newFixedThreadPool"><a href="#2-7-2-newFixedThreadPool" class="headerlink" title="2.7.2 newFixedThreadPool"></a>2.7.2 newFixedThreadPool</h3><p><code>newFixedThreadPool</code> 的源码实现如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>分析一下：</p>
<p>核心线程数量和总线程数量相等，都是传入的参数<code>nThreads</code>，所以只能创建核心线程，不能创建非核心线程。因为<code>LinkedBlockingQueue</code>的默认大小是<code>Integer.MAX_VALUE</code>，故如果核心线程空闲，则交给核心线程处理；如果核心线程不空闲，则入列等待，直到核心线程空闲。</p>
<p><strong><code>FixedThreadPool</code> 执行任务过程介绍：</strong></p>
<p><code>FixedThreadPool</code> 的 <code>execute()</code> 方法运行示意图（该图片来源：《Java 并发编程的艺术》）：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/03/ys3GoqdfXANMJIR.png"  alt="FixedThreadPool 执行任务模型"></p>
<p>上图说明：</p>
<ol>
<li>如果当前运行的线程数小于 corePoolSize， 如果再来新任务的话，就创建新的线程来执行任务；</li>
<li>当前运行的线程数等于 corePoolSize 后， 如果再来新任务的话，会将任务加入 LinkedBlockingQueue；</li>
<li>线程池中的线程执行完 手头的任务后，会在循环中反复从 LinkedBlockingQueue 中获取任务来执行；</li>
</ol>
<p><strong>为什么不推荐使用<code>FixedThreadPool</code>？（注意这也是阿里巴巴不推荐使用的理由！）</strong></p>
<ul>
<li><code>FixedThreadPool</code> 使用无界队列 <code>LinkedBlockingQueue</code>（队列的容量为 <code>Intger.MAX_VALUE</code>）作为线程池的工作队列会对线程池带来如下影响 ：<ol>
<li>当线程池中的线程数达到 <code>corePoolSize</code> 后，新任务将在无界队列中等待，因此线程池中的线程数不会超过 <code>corePoolSize</code>；</li>
<li>由于使用无界队列时 <code>maximumPoolSize</code> 将是一个无效参数，因为不可能存在任务队列满的情况。所以，通过创建 <code>FixedThreadPool</code>的源码可以看出创建的 <code>FixedThreadPool</code> 的 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 被设置为同一个值。</li>
<li>由于 1 和 2，使用无界队列时 <code>keepAliveTime</code> 将是一个无效参数；</li>
<li>运行中的 <code>FixedThreadPool</code>（未执行 <code>shutdown()</code>或 <code>shutdownNow()</code>）不会拒绝任务，在任务比较多的时候会导致 OOM（内存溢出）。</li>
</ol>
</li>
</ul>
<p><strong>注意：<code>newFixedThreadPool</code> 与<code>CachedThreadPool</code> 的联系与区别：</strong></p>
<ul>
<li>因为 <code>corePoolSize == maximumPoolSize</code> ，所以<code>FixedThreadPool</code>只会创建核心线程。 而<code>CachedThreadPool</code>因为<code>corePoolSize=0</code>，所以只会创建非核心线程。</li>
<li>在 <code>getTask()</code> 方法，如果队列里没有任务可取，线程会一直阻塞在 <code>LinkedBlockingQueue.take()</code> ，线程不会被回收。 <code>CachedThreadPool</code>会在60s后收回。</li>
<li>由于线程不会被回收，会一直卡在阻塞，所以<strong>没有任务的情况下， FixedThreadPool占用资源更多</strong>。</li>
<li>都几乎不会触发拒绝策略，但是原理不同。<code>FixedThreadPool</code>是因为阻塞队列可以很大（最大为Integer最大值），故几乎不会触发拒绝策略；<code>CachedThreadPool</code>是因为线程池很大（最大为Integer最大值），几乎不会导致线程数量大于最大线程数，故几乎不会触发拒绝策略。</li>
</ul>
<hr>
<h3 id="2-7-3-newSingleThreadExecutor"><a href="#2-7-3-newSingleThreadExecutor" class="headerlink" title="2.7.3 newSingleThreadExecutor"></a>2.7.3 newSingleThreadExecutor</h3><p>其创建函数如下所示：</p>
<figure class="highlight haxe"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">SingleThreadExecutor</span>() {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">FinalizableDelegatedExecutorService</span></span><br><span class="line"><span class="type"></span>        (<span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0</span>L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>有且仅有一个核心线程（ <code>corePoolSize == maximumPoolSize=1</code>），使用了<code>LinkedBlockingQueue</code>（容量很大），所以，<strong>不会创建非核心线程</strong>。所有任务按照<strong>先来先执行</strong>的顺序执行。如果这个唯一的线程不空闲，那么新来的任务会存储在任务队列里等待执行。</p>
<p>从上面源代码可以看出新创建的 <code>SingleThreadExecutor</code> 的 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 都被设置为 1.其他参数和 <code>FixedThreadPool</code> 相同。</p>
<p><strong><code>newSingleThreadExecutor</code> 执行任务过程介绍：</strong></p>
<p><code>SingleThreadExecutor</code> 的运行示意图（该图片来源：《Java 并发编程的艺术》）：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/03/JAtXSsHNvQyw4dx.png"  alt="SingleThreadExecutor 执行任务模型"></p>
<p>上图说明：</p>
<ol>
<li>如果当前运行的线程数少于 <code>corePoolSize</code>，则创建一个新的线程执行任务；</li>
<li>当前线程池中有一个运行的线程后，将任务加入 <code>LinkedBlockingQueue</code>线程执行完；</li>
<li>当前的任务后，会在循环中反复从 <code>LinkedBlockingQueue</code> 中获取任务来执行；</li>
</ol>
<p><strong>为什么不推荐使用<code>SingleThreadExecutor</code>？</strong></p>
<ul>
<li><code>SingleThreadExecutor</code> 使用无界队列 <code>LinkedBlockingQueue</code> 作为线程池的工作队列（队列的容量为 <code>Intger.MAX_VALUE</code>）。对线程池带来的影响与 <code>FixedThreadPool</code> 相同。说简单点就是可能会导致 OOM。</li>
</ul>
<hr>
<h3 id="2-7-4-newScheduledThreadPool"><a href="#2-7-4-newScheduledThreadPool" class="headerlink" title="2.7.4 newScheduledThreadPool"></a>2.7.4 newScheduledThreadPool</h3><p><code>ScheduledThreadPool</code>是一<strong>个支持任务定时调度的线程池</strong>。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//ScheduledThreadPoolExecutor():</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong><code>newScheduledThreadPool</code> 执行任务过程介绍：</strong></p>
<p><code>ScheduledThreadPoolExecutor</code>继承自<code>ThreadPoolExecutor</code>。它主要用来在给定的延迟之后运行任务，或者定期执行任务。<code>ScheduledThreadPoolExecutor</code>的功能与Timer类似，但<code>ScheduledThreadPoolExecutor</code>功能更强大、更灵活。Timer对应的是单个后台线程，而<code>ScheduledThreadPoolExecutor</code>可以在构造函数中指定多个对应的后台线程数。</p>
<p>其源码如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//ScheduledThreadPoolExecutor():</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>newScheduledThreadPool</code> 的运行示意图（该图片来源：《Java 并发编程的艺术》）：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/03/AuUxb6LqDC9OHKv.png"  alt="newScheduledThreadPool 任务机制"></p>
<p><code>ScheduledThreadPoolExecutor</code>的执行主要分为两大部分</p>
<ol>
<li>当调用<code>ScheduledThreadPoolExecutor</code>的<code>scheduleAtFixedRate()</code>方法或者<code>scheduleWithFixedDelay()</code>方法时，会向<code>cheduledThreadPoolExecutor</code>的<code>DelayQueue</code>添加一个实现了<code>RunnableScheduledFutur</code>接口的<code>cheduledFutureTask</code>。</li>
<li>线程池中的线程从<code>DelayQueue</code>中获取<code>ScheduledFutureTask</code>，然后执行任务。</li>
</ol>
<hr>
<h1 id="3-线程池监控"><a href="#3-线程池监控" class="headerlink" title="3.线程池监控"></a>3.线程池监控</h1><p>通过线程池提供的参数进行监控。线程池里有一些属性在监控线程池的时候可以使用</p>
<ul>
<li>getTaskCount：线程池已经执行的和未执行的任务总数；</li>
<li>getCompletedTaskCount：线程池已完成的任务数量，该值小于等于taskCount；</li>
<li>getLargestPoolSize：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过，也就是达到了maximumPoolSize；</li>
<li>getPoolSize：线程池当前的线程数量；</li>
<li>getActiveCount：当前线程池中正在执行任务的线程数量。</li>
</ul>
<p><strong>通过扩展线程池进行监控</strong>。通过继承线程池并重写线程池的<code>beforeExecute</code>，<code>afterExecute</code>和<code>terminated</code>方法，我们可以在任务执行前，执行后和线程池关闭前干一些事情。如监控任务的平均执行时间，最大执行时间和最小执行时间等。</p>
<hr>
<h1 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h1><p>通过这么一系列从头到尾的对线程池进行了一个剖析，大概了解了其内部的运行机制了，线程池在Java 并发当中占据很重要的一个部分，能够运用好是一个很不容易的事情，如果对原理有更深入的了解的话，应该可以避免一些坑，多线程并发编程很多知识都在这里展示出来，需要了解多个方面的知识，应该要进行掌握线程池的原理和使用。</p>
<p>这篇文章大概说了以下几个内容：</p>
<ul>
<li>线程池总体设计</li>
<li>线程池任务执行的机制</li>
<li>ThreadPoolExecutor 的核心参数解析</li>
<li>ThreadPoolExecutor 的整体流程源码剖析</li>
<li>线程池复用是如何进行的</li>
<li>线程池线程异常的处理</li>
<li>四种线程池</li>
<li>如何配置及关闭线程池</li>
<li>两种使用ThreadPoolExecutor 的Demo</li>
</ul>
<p>最后留意一下阿里Java开发手册中关于线程池涉及到这几个问题：</p>
<ul>
<li>【强制】 线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。<ul>
<li>说明：线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换” 的问题。</li>
</ul>
</li>
<li>【强制】 线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。<ul>
<li>说明：Executors 返回的线程池对象的弊端如下：<ol>
<li><code>FixedThreadPool</code> 和 <code>SingleThreadPool</code>：<strong>允许的请求队列长度为 <code>Integer.MAX_VALUE</code>，可能会堆积大量的请求，从而导致 OOM</strong>。</li>
<li><code>CachedThreadPool</code>：<strong>允许的创建线程数量为 <code>Integer.MAX_VALUE</code>，可能会创建大量的线程，从而导致 OOM</strong>。</li>
</ol>
</li>
</ul>
</li>
<li>【强制】 必须回收自定义的 <code>ThreadLocal</code> 变量，尤其在线程池场景下，线程经常会被复用，如果不清理自定义的 <code>ThreadLocal</code> 变量，可能会影响后续业务逻辑和造成内存泄露等问题。尽量在代理中使用 <code>try-finally</code> 块进行回收。</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/03/McIv6xRuoEqQODY.png"  alt="image.png"></p>
<hr>
<p>参考资料：</p>
<ul>
<li><a href="[http://www.ideabuffer.cn/2017/04/04/深入理解Java线程池：ThreadPoolExecutor/](http://www.ideabuffer.cn/2017/04/04/深入理解Java线程池：ThreadPoolExecutor/)">深入理解Java线程池：ThreadPoolExecutor</a></li>
<li><a href="https://mp.weixin.qq.com/s/baYuX8aCwQ9PP6k7TDl2Ww" target="_blank" rel="noopener">Java线程池实现原理及其在美团业务中的实践</a></li>
<li><a href="http://www.tianxiaobo.com/2018/04/17/Java-线程池原理分析/" target="_blank" rel="noopener">Java 线程池原理分析</a></li>
<li><a href="https://www.cnblogs.com/dongguacai/p/6030187.html" target="_blank" rel="noopener">JAVA线程池原理详解一</a></li>
<li><a href="https://blog.csdn.net/lift_class/article/details/70216690" target="_blank" rel="noopener">线程池，这一篇或许就够了</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzIxNTQ4MzE1NA==&amp;mid=2247483741&amp;idx=1&amp;sn=238fc933c3b9b19ab1754b23283ac6fd&amp;chksm=9796d720a0e15e364f4105c29de606e7329760a41607136a722dc97bb177f9362aeacd92f762&amp;mpshare=1&amp;scene=1&amp;srcid=0327sk1b22zCDOAxzazzEBon&amp;sharer_sharetime=1585311891544&amp;sharer_shareid=b9c5b20e14a5ec65e524cd503ba56884&amp;key=362c475b03eb9012c3a4814de16c542df00e00cb88ad625adda59fe05e00e41bf016bca7d19de52329538b9719e995fa2746837543243fdd9b9a8a873c4b7306ae9be2f34fc0a8f197397eec5bcf36d7&amp;ascene=1&amp;uin=MjkxODQzNTgxMg%3D%3D&amp;devicetype=Windows+7&amp;version=62080079&amp;lang=zh_TW&amp;exportkey=A7VoXZ0wFQgcHgODYeWgoNo%3D&amp;pass_ticket=cBjPmhH%2B5L9207Zh9fWCw5cVrpKDK%2B3yqD%2FHI0IlhthmyIKGfVv3OEP8DCmqTYVl" target="_blank" rel="noopener">有的线程它死了，于是它变成一道面试题</a></li>
<li><a href="https://crossoverjie.top/2018/07/29/java-senior/ThreadPool/#" target="_blank" rel="noopener">如何优雅的使用和理解线程池</a></li>
<li>书籍：Java 并发编程的艺术</li>
<li>书籍：深入浅出Java 多线程</li>
<li>书籍：阿里巴巴Java开发手册</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - 锁相关：ReentrantReadWriteLock 分析</title>
    <url>/2020/03/31/java-bing-fa-suo-xiang-guan-reentrantreadwritelock-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>AQS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - 通信工具类：Semaphore 分析</title>
    <url>/2020/03/31/java-bing-fa-tong-xin-gong-ju-lei-semaphore-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>AQS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 集合框架 - HashTable 分析</title>
    <url>/2020/03/31/java-ji-he-kuang-jia-hashtable-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 集合框架 - CopyOnWriteArrayList 分析</title>
    <url>/2020/03/31/java-ji-he-kuang-jia-copyonwritearraylist-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 集合框架 - TreeMap 分析</title>
    <url>/2020/03/31/java-ji-he-kuang-jia-treemap-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 集合框架 - HashSet 分析</title>
    <url>/2020/03/31/java-ji-he-kuang-jia-hashset-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 框架分析 - 设计模式</title>
    <url>/2020/03/31/spring-kuang-jia-fen-xi-she-ji-mo-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - 通信工具类：Exchanger 分析</title>
    <url>/2020/03/31/java-bing-fa-tong-xin-gong-ju-lei-exchanger-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - 通信工具类：CountDownLatch 分析</title>
    <url>/2020/03/31/java-bing-fa-tong-xin-gong-ju-lei-countdownlatch-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>AQS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - 通信工具类：Cyclibarrier 分析</title>
    <url>/2020/03/31/java-bing-fa-tong-xin-gong-ju-lei-cyclibarrier-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>AQS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - AQS：框架分析</title>
    <url>/2020/03/31/java-bing-fa-aqs-kuang-jia-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-介绍AQS"><a href="#1-介绍AQS" class="headerlink" title="1.介绍AQS"></a>1.介绍AQS</h1><p>AbstractQueuedSynchronizer （抽象队列同步器，以下简称 AQS）出现在 JDK 1.5 中，AQS 这个东西在Java的并发中是很重要的一部分，因为他是很多同步器的基础框架，比如 ReentrantLock、CountDownLatch 和 Semaphore 等等都是基于 AQS 实现的。基于AQS来构建同步器可以带来很多好处。它不仅能够极大地减少实现工作，而且也不必处理在多个位置上发生的竞争问题。 </p>
<p>在基于AQS构建的同步器中，<u>只能在一个时刻发生阻塞，从而降低上下文切换的开销，提高了吞吐量</u>。同时在设计AQS时充分考虑了可伸缩行，因此J.U.C中所有基于AQS构建的同步器均可以获得这个优势。 </p>
<p>AQS的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态。</p>
<p>AQS使用一个int类型的成员变量state来表示同步状态，<u>当state&gt;0时表示已经获取了锁，当state = 0时表示释放了锁</u>。它提供了三个方法（<code>getState()</code>、<code>setState(int newState)</code>、<code>compareAndSetState(int expect,int update)</code>）来对同步状态state进行操作，当然AQS可以确保对state的操作是安全的。</p>
<p>AQS通过内置的<strong>FIFO同步队列</strong>（这个会重点分析一下）来完成资源获取线程的排队工作，如果当前线程获取同步状态失败（锁）时，AQS则会将当前线程以及等待状态等信息构造成一个节点（Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，则会把节点中的线程唤醒，使其再次尝试获取同步状态。 </p>
<p>一句话：AQS使用一个Volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值的修改。</p>
<p>这里列出了AQS主要提供的一些方法，方便快速定位：</p>
<ul>
<li><code>getState()</code>：返回同步状态的当前值；</li>
<li><code>setState(int newState)</code>：设置当前同步状态；</li>
<li><code>compareAndSetState(int expect, int update)</code>：使用CAS设置当前状态，该方法能够保证状态设置的原子性；</li>
<li><code>tryAcquire(int arg)</code>：独占式获取同步状态，获取同步状态成功后，其他线程需要等待该线程释放同步状态才能获取同步状态；</li>
<li><code>tryRelease(int arg)</code>：独占式释放同步状态；</li>
<li><code>tryAcquireShared(int arg)</code>：共享式获取同步状态，返回值大于等于0则表示获取成功，否则获取失败；</li>
<li><code>tryReleaseShared(int arg)</code>：共享式释放同步状态；</li>
<li><code>isHeldExclusively()</code>：当前同步器是否在独占式模式下被线程占用，一般该方法表示是否被当前线程所独占；</li>
<li><code>acquire(int arg)</code>：独占式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回，否则，将会进入同步队列等待，该方法将会调用可重写的tryAcquire(int arg)方法；</li>
<li><code>acquireInterruptibly(int arg)</code>：与acquire(int arg)相同，但是该方法响应中断，当前线程为获取到同步状态而进入到同步队列中，如果当前线程被中断，则该方法会抛出InterruptedException异常并返回；</li>
<li><code>tryAcquireNanos(int arg,long nanos)</code>：超时获取同步状态，如果当前线程在nanos时间内没有获取到同步状态，那么将会返回false，已经获取则返回true；</li>
<li><code>acquireShared(int arg)</code>：共享式获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，与独占式的主要区别是在同一时刻可以有多个线程获取到同步状态；</li>
<li><code>acquireSharedInterruptibly(int arg)</code>：共享式获取同步状态，响应中断；</li>
<li><code>tryAcquireSharedNanos(int arg, long nanosTimeout)</code>：共享式获取同步状态，增加超时限制；</li>
<li><code>release(int arg)</code>：独占式释放同步状态，该方法会在释放同步状态之后，将同步队列中第一个节点包含的线程唤醒；</li>
<li><code>releaseShared(int arg)</code>：共享式释放同步状态；</li>
</ul>
<p>以上这些方法在下面的源码分析中都会有所涉及，这个AQS框架还是有些代码量挺复杂的，好好理解的话对于后面的其他的一些锁相关机制、通信工具类都是很有帮助的，内功心法都学会了，其他的就简单很多了。</p>
<p>大体整个框架图（图出自美团）：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/W2c1Kex85fz3Z6V.png"  alt="AQS框架图"></p>
<hr>
<h1 id="2-AQS理论的数据结构"><a href="#2-AQS理论的数据结构" class="headerlink" title="2.AQS理论的数据结构"></a>2.AQS理论的数据结构</h1><p>AQS类中维护了一个双向链表(FIFO队列)， 这个队列也称CLH同步队列，有什么用呢？AQS就是靠这个队列来完成同步状态的管理的！</p>
<p>怎么进行管理的？这个问题问得好，大概流程就是这样：当前线程如果获取同步状态失败时，AQS则会将当前线程已经等待状态等信息构造成一个节点（Node）并将其加入到CLH同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点唤醒（公平锁），使其再次尝试获取同步状态。 </p>
<p>Node源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line">    <span class="comment">//标记一个结点（对应的线程）在共享模式下等待</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">// 标记一个结点（对应的线程）在独占模式下等待</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// waitStatus的值，表示该结点（对应的线程）已被取消</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED = <span class="number">1</span>; </span><br><span class="line">    <span class="comment">//waitStatus的值，表示后继结点（对应的线程）需要被唤醒</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//waitStatus的值，表示该结点（对应的线程）在等待某一条件</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// waitStatus的值，表示有资源可用，新head结点需要继续唤醒后继结点</span></span><br><span class="line">    <span class="comment">// （共享模式下，多线程并发释放资源，而head唤醒其后继结点后，需要把多出来的资源留给后面的结点；</span></span><br><span class="line">    <span class="comment">//  设置新的head结点时，会继续唤醒其后继结点）*/</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 等待状态，取值范围，-3，-2，-1，0，1(如上)</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">    <span class="comment">// 前驱结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev; </span><br><span class="line">    <span class="comment">// 后继结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next; </span><br><span class="line">    <span class="comment">// 结点对应的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread; </span><br><span class="line">    <span class="comment">// 等待队列里下一个等待条件的结点</span></span><br><span class="line">    Node nextWaiter; </span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>线程两种锁的模式：</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SHARED</td>
<td align="left">表示线程以共享的模式等待锁</td>
</tr>
<tr>
<td align="left">EXCLUSIVE</td>
<td align="left">表示线程正在以独占的方式等待锁</td>
</tr>
</tbody></table>
<p>waitStatus有下面几个枚举值：</p>
<table>
<thead>
<tr>
<th align="left">枚举</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">当一个Node被初始化的时候的默认值</td>
</tr>
<tr>
<td align="left">CANCELLED</td>
<td align="left">为1，表示线程获取锁的请求已经取消了</td>
</tr>
<tr>
<td align="left">CONDITION</td>
<td align="left">为-2，表示节点在等待队列中，节点线程等待唤醒</td>
</tr>
<tr>
<td align="left">PROPAGATE</td>
<td align="left">为-3，当前线程处在SHARED情况下，该字段才会使用</td>
</tr>
<tr>
<td align="left">SIGNAL</td>
<td align="left">为-1，表示线程已经准备好了，就等资源释放了</td>
</tr>
</tbody></table>
<p>Node的内部其实是这样的：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/11/1k73AyCUJz9lVTd.png"  alt="Node结点内部"></p>
<p>如上图所示，Node 的数据结构其实也挺简单的，就是 thread + waitStatus + pre + next 四个属性而已。</p>
<p>而AQS还有哪些属性呢？如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 头结点，可以理解为：当前持有锁的线程 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个链表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意区分state和waiteState！！！</span></span><br><span class="line"><span class="comment">// 这个是最重要的，代表当前锁的状态，0代表没有被占用，大于 0 代表有线程持有当前锁</span></span><br><span class="line"><span class="comment">// 这个值可以大于 1，是因为锁可以重入，每次重入都加上 1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表当前持有独占锁的线程，举个最重要的使用例子，因为锁可以重入</span></span><br><span class="line"><span class="comment">// reentrantLock.lock()可以嵌套调用多次，所以每次用这个来判断当前线程是否已经拥有了锁</span></span><br><span class="line"><span class="comment">// if (currentThread == getExclusiveOwnerThread()) {state++}</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread; <span class="comment">//继承自AbstractOwnableSynchronizer</span></span><br></pre></td></tr></tbody></table></figure>


<p>再抽象一点就是这样了，使用图示的话就如下可以很清晰的表达了（图源文末参考文章），不过需要注意的是：<u>阻塞队列不包含 head 节点。（如上图所示）</u></p>
<p>解释一下head：head是队列中标志，用于指示下一个被unpack的node，head来源于初始化的或曾取得过锁的node。</p>
<p>AbstractQueuedSynchronizer 的等待队列示意如下所示：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/11/9WIVEU64vpXCcP7.png"  alt="CLH队列（FIFO）"></p>
<p>关于双向队列的入队操作和出队操作这些应该比较容易理解，这里就不再讲了。</p>
<hr>
<h1 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3.源码分析"></a>3.源码分析</h1><p>AQS同时提供了互斥模式（exclusive）和共享模式（shared）两种不同的同步逻辑。一般情况下，子类只需要根据需求实现其中一种模式，当然也有同时实现两种模式的同步类，如<code>ReadWriteLock</code>。接下来将详细介绍这两种模式。</p>
<h2 id="3-1-独占模式"><a href="#3-1-独占模式" class="headerlink" title="3.1 独占模式"></a>3.1 独占模式</h2><h3 id="3-1-1-独占式同步状态获取：acquire"><a href="#3-1-1-独占式同步状态获取：acquire" class="headerlink" title="3.1.1 独占式同步状态获取：acquire"></a>3.1.1 独占式同步状态获取：acquire</h3><p>独占式获取同步状态时通过 acquire 进行的，他是AQS提供的模板方法，该方法为独占式获取同步状态。但是该方法对中断不敏感，也就是说由于线程获取同步状态失败加入到CLH同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移除。</p>
<p>acquire的主要完成的事情是这样的：</p>
<ol>
<li>获取独占锁，对中断不敏感。</li>
<li>首先尝试获取一次锁，如果成功，则返回，就结束了！！！</li>
<li>否则会把当前线程包装成Node插入到队列中，在队列中会检测是否为head的直接后继，并尝试获取锁</li>
<li>如果获取失败，则会通过LockSupport阻塞当前线程，直至被释放锁的线程唤醒或者被中断，随后再次尝试获取锁，如此反复。</li>
</ol>
<p>其源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">       <span class="comment">// tryAcquire:去尝试获取锁，获取成功则设置锁状态并返回true，否则返回false。</span></span><br><span class="line">       <span class="comment">// addWaiter：如果tryAcquire返回FALSE（获取同步状态失败），则调用该方法将当前线程加入到CLH同步队列尾部。</span></span><br><span class="line">       <span class="comment">// acquireQueued：当前线程会根据公平性原则来进行阻塞等待（自旋）,直到获取锁为止；并且返回当前线程在等待过程中有没有中断过。</span></span><br><span class="line">       <span class="comment">// selfInterrupt：产生一个中断。</span></span><br><span class="line">       <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; </span><br><span class="line">           <span class="comment">// tryAcquire(arg)没有成功，这个时候需要把当前线程挂起，放到阻塞队列中。</span></span><br><span class="line">           acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">           selfInterrupt();</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>



<h4 id="tryAcquire-int"><a href="#tryAcquire-int" class="headerlink" title="tryAcquire(int)"></a>tryAcquire(int)</h4><p>上面提到的<code>tryAcquire</code>方法， tryAcquire尝试以独占的方式获取资源，如果获取成功，则直接返回true，否则直接返回false。该方法可以用于实现Lock中的tryLock()方法。而AQS中并没有实现上面的<code>tryAcquire(arg)</code>方法，当你跟进去的时候会发现，只是抛出一个异常而已，该方法自定义同步组件自己实现，该方法必须要保证线程安全的获取同步状态。AQS在这里只负责定义了一个公共的方法框架。</p>
<p>这里之所以没有定义成abstract，是因为独占模式下只用实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。</p>
<p>其代码如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 去尝试获取锁，获取成功则设置锁状态并返回true，否则返回false。</span></span><br><span class="line"><span class="comment"> * 该方法自定义同步组件自己实现，该方法必须要保证线程安全的获取同步状态。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>而具体获取锁的操作需要由其子类进行实现，比如ReentrantLock中的Sync实现，如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fair version of tryAcquire.  Don't grant access unless</span></span><br><span class="line"><span class="comment"> * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 尝试直接获取锁，返回值是boolean，代表是否获取到锁</span></span><br><span class="line"><span class="comment">// 返回true：1.没有线程在等待锁；2.重入锁，线程本来就持有锁，也就可以理所当然可以直接获取</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// state == 0 此时此刻没有线程持有锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 虽然此时此刻锁是可以用的，但是这是公平锁，既然是公平，就得讲究先来后到，</span></span><br><span class="line">        <span class="comment">// 看看有没有别人在队列中等了半天了</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            <span class="comment">// 如果没有线程在等待，那就用CAS尝试一下，成功了就获取到锁了，</span></span><br><span class="line">            <span class="comment">// 不成功的话，只能说明一个问题，就在刚刚几乎同一时刻有个线程抢先了 =_=</span></span><br><span class="line">            <span class="comment">// 因为刚刚还没人的，我判断过了</span></span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) {</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 到这里就是获取到锁了，标记一下，告诉大家，现在是我占用了锁</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 会进入这个else if分支，说明是重入了，需要操作：state=state+1</span></span><br><span class="line">    <span class="comment">// 这里不存在并发问题</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) {</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果到这里，说明前面的if和else if都没有返回true，说明没有获取到锁</span></span><br><span class="line">    <span class="comment">// 回到上面一个外层调用方法继续看:</span></span><br><span class="line">    <span class="comment">// if (!tryAcquire(arg) </span></span><br><span class="line">    <span class="comment">//        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) </span></span><br><span class="line">    <span class="comment">//     selfInterrupt();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里你会发现上面有重入锁的概念，意思就是已经获取到锁的线程还可以再次获取到同一个锁，这里多嘴一下，有哪些锁是重入锁呢？比如：syschronized、ReentrantLock都属于重入锁，而自旋锁不属于重入锁。</p>
<hr>
<h4 id="addWaiter-Node"><a href="#addWaiter-Node" class="headerlink" title="addWaiter(Node)"></a>addWaiter(Node)</h4><p>假设<code>tryAcquire(arg)</code> 返回false，那么代码将执行：<code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code>，这个方法，首先需要执行：<code>addWaiter(Node.EXCLUSIVE)</code></p>
<p>该方法用于将当前线程根据不同的模式（<code>Node.EXCLUSIVE</code>互斥模式、<code>Node.SHARED</code>共享模式）加入到等待队列的队尾，并返回当前线程所在的结点。其添加过程是一个自旋过程，会去尝试能否添加到尾结点，如果队列为空会进行同步队列的初始化。需要注意的是，这里取消了快速尝试这个方法，<code>addWaiter</code>直接就自旋了，所以在这里是没有<code>enq(node);</code>这个方法的。</p>
<p>源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>{</span><br><span class="line">    <span class="comment">// 新建Node</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(mode);</span><br><span class="line">    <span class="comment">// 通过 CAS + 自旋的方式插入节点到队尾</span></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="comment">// 如果队列不为空，则先记录当前尾结点为旧的尾结点</span></span><br><span class="line">        Node oldTail = tail;</span><br><span class="line">        <span class="comment">// 判断队列是否为空，队列为空的话就先初始化队列再重新进入for循环当中，将结点node入队！</span></span><br><span class="line">        <span class="keyword">if</span> (oldTail != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 这个操作其实就是：node.prev = pred;</span></span><br><span class="line"><span class="comment">             * AQS的精妙就是体现在很多细节的代码，比如需要用CAS往队尾里增加一个元素</span></span><br><span class="line"><span class="comment">             * 此处的else分支是先在CAS的if前设置node.prev = oldTail，而不是在CAS成功之后再设置。</span></span><br><span class="line"><span class="comment">             * 一方面是基于CAS的双向链表插入目前没有完美的解决方案，另一方面这样子做的好处是：</span></span><br><span class="line"><span class="comment">             * 保证每时每刻tail.prev都不会是一个null值，否则如果node.prev = t</span></span><br><span class="line"><span class="comment">             * 放在下面if的里面，会导致一个瞬间tail.prev = null，这样会使得队列不完整。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            node.setPrevRelaxed(oldTail);</span><br><span class="line">            <span class="comment">// CAS设置tail为node，成功后把老的tail也就是连接到node。</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(oldTail, node)) {</span><br><span class="line">                <span class="comment">// 实现了和之前的尾节点双向连接了</span></span><br><span class="line">                oldTail.next = node;</span><br><span class="line">                <span class="comment">// 线程入队了，可以返回了</span></span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 如果队列为空，则初始化该同步队列</span></span><br><span class="line">            <span class="comment">// 初始化之后，没有return，会继续for循环！！！</span></span><br><span class="line">            initializeSyncQueue();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>initializeSyncQueue就是一个初始化同步队列的方法，其源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes head and tail fields on first contention.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initializeSyncQueue</span><span class="params">()</span> </span>{</span><br><span class="line">    Node h;</span><br><span class="line">    <span class="keyword">if</span> (HEAD.compareAndSet(<span class="keyword">this</span>, <span class="keyword">null</span>, (h = <span class="keyword">new</span> Node())))</span><br><span class="line">        <span class="comment">// 这个时候有了head，但是tail还是null，设置一下， 把tail指向head</span></span><br><span class="line">        <span class="comment">//，但是很快有线程进来，tail就会重新指向</span></span><br><span class="line">        <span class="comment">// 注意：这里只是设置了tail=head，此处没有return;</span></span><br><span class="line">        <span class="comment">// 所以，设置完了以后，继续for循环</span></span><br><span class="line">        tail = h;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<hr>
<h4 id="acquireQueued-Node-int"><a href="#acquireQueued-Node-int" class="headerlink" title="acquireQueued(Node, int)"></a>acquireQueued(Node, int)</h4><p>返回<code>acquire</code>方法中，参数node，经过addWaiter(Node.EXCLUSIVE)，此时已经进入阻塞队列，注意一下：如果acquireQueued(addWaiter(Node.EXCLUSIVE), arg))返回true的话，意味着上面这段代码将进入<code>selfInterrupt()</code>，所以正常情况下，下面应该返回false。</p>
<p>这个方法非常重要，应该说真正的线程挂起，然后被唤醒后去获取锁，都在这个方法里了！！！</p>
<p><code>acquireQueued</code>方法为一个<u>自旋的过程</u>，也就是说当前线程（Node）进入同步队列后，就会进入一个自旋的过程，每个节点都会自省地观察，当条件满足，获取到同步状态后，就可以从这个自旋过程中退出，否则会一直执行下去。如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="comment">// 中断标志</span></span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 自旋的过程</span></span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="comment">// 当前线程的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 检测当前节点前驱是否head，这是试获取锁的资格</span></span><br><span class="line">            <span class="comment">// 如果是的话，则调用tryAcquire尝试获取锁</span></span><br><span class="line">            <span class="comment">// 成功，则将head置为当前节点。</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) {</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 到这里，说明上面的if分支没有成功，要么当前node本来就不是队头，要么就是tryAcquire(arg)没有抢赢别人</span></span><br><span class="line">            <span class="comment">// 如果未成功获取锁则根据前驱节点判断是否要阻塞</span></span><br><span class="line">            <span class="comment">// 注意：在获取同步状态失败后，线程并不是立马进行阻塞，需要检查该线程的状态</span></span><br><span class="line">            <span class="comment">// 如果shouldParkAfterFailedAcquire返回false，会继续上面的for循环！！！</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node))</span><br><span class="line">                <span class="comment">// 上面的判断如果返回true, 说明前驱节点的waitStatus==-1，是正常情况</span></span><br><span class="line">                <span class="comment">//    那么当前线程需要被挂起，等待以后被唤醒</span></span><br><span class="line">                <span class="comment">//    以后是被前驱节点唤醒，就等着前驱节点拿到锁，然后释放锁的时候叫你好了</span></span><br><span class="line">                <span class="comment">// 如果返回false, 说明当前不需要被挂起</span></span><br><span class="line">                <span class="comment">//    仔细看shouldParkAfterFailedAcquire(p, node)，我们可以发现，其实第一次进来的时候，一般都不会返回true的</span></span><br><span class="line">                <span class="comment">//    原因很简单，前驱节点的waitStatus=-1是依赖于后继节点设置的。</span></span><br><span class="line">                <span class="comment">//    也就是说，我都还没给前驱设置-1呢，怎么可能是true呢，但是要看到，这个方法是套在循环里的，所以第二次进来的时候状态就是-1了。</span></span><br><span class="line">                <span class="comment">//    所以：是为了应对在经过这个方法后，node已经是head的直接后继节点了</span></span><br><span class="line">                interrupted |= parkAndCheckInterrupt();</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">        <span class="comment">// 如果tryAcquire 抛出异常的话，则进行状态获取的取消</span></span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">        <span class="comment">// 如果是中断状态的话，进行一个自我中断</span></span><br><span class="line">        <span class="keyword">if</span> (interrupted)</span><br><span class="line">            selfInterrupt();</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>从上面代码中可以看到，当前线程会一直尝试获取同步状态，当然前提是只有其前驱节点为头结点才能够尝试获取同步状态，理由：</p>
<ol>
<li>保持FIFO同步队列原则。</li>
<li>头节点释放同步状态后，将会唤醒其后继节点，后继节点被唤醒后需要检查自己是否为头节点。</li>
</ol>
<p>上面还有一点，就是当获取同步状态失败后，线程并不是立马进行阻塞，需要检查该线程的状态，检查状态的方法为 <code>shouldParkAfterFailedAcquire(Node pred, Node node)</code> 方法。该方法主要用途是：当线程在获取同步状态失败时，根据前驱节点的等待状态，决定后续的动作。比如前驱节点等待状态为 SIGNAL，表明当前节点线程应该被阻塞住了。不能老是尝试，避免 CPU 忙等。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 会到这里就是没有抢到锁，这个方法说的是："当前线程没有抢到锁，是否需要挂起当前线程？"</span></span><br><span class="line"><span class="comment">// 第一个参数是前驱节点，第二个参数才是代表当前线程的节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>{</span><br><span class="line">    <span class="comment">// 前驱节点</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">// 前驱节点状态为SIGNAL（-1），说明前驱节点状态正常，当前线程需要挂起，直接可以返回true</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 前驱节点 waitStatus大于0 ，之前说过，大于0 说明前驱节点取消了排队。</span></span><br><span class="line">    <span class="comment">// 这里需要知道这点：进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。</span></span><br><span class="line">    <span class="comment">// 所以下面这块代码说的是将当前节点的prev指向waitStatus&lt;=0的节点，</span></span><br><span class="line">    <span class="comment">// 简单说，就是为了找个好爹，因为你还得依赖它来唤醒呢，如果前驱节点取消了排队，</span></span><br><span class="line">    <span class="comment">// 找前驱节点的前驱节点做爹，往前遍历总能找到一个好爹的！！！</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">do</span> {</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        } <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 仔细想想，如果进入到这个分支意味着什么</span></span><br><span class="line">        <span class="comment">// 前驱节点的waitStatus不等于-1和1，那也就是只可能是0，-2，-3</span></span><br><span class="line">        <span class="comment">// 在我们前面的源码中，都没有看到有设置waitStatus的，所以每个新的node入队时，waitStatu都是0</span></span><br><span class="line">        <span class="comment">// 正常情况下，前驱节点是之前的 tail，那么它的 waitStatus 应该是 0</span></span><br><span class="line">        <span class="comment">// 用CAS将前驱节点的waitStatus设置为Node.SIGNAL(也就是-1)</span></span><br><span class="line">        pred.compareAndSetWaitStatus(ws, Node.SIGNAL);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 这个方法返回 false，那么会再走一次 for 循序，</span></span><br><span class="line">    <span class="comment">// 然后再次进来此方法，此时会从第一个分支返回 true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>这段代码主要检查当前线程是否需要被阻塞，具体规则如下：</p>
<ol>
<li>如果当前线程的前驱节点状态为SIGNAL，则表明当前线程需要被阻塞，调用unpark()方法唤醒，直接返回true，当前线程阻塞</li>
<li>如果当前线程的前驱节点状态为CANCELLED（ws &gt; 0），则表明该线程的前驱节点已经等待超时或者被中断了，则需要从CLH队列中将该前驱节点删除掉，直到回溯到前驱节点状态 &lt;= 0 ，返回false</li>
<li>如果前驱节点非SINGAL，非CANCELLED，则通过CAS的方式将其前驱节点设置为SIGNAL，返回false</li>
</ol>
<p>上面一堆看得眼花，简略来说如下：</p>
<ol>
<li>前驱节点为SIGNAL：阻塞。</li>
<li>前驱节点为CANCELLED ：向前遍历, 移除前面所有为该状态的节点。</li>
<li>前驱节点为waitStatus &lt; 0：将前驱节点状态设为 SIGNAL, 并再次尝试获取同步状态。</li>
</ol>
<p>如果<code>shouldParkAfterFailedAcquire</code>返回true，则<code>acquireQueued</code>则会接着调用<code>parkAndCheckInterrupt</code>来阻塞当前线程，该方法主要是把当前线程挂起，从而阻塞住线程的调用栈，同时返回当前线程的中断状态，其源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 调用LockSupport工具类的park()方法来阻塞该方法。</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 返回当前线程的中断状态</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>而关于<code>LockSupport</code>相关的东西，可以查看我对其分析的笔记：<a href="https://dongxiem.github.io/2020/04/11/java-bing-fa-aqs-locksupport-zu-sai-huan-xing-xian-cheng/">Java 并发 - AQS：LockSupport阻塞唤醒线程</a></p>
<p>再回到acquireQueued中，如果在获取同步状态中出现异常，<code>failed = true</code>，<code>cancelAcquire</code> 方法会被执行。因为tryAcquire 需同步组件开发者覆写，难免不了会出现异常。该方法主要的作用就是：取消获取同步状态。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>{</span><br><span class="line">       <span class="comment">// Ignore if node doesn't exist</span></span><br><span class="line">       <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">       node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 遍历并更新节点前驱，把node的prev指向前部第一个非取消节点</span></span><br><span class="line">       Node pred = node.prev;</span><br><span class="line">       <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">           node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 记录pred节点的后继为predNext，后续CAS会用到</span></span><br><span class="line">       Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 直接把当前节点的等待状态置为取消,后继节点即便也在cancel可以跨越node节点。</span></span><br><span class="line">       node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 如果CAS将tail从node置为pred节点了</span></span><br><span class="line"><span class="comment">       * 则剩下要做的事情就是尝试用CAS将pred节点的next更新为null以彻底切断pred和node的联系。</span></span><br><span class="line"><span class="comment">       * 这样一来就断开了pred与pred的所有后继节点，这些节点由于变得不可达，最终会被回收掉。</span></span><br><span class="line"><span class="comment">       * 由于node没有后继节点，所以这种情况到这里整个cancel就算是处理完毕了。</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * 这里的CAS更新pred的next即使失败了也没关系，说明有其它新入队线程或者其它取消线程更新掉了。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) {</span><br><span class="line">           <span class="comment">/* </span></span><br><span class="line"><span class="comment">            * 执行到这里，表明 pred 节点被成功设为了尾节点，这里通过 CAS 将 pred 节点的后继节点</span></span><br><span class="line"><span class="comment">            * 设为 null。注意这里的 CAS 即使失败了，也没关系。失败了，表明 pred 的后继节点更新</span></span><br><span class="line"><span class="comment">            * 了。pred 此时已经是尾节点了，若后继节点被更新，则是有新节点入队了。这种情况下，CAS </span></span><br><span class="line"><span class="comment">            * 会失败，但失败不会影响同步队列的结构。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           pred.compareAndSetNext(predNext, <span class="keyword">null</span>);</span><br><span class="line">       } <span class="keyword">else</span> {</span><br><span class="line">           <span class="comment">// 根据条件判断是唤醒后继节点，还是将前驱节点和后继节点连接到一起</span></span><br><span class="line">           <span class="keyword">int</span> ws;</span><br><span class="line">           <span class="comment">// 如果当前节点不是head的后继节点，1:判断当前节点前驱节点的是否为SIGNAL，2:如果不是，则把前驱节点设置为SINGAL看是否成功</span></span><br><span class="line">           <span class="comment">// 如果1和2中有一个为true，再判断当前节点的线程是否为null</span></span><br><span class="line">           <span class="comment">// 如果上述条件都满足，把当前节点的前驱节点的后继指针指向当前节点的后继节点    </span></span><br><span class="line">           <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">               ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">                (ws &lt;= <span class="number">0</span> &amp;&amp; pred.compareAndSetWaitStatus(ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">               pred.thread != <span class="keyword">null</span>) {</span><br><span class="line">               Node next = node.next;</span><br><span class="line">               <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                   <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    * 这里使用 CAS 设置 pred 的 next，表明多个线程同时在取消，这里存在竞争。</span></span><br><span class="line"><span class="comment">                    * 不过此处没针对 compareAndSetNext 方法失败后做一些处理，表明即使失败了也</span></span><br><span class="line"><span class="comment">                    * 没关系。实际上，多个线程同时设置 pred 的 next 引用时，只要有一个能设置成</span></span><br><span class="line"><span class="comment">                    * 功即可。</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                   pred.compareAndSetNext(predNext, next);</span><br><span class="line">           } <span class="keyword">else</span> {</span><br><span class="line">               <span class="comment">/*</span></span><br><span class="line"><span class="comment">                * 如果当前节点是head的后继节点，或者上述条件不满足，那就唤醒当前节点的后继节点</span></span><br><span class="line"><span class="comment">                * 这里简单讲一下为什么要唤醒后继线程，考虑下面一种情况：</span></span><br><span class="line"><span class="comment">                *        head          node1         node2         tail</span></span><br><span class="line"><span class="comment">                *        ws=0          ws=1          ws=-1         ws=0</span></span><br><span class="line"><span class="comment">                *      +------+  prev +-----+  prev +-----+  prev +-----+</span></span><br><span class="line"><span class="comment">                *      |      | &lt;---- |     | &lt;---- |     | &lt;---- |     |  </span></span><br><span class="line"><span class="comment">                *      |      | ----&gt; |     | ----&gt; |     | ----&gt; |     |</span></span><br><span class="line"><span class="comment">                *      +------+  next +-----+  next +-----+  next +-----+</span></span><br><span class="line"><span class="comment">                *      </span></span><br><span class="line"><span class="comment">                * 头结点初始状态为 0，node1、node2 和 tail 节点依次入队。node1 自旋过程中调用 </span></span><br><span class="line"><span class="comment">                * tryAcquire 出现异常，进入 cancelAcquire。head 节点此时等待状态仍然是 0，它</span></span><br><span class="line"><span class="comment">                * 会认为后继节点还在运行中，所它在释放同步状态后，不会去唤醒后继等待状态为非取消的</span></span><br><span class="line"><span class="comment">                * 节点 node2。如果 node1 再不唤醒 node2 的线程，该线程面临无法被唤醒的情况。此</span></span><br><span class="line"><span class="comment">                * 时，整个同步队列就回全部阻塞住。</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">               unparkSuccessor(node);</span><br><span class="line">           }</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">           * 取消节点的next之所以设置为自己本身而不是null,</span></span><br><span class="line"><span class="comment">           * 是为了方便AQS中Condition部分的isOnSyncQueue方法,</span></span><br><span class="line"><span class="comment">           * 判断一个原先属于条件队列的节点是否转移到了同步队列。</span></span><br><span class="line"><span class="comment">           *</span></span><br><span class="line"><span class="comment">           * 因为同步队列中会用到节点的next域，取消节点的next也有值的话，</span></span><br><span class="line"><span class="comment">           * 可以断言next域有值的节点一定在同步队列上。</span></span><br><span class="line"><span class="comment">           *</span></span><br><span class="line"><span class="comment">           * 在GC层面，和设置为null具有相同的效果。</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">           node.next = node; <span class="comment">// help GC</span></span><br><span class="line">       }</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line"><span class="comment">// unparkSuccessor的作用是唤醒后继节点，其源码如下：</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>{</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">        * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">        * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">// 当前节点状态</span></span><br><span class="line">       <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">       <span class="comment">// 通过 CAS 将等待状态设为 0，让后继节点线程多一次尝试获取同步状态的机会</span></span><br><span class="line">       <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">           node.compareAndSetWaitStatus(ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 当前节点的后继节点</span></span><br><span class="line">       Node s = node.next;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 这里的逻辑就是如果node.next存在并且状态不为取消，则直接唤醒s即可</span></span><br><span class="line"><span class="comment">        * 否则需要从tail开始向前找到node之后最近的非取消节点。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 这里为什么要从tail开始向前查找也是值得琢磨的:</span></span><br><span class="line"><span class="comment">        * 如果读到s == null，不代表node就为tail，参考addWaiter以及enq函数中的我的注释。</span></span><br><span class="line"><span class="comment">        * 不妨考虑到如下场景：</span></span><br><span class="line"><span class="comment">        * 1. node某时刻为tail</span></span><br><span class="line"><span class="comment">        * 2. 有新线程通过addWaiter中的if分支或者enq方法添加自己</span></span><br><span class="line"><span class="comment">        * 3. compareAndSetTail成功</span></span><br><span class="line"><span class="comment">        * 4. 此时这里的Node s = node.next读出来s == null，但事实上node已经不是tail，它有后继了!</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) {</span><br><span class="line">           s = <span class="keyword">null</span>;</span><br><span class="line">           <span class="comment">// 从tail节点开始往前遍历来找可用节点</span></span><br><span class="line">           <span class="comment">// 为何是从tail尾节点开始，而不是从node.next开始呢？</span></span><br><span class="line">           <span class="comment">// 原因在于node.next仍然可能会存在null或者取消了，所以采用tail回溯办法找第一个可用的线程。</span></span><br><span class="line">           <span class="comment">// 最后调用LockSupport的unpark(Thread thread)方法唤醒该线程。</span></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">           * 这里如果 s == null 处理，是不是表明 node 是尾节点？答案是不一定。 </span></span><br><span class="line"><span class="comment">           * 新节点入队时，队列瞬时结构可能如下：</span></span><br><span class="line"><span class="comment">           *                      node1         node2</span></span><br><span class="line"><span class="comment">           *      +------+  prev +-----+ prev  +-----+</span></span><br><span class="line"><span class="comment">           * head |      | &lt;---- |     | &lt;---- |     |  tail</span></span><br><span class="line"><span class="comment">           *      |      | ----&gt; |     |       |     |</span></span><br><span class="line"><span class="comment">           *      +------+ next  +-----+       +-----+</span></span><br><span class="line"><span class="comment">           * </span></span><br><span class="line"><span class="comment">           * node2 节点为新入队节点，此时 tail 已经指向了它，但 node1 后继引用还未设置。</span></span><br><span class="line"><span class="comment">           * 这里 node1 就是 node 参数，s = node1.next = null，但此时 node1 并不是尾</span></span><br><span class="line"><span class="comment">           * 节点。所以这里不能从前向后遍历同步队列，应该从后向前。</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">           <span class="keyword">for</span> (Node p = tail; p != node &amp;&amp; p != <span class="keyword">null</span>; p = p.prev)</span><br><span class="line">               <span class="keyword">if</span> (p.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                   s = p;</span><br><span class="line">       }</span><br><span class="line">       <span class="comment">// 唤醒后继节点</span></span><br><span class="line">       <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">           LockSupport.unpark(s.thread);</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>



<p>上面大概就是：获取当前节点的前驱节点，如果前驱节点的状态是CANCELLED，那就一直往前遍历，找到第一个waitStatus &lt;= 0的节点，将找到的Pred节点和当前Node关联，将当前Node设置为CANCELLED。</p>
<p>进行了上述的一些操作之后根据当前节点的位置，其实需要考虑以下三种情况：</p>
<ol>
<li>当前节点是尾节点。</li>
<li>当前节点是Head的后继节点。</li>
<li>当前节点不是Head的后继节点，也不是尾节点。</li>
</ol>
<p>具体分析一下一上三种情况：</p>
<p>当前节点是尾节点</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/cRFCu2bP7m4a5Yt.png"  alt="当前节点是尾节点"></p>
<p>当前节点是Head的后继节点：</p>
<p>取消节点的next可以设置为自己本身，不设置为null，上面的注释中有进行解释了，这里就不再解释了，如果有疑惑就往上面翻一下下。</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/qSL31JfmY86jkCF.png"  alt="当前节点是Head的后继节点"></p>
<p>当前节点不是Head的后继节点，也不是尾节点</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/xJrFBz24lspPAIw.png"  alt="当前节点不是Head的后继节点 也不是尾节点"></p>
<hr>
<h4 id="selfInterrupt"><a href="#selfInterrupt" class="headerlink" title="selfInterrupt"></a>selfInterrupt</h4><p>在上面如果acquireQueued为True，就会执行selfInterrupt方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>{</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread()) {</span><br><span class="line">        checkAccess();</span><br><span class="line">        <span class="comment">// 线程可能因为IO操作被阻塞</span></span><br><span class="line">        <span class="keyword">synchronized</span> (blockerLock) {</span><br><span class="line">            Interruptible b = blocker;</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="keyword">null</span>) {</span><br><span class="line">                interrupt0();  <span class="comment">// 设置中断状态</span></span><br><span class="line">                b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 设置中断状态</span></span><br><span class="line">    interrupt0();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>该方法其实是为了中断线程。但<u>为什么获取了锁以后还要中断线程呢</u>？这部分属于Java提供的协作式中断知识内容，这里简单介绍一下：</p>
<ol>
<li>当中断线程被唤醒时，并不知道被唤醒的原因，可能是当前线程在等待中被中断，也可能是释放了锁以后被唤醒。因此我们通过Thread.interrupted()方法检查中断标记（该方法返回了当前线程的中断状态，并将当前线程的中断标识设置为False），并记录下来，如果发现该线程被中断过，就再中断一次。</li>
<li>线程在等待资源的过程中被唤醒，唤醒后还是会不断地去尝试获取锁，直到抢到锁为止。也就是说，在整个流程中，并不响应中断，只是记录中断记录。最后抢到锁返回了，那么如果被中断过的话，就需要补充一次中断。</li>
</ol>
<p>这里的处理方式主要是运用线程池中基本运作单元Worder中的runWorker，通过Thread.interrupted()进行额外的判断处理。</p>
<p>整个流程大概就是这么一个回事了，大概的流程还是清楚的，但是个中细节还有待深挖。</p>
<hr>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>总结一下，acquire的大概流程如下：</p>
<ol>
<li>调用 tryAcquire 方法尝试获取同步状态</li>
<li>获取成功，直接返回</li>
<li>获取失败，将线程封装到节点中，并将节点入队</li>
<li>入队节点在 acquireQueued 方法中自旋获取同步状态</li>
<li>若节点的前驱节点是头节点，则再次调用 tryAcquire 尝试获取同步状态</li>
<li>获取成功，当前节点将自己设为头节点并返回</li>
<li>获取失败，可能再次尝试，也可能会被阻塞。这里简单认为会被阻塞。</li>
</ol>
<p>acquire的流程图如下（图源见文末文章出处）：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/11/TSpwJ46vCqWVF9l.png"  alt="acquire执行过程"></p>
<h4 id="示例分析："><a href="#示例分析：" class="headerlink" title="示例分析："></a>示例分析：</h4><p>以下摘自：<a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer" target="_blank" rel="noopener">一行一行源码分析清楚AbstractQueuedSynchronizer</a>，他以<code>reentrantLock</code>进行一个简单的分析：</p>
<p>首先，第一个线程调用 reentrantLock.lock()，<code>tryAcquire(1)</code> 直接就返回 true 了，结束。只是设置了 <code>state=1</code>，连 head 都没有初始化，更谈不上什么阻塞队列了。要是线程 1 调用 unlock() 了，才有线程 2 来，完全没有交集嘛，AQS就派不上用场了。</p>
<p>于是便引出一个问题：如果线程 1 没有调用 unlock() 之前，线程 2 调用了 lock(), 想想会发生什么？</p>
<p>线程 2 会初始化 head【<code>new Node()</code>】，同时线程 2 也会插入到阻塞队列并挂起 （注意看这里是一个 for 循环，而且设置 head 和 tail 的部分是不 return 的，只有入队成功才会跳出循环）</p>
<p>首先，是线程 2 初始化 head 节点，此时 <code>head== tail</code>,  <code>waitStatus==0</code></p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/2P9voOH3txybzYM.png"  alt="初始化head节点"></p>
<p>然后线程 2 入队：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/nexW1CDvzYcRPAh.png"  alt="线程2入队"></p>
<p>同时我们也要看此时节点的 <code>waitStatus</code>，我们知道 head 节点是线程 2 初始化的，此时的 <code>waitStatus</code> 没有设置， java 默认会设置为 0，但是到 <code>shouldParkAfterFailedAcquire</code> 这个方法的时候，线程 2 会把前驱节点，也就是 head 的<code>waitStatus</code>设置为 -1。</p>
<p>那线程 2 节点此时的 <code>waitStatus</code> 是多少呢，由于没有设置，所以是 0；</p>
<p>如果线程 3 此时再进来，直接插到线程 2 的后面就可以了，此时线程 3 的 waitStatus 是 0，到 <code>shouldParkAfterFailedAcquire</code> 方法的时候把前驱节点线程 2 的 waitStatus 设置为 -1。</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/v6EI48NwXt9Hsx3.png"  alt="线程3入队"></p>
<p>这里可以简单说下 <code>waitStatus</code> 中 <code>SIGNAL(-1)</code> 状态的意思，Doug Lea 注释的是：<strong>代表后继节点需要被唤醒</strong>。也就是说<u>这个 waitStatus 其实代表的不是自己的状态，而是后继节点的状态</u>，我们知道，每个 node 在入队的时候，都会把前驱节点的状态改为 SIGNAL，然后阻塞，等待被前驱唤醒。这里涉及的是两个问题：有线程取消了排队、唤醒操作。其实本质是一样的，可以顺着 “waitStatus代表后继节点的状态” 这种思路去看一遍源码。</p>
<hr>
<h3 id="3-1-2-独占式获取响应中断"><a href="#3-1-2-独占式获取响应中断" class="headerlink" title="3.1.2 独占式获取响应中断"></a>3.1.2 独占式获取响应中断</h3><p>AQS提供了<code>acquire(int arg)</code>方法以供独占式获取同步状态，但是该方法对中断不响应，对线程进行中断操作后，该线程会依然位于CLH同步队列中等待着获取同步状态。为了响应中断，AQS提供了<code>acquireInterruptibly(int arg)</code>方法，<u>该方法在等待获取同步状态时，如果当前线程被中断了，会立刻响应中断抛出异常`InterruptedException</u></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>{ <span class="comment">// 这里直接抛出InterruptedException</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 还是一样自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) {</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">        <span class="comment">// 如果有异常，一样要取消申请</span></span><br><span class="line">        <span class="comment">// 然后再抛出异常，而不是使用interrupted标志</span></span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>首先校验该线程是否已经中断了，如果是则抛出<code>InterruptedException</code>，否则执行<code>tryAcquire(int arg)</code>方法获取同步状态，如果获取成功，则直接返回，否则执行<code>doAcquireInterruptibly(int arg)</code>。<code>doAcquireInterruptibly(int arg)</code>定义如下：</p>
<p>doAcquireInterruptibly(int arg)方法与acquire(int arg)方法仅有两个差别：</p>
<ol>
<li>方法声明抛出InterruptedException异常</li>
<li>在中断方法处不再是使用interrupted标志，而是直接抛出InterruptedException异常。</li>
</ol>
<hr>
<h3 id="3-1-3-独占式超时获取"><a href="#3-1-3-独占式超时获取" class="headerlink" title="3.1.3 独占式超时获取"></a>3.1.3 独占式超时获取</h3><p>AQS除了提供上面两个方法外，还提供了一个<u>增强版的方法</u>：<code>tryAcquireNanos(int arg,long nanos)</code>。该方法为<code>acquireInterruptibly</code>方法的进一步增强，它除了响应中断外，还有超时控制。即如果当前线程没有在指定时间内获取同步状态，则会返回false，否则返回true。如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">     <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">     <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">         doAcquireNanos(arg, nanosTimeout);</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">     <span class="comment">// nanosTimeout &lt;= 0</span></span><br><span class="line">     <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     <span class="comment">// 超时时间</span></span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">     <span class="comment">// 新增Node节点</span></span><br><span class="line">     <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">     <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">     <span class="keyword">try</span> {</span><br><span class="line">         <span class="comment">// 自旋</span></span><br><span class="line">         <span class="keyword">for</span> (;;) {</span><br><span class="line">             <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">             <span class="comment">// 获取同步状态成功</span></span><br><span class="line">             <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) {</span><br><span class="line">                 setHead(node);</span><br><span class="line">                 p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                 failed = <span class="keyword">false</span>;</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">             }</span><br><span class="line">             <span class="comment">/*</span></span><br><span class="line"><span class="comment">              * 获取失败，做超时、中断判断</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">             <span class="comment">// 重新计算需要休眠的时间</span></span><br><span class="line">             nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">             <span class="comment">// 已经超时，返回false</span></span><br><span class="line">             <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             <span class="comment">// 如果没有超时，则等待nanosTimeout纳秒</span></span><br><span class="line">             <span class="comment">// 注：该线程会直接从LockSupport.parkNanos中返回，</span></span><br><span class="line">             <span class="comment">// LockSupport为JUC提供的一个阻塞和唤醒的工具类，后面做详细介绍</span></span><br><span class="line">             <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                     nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                 LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">             <span class="comment">// 线程是否已经中断了</span></span><br><span class="line">             <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                 <span class="comment">// 抛出一个异常并且结束</span></span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">         }</span><br><span class="line">     } <span class="keyword">finally</span> {</span><br><span class="line">         <span class="keyword">if</span> (failed)</span><br><span class="line">             cancelAcquire(node);</span><br><span class="line">     }</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>



<p>其大概流程如下：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/11/LKxausrV8qbcQm6.png"  alt="独占式超时获取"></p>
<hr>
<h3 id="3-1-4-独占式同步状态释放：release"><a href="#3-1-4-独占式同步状态释放：release" class="headerlink" title="3.1.4 独占式同步状态释放：release"></a>3.1.4 独占式同步状态释放：release</h3><p>释放的过程会比较简单点：</p>
<ol>
<li>调用 <code>tryRelease(arg)</code> 尝试释放同步状态</li>
<li>如果 <code>tryRelease</code> 返回true也就是独占锁被完全释放，唤醒后继线程。</li>
</ol>
<p>这里的唤醒是根据head几点来判断的，下面代码的注释中也分析了head节点的情况，只有在head存在并且等待状态小于零的情况下唤醒。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Releases in exclusive mode.  Implemented by unblocking one or</span></span><br><span class="line"><span class="comment"> * more threads if {<span class="doctag">@link</span> #tryRelease} returns true.</span></span><br><span class="line"><span class="comment"> * This method can be used to implement method {<span class="doctag">@link</span> Lock#unlock}.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment"> *        {<span class="doctag">@link</span> #tryRelease} but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment"> *        can represent anything you like.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the value returned from {<span class="doctag">@link</span> #tryRelease}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 当线程获取同步状态后，执行完相应逻辑后就需要释放同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 此时的head节点可能有3种情况:</span></span><br><span class="line"><span class="comment">     * 1. null (AQS的head延迟初始化+无竞争的情况)</span></span><br><span class="line"><span class="comment">     * 2. 当前线程在获取锁时new出来的节点通过setHead设置的</span></span><br><span class="line"><span class="comment">     * 3. 由于通过tryRelease已经完全释放掉了独占锁，有新的节点在acquireQueued中获取到了独占锁，并设置了head</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 第三种情况可以再分为两种情况：</span></span><br><span class="line"><span class="comment">     * （一）时刻1:线程A通过acquireQueued，持锁成功，set了head</span></span><br><span class="line"><span class="comment">     *          时刻2:线程B通过tryAcquire试图获取独占锁失败失败，进入acquiredQueued</span></span><br><span class="line"><span class="comment">     *          时刻3:线程A通过tryRelease释放了独占锁</span></span><br><span class="line"><span class="comment">     *          时刻4:线程B通过acquireQueued中的tryAcquire获取到了独占锁并调用setHead</span></span><br><span class="line"><span class="comment">     *          时刻5:线程A读到了此时的head实际上是线程B对应的node</span></span><br><span class="line"><span class="comment">     * （二）时刻1:线程A通过tryAcquire直接持锁成功，head为null</span></span><br><span class="line"><span class="comment">     *          时刻2:线程B通过tryAcquire试图获取独占锁失败失败，入队过程中初始化了head，进入acquiredQueued</span></span><br><span class="line"><span class="comment">     *          时刻3:线程A通过tryRelease释放了独占锁，此时线程B还未开始tryAcquire</span></span><br><span class="line"><span class="comment">     *          时刻4:线程A读到了此时的head实际上是线程B初始化出来的傀儡head</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) {</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// head节点状态不会是CANCELLED，所以这里h.waitStatus != 0相当于h.waitStatus &lt; 0</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 释放成功后，会调用unparkSuccessor(Node node)方法唤醒后继节点</span></span><br><span class="line">            <span class="comment">// 上面已经分析过了，不再叙述</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>跟tryAcquire一样，tryRelease也是由用户自己去实现了，其源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 独占式释放同步状态；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<hr>
<h2 id="3-2-共享模式"><a href="#3-2-共享模式" class="headerlink" title="3.2 共享模式"></a>3.2 共享模式</h2><p>其实如果理解了上面的独享模式之后再来理解共享模式，难度不大，主要是与共享模式下，同一时刻会有多个线程获取共享同步状态。共享模式是实现读写锁中的读锁、CountDownLatch 和 Semaphore 等同步组件的基础，这样再去理解一些共享同步组件就不难了。</p>
<h3 id="3-2-1-同步状态获取：acquireShared"><a href="#3-2-1-同步状态获取：acquireShared" class="headerlink" title="3.2.1 同步状态获取：acquireShared"></a>3.2.1 同步状态获取：acquireShared</h3><p>共享式获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，与独占式的主要区别是在同一时刻可以有多个线程获取到同步状态；</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="comment">// 尝试获取共享同步状态，tryAcquireShared 返回的是整型</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 获取失败，自旋获取同步状态</span></span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>其中<code>doAcquireShared</code>以自旋方式获取同步状态，共享式获取同步状态的标志是返回 &gt;= 0 的值表示获取成功，该方法不响应中断，与独占式相似；</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="comment">// 共享式节点</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 这里和前面一样，也是通过有限次自旋的方式获取同步状态</span></span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="comment">// 前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 前驱是头结点，其类型可能是 EXCLUSIVE，也可能是 SHARED.</span></span><br><span class="line"><span class="comment">             * 如果是 EXCLUSIVE，线程无法获取共享同步状态。</span></span><br><span class="line"><span class="comment">             * 如果是 SHARED，线程则可获取共享同步状态。</span></span><br><span class="line"><span class="comment">             * 能不能获取共享同步状态要看 tryAcquireShared 具体的实现。比如多个线程竞争读写</span></span><br><span class="line"><span class="comment">             * 锁的中的读锁时，均能成功获取读锁。但多个线程同时竞争信号量时，可能就会有一部分线</span></span><br><span class="line"><span class="comment">             * 程因无法竞争到信号量资源而阻塞。</span></span><br><span class="line"><span class="comment">             */</span> </span><br><span class="line">            <span class="keyword">if</span> (p == head) {</span><br><span class="line">                <span class="comment">// 尝试获取同步状态</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) {</span><br><span class="line">                    <span class="comment">// 设置头结点，如果后继节点是共享类型，唤醒后继节点</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node))</span><br><span class="line">                interrupted |= parkAndCheckInterrupt();</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (interrupted)</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p><code>setHeadAndPropagate</code>这个函数主要做了两件事：</p>
<ol>
<li>在获取共享锁成功后，设置head节点</li>
<li>根据调用tryAcquireShared返回的状态以及节点本身的等待状态来判断是否要需要唤醒后继线程。</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>{</span><br><span class="line">    <span class="comment">// 把当前的head封闭在方法栈上，用以下面的条件检查。</span></span><br><span class="line">    Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Try to signal next queued node if:</span></span><br><span class="line"><span class="comment">     *   Propagation was indicated by caller,</span></span><br><span class="line"><span class="comment">     *     or was recorded (as h.waitStatus either before</span></span><br><span class="line"><span class="comment">     *     or after setHead) by a previous operation</span></span><br><span class="line"><span class="comment">     *     (note: this uses sign-check of waitStatus because</span></span><br><span class="line"><span class="comment">     *      PROPAGATE status may transition to SIGNAL.)</span></span><br><span class="line"><span class="comment">     * and</span></span><br><span class="line"><span class="comment">     *   The next node is waiting in shared mode,</span></span><br><span class="line"><span class="comment">     *     or we don't know, because it appears null</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The conservatism in both of these checks may cause</span></span><br><span class="line"><span class="comment">     * unnecessary wake-ups, but only when there are multiple</span></span><br><span class="line"><span class="comment">     * racing acquires/releases, so most need signals now or soon</span></span><br><span class="line"><span class="comment">     * anyway.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// propagate是tryAcquireShared的返回值，这是决定是否传播唤醒的依据之一。</span></span><br><span class="line">    <span class="comment">// h.waitStatus为SIGNAL或者PROPAGATE时也根据node的下一个节点共享来决定是否传播唤醒</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        <span class="comment">// h.waitStatus &lt; 0 时，waitStatus = SIGNAL 或 PROPAGATE。</span></span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) {</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="comment">// 节点 s 如果是共享类型节点，则应该唤醒该节点</span></span><br><span class="line">        <span class="comment">// 至于 s == null 的情况前面分析过，这里不在赘述。</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>那继续到<code>doReleaseShared</code>里面看看做了些什么：</p>
<p><code>doReleaseShared</code>该方法用于在 acquires/releases 存在竞争的情况下，确保唤醒动作向后传播。这是共享锁中的核心唤醒函数，主要做的事情就是唤醒下一个线程或者设置传播状态。后继线程被唤醒后，会尝试获取共享锁，如果成功之后，则又会调用setHeadAndPropagate,将唤醒传播下去。</p>
<p>总的来说：<u>这个函数的作用是保障在acquire和release存在竞争的情况下，保证队列中处于等待状态的节点能够有办法被唤醒。</u></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Release action for shared mode -- signals successor and ensures</span></span><br><span class="line"><span class="comment"> * propagation. (Note: For exclusive mode, release just amounts</span></span><br><span class="line"><span class="comment"> * to calling unparkSuccessor of head if it needs signal.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 以下的循环做的事情就是，在队列存在后继线程的情况下，唤醒后继线程；</span></span><br><span class="line"><span class="comment">     * 或者由于多线程同时释放共享锁由于处在中间过程，读到head节点等待状态为0的情况下，</span></span><br><span class="line"><span class="comment">     * 虽然不能unparkSuccessor，但为了保证唤醒能够正确稳固传递下去，设置节点状态为PROPAGATE。</span></span><br><span class="line"><span class="comment">     * 这样的话获取锁的线程在执行setHeadAndPropagate时可以读到PROPAGATE，从而由获取锁的线程去释放后继等待线程。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// 如果队列中存在后继线程。</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) {</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) {</span><br><span class="line">                <span class="keyword">if</span> (!h.compareAndSetWaitStatus(Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 如果h节点的状态为0，需要设置为PROPAGATE用以保证唤醒的传播。</span></span><br><span class="line">            <span class="comment">// setHeadAndPropagate 在读到 h.waitStatus &lt; 0 时，可以继续唤醒后面的节点。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !h.compareAndSetWaitStatus(<span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 检查h是否仍然是head，如果不是的话需要再进行循环。</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>最后说一下共享模式下获取同步状态的大致流程，如下：</p>
<ol>
<li>获取共享同步状态</li>
<li>若获取失败，则生成节点，并入队</li>
<li>如果前驱为头结点，再次尝试获取共享同步状态</li>
<li>获取成功则将自己设为头结点，如果后继节点是共享类型的，则唤醒</li>
<li>若失败，将节点状态设为 SIGNAL，再次尝试。若再次失败，线程进入等待状态</li>
</ol>
<hr>
<h3 id="3-2-2-共享状态释放：releaseShared"><a href="#3-2-2-共享状态释放：releaseShared" class="headerlink" title="3.2.2 共享状态释放：releaseShared"></a>3.2.2 共享状态释放：releaseShared</h3><p>释放共享状态主要逻辑在 doReleaseShared ，而我们前面已经分析过他了，所以就不继续了。共享节点线程在获取同步状态和释放同步状态时都会调用 doReleaseShared，所以 doReleaseShared 是多线程竞争集中的地方。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) {</span><br><span class="line">        <span class="comment">// 因为可能会存在多个线程同时进行释放同步状态资源</span></span><br><span class="line">        <span class="comment">// 所以在doReleaseShared需要确保同步状态安全地成功释放，一般都是通过CAS和循环来完成的。</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<hr>
<h1 id="4-一些疑问"><a href="#4-一些疑问" class="headerlink" title="4.一些疑问"></a>4.一些疑问</h1><h2 id="4-1-插入节点时的代码顺序"><a href="#4-1-插入节点时的代码顺序" class="headerlink" title="4.1 插入节点时的代码顺序"></a>4.1 插入节点时的代码顺序</h2><p><code>addWaiter</code> 方法中新增一个节点时为什么要先将新节点的prev置为tail再尝试CAS，而不是CAS成功后来构造节点之间的双向链接？</p>
<p>这是因为，双向链表目前没有基于CAS原子插入的手段，如果我们将<code>node.prev = t</code>和<code>t.next = node</code>（t为方法执行时读到的tail，引用封闭在栈上）放到<code>compareAndSetTail(t, node)</code>成功后执行，如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (compareAndSetTail(t, node)) {</span><br><span class="line">   node.prev = t;</span><br><span class="line">   t.next = node;</span><br><span class="line">   <span class="keyword">return</span> t;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>会导致这一瞬间的tail也就是t的prev为null，这就使得这一瞬间队列处于一种不一致的中间状态。</p>
<h2 id="4-2-唤醒节点时为什么从tail向前遍历"><a href="#4-2-唤醒节点时为什么从tail向前遍历" class="headerlink" title="4.2 唤醒节点时为什么从tail向前遍历"></a>4.2 唤醒节点时为什么从tail向前遍历</h2><p>unparkSuccessor方法中为什么唤醒后继节点时要从tail向前查找最接近node的非取消节点，而不是直接从node向后找到第一个后break掉?</p>
<p>其实上面的注释中也解释得很清楚了，如果读到<code>s == null</code>，不代表node就为tail。</p>
<p>考虑如下场景：</p>
<ol>
<li>node某时刻为tail</li>
<li>有新线程通过addWaiter中的if分支或者enq方法添加自己</li>
<li>compareAndSetTail成功</li>
<li>此时这里的Node s = node.next读出来s == null，<strong>但事实上node已经不是tail，它有后继了!</strong></li>
</ol>
<h2 id="4-3-AQS如何保证队列活跃"><a href="#4-3-AQS如何保证队列活跃" class="headerlink" title="4.3 AQS如何保证队列活跃"></a>4.3 AQS如何保证队列活跃</h2><p>AQS如何保证在节点释放的同时又有新节点入队的情况下，不出现原持锁线程释放锁，后继线程被自己阻塞死的情况,保持同步队列的活跃？</p>
<p>回答这个问题，需要理解<code>shouldParkAfterFailedAcquire</code>和<code>unparkSuccessor</code>这两个方法。</p>
<ul>
<li>以独占锁为例，后继争用线程阻塞自己的情况是读到前驱节点的等待状态为SIGNAL,只要不是这种情况都会再试着去争取锁。假设后继线程读到了前驱状态为SIGNAL，说明之前在tryAcquire的时候，前驱持锁线程还没有tryRelease完全释放掉独占锁。</li>
<li>此时如果前驱线程完全释放掉了独占锁，则在<code>unparkSuccessor</code>中还没执行完置<code>waitStatus</code>为0的操作，也就是还没执行到下面唤醒后继线程的代码，否则后继线程会再去争取锁。那么就算后继争用线程此时把自己阻塞了，也一定会马上被前驱线程唤醒。</li>
<li>那么是否可能持锁线程执行唤醒后继线程的逻辑时，后继线程读到前驱等待状态为SIGNAL把自己给阻塞，再也无法苏醒呢？</li>
<li>确实可能在扫描后继需要唤醒线程时读不到新来的线程，但只要<code>tryRelease</code>语义实现正确，在true时表示完全释放独占锁，则后继线程理应能够<code>tryAcquire</code>成功，<code>shouldParkAfterFailedAcquire</code>在读到前驱状态不为<code>SIGNAL</code>会给当前线程再一次获取锁的机会的。</li>
</ul>
<h2 id="4-4-AQS如何防止内存泄露"><a href="#4-4-AQS如何防止内存泄露" class="headerlink" title="4.4 AQS如何防止内存泄露"></a>4.4 AQS如何防止内存泄露</h2><p>AQS维护了一个FIFO队列，它是如何保证在运行期间不发生内存泄露的？</p>
<p>AQS在无竞争条件下，甚至都不会new出head和tail节点。线程成功获取锁时设置head节点的方法为setHead，由于头节点的thread并不重要，此时会置node的thread和prev为null，完了之后还会置原先head也就是线程对应node的前驱的next为null，从而实现队首元素的安全移出。而在取消节点时，也会令<code>node.thread = null</code>，在node不为tail的情况下，会使<code>node.next = node</code>（之所以这样也是为了<code>isOnSyncQueue</code>实现更加简洁）</p>
<hr>
<h1 id="5小结"><a href="#5小结" class="headerlink" title="5小结"></a>5小结</h1><p>在并发环境下，加锁和解锁需要以下三个部件的协调：</p>
<ol>
<li>锁状态。我们要知道锁是不是被别的线程占有了，这个就是 state 的作用，它为 0 的时候代表没有线程占有锁，可以去争抢这个锁，用 CAS 将 state 设为 1，如果 CAS 成功，说明抢到了锁，这样其他线程就抢不到了，如果锁重入的话，state进行 +1 就可以，解锁就是减 1，直到 state 又变为 0，代表释放锁，所以 lock() 和 unlock() 必须要配对啊。然后唤醒等待队列中的第一个线程，让其来占有锁。</li>
<li>线程的阻塞和解除阻塞。AQS 中采用了 LockSupport.park(thread) 来挂起线程，用 unpark 来唤醒线程。</li>
<li>阻塞队列。因为争抢锁的线程可能很多，但是只能有一个线程拿到锁，其他的线程都必须等待，这个时候就需要一个 queue 来管理这些线程，AQS 用的是一个 FIFO 的队列，就是一个链表，每个 node 都持有后继节点的引用。AQS 采用了 CLH 锁的变体来实现。</li>
</ol>
<p>用了好几天，看了很多博客还有翻了一些书，对着JDK源码一点一点的抠了出来上面的这些阅读理解，感觉这个源码还是有些难度，还是需要时不时的回头看看，其实主要就分为独占式和共享式，然后各有没有完成的方法需要继承AQS的子类去完成，要对大致的状态获取、状态释放有所了解，这些会比较重要点，对那几个状态需要多了解了解是什么个意思，一般会出现在什么情况，感觉看了一些源码之后，发现这些源码中的状态位其实很重要，每个方法都伴随着状态位的改变，通过状态位可以了解到很多内部细节，最后还是说分析得太烂，以后又有认识之后一定要把上面这个重新整理一遍，还是不太深刻，盲人摸象，只了解到了一小部分罢了。</p>
<hr>
<p>以上参考：</p>
<ol>
<li><a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer" target="_blank" rel="noopener">一行一行源码分析清楚AbstractQueuedSynchronizer</a></li>
<li><a href="http://cmsblogs.com/?p=2174" target="_blank" rel="noopener">【死磕Java并发】—–J.U.C之AQS：AQS简介</a></li>
<li><a href="http://www.tianxiaobo.com/2018/05/01/AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-%E7%8B%AC%E5%8D%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F/#41-%E8%8A%82%E7%82%B9%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">AbstractQueuedSynchronizer 原理分析 - 独占/共享模式</a></li>
<li><a href="https://www.cnblogs.com/showing/p/6858410.html" target="_blank" rel="noopener">JDK源码之AQS源码剖析</a></li>
<li><a href="https://www.cnblogs.com/micrari/p/6937995.html" target="_blank" rel="noopener">AbstractQueuedSynchronizer源码解读</a></li>
<li><a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html" target="_blank" rel="noopener">从ReentrantLock的实现看AQS的原理及应用</a></li>
<li>书籍：Java并发编程的艺术</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>AQS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - 锁相关：Condition接口分析</title>
    <url>/2020/03/31/java-bing-fa-suo-xiang-guan-condition-jie-kou-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>Condition就是一接口，而在AQS 中的<code>ConditionObject</code>内部类实现了这个接口。Condition接口中只是进行了一些等待和通知方法的声明，并没有进行实现，Condition 经常可以用在<strong>生产者-消费者</strong>的场景中，关于Condition相关的东西，我们需要先了解AQS相关的知识，可以看看之前的那篇文章：<a href="https://dongxiem.github.io/2020/03/31/java-bing-fa-aqs-kuang-jia-fen-xi/">Java 并发 - AQS：框架分析</a>，然后再进行Condition的了解</p>
<p>这里先讲一句：Condition 中的方法则要配合锁对象使用，并通过<code>newCondition</code>方法获取实现类对象。这有点像Object 中的方法需要配合 synchronized 关键字使用。关于Condition与Object类实现的这些方法可以看这篇文章中最下面的那个对比，Ojbect类的<code>wait()</code>, <code>notify()</code> 或 <code>notifyAll()</code> 方法是基于对象的监视器锁的，我们现在所讲的Condition是基于 <code>ReentrantLock</code>  实现的，而ReentrantLock 是依赖于 AbstractQueuedSynchronizer 实现的。</p>
<h3 id="Demo开场"><a href="#Demo开场" class="headerlink" title="Demo开场"></a>Demo开场</h3><p>我们可以先从源码中给出的一个Demo来进行了解：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// condition 依赖于 lock 来产生</span></span><br><span class="line">    <span class="keyword">final</span> Condition notFull = lock.newCondition();</span><br><span class="line">    <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> putptr, takeptr, count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (count == items.length)</span><br><span class="line">                notFull.await();  <span class="comment">// 队列已满，等待，直到 not full 才能继续生产</span></span><br><span class="line">            items[putptr] = x;</span><br><span class="line">            <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;</span><br><span class="line">            ++count;</span><br><span class="line">            notEmpty.signal(); <span class="comment">// 生产成功，队列已经 not empty 了，发个通知出去</span></span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">                notEmpty.await(); <span class="comment">// 队列为空，等待，直到队列 not empty，才能继续消费</span></span><br><span class="line">            Object x = items[takeptr];</span><br><span class="line">            <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;</span><br><span class="line">            --count;</span><br><span class="line">            notFull.signal(); <span class="comment">// 被我消费掉一个，队列 not full 了，发个通知出去</span></span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>这里创建两个线程让上面JDK给的Demo跑起来：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// condition 依赖于 lock 来产生</span></span><br><span class="line">    <span class="keyword">final</span> Condition notFull = lock.newCondition();</span><br><span class="line">    <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> putptr, takeptr, count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略put和take方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        BoundedBuffer boundedBuffer = <span class="keyword">new</span> BoundedBuffer();</span><br><span class="line"></span><br><span class="line">        ExecutorService executor1 = Executors.newCachedThreadPool();</span><br><span class="line">        executor1.execute(</span><br><span class="line">            <span class="keyword">new</span> Runnable() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) {</span><br><span class="line">                        <span class="keyword">try</span> {</span><br><span class="line">                            boundedBuffer.put(i);</span><br><span class="line">                            System.out.println(<span class="string">"放入了："</span> + i);</span><br><span class="line">                        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        ExecutorService executor2 = Executors.newCachedThreadPool();</span><br><span class="line">        executor2.execute(</span><br><span class="line">            <span class="keyword">new</span> Runnable() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) {</span><br><span class="line">                        <span class="keyword">try</span> {</span><br><span class="line">                            <span class="comment">// Thread.sleep(200);</span></span><br><span class="line">                            System.out.println(<span class="string">"取出了："</span> + boundedBuffer.take());</span><br><span class="line">                        } <span class="keyword">catch</span> (InterruptedException e){</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//终止线程池</span></span><br><span class="line">        executor1.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executor1.isTerminated()) {</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"Finished executor1"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//终止线程池</span></span><br><span class="line">        executor2.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executor2.isTerminated()) {</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"Finished executor2"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>因为设置了容量为5，所以会不断的生产和消费：</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="code"><pre><span class="line">放入了：<span class="number">0</span></span><br><span class="line">放入了：<span class="number">1</span></span><br><span class="line">放入了：<span class="number">2</span></span><br><span class="line">放入了：<span class="number">3</span></span><br><span class="line">放入了：<span class="number">4</span></span><br><span class="line">取出了：<span class="number">0</span></span><br><span class="line">取出了：<span class="number">1</span></span><br><span class="line">取出了：<span class="number">2</span></span><br><span class="line">取出了：<span class="number">3</span></span><br><span class="line">取出了：<span class="number">4</span></span><br></pre></td></tr></tbody></table></figure>



<p>通过上面我们可以大概了解到：</p>
<ol>
<li>在使用Condition的时候，必须要先持有相对应的锁，而Object类也是差不多这样的一种机制，我们在Object类中，如果要使用<code>wait()</code>, <code>notify()</code> 或 <code>notifyAll()</code> 方法，则我们必须要先持有某个对象的监视器！</li>
<li>还有一点：ArrayBlockingQueue 采用这种方式实现了生产者-消费者，所以请只把这个例子当做学习例子，<u>实际生产中可以直接使用 ArrayBlockingQueue！！！</u></li>
</ol>
<h3 id="Condition与ReentrantLock的联系"><a href="#Condition与ReentrantLock的联系" class="headerlink" title="Condition与ReentrantLock的联系"></a>Condition与ReentrantLock的联系</h3><p>上面的例子是要让我们清楚的知道，就是condition是与ReentrantLock是息息相关的，可以说他们一般都是结合在一起使用的，那么我们在使用condition的一些方法，比如<code>await()</code> 或者 <code>signale()</code>方法的时候，我们就应该获取到这个Lock才能进行使用！</p>
<p>而每个 <code>ReentrantLock</code>  实例可以通过调用多次 <code>newCondition</code> 产生多个 <code>ConditionObject</code> 的实例：</p>
<p>就如同我们上面的Demo中所示那样：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Condition notFull = lock.newCondition();</span><br><span class="line"><span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br></pre></td></tr></tbody></table></figure>

<p>在<code>ReentrantLock</code> 源码中可以看到：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们再继续看看这个<code>ConditionObject</code>是个什么东西，进去源码发现，原来是个 Condition 的实现类 ，它存在于<code>AbstractQueuedSynchronizer</code>中：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1173984872572414699L</span>;</span><br><span class="line">        <span class="comment">// 条件队列的第一个节点</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">        <span class="comment">// 条件队列的最后一个节点</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">        ......</span><br></pre></td></tr></tbody></table></figure>

<p>需要注意的是Condition就是一个接口，里面就是实现一些规范而已了：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们上面也看到了每个 <code>ReentrantLock</code>  实例可以通过调用多次 <code>newCondition</code> 产生多个 <code>ConditionObject</code> 的实例，那么该如何去管理这些实例呢？我们可以引入跟AQS中的阻塞队列相似的另一种概念，称之为条件队列或者同步队列，图示如下：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/XU31Grz9CI6FPfD.png"  alt="条件队列"></p>
<p>其实这里差不多就代表了整个Condition的核心思想所在了：</p>
<ol>
<li>条件队列和阻塞队列的节点，都是 Node 的实例，因为条件队列的节点是需要转移到阻塞队列中去的；</li>
<li>我们知道一个 ReentrantLock 实例可以通过多次调用 newCondition() 来产生多个 Condition 实例，这里对应 condition1 和 condition2。注意，ConditionObject 只有两个属性 firstWaiter 和 lastWaiter；</li>
<li>每个 condition 有一个关联的<strong>条件队列</strong>，如线程 1 调用 <code>condition1.await()</code> 方法即可将当前线程 1 包装成 Node 后加入到条件队列中，然后阻塞在这里，不继续往下执行，条件队列是一个单向链表；</li>
<li>调用<code>condition1.signal()</code> 触发一次唤醒，此时唤醒的是队头，会将condition1 对应的<strong>条件队列</strong>的 firstWaiter（队头） 移到<strong>阻塞队列的队尾</strong>，等待获取锁，获取锁后 await 方法才能返回，继续往下执行。</li>
</ol>
<p>可以先看一下这张图，了解一下简单的流程所在，具体的源码展开在下面。</p>
<h3 id="Condition主要的方法："><a href="#Condition主要的方法：" class="headerlink" title="Condition主要的方法："></a>Condition主要的方法：</h3><table>
<thead>
<tr>
<th>方法名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>await()</td>
<td>当前线程进入等待状态直到被通知（signal）或者中断；当前线程进入运行状态并从await()方法返回的场景包括：（1）其他线程调用相同Condition对象的signal/signalAll方法，并且当前线程被唤醒；（2）其他线程调用interrupt方法中断当前线程；</td>
</tr>
<tr>
<td>awaitUninterruptibly()</td>
<td>当前线程进入等待状态直到被通知，在此过程中对中断信号不敏感，不支持中断当前线程</td>
</tr>
<tr>
<td>awaitNanos(long)</td>
<td>当前线程进入等待状态，直到被通知、中断或者超时。如果返回值小于等于0，可以认定就是超时了</td>
</tr>
<tr>
<td>awaitUntil(Date)</td>
<td>当前线程进入等待状态，直到被通知、中断或者超时。如果没到指定时间被通知，则返回true，否则返回false</td>
</tr>
<tr>
<td>signal()</td>
<td>唤醒一个等待在Condition上的线程，被唤醒的线程在方法返回前必须获得与Condition对象关联的锁</td>
</tr>
<tr>
<td>signalAll()</td>
<td>唤醒所有等待在Condition上的线程，能够从await()等方法返回的线程必须先获得与Condition对象关联的锁</td>
</tr>
</tbody></table>
<hr>
<h1 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2.源码分析"></a>2.源码分析</h1><h2 id="2-1-等待"><a href="#2-1-等待" class="headerlink" title="2.1 等待"></a>2.1 等待</h2><h2 id="2-2-通知"><a href="#2-2-通知" class="headerlink" title="2.2 通知"></a>2.2 通知</h2><hr>
<h1 id="3-一些对比"><a href="#3-一些对比" class="headerlink" title="3.一些对比"></a>3.一些对比</h1><h2 id="3-1-Condition与Object监视器的对比"><a href="#3-1-Condition与Object监视器的对比" class="headerlink" title="3.1 Condition与Object监视器的对比"></a>3.1 Condition与Object监视器的对比</h2><p>每个对象都可以用继承自<code>Object</code>的<strong>wait/notify</strong>方法来实现<strong>等待/通知机制</strong>。而Condition接口也提供了类似Object监视器的方法，通过与<strong>Lock</strong>配合来实现等待/通知模式。</p>
<p>那为什么既然有Object的监视器方法了，还要用Condition呢？这里有一个二者简单的对比：</p>
<table>
<thead>
<tr>
<th>对比项</th>
<th>Object监视器</th>
<th>Condition</th>
</tr>
</thead>
<tbody><tr>
<td>前置条件</td>
<td>获取对象的锁</td>
<td>调用Lock.lock获取锁，调用Lock.newCondition获取Condition对象</td>
</tr>
<tr>
<td>调用方式</td>
<td>直接调用，比如object.notify()</td>
<td>直接调用，比如condition.await()</td>
</tr>
<tr>
<td>等待队列的个数</td>
<td>一个</td>
<td>多个</td>
</tr>
<tr>
<td>当前线程释放锁进入等待状态</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>当前线程释放锁进入等待状态，在等待状态中不中断</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>当前线程释放锁并进入超时等待状态</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>当前线程释放锁并进入等待状态直到将来的某个时间</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>唤醒等待队列中的一个线程</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>唤醒等待队列中的全部线程</td>
<td>支持</td>
<td>支持</td>
</tr>
</tbody></table>
<p>Condition和Object的wait/notify基本相似。其中，Condition的await方法对应的是Object的wait方法，而Condition的<strong>signal/signalAll</strong>方法则对应Object的notify/notifyAll()。但Condition类似于Object的等待/通知机制的加强版。</p>
<hr>
<h1 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h1><hr>
<p>以上参考：</p>
<ol>
<li><a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer-2#toc_0" target="_blank" rel="noopener">一行一行源码分析清楚 AbstractQueuedSynchronizer (二)</a></li>
<li><a href="http://www.tianxiaobo.com/2018/05/04/AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-Condition-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">AbstractQueuedSynchronizer 原理分析 - Condition 实现原理</a></li>
<li><a href="http://cmsblogs.com/?p=2222" target="_blank" rel="noopener">【死磕Java并发】—–J.U.C之Condition</a></li>
<li>Java并发编程的艺术</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - 如何停止一个线程</title>
    <url>/2020/03/31/java-bing-fa-ru-he-ting-zhi-yi-ge-xian-cheng/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h1><p>对于一个线程要如何去停止呢？还有不同情况下的线程要如何停止呢？停止一个线程是什么意思？就是让这个线程在它进行任务处理的时候进行停止，停掉当前的操作，之前有学习到一个<code>Thread.stop()</code>方法，好像已经被废弃了，是不安全的一个方法，那么除了这个方法，还有其他什么办法吗？</p>
<p>总的来说，Java有如下几种方法去停止线程：</p>
<ol>
<li>使用stop方法强行终止，但是不推荐这个方法，因为stop是过期作废的方法<ul>
<li>stop()方法作废的原因：如果强制让线程停止有可能使一些清理性的工作得不到完成。另外一个情况就是对锁定的对象进行了解锁，导致数据得不到同步的处理，出现数据不一致的问题</li>
</ul>
</li>
<li>使用<strong>interrupt方法中断线程</strong>：<ul>
<li>停止不了的线程，interrupt()方法的使用效果并不像for+break语句那样，马上就停止循环。调用interrupt方法是<strong>在当前线程中打了一个停止标志，并不是真的停止线程</strong></li>
<li>可以用查看线程是否中断，并抛出异常的方式来停止执行线程中的函数</li>
<li>如果线程在<code>sleep()</code>函数的时间范围内被interrupted就会中断线程，置状态位为false并抛出sleep interrupted异常。</li>
</ul>
</li>
<li>使用<strong>退出标志</strong>，使线程正常退出，也就是当run方法完成后线程终止<ul>
<li>使用return，配合interrupt标志可以直接中断线程</li>
<li>但是还是建议使用异常中断线程，因为可以使用catch向上抛出异常，从而使线程停止事件得以传播</li>
</ul>
</li>
<li>线程池使用<strong>shutDownAll()</strong>；</li>
<li>Looper的<strong>quit方法或quitSafely方法</strong></li>
</ol>
<hr>
<h1 id="2-总体方法详细介绍"><a href="#2-总体方法详细介绍" class="headerlink" title="2 总体方法详细介绍"></a>2 总体方法详细介绍</h1><h2 id="2-1-interrupt的特性"><a href="#2-1-interrupt的特性" class="headerlink" title="2.1 interrupt的特性"></a>2.1 interrupt的特性</h2><p>interrupt的特性是什么？interrupt()方法的使用效果并不像for+break语句那样，马上就停止循环。调用interrupt方法是<strong>在当前线程中打了一个停止标志，并不是真的停止线程</strong></p>
<p>那样的话会带来什么后果呢？看一下下面的Demo的运行：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="comment">// 线程不断的进行打印</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">500000</span>; i++){</span><br><span class="line">            System.out.println(<span class="string">"i="</span>+(i+<span class="number">1</span>));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>{</span><br><span class="line">        Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="comment">// 注意我这里使用了interrupt方法了！</span></span><br><span class="line">            thread.interrupt();</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>打印输出如下：</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">..</span>.</span><br><span class="line"><span class="attribute">i</span>=499994</span><br><span class="line"><span class="attribute">i</span>=499995</span><br><span class="line"><span class="attribute">i</span>=499996</span><br><span class="line"><span class="attribute">i</span>=499997</span><br><span class="line"><span class="attribute">i</span>=499998</span><br><span class="line"><span class="attribute">i</span>=499999</span><br><span class="line"><span class="attribute">i</span>=500000</span><br></pre></td></tr></tbody></table></figure>



<p>你会发现他会不停的打印输出，并没有停止，我用了<code>interrupt</code>方法了啊？哪里出问题了？？</p>
<p>其实原理上面都已经讲了，只是在当前线程中打了一个停止标志，没有真的停止线程！</p>
<p>那我要这interrupt有何用？？？冷静，还是有用的，配合其他方法使用不就可以了吗？</p>
<p>打出两套组合拳：</p>
<ol>
<li>使用interrupt+状态停止判断+抛异常</li>
<li>使用interrupt+状态停止判断+退出标志（例如：return）</li>
</ol>
<p>具体组合拳如何打法如以下两个小点所示。</p>
<hr>
<h2 id="2-2-停止状态判断"><a href="#2-2-停止状态判断" class="headerlink" title="2.2 停止状态判断"></a>2.2 停止状态判断</h2><p>线程与状态是密不可分的，即我们要去停止一个线程，我们也要去判断当前是什么状态，执行了想要的停止操作之后，线程是否马上就变为停止状态了，所以如何去判断线程是否为中断状态是很关键的一点，<code>Thread.java</code>类中提供了两种方法：</p>
<ol>
<li><code>this.interrupted()</code>: 测试当前线程是否已经中断，同时线程的中断状态由该方法清除；</li>
<li><code>this.isInterrupted()</code>: 测试线程是否已经中断，同时不会清除标志位；</li>
</ol>
<p>两种方法都能用？那这两种方法的区别在哪里？这也是我的一个疑问了。</p>
<p>其实主要的区别有两个：</p>
<ol>
<li><code>this.interrupted()</code> 测试的是<strong>当前线程</strong>，当前线程指的是什么？就是指运行<code>this.interrupted()</code>方法的线程。</li>
<li>连续调用两次<code>this.interrupted()</code> 会进行<strong>状态清除</strong>，而连续调用多次<code>this.isInterrupted()</code>不会发生状态清除。</li>
</ol>
<p>先讲讲第一个区别，当前线程具体是如何的当前！</p>
<p>验证Demo如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 通过继承Thread 方式实现一个线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">500000</span>; i++){</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>{</span><br><span class="line">    <span class="comment">// main 主线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>{</span><br><span class="line">        Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="comment">// 此处就调用了interrupt 方法试图去停止线程了</span></span><br><span class="line">            thread.interrupt();</span><br><span class="line">            <span class="comment">// 注意此处调用了两次 interrupted</span></span><br><span class="line">            System.out.println(<span class="string">"stop 1??"</span> + thread.interrupted());</span><br><span class="line">            System.out.println(<span class="string">"stop 2??"</span> + thread.interrupted());</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果如下所示：</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="code"><pre><span class="line">stop <span class="number">1</span>??<span class="literal">false</span></span><br><span class="line">stop <span class="number">2</span>??<span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure>

<p>在上面的代码中我们可以看见，我们thread 对象上进行调用了<code>thread.interrupt();</code>，接着又连续使用了两次的<code>thread.interrupted());</code> 去进行thread对象所代表的线程是否已经停止了，但是结果验证发现thread对象所代表的线程是未停止的，也就是不生效？？？</p>
<p>其实是<code>thread.interrupt();</code>是有对Thread对象生效的，但是<code>thread.interrupted());</code> 并不是针对thread 对象的，其实他所针对的是main，当前线程是main！这就是为什么打印了两个false，因为当前线程main从未中断过。</p>
<p>如何让thread线程进行<code>thread.interrupt();</code>的生效呢？我的想法就是在MyThread里面进行使用<code>this.interrupted()</code>，则能够进行判断了。</p>
<p>那么如何让main线程产生中断效果？答案就是使用：<code>Thread.currentThread().interrupt();</code></p>
<h3 id="interrupted-的验证"><a href="#interrupted-的验证" class="headerlink" title="interrupted 的验证"></a>interrupted 的验证</h3><p>查阅相关资料，发现这个方法的解释为：官方帮助文档中对<code>interrupted</code>方法的解释：<strong>测试当前线程是否已经中断。线程的中断状态由该方法清除。</strong> 换句话说，如果连续两次调用该方法，则第二次调用返回false。</p>
<p>注意：当前线程！！！</p>
<p>以下为<code>interrupted</code>方法的测试Demo：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterrruptedTest</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>{</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">        System.out.println(<span class="string">"stop 1??"</span> + Thread.interrupted());</span><br><span class="line">        System.out.println(<span class="string">"stop 2??"</span> + Thread.interrupted());</span><br><span class="line">        System.out.println(<span class="string">"End"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">stop <span class="number">1</span>??<span class="keyword">true</span></span><br><span class="line">stop <span class="number">2</span>??<span class="keyword">false</span></span><br><span class="line">End</span><br></pre></td></tr></tbody></table></figure>

<p>方法interrupted()的确判断出当前线程是否是停止状态。但为什么第2个布尔值是false呢？官方帮助文档中对interrupted方法的解释：<strong>测试当前线程是否已经中断。线程的中断状态由该方法清除。</strong> 换句话说，如果连续两次调用该方法，则第二次调用返回false。</p>
<h3 id="isInterrupted-的验证"><a href="#isInterrupted-的验证" class="headerlink" title="isInterrupted 的验证"></a>isInterrupted 的验证</h3><p>主要验证的就是<code>isInterrupted</code>这个方法不会去清除状态，就算是连续多次调用都不会清除状态。</p>
<p>测试Demo如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsInterruptedTest</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>{</span><br><span class="line">        Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">// 此处调用了interrupt</span></span><br><span class="line">        thread.interrupt();</span><br><span class="line">        <span class="comment">// 使用isInterrupted 进行验证线程是否为停止状态</span></span><br><span class="line">        System.out.println(<span class="string">"stop 1??"</span> + thread.isInterrupted());</span><br><span class="line">        System.out.println(<span class="string">"stop 2??"</span> + thread.isInterrupted());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>打印结果如下：</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="code"><pre><span class="line">stop <span class="number">1</span>??<span class="literal">true</span></span><br><span class="line">stop <span class="number">2</span>??<span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure>

<p>可以看见<code>isInterrupted</code> 不会像<code>interrupted</code> 去清除状态，于是便打印了两个true。</p>
<hr>
<h2 id="2-3-使用抛异常的方法停止线程"><a href="#2-3-使用抛异常的方法停止线程" class="headerlink" title="2.3 使用抛异常的方法停止线程"></a>2.3 使用抛异常的方法停止线程</h2><p>在使用抛异常的方法来停止线程之前，可以看看如果不使用抛异常的方法来停止线程会产生什么后果？我们前面知道了，可以使用<code>thread.interrupt()</code> 方法去进行停止线程，然后再联系<code>Thread.interrupted</code> 方法区判断是否为停止状态，那么我们需要的就是是如果是停止状态，后面的代码不再运行就可以了。</p>
<p>验证Demo如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="comment">// for循环进行打印</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">500000</span>; i++){</span><br><span class="line">            <span class="comment">// 判断是否为中断状态</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.interrupted()) {</span><br><span class="line">                System.out.println(<span class="string">"线程已经终止， for循环不再执行"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 否则进行打印输出</span></span><br><span class="line">            System.out.println(<span class="string">"i="</span>+(i+<span class="number">1</span>));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>{</span><br><span class="line">        <span class="comment">// 申请线程并且开启线程</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            thread.interrupt();</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>打印输出如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">...</span><br><span class="line">i=<span class="number">202053</span></span><br><span class="line">i=<span class="number">202054</span></span><br><span class="line">i=<span class="number">202055</span></span><br><span class="line">i=<span class="number">202056</span></span><br><span class="line">线程已经终止， <span class="keyword">for</span>循环不再执行</span><br></pre></td></tr></tbody></table></figure>



<p>上面的示例虽然停止了线程，但如果for语句下面还有语句，还是会继续运行的。看下面的例子：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">500000</span>; i++){</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.interrupted()) {</span><br><span class="line">                System.out.println(<span class="string">"线程已经终止， for循环不再执行"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            System.out.println(<span class="string">"i="</span>+(i+<span class="number">1</span>));</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 这里再来一句，按道理我是不想这里被执行到的</span></span><br><span class="line">        System.out.println(<span class="string">"这是for循环外面的语句，也会被执行"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>打印输出结果如下：</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">..</span>.</span><br><span class="line"><span class="attribute">i</span>=180136</span><br><span class="line"><span class="attribute">i</span>=180137</span><br><span class="line"><span class="attribute">i</span>=180138</span><br><span class="line"><span class="attribute">i</span>=180139</span><br><span class="line">线程已经终止， <span class="keyword">for</span>循环不再执行</span><br><span class="line">这是<span class="keyword">for</span>循环外面的语句，也会被执行</span><br></pre></td></tr></tbody></table></figure>

<p>但是很不幸的是，并没有达到我们的目的，我们完成的仅仅只是for循环里面的结束而已，只是在for里面进行了一个判断中断标志位，并进行break而已，没有中断到我们的线程，那么我们该怎么做呢？</p>
<p>此时有一个好办法，就是使用抛异常的方法来解决：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">500000</span>; i++){</span><br><span class="line">                <span class="comment">// 如果判断当前线程是为interrupt状态，则抛出一个中断异常</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.interrupted()) {</span><br><span class="line">                    System.out.println(<span class="string">"线程已经终止， for循环不再执行"</span>);</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">                }</span><br><span class="line">                System.out.println(<span class="string">"i="</span>+(i+<span class="number">1</span>));</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 我们不希望这一句被执行到</span></span><br><span class="line">            System.out.println(<span class="string">"这是for循环外面的语句，也会被执行"</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            <span class="comment">// 使用catch进行异常捕获，如果捕获到异常，打印输出下面的话</span></span><br><span class="line">            System.out.println(<span class="string">"进入MyThread.java类中的catch了。。。"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出如下：</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">..</span>.</span><br><span class="line"><span class="attribute">i</span>=203798</span><br><span class="line"><span class="attribute">i</span>=203799</span><br><span class="line"><span class="attribute">i</span>=203800</span><br><span class="line">线程已经终止， <span class="keyword">for</span>循环不再执行</span><br><span class="line">进入MyThread.java类中的catch了。。。</span><br><span class="line">java.lang.InterruptedException at thread.MyThread.<span class="builtin-name">run</span>(MyThread.java:13)</span><br></pre></td></tr></tbody></table></figure>

<p>这样一来，发现其实我们想要的目的已经达到了，所以这个方案可行。</p>
<hr>
<h2 id="2-4-使用return-停止线程"><a href="#2-4-使用return-停止线程" class="headerlink" title="2.4 使用return 停止线程"></a>2.4 使用return 停止线程</h2><p>将方法interrupt()与return结合使用也能实现停止线程的效果：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>){</span><br><span class="line">            <span class="comment">// 如果判断是线程停止状态，则调用return;</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isInterrupted()){</span><br><span class="line">                System.out.println(<span class="string">"线程被停止了！"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 否则打印输出当前时间</span></span><br><span class="line">            System.out.println(<span class="string">"Time: "</span> + System.currentTimeMillis());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="comment">// 此处调用了 interrupt 方法</span></span><br><span class="line">        thread.interrupt();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>打印如下：</p>
<figure class="highlight subunit"><table><tbody><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">Time:</span> 1467072288503</span><br><span class="line"><span class="keyword">Time:</span> 1467072288503</span><br><span class="line"><span class="keyword">Time:</span> 1467072288503</span><br><span class="line">线程被停止了！</span><br></pre></td></tr></tbody></table></figure>

<p>不过还是建议使用“抛异常”的方法来实现线程的停止，因为在catch块中还可以将异常向上抛，使线程停止事件得以传播。</p>
<hr>
<h2 id="2-5-sleep状态下如何停止线程"><a href="#2-5-sleep状态下如何停止线程" class="headerlink" title="2.5 sleep状态下如何停止线程"></a>2.5 sleep状态下如何停止线程</h2><p>如果一个线程处于sleep()状态，我们去停止该线程，会发生什么？</p>
<p>以下我们进行了开启了一个线程，并且start了之后瞬间进入sleep()，然后我们再在主线程中进行一个<code>thread.interrupt();</code>看看会发生什么事情？</p>
<p>看看一下的测试Demo：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(<span class="string">"线程开始。。。"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">200000</span>);</span><br><span class="line">            System.out.println(<span class="string">"线程结束。"</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            System.out.println(<span class="string">"在沉睡中被停止, 进入catch， 调用isInterrupted()方法的结果是："</span> + <span class="keyword">this</span>.isInterrupted());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">run</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果如下：</p>
<figure class="highlight oxygene"><table><tbody><tr><td class="code"><pre><span class="line">线程开始。。。</span><br><span class="line">在沉睡中被停止, 进入catch， 调用isInterrupted()方法的结果是：<span class="keyword">false</span></span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line"> at java.lang.Thread.sleep(Native <span class="function"><span class="keyword">Method</span>)</span></span><br><span class="line"><span class="function"> <span class="title">at</span> <span class="title">thread</span>.<span class="title">MyThread</span>.<span class="title">run</span><span class="params">(MyThread.java:12)</span></span></span><br></pre></td></tr></tbody></table></figure>



<p>从打印的结果来看， <strong>如果在sleep状态下停止某一线程，会进入catch语句，并且清除停止状态值，使之变为false</strong>。</p>
<p>那么，换一种方式！前面是先进入<code>sleep()</code>，然后再<code>interrupt</code>。</p>
<p>如果我们让线程开始了之后，立马就使用<code>interrupt</code>方法，然后再进入<code>sleep()</code>，会发生什么？</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(<span class="string">"线程开始。。。"</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++){</span><br><span class="line">                System.out.println(<span class="string">"i="</span> + i);</span><br><span class="line">            }</span><br><span class="line">            Thread.sleep(<span class="number">200000</span>);</span><br><span class="line">            System.out.println(<span class="string">"线程结束。"</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            System.out.println(<span class="string">"先停止，再遇到sleep，进入catch异常"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>{</span><br><span class="line">        Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">// 注意在start之后就进行interrupt了！</span></span><br><span class="line">        thread.interrupt();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果：</p>
<figure class="highlight oxygene"><table><tbody><tr><td class="code"><pre><span class="line">i=<span class="number">9998</span></span><br><span class="line">i=<span class="number">9999</span></span><br><span class="line">先停止，再遇到sleep，进入catch异常</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line"> at java.lang.Thread.sleep(Native <span class="function"><span class="keyword">Method</span>)</span></span><br><span class="line"><span class="function"> <span class="title">at</span> <span class="title">thread</span>.<span class="title">MyThread</span>.<span class="title">run</span><span class="params">(MyThread.java:15)</span></span></span><br></pre></td></tr></tbody></table></figure>



<p>直观感觉就是，使用interrupt 之后，遇到了sleep还是一样会进入异常！可以得出的结果就是：<u>如果线程在<code>sleep()</code>函数的时间范围内被interrupted就会中断线程，置状态位为false并抛出sleep interrupted异常</u></p>
<hr>
<h2 id="2-6-关于stop的几句唠叨"><a href="#2-6-关于stop的几句唠叨" class="headerlink" title="2.6 关于stop的几句唠叨"></a>2.6 关于stop的几句唠叨</h2><h3 id="2-6-1-stop的暴力"><a href="#2-6-1-stop的暴力" class="headerlink" title="2.6.1 stop的暴力"></a>2.6.1 stop的暴力</h3><p>使用stop方法非常暴力，直接粗暴！</p>
<p>Demo测试如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>){</span><br><span class="line">                System.out.println(<span class="string">"i="</span> + i);</span><br><span class="line">                i++;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        thread.stop();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>测试结果如下：</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attribute">i</span>=0</span><br><span class="line"><span class="attribute">i</span>=1</span><br><span class="line"><span class="attribute">i</span>=2</span><br><span class="line"><span class="attribute">i</span>=3</span><br><span class="line"><span class="attribute">i</span>=4</span><br><span class="line"><span class="attribute">i</span>=5</span><br><span class="line"><span class="attribute">i</span>=6</span><br><span class="line"><span class="attribute">i</span>=7</span><br><span class="line"><span class="attribute">i</span>=8</span><br><span class="line"><span class="attribute">i</span>=9</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></tbody></table></figure>



<h3 id="2-6-2-stop与异常"><a href="#2-6-2-stop与异常" class="headerlink" title="2.6.2 stop与异常"></a>2.6.2 stop与异常</h3><p>调用stop()方法时会抛出java.lang.ThreadDeath异常，但是通常情况下，此异常不需要显示地捕捉。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>{</span><br><span class="line">            <span class="keyword">super</span>.run();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 使用了stop</span></span><br><span class="line">                <span class="keyword">this</span>.stop();</span><br><span class="line">            } <span class="keyword">catch</span> (ThreadDeath e) { <span class="comment">// 进行了异常捕获</span></span><br><span class="line">                System.out.println(<span class="string">"进入异常catch"</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">        Thread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        myThread.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>打印输出如下：</p>
<figure class="highlight reasonml"><table><tbody><tr><td class="code"><pre><span class="line">进入异常catch</span><br><span class="line">java.lang.ThreadDeath</span><br><span class="line">	at java.lang.<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>stop(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>java:<span class="number">853</span>)</span><br><span class="line">	at stopTest.<span class="module-access"><span class="module"><span class="identifier">Test$MyThread</span>.</span></span>run(<span class="module-access"><span class="module"><span class="identifier">Test</span>.</span></span>java:<span class="number">13</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>stop()方法为什么要作废？就是因为如果强制让线程停止有可能使一些清理性的工作得不到完成。</p>
<h3 id="2-6-3-stop与锁"><a href="#2-6-3-stop与锁" class="headerlink" title="2.6.3 stop与锁"></a>2.6.3 stop与锁</h3><p>使用stop()释放锁将会给数据造成不一致性的结果。如果出现这样的情况，程序处理的数据就有可能遭到破坏，最终导致程序执行的流程错误，一定要特别注意：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedObject</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"a"</span>;</span><br><span class="line">    <span class="keyword">private</span> String password = <span class="string">"aa"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">printString</span><span class="params">(String name, String password)</span></span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            Thread.sleep(<span class="number">100000</span>);</span><br><span class="line">            <span class="keyword">this</span>.password = password;</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 隐藏get和set</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">---------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> SynchronizedObject synchronizedObject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(SynchronizedObject synchronizedObject)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.synchronizedObject = synchronizedObject;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">// 调用该方法，想要加锁对象存入name为b替代已有的a，存入password为b替换已有的aa</span></span><br><span class="line">        synchronizedObject.printString(<span class="string">"b"</span>, <span class="string">"bb"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        SynchronizedObject synchronizedObject = <span class="keyword">new</span> SynchronizedObject();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> MyThread(synchronizedObject);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        thread.stop();</span><br><span class="line">        System.out.println(synchronizedObject.getName() + <span class="string">"  "</span> + synchronizedObject.getPassword());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<figure class="highlight armasm"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">b </span> aa</span><br></pre></td></tr></tbody></table></figure>

<p>由于突如其来的刹车，使用了stop()暴力释放了锁，使得本应该输出 b bb 的，被拦腰斩了一半，只得到b aa了！</p>
<p>由于stop()方法以及在JDK中被标明为“过期/作废”的方法，显然它在功能上具有缺陷，所以不建议在程序张使用stop()方法。</p>
<hr>
<h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h1><p>以上总结了一些如何去停止线程的方法，最重要的就是使用<code>interrupt</code>打出的那两套组合拳，还讲了<code>interrupted</code> 和 <code>isinterrupted</code>的区别，还讲了一下sleep()方法下进行线程停止会发生什么，最后再浅显的讲解了一下stop方法带来的不好，还是有很多东西需要深入理解的。</p>
<p>以上参考书籍及文章：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 集合框架 - ArrayList 分析</title>
    <url>/2020/03/31/java-ji-he-kuang-jia-arraylist-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 集合框架 - LinkedList 分析</title>
    <url>/2020/03/31/java-ji-he-kuang-jia-linkedlist-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 集合框架 - HashMap 认识与理解</title>
    <url>/2020/03/31/java-ji-he-kuang-jia-hashmap-ren-shi-yu-li-jie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>关于HashMap 其实还是有很多困惑的，学习了这么长时间，一边记录遇到的一些问题，一边整理笔记，如下所示。</p>
<h1 id="2-主要一些知识点"><a href="#2-主要一些知识点" class="headerlink" title="2.主要一些知识点"></a>2.主要一些知识点</h1><h2 id="2-1-HashMap-底层结构的一些问题与解答"><a href="#2-1-HashMap-底层结构的一些问题与解答" class="headerlink" title="2.1 HashMap 底层结构的一些问题与解答"></a>2.1 HashMap 底层结构的一些问题与解答</h2><p>关于HashMap 的底层数据结构，我有以下这么几个疑问，当时也是查看书籍和百度谷歌了好一会儿，然后连带着寻找到其他的一些问题，如下。</p>
<hr>
<h3 id="数组与链表相关"><a href="#数组与链表相关" class="headerlink" title="数组与链表相关"></a>数组与链表相关</h3><p>关于底层数据结构为什么采用 数组+链表 这么一种组合的几个问题：</p>
<h4 id="1-为什么用数组-链表？"><a href="#1-为什么用数组-链表？" class="headerlink" title="1.为什么用数组+链表？"></a><strong>1.为什么用数组+链表？</strong></h4><ul>
<li>我认为数组是用来确定桶的位置，利用元素的key的hash值对数组长度取模得到.</li>
<li>链表是用来解决hash冲突问题，当出现hash值一样的情形，就在数组上的对应位置形成一条链表。</li>
<li>注：这里的hash值并不是指hashcode，而是将hashcode高低十六位异或过的。</li>
</ul>
<h4 id="2-那使用LinkedList代替数组结构可以么？"><a href="#2-那使用LinkedList代替数组结构可以么？" class="headerlink" title="2.那使用LinkedList代替数组结构可以么？"></a><strong>2.那使用LinkedList代替数组结构可以么？</strong></h4><ul>
<li>这里的意思是，源码中是这样的：<code>Entry[] table = new Entry[capacity];</code><ul>
<li>ps：Entry就是一个链表节点。</li>
</ul>
</li>
<li>那我用下面这样表示：<ul>
<li><code>List&lt;Entry&gt; table = new LinkedList&lt;Entry&gt;();</code></li>
</ul>
</li>
<li>所以没毛病是可以使用LinkedList代替数组结构</li>
</ul>
<h4 id="3-那既然是可以的，为什么HashMap不用LinkedList，而选用数组"><a href="#3-那既然是可以的，为什么HashMap不用LinkedList，而选用数组" class="headerlink" title="3.那既然是可以的，为什么HashMap不用LinkedList，而选用数组?"></a><strong>3.那既然是可以的，为什么HashMap不用LinkedList，而选用数组?</strong></h4><ul>
<li>因为用数组效率最高！在HashMap中，定位桶的位置是利用元素的key的哈希值对数组长度取模得到。此时，我们已得到桶的位置。显然数组的查找效率比LinkedList大。</li>
</ul>
<h4 id="4-继续挖一下，那ArrayList，底层也是数组，查找也快啊，为什么不用ArrayList"><a href="#4-继续挖一下，那ArrayList，底层也是数组，查找也快啊，为什么不用ArrayList" class="headerlink" title="4.继续挖一下，那ArrayList，底层也是数组，查找也快啊，为什么不用ArrayList?"></a><strong>4.继续挖一下，那ArrayList，底层也是数组，查找也快啊，为什么不用ArrayList?</strong></h4><ul>
<li>因为采用基本数组结构，扩容机制可以自己定义，HashMap中数组扩容刚好是2的次幂，在做取模运算的效率高。而ArrayList的扩容机制是1.5倍扩容。</li>
<li>而为什么需要两倍扩容，现在此处存疑，在下面我会进行展开分析一下。</li>
</ul>
<hr>
<h3 id="红黑树相关"><a href="#红黑树相关" class="headerlink" title="红黑树相关"></a>红黑树相关</h3><p>关于树化为什么采用红黑树、及红黑树的一些特性的一些问题、：</p>
<h4 id="1-如果进行树化了，为什么是红黑树？别的树不可以吗？"><a href="#1-如果进行树化了，为什么是红黑树？别的树不可以吗？" class="headerlink" title="1.如果进行树化了，为什么是红黑树？别的树不可以吗？"></a><strong>1.如果进行树化了，为什么是红黑树？别的树不可以吗？</strong></h4><ul>
<li>比如二叉查找树，是可以的。但是二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。</li>
<li>AVL树中，根到任何叶子的最短路径和最长路径之间的差异最多为1，而红黑树可以是两倍，虽然红黑树放弃了一定的平衡，但是当进行查找时AVL树可能需要O（Logn）次旋转，而红黑树只需要最多两次，红黑树更加适合插入修改密集型任务</li>
</ul>
<h4 id="2-为什么在解决hash冲突的时候，不直接用红黑树-而选择先用链表，再转红黑树"><a href="#2-为什么在解决hash冲突的时候，不直接用红黑树-而选择先用链表，再转红黑树" class="headerlink" title="2.为什么在解决hash冲突的时候，不直接用红黑树?而选择先用链表，再转红黑树?"></a><strong>2.为什么在解决hash冲突的时候，不直接用红黑树?而选择先用链表，再转红黑树?</strong></h4><ul>
<li><strong>因为红黑树需要进行</strong>左旋，右旋，变色这些操作来保持平衡，而单链表不需要。当元素小于8个当时候，此时做查询操作，链表结构已经能保证查询性能。当元素大于8个的时候，此时需要红黑树来加快查询速度，但是新增节点的效率变慢了。因此，如果一开始就用红黑树结构，元素太少，新增效率又比较慢，无疑这是浪费性能的。</li>
</ul>
<h4 id="3-当链表转为红黑树后，什么时候退化为链表"><a href="#3-当链表转为红黑树后，什么时候退化为链表" class="headerlink" title="3.当链表转为红黑树后，什么时候退化为链表?"></a><strong>3.当链表转为红黑树后，什么时候退化为链表?</strong></h4><ul>
<li>为6的时候退转为链表。中间有个差值7可以防止链表和树之间频繁的转换。假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。</li>
</ul>
<h4 id="4其实这样引出了一个问题：为什么链化阈值是-6-，树化阈值是-8（为什么8的时候树化，4不可以吗？）？"><a href="#4其实这样引出了一个问题：为什么链化阈值是-6-，树化阈值是-8（为什么8的时候树化，4不可以吗？）？" class="headerlink" title="4其实这样引出了一个问题：为什么链化阈值是 6 ，树化阈值是 8（为什么8的时候树化，4不可以吗？）？"></a><strong>4其实这样引出了一个问题：为什么链化阈值是 6 ，树化阈值是 8（为什么8的时候树化，4不可以吗？）？</strong></h4><ul>
<li>8树化，是经测试，冲突链表个数符合<u>泊松分布</u>，为8时概率零点几，为6而不是7退化，是为了避免7 8来回变引入不可变开销。线程数其实在考cpu密集型和io密集型。</li>
</ul>
<hr>
<h3 id="哈希相关"><a href="#哈希相关" class="headerlink" title="哈希相关"></a>哈希相关</h3><p>还有HashMap 中的哈希的一些问题</p>
<h4 id="1-HashMap-中哈希方法，为什么要选择31？？？"><a href="#1-HashMap-中哈希方法，为什么要选择31？？？" class="headerlink" title="1.HashMap 中哈希方法，为什么要选择31？？？"></a><strong>1.HashMap 中哈希方法，为什么要选择31？？？</strong></h4><p>首先看下String hashcode 的方法是如何实现的：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/02/gCVO9duskcUS1TP.png"  alt="image.png"></p>
<p>我们可以由上面的 for 循环推导出一个计算公式，hashCode 方法注释中已经给出。如下：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/02/GtJUCvLyr19lIHj.png"  alt="image.png"></p>
<p>这里说明一下，上面的 s 数组即源码中的 val 数组，是 String 内部维护的一个 char 类型数组。这里我来简单推导一下这个公式：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/02/6lyFtYu9bM5pz81.png"  alt="image.png"></p>
<p>上面的公式包括公式的推导并不是本文的重点，大家了解了解即可。接下来来说说本文的重点，即选择31的理由。从网上的资料来看，一般有如下两个原因：</p>
<ol>
<li>第一，31是一个不大不小的质数，是作为 hashCode 乘子的优选质数之一。另外一些相近的质数，比如37、41、43等等，也都是不错的选择。那么为啥偏偏选中了31呢？请看第二个原因。<ul>
<li><strong>第一点解释一下：31是一个不大不小的质数，是优选乘子。那为啥同是质数的2和101（或者更大的质数）就不是优选乘子呢？</strong></li>
<li>这里先分析质数2。首先，假设 n = 6，然后把质数2和 n 带入上面的计算公式。并仅计算公式中次数最高的那一项，结果是2^5 = 32，是不是很小。所以这里可以断定，当字符串长度不是很长时，用质数2做为乘子算出的哈希值，数值不会很大。也就是说，哈希值会分布在一个较小的数值区间内，分布性不佳，最终可能会导致冲突率上升。</li>
<li>那么如果用一个较大的大质数101会产生什么样的结果呢？根据上面的分析，我想大家应该可以猜出结果了。就是不用再担心哈希值会分布在一个小的区间内了，因为101^5 = 10,510,100,501。但是要注意的是，这个计算结果太大了。如果用 int 类型表示哈希值，结果会溢出，最终导致数值信息丢失。尽管数值信息丢失并不一定会导致冲突率上升，但是我们暂且先认为质数101（或者更大的质数）也不是很好的选择。</li>
<li>最后，我们再来看看质数31的计算结果： 31^5 = 28629151，结果值相对于32和10,510,100,501来说。是不是很nice，不大不小。</li>
<li>总的来说，是100以内的比较好的奇质数（既要是奇数，又要是质数的数）</li>
</ul>
</li>
<li>第二、31可以被 JVM 优化，31 * i = (i &lt;&lt; 5) - i。</li>
</ol>
<p>Stack Overflow 上关于这个问题的讨论：Why does Java’s hashCode() in String use 31 as a multiplier?</p>
<p>其中排名第一的答案引用了《Effective Java》中的一段话，这里也引用一下：</p>
<blockquote>
<p>The value 31 was chosen because it is an odd prime. If it were even and the multiplication overflowed, information would be lost, as multiplication by 2 is equivalent to shifting. The advantage of using a prime is less clear, but it is traditional. A nice property of 31 is that the multiplication can be replaced by a shift and a subtraction for better performance: 31 * i == (i &lt;&lt; 5) - i`. Modern VMs do this sort of optimization automatically.</p>
</blockquote>
<p>翻译过来是这么说的：</p>
<ul>
<li>选择数字31是因为它是一个奇质数，如果选择一个偶数会在乘法运算中产生溢出，导致数值信息丢失，因为乘二相当于移位运算。</li>
<li>选择质数的优势并不是特别的明显，但这是一个传统。</li>
<li>同时，数字31有一个很好的特性，即乘法运算可以被移位和减法运算取代，来获取更好的性能：31 * i == (i &lt;&lt; 5) - i，现代的 Java 虚拟机可以自动的完成这个优化。</li>
</ul>
<p>排名第二的答案是这样说的：</p>
<blockquote>
<p>As Goodrich and Tamassia point out, If you take over 50,000 English words (formed as the union of the word lists provided in two variants of Unix), using the constants 31, 33, 37, 39, and 41 will produce less than 7 collisions in each case. Knowing this, it should come as no surprise that many Java implementations choose one of these constants.</p>
</blockquote>
<p>翻译过来是这样的：</p>
<ul>
<li>正如 Goodrich 和 Tamassia 指出的那样，如果你对超过 50,000 个英文单词（由两个不同版本的 Unix 字典合并而成）进行 hash code 运算，并使用常数 31, 33, 37, 39 和 41 作为乘子，每个常数算出的哈希值冲突数都小于7个，所以在上面几个常数中，常数 31 被 Java 实现所选用也就不足为奇了。</li>
</ul>
<h2 id="2-2-HashMap-容量相关的一些问题与解答"><a href="#2-2-HashMap-容量相关的一些问题与解答" class="headerlink" title="2.2 HashMap 容量相关的一些问题与解答"></a>2.2 HashMap 容量相关的一些问题与解答</h2><h2 id="2-3-HashMap-并发相关的一些问题与解答"><a href="#2-3-HashMap-并发相关的一些问题与解答" class="headerlink" title="2.3 HashMap 并发相关的一些问题与解答"></a>2.3 HashMap 并发相关的一些问题与解答</h2><h2 id="2-4-HashMap与其他一些容器的比较"><a href="#2-4-HashMap与其他一些容器的比较" class="headerlink" title="2.4 HashMap与其他一些容器的比较"></a>2.4 HashMap与其他一些容器的比较</h2><h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h1><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>WTIM 简介</title>
    <url>/2020/03/30/wtim-jian-jie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>搭建一个基于分布式的IM（即时通讯）系统</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>WTIM</category>
      </categories>
      <tags>
        <tag>WTIM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 集合框架 - HashMap 分析</title>
    <url>/2020/03/29/java-ji-he-kuang-jia-hashmap-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-HashMap实现原理"><a href="#1-HashMap实现原理" class="headerlink" title="1.HashMap实现原理"></a>1.HashMap实现原理</h1><p><strong>简述HashMap的工作原理：</strong></p>
<p>HashMap是<strong>基于散列法（又称哈希法）的原理</strong>，使用<code>put(key, value)</code>存储对象到HashMap中，使用<code>get(key)</code>从HashMap中获取对象。使用HashMap进行查询和修改的速度都很快，平均时间复杂度O(1)。HashMap非线程安全，如果需要考虑并发，则需要使用ConcurrentHashMap，且HashMap不保证存储元素的序列；</p>
<hr>
<h1 id="2-HashMap的底层结构"><a href="#2-HashMap的底层结构" class="headerlink" title="2.HashMap的底层结构"></a>2.HashMap的底层结构</h1><p>JDK18之前：数组+链表</p>
<p>JDK1.8之后：数组+链表+红黑树</p>
<p>特点是HashMap采用Entry数组来存储key-value对，每一个键值对组成了一个Entry实体，Entry类实际上是一个单向的链表结构，它具有Next指针，可以连接下一个Entry实体。只是在JDK1.8中，链表长度大于8的时候，链表会转成红黑树！</p>
<p>在添加元素时，会根据hash值算出元素在数组中的位置，如果该位置没有元素，则直接把元素放置在此处，如果该位置有元素了，则把元素以链表的形式放置在链表的尾部。</p>
<p>数组的查询效率为O(1)，链表的查询效率是O(k)，红黑树的查询效率是O(log k)，k为桶中的元素个数，所以当元素数量非常多的时候，转化为红黑树能极大地提高效率。</p>
<p>底层结构具体如下所示：</p>
<ol>
<li><p>关于红黑树相关的知识：</p>
</li>
</ol>
<ul>
<li>可以看这篇文章：    </li>
</ul>
<hr>
<h1 id="3-源码阅读"><a href="#3-源码阅读" class="headerlink" title="3.源码阅读"></a>3.源码阅读</h1><h2 id="3-1-HashMap的继承与实现"><a href="#3-1-HashMap的继承与实现" class="headerlink" title="3.1.HashMap的继承与实现"></a>3.1.HashMap的继承与实现</h2><ul>
<li>HashMap实现了Cloneable，可以被克隆。</li>
<li>HashMap实现了Serializable，可以被序列化。</li>
<li>HashMap继承自AbstractMap，实现了Map接口，具有Map的所有功能。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>{}</span><br></pre></td></tr></tbody></table></figure>

<p>具体继承如下所示：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/02/fZVderRq2NO81Sc.png"  alt="HashMap.png"></p>
<h2 id="3-2-HashMap的基本属性及内部类"><a href="#3-2-HashMap的基本属性及内部类" class="headerlink" title="3.2.HashMap的基本属性及内部类"></a>3.2.HashMap的基本属性及内部类</h2><h3 id="3-2-1-基本属性"><a href="#3-2-1-基本属性" class="headerlink" title="3.2.1 基本属性"></a>3.2.1 基本属性</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 哈希数组初始容量</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 哈希数组最大容量</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * HashMap默认装载因子（负载因子）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 当前 HashMap 所能容纳键值对数量的最大值，超过这个值，则需扩容</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 哈希槽（链）上的红黑树上的元素数量减少到此值时，将红黑树转换为链表</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 当桶的个数达到64的时候才进行树化</span></span><br><span class="line"><span class="comment">  * 即是说当桶数组容量小于该值时，优先进行扩容，而不是树化</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 哈希数组</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * entry集合</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * HashMap的元素数量</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *  HashMap结构的修改次数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * (The javadoc description is true upon serialization.</span></span><br><span class="line"><span class="comment">  * Additionally, if the table array has not been allocated, this</span></span><br><span class="line"><span class="comment">  * field holds the initial array capacity, or zero signifying</span></span><br><span class="line"><span class="comment">  * DEFAULT_INITIAL_CAPACITY.)</span></span><br><span class="line"><span class="comment">  * HashMap扩容阈值，并没有默认阈值，原因是阈值可由容量乘上负载因子计算而来（注释中有说明）</span></span><br><span class="line"><span class="comment">  * 计算公式：threshold = capacity * loadFactor</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * HashMap当前使用的装载因子</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></tbody></table></figure>

<p>上面举例了一些HashMap的属性字段，比较有意思的是羡慕几个属性字段，在接下来中会单拎出来进行详细讲解。：</p>
<ul>
<li>哈希数组的初始容量：DEFAULT_INITIAL_CAPACITY</li>
<li>负载因子：loadFactor</li>
<li>链表树化与树化链表的两个阈值：UNTREEIFY_THRESHOLD 和TREEIFY_THRESHOLD</li>
</ul>
<h3 id="3-2-2-Node内部类"><a href="#3-2-2-Node内部类" class="headerlink" title="3.2.2 Node内部类"></a>3.2.2 Node内部类</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>{</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>HashMap采用Entry数组来存储key-value对，每一个键值对组成了一个Entry实体，Entry类实际上是一个单向的链表结构，它具有Next指针，可以连接下一个Entry实体。只是在JDK1.8中，链表长度大于8的时候，链表会转成红黑树！</p>
<h3 id="3-2-3-TreeNode内部类"><a href="#3-2-3-TreeNode内部类" class="headerlink" title="3.2.3 TreeNode内部类"></a>3.2.3 TreeNode内部类</h3><p>TreeNode是一个典型的树型节点，其中，prev是链表中的节点，用于在删除元素的时候可以快速找到它的前置节点。</p>
<figure class="highlight scala"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 位于HashMap中</span></span><br><span class="line">static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode&lt;K</span>,<span class="title">V&gt;</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry&lt;K</span>,<span class="title">V&gt;</span> </span>{</span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; left;</span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; right;</span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    boolean red;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位于LinkedHashMap中，典型的双向链表节点</span></span><br><span class="line">static <span class="class"><span class="keyword">class</span> <span class="title">Entry&lt;K</span>,<span class="title">V&gt;</span> <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node&lt;K</span>,<span class="title">V&gt;</span> </span>{</span><br><span class="line">    <span class="type">Entry</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; before, after;</span><br><span class="line">    <span class="type">Entry</span>(int hash, <span class="type">K</span> key, <span class="type">V</span> value, <span class="type">Node</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; next) {</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<hr>
<h2 id="3-3-HashMap的四种构造及参数分析"><a href="#3-3-HashMap的四种构造及参数分析" class="headerlink" title="3.3.HashMap的四种构造及参数分析"></a>3.3.HashMap的四种构造及参数分析</h2><ol>
<li>无参构造，初始化一个哈希数组容量为16，装载因子为0.75的HashMap</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty {<span class="doctag">@code</span> HashMap} with the default initial capacity</span></span><br><span class="line"><span class="comment"> * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>初始化一个哈希数组容量为initialCapacity，装载因子为0.75的HashMap</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty {<span class="doctag">@code</span> HashMap} with the specified initial</span></span><br><span class="line"><span class="comment"> * capacity and the default load factor (0.75).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity the initial capacity.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li>初始化一个哈希数组容量为initialCapacity，装载因子为loadFactor的HashMap</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Constructs an empty {<span class="doctag">@code</span> HashMap} with the specified initial</span></span><br><span class="line"><span class="comment">   * capacity and load factor.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment">   *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>{</span><br><span class="line">      <span class="comment">// 检查传入的初始容量是否合法</span></span><br><span class="line">      <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                             initialCapacity);</span><br><span class="line">      <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">          initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">      <span class="comment">// 检查装载因子是否合法</span></span><br><span class="line">      <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                             loadFactor);</span><br><span class="line">      <span class="comment">// 初始化装载因子</span></span><br><span class="line">      <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">      <span class="comment">// 用初始容量信息来计算扩容门槛</span></span><br><span class="line">      <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<ol start="4">
<li>使用指定的HashMap中的元素来初始化一个新的HashMap</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new {<span class="doctag">@code</span> HashMap} with the same mappings as the</span></span><br><span class="line"><span class="comment"> * specified {<span class="doctag">@code</span> Map}.  The {<span class="doctag">@code</span> HashMap} is created with</span></span><br><span class="line"><span class="comment"> * default load factor (0.75) and an initial capacity sufficient to</span></span><br><span class="line"><span class="comment"> * hold the mappings in the specified {<span class="doctag">@code</span> Map}.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   m the map whose mappings are to be placed in this map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    <span class="comment">// 将指定HashMap中的元素存入到当前HashMap（允许覆盖）</span></span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们这这里对几个字段进行解释一下：</p>
<h2 id="3-4-查询"><a href="#3-4-查询" class="headerlink" title="3.4.查询"></a>3.4.查询</h2><h3 id="3-4-1-查询HashMap大小"><a href="#3-4-1-查询HashMap大小" class="headerlink" title="3.4.1.查询HashMap大小"></a>3.4.1.查询HashMap大小</h3><p>该方法返回HashMap的大小，键值对的数目：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-4-2-查询HashMap是否为空"><a href="#3-4-2-查询HashMap是否为空" class="headerlink" title="3.4.2 查询HashMap是否为空"></a>3.4.2 查询HashMap是否为空</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-4-3-查询HashMap是否存在指定key"><a href="#3-4-3-查询HashMap是否存在指定key" class="headerlink" title="3.4.3.查询HashMap是否存在指定key"></a>3.4.3.查询HashMap是否存在指定key</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> getNode(hash(key), key) != <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-4-4-查询HashMap中是否存在指定value的元素"><a href="#3-4-4-查询HashMap中是否存在指定value的元素" class="headerlink" title="3.4.4.查询HashMap中是否存在指定value的元素"></a>3.4.4.查询HashMap中是否存在指定value的元素</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>{</span><br><span class="line">    Node&lt;K,V&gt;[] tab; V v;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 进行循环遍历查找value</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; e : tab) {</span><br><span class="line">            <span class="keyword">for</span> (; e != <span class="keyword">null</span>; e = e.next) {</span><br><span class="line">                <span class="keyword">if</span> ((v = e.value) == value ||</span><br><span class="line">                    (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="3-5-取值"><a href="#3-5-取值" class="headerlink" title="3.5.取值"></a>3.5.取值</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>{</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>它调用了<code>getNode(int hash, Object key)</code>方法，详细代码如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>{</span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">      <span class="comment">// 如果桶的数量大于0，并且所查找的key所在的桶的第一个元素不为空</span></span><br><span class="line">      <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">          (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) {</span><br><span class="line">          <span class="comment">// 检查第一个元素是不是要查的元素，如果是则直接返回</span></span><br><span class="line">          <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">              ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">              <span class="keyword">return</span> first;</span><br><span class="line">          <span class="comment">// 如果不止一个元素，则继续寻找</span></span><br><span class="line">          <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) {</span><br><span class="line">              <span class="comment">// 如果第一个元素是树节点，则按树的方式查找</span></span><br><span class="line">              <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                  <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">              <span class="keyword">do</span> {</span><br><span class="line">                  <span class="comment">// 否则就遍历整个链表查找该元素</span></span><br><span class="line">                  <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                      ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                      <span class="keyword">return</span> e;</span><br><span class="line">              } <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">          }</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-6-添加"><a href="#3-6-添加" class="headerlink" title="3.6.添加"></a>3.6.添加</h2><h3 id="3-6-1-HashMap的添加过程"><a href="#3-6-1-HashMap的添加过程" class="headerlink" title="3.6.1.HashMap的添加过程"></a>3.6.1.HashMap的添加过程</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>实际上它调用了<code>putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict)</code>方法，详细代码如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 向当前Map中存入新的元素，并返回旧元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * hash         key的哈希值</span></span><br><span class="line"><span class="comment"> * onlyIfAbsent 是否需要维持原状（不覆盖旧值）</span></span><br><span class="line"><span class="comment"> * evict        如果为false，则表处于创建模式。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回同位元素的旧值（在当前Map中占据相同位置的元素）</span></span><br><span class="line"><span class="comment"> * 如果不存在同位元素，即插入了新元素，则返回null</span></span><br><span class="line"><span class="comment"> * 如果存在同位元素，但同位元素的旧值为null，那么也返回null</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>{</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 如果桶的长度为0，未初始化，则进行初始化并得到长度n</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 调用resize进行初始化</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 如果桶中还没有元素，则将要插入的key和value放到第一位</span></span><br><span class="line">    <span class="comment">// 使用(n - 1) &amp; hash 计算元素在哪个桶中</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> {  <span class="comment">// 桶中此时已存在元素</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 如果待插入的元素的hash值和key值与第一个元素的哈希值和key相同，保存到e用于后续修改value值</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 如果桶的第一个元素为树节点，则调用树节点的putTreeVal方法插入元素</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 遍历这个桶对应的链表，binCount用于存储链表中元素的个数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) {</span><br><span class="line">                <span class="comment">// 遍历整个链表，没有相同哈希值和key的元素，则在链表最后插入该key和value结点</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) {</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 如果插入结点之后的长度大于等于8，则树化</span></span><br><span class="line">                    <span class="comment">// 这里-1的解释为：因为第一个元素没有加到binCount中，所以这里-1</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">// 进行树化</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 假如待插入的key在链表中找到，则退出循环</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 找到了对应key的元素</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) { <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;   <span class="comment">// 记录旧值</span></span><br><span class="line">            <span class="comment">// 判断是否需要替换旧值</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;    <span class="comment">// 替换旧值为新值</span></span><br><span class="line">            <span class="comment">// 在节点被访问后做点什么事，在LinkedHashMap中用到</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 到了此处证明没有找到元素，即添加了新元素，修改次数加1</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 如果哈希数组的容量已超过阈值，则需要对哈希数组扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 在节点插入后做点什么事，在LinkedHashMap中用到</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>添加方法除了可以单个key-value键值对的添加，还可以将指定HashMap中的元素存入到当前HashMap中（允许覆盖），详细代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 如果当前HashMap的哈希数组还未初始化</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) { <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">// 根据HashMap中的元素数量反推哈希数组的最低容量要求</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;  <span class="comment">// 注意这里!!!!</span></span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">// 如果大于需要扩容的阈值，则重新计算扩容阈值</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// Because of linked-list bucket constraints, we cannot</span></span><br><span class="line">            <span class="comment">// expand all at once, but can reduce total resize</span></span><br><span class="line">            <span class="comment">// effort by repeated doubling now vs later</span></span><br><span class="line">            <span class="comment">// 由于链表存储桶的限制，我们无法一次全部扩展</span></span><br><span class="line">            <span class="comment">// 但可以通过立即加倍与以后加倍来减少总的调整工作量</span></span><br><span class="line">            <span class="comment">// 初始化哈希数组，或者对哈希数组扩容，并返回新的哈希数组</span></span><br><span class="line">            <span class="keyword">while</span> (s &gt; threshold &amp;&amp; table.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                resize();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 循环遍历进行添加，允许覆盖</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) {</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-6-2-HashMap的扩容过程"><a href="#3-6-2-HashMap的扩容过程" class="headerlink" title="3.6.2.HashMap的扩容过程"></a>3.6.2.HashMap的扩容过程</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 扩容机制：在初始化时、对哈希数组扩容时两种情况下调用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() {</span><br><span class="line">    <span class="comment">// 旧数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 旧容量，或者未初始化时的容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">// 旧扩容阈值</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="comment">// 新容量、新扩容阈值</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果哈希数组已经初始化，不是首次进入</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 如果旧容量大于最大容量，则不再扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) {</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果旧容量的两倍（左移一位）小于最大容量，并且大于默认初始容量（16）</span></span><br><span class="line">        <span class="comment">// 则新容量扩大为旧容量的两倍，扩容阈值也扩大为旧阈值的两倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果哈希数组还未初始化（首次进来）并且实例化HashMap的时候指定了初始容量</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        <span class="comment">// 则将哈希数组的当前容量初始化为与旧阈值一样大（传入初始容量时候会调用tableSizeFor()方法）</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">// 如果哈希数组还未初始化（首次进来）并且实例化HashMap的时候没有指定了初始容量</span></span><br><span class="line">    <span class="keyword">else</span> {               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">// 则使用默认的初始容量（16）和默认公式计算的阈值</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果新扩容阈值为0，则使用公式计算得到新的扩容阈值，并且不可超过最大容量</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 赋值扩容阈值为新扩容阈值</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">// 根据新扩容容量建立一个新容量的数组</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>({<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>})</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    <span class="comment">// 将桶赋值为新数组</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">// 旧数组不为空，则搬移元素</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 遍历旧数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) {</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">// 如果桶中的第一个元素不为空，则赋值给e</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="comment">// 清空旧桶，帮助GC</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 如果桶中只有一个元素，进行新桶的位置定位，并搬迁</span></span><br><span class="line">                <span class="comment">// 注意：只有第一个元素才可以这样，因为每次扩容都是两倍</span></span><br><span class="line">                <span class="comment">//       则第一个元素搬移到新桶的时候肯定还没有元素</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 如果该哈希槽上链接了不止一个元素，且该元素是TreeNode类型</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 如果第一个元素是树节点，则把这颗树打散成两颗树插入到新桶中去</span></span><br><span class="line">                    <span class="comment">// 拆分红黑树</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> { <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 如果这个链表不止一个元素且不是一颗树</span></span><br><span class="line">                    <span class="comment">// 则进行分化成两个链表插到新的桶中</span></span><br><span class="line">                    <span class="comment">// 举例：假如原来容量为4，3、7、11、15这四个元素都在三号桶中</span></span><br><span class="line">                    <span class="comment">// 现在扩容到8，则3和11还是在三号桶，7和15要搬移到七号桶中去</span></span><br><span class="line">                    <span class="comment">// 也就是分化成了两个链表</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> {</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// (e.hash &amp; oldCap) == 0的元素放在低位链表中</span></span><br><span class="line">                        <span class="comment">// 比如，3 &amp; 4 == 0</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) {</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">else</span> {</span><br><span class="line">                            <span class="comment">// (e.hash &amp; oldCap) != 0的元素放在高位链表中</span></span><br><span class="line">                            <span class="comment">// 比如，7 &amp; 4 != 0</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        }</span><br><span class="line">                    } <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 遍历完成得到两个链表</span></span><br><span class="line">                    <span class="comment">// 低位链表在新桶的位置与旧桶一样（即3和11还在三号桶中）</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) {</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">// 高位链表在新桶中的位置正好是原来的位置加上旧容量（即7和15搬移到七号桶了）</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) {</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-6-3-HashMap扩容的思考"><a href="#3-6-3-HashMap扩容的思考" class="headerlink" title="3.6.3.HashMap扩容的思考"></a>3.6.3.HashMap扩容的思考</h3><h3 id="3-6-4-树化与链化过程"><a href="#3-6-4-树化与链化过程" class="headerlink" title="3.6.4.树化与链化过程"></a>3.6.4.树化与链化过程</h3><h2 id="3-7-移除"><a href="#3-7-移除" class="headerlink" title="3.7.移除"></a>3.7.移除</h2><figure class="highlight processing"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据传入的key进行数据移除元素，并返回刚刚移除的元素的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> V remove(<span class="keyword">Object</span> <span class="built_in">key</span>) {</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(<span class="built_in">key</span>), <span class="built_in">key</span>, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>实际上它调用了<code>removeNode(int hash, Object key, Object value,boolean matchValue, boolean movable)</code>方法，详细代码如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 从HashMap中移除指定的元素，并返回刚刚移除的元素（移除失败返回null）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * matchValue 移除元素时是否需要考虑value的匹配问题</span></span><br><span class="line"><span class="comment"> * movable    移除元素后如果红黑树根结点发生了变化，那么是否需要改变结点在链表上的顺序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>{</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">// 如果桶的数量大于0（不空）且待删除的元素所在的桶的第一个元素不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) {</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">// 如果键的值与链表第一个节点相等，则将 node 指向该节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 如果该Tab的第一个元素是树节点，则以树的方式进行寻找</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 否则，就以链表的形式进行遍历寻找</span></span><br><span class="line">                <span class="keyword">do</span> {</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) {</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                    p = e;</span><br><span class="line">                } <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果找到了该元素，则进行值比对</span></span><br><span class="line">        <span class="comment">// 根据传递进来的matchValue判断是否需要匹配</span></span><br><span class="line">        <span class="comment">// 如果不需要匹配直接删除，如果需要匹配看是否与传入的value相等</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) {</span><br><span class="line">            <span class="comment">// 如果是树结点，则调用树的删除方法；</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="comment">// 如果待删除的元素是第一个元素，则将第二个元素移到到第一个元素的位置</span></span><br><span class="line">            <span class="comment">// 注意：上面的代码可知，node==p的情况只有待删除元素node是第一个结点才会发生</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="comment">// 如果待删除的元素不是第一个元素，则将中间结点连接断开（单向链表）</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            <span class="comment">// 修改次数＋1</span></span><br><span class="line">            ++modCount;</span><br><span class="line">            <span class="comment">// size-1</span></span><br><span class="line">            --size;</span><br><span class="line">            <span class="comment">// 删除结点之后应处理的事情</span></span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<hr>
<h1 id="4-HashMap的其他问题思考"><a href="#4-HashMap的其他问题思考" class="headerlink" title="4.HashMap的其他问题思考"></a>4.HashMap的其他问题思考</h1><hr>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h1><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>关于对Java编程的一些理解</title>
    <url>/2020/03/29/guan-yu-dui-java-bian-cheng-de-yi-xie-li-jie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="Java是解析运行吗？"><a href="#Java是解析运行吗？" class="headerlink" title="Java是解析运行吗？"></a>Java是解析运行吗？</h4><p>不是的！Java源代码经过Javac编译成.class文件，class文件经JVM解析或编译运行。</p>
<ul>
<li>解析: .class文件经过JVM内嵌的解析器解析执行。</li>
<li>编译:存在JIT编译器（Just In Time Compile 即时编译器）把经常运行的代码作为”热点代码”编译与本地平台相关的机器码，并进行各种层次的优化。</li>
<li>AOT编译器: Java 9提供的直接将所有代码编译成机器码执行。</li>
</ul>
<p>写个程序直接执行字节码就是解释执行。写个程序运行时把字节码动态翻译成机器码就是jit。写个程序把java源代码直接翻译为机器码就是aot。造个CPU直接执行字节码，字节码就是机器码。<br>因为如果虚拟机加载字节码后，完全进行解释执行，这势必会影响执行效率。所以，对于这个运行环节，虚拟机会进行一些优化处理，例如JIT技术，会将某些运行特别频繁的代码编译成机器码。而AOT技术，是在运行前，通过工具直接将字节码转换为机器码。</p>
<h4 id="上面提到了JIT-AOT，他们两个之间的区别是什么呢？"><a href="#上面提到了JIT-AOT，他们两个之间的区别是什么呢？" class="headerlink" title="上面提到了JIT,AOT，他们两个之间的区别是什么呢？"></a>上面提到了JIT,AOT，他们两个之间的区别是什么呢？</h4><ul>
<li>JIT是运行时才做的，需要预热才知道哪些是热点；</li>
<li>AOT是编译期，静态的，直接编成类似类库的东西</li>
</ul>
<p>接下来关于几个问题的理解：</p>
<ul>
<li>理解一下：『Write once, run anywhere』 “书写一次，到处运行”？<ul>
<li>“一次编译、到处运行”说的是Java语言跨平台的特性， Java的跨平台特性与Java虚拟机的存在密不可分，可在不同的环境中运行。比如说Windows平台和Linux平台都有相应的JDK，安装好JDK后也就有了Java语言的运行环境。其实Java语言本身与其他的编程语言没有特别大的差异，并不是说Java语言可以跨平台，而是在不同的平台都有可以让Java语言运行的环境而已，所以才有了Java一次编译，到处运行这样的效果。</li>
<li>严格的讲，跨平台的语言不止Java一种，但Java是较为成熟的一种。 “一次编译，到处运行”这种效果跟编译器有关。编程语言的处理需要编译器和解释器。 Java虚拟机和DOS类似，相当于一个供程序运行的平台。</li>
<li>程序从源代码到运行的三个阶段：编码——编译——运行——调试。 Java在编译阶段则体现了跨平台的特点。编译过程大概是这样的：首先是将Java源代码转化成.CLASS文件字节码，这是第一次编译。 .class文件就是可以到处运行的文件。然后Java字节码会被转化为目标机器代码，这是是由JVM来执行的，即Java的第二次编译。</li>
<li>到处运行”的关键和前提就是JVM。因为在第二次编译中JVM起着关键作用。在可以运行Java虚拟机的地方都内含着一个JVM操作系统。从而使JAVA提供了各种不同平台上的虚拟机制，因此实现了“到处运行”的效果。需要强调的一点是， java并不是编译机制，而是解释机制。 Java字节码的设计充分考虑了JIT这一即时编译方式，可以将字节码直接转化成高性能的本地机器码，这同样是虚拟机的一个构成部分。</li>
</ul>
</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java基础知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring IoC源码分析 - 深入理解IoC</title>
    <url>/2020/03/29/spring-ioc-yuan-ma-fen-xi-shen-ru-li-jie-ioc/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在开始IOC源码之前先了解清楚一下理论知识，因为IOC和DI（即依赖注入）大概分为一下几点：</p>
<ol>
<li>IoC是什么？</li>
<li>IoC能做什么？</li>
<li>IoC的别名：DI(依赖注入)</li>
<li>IoC和DI的关系是什么？</li>
</ol>
<h4 id="1-IoC是什么？"><a href="#1-IoC是什么？" class="headerlink" title="1.IoC是什么？"></a>1.IoC是什么？</h4><p>IoC 全称为 Inversion of Control，翻译为 “控制反转”，可以说这并不是一项技术，只是一种思想而已。<strong>在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。</strong> 理解IoC主要的关键在于理解两个问题：</p>
<ol>
<li><strong>谁控制谁，控制什么</strong>：<u>直接说明，是IoC容器控制了对象，控制了外部资源的获取（不只是对象，还有文件等等）</u><ul>
<li>在传统Java SE程序设计中，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建；</li>
</ul>
</li>
<li><strong>为何是反转，哪些方面反转了</strong>：<ul>
<li>首先需要理解的是，正转的意思：在传统应用程序中，是由我们自己在对象中主动控制去直接获取依赖对象，这就是正转。</li>
<li>反转的意思： 由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，这是反转。 </li>
<li>哪些方面反转了呢：依赖对象的获取被反转了。</li>
</ul>
</li>
</ol>
<p>总的来说对于IoC一句话概括为：<strong>所谓IoC就是由 Spring IOC 容器来负责对象的生命周期和对象之间的关系。</strong> 其理念即为：让别人为你服务。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 框架分析 - 导页</title>
    <url>/2020/03/29/spring-kuang-jia-fen-xi-dao-ye/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>Spring 是分层的 Java SE/EE 应用 full-stack 轻量级开源框架，以 IoC（Inverse Of Control：反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）为内核，提供了展现层 Spring MVC 和持久层 Spring JDBC 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的 Java EE 企业应用开源框架。</p>
<p>因为这阵子学习Java框架但是只是会表面的进行一些使用，对内部的结构原理并没有深入的去了解，所以觉得还是有必要进行一下源码的解读，一方面可以对Spring的原理更加深入的了解，另一方面也学习如下如何更加系统的阅读代码。主要还是跟着书籍及一些博主进行阅读，最好的当然是有自己的认识，多写注释多画图，相信会有一些收获的。</p>
<p>可从GitHub上面拉取进行源码分析：<a href="https://github.com/spring-projects/spring-framework。" target="_blank" rel="noopener">https://github.com/spring-projects/spring-framework。</a> 我是直接进行了最新版本的clone：version=5.2.4.BUILD-SNAPSHOT。应该不会有什么问题，进行源码的阅读也仅仅是基础模块，不会对新的内容方向进行深入了解。</p>
<p>所使用的工具及版本号如下：</p>
<ul>
<li>JDK1.8+</li>
<li>IntelliJ IDEA 2019.2</li>
<li>spring-framework 5.2.4.BUILD-SNAPSHOT</li>
</ul>
<h3 id="2-文章的排序"><a href="#2-文章的排序" class="headerlink" title="2.文章的排序"></a>2.文章的排序</h3><p>对于Spring框架的庞大早有耳闻，鉴于自己的水平不够，只能先制订一下大体阅读Spring源码的方向，再各个方向去进行攻克，如果发现有可以继续深入探索的地方，则后面续上；大体上对Spring源码的阅读分为两大部分：IOC 及 AOP</p>
<ul>
<li>IOC方面主要深入了解：<ul>
<li>IOC的基础原理，IOC特性及IOC的使用认识。</li>
<li>单例Bean的注册、获取、创建、解析、加载等等过程。</li>
<li>分析单例Bean的生命周期。</li>
<li>分析BeanDefinitions装载过程。</li>
<li>分析BeanWrapper。</li>
<li></li>
</ul>
</li>
<li>AOP方面主要深入了解：<ul>
<li>AOP的基础原理，</li>
<li>基于XML和基于注解的使用</li>
<li>创建代理对象的过程</li>
<li>请求的完整过程</li>
<li></li>
</ul>
</li>
</ul>
<h3 id="3-Spring-模块结构"><a href="#3-Spring-模块结构" class="headerlink" title="3.Spring 模块结构"></a>3.Spring 模块结构</h3><h3 id="4-结束语"><a href="#4-结束语" class="headerlink" title="4.结束语"></a>4.结束语</h3><p>附录：Spring 源码分析文章列表</p>
<table>
<thead>
<tr>
<th>更新时间</th>
<th>更新文章</th>
</tr>
</thead>
<tbody><tr>
<td>2020-2-13</td>
<td></td>
</tr>
<tr>
<td>2020-2-13</td>
<td></td>
</tr>
<tr>
<td>content1</td>
<td>content2</td>
</tr>
<tr>
<td>content1</td>
<td>content2</td>
</tr>
</tbody></table>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>导页</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 集合框架 - 导页</title>
    <url>/2019/10/07/java-ji-he-kuang-jia-dao-ye/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>对于集合的学习，或者说对于所有知识的学习，总结一点我觉得非常重要的就是：假如可以带着问题去看知识的话那我觉得会更加深入，因为在这个过程当中我们会反复的推问原理为何，才能到达更深入的地步，所以在此系列文章的开头我都会尽量去整理问题的所在点，然后分析源代码，进行知识的总结，在最后再将思考所得写在下一篇文章当中，我觉得这样一来对知识的学习帮助或者更大。</p>
<p>集合的内容也是繁多，跟并发结合在一起两大模块成为Java学习过程当中的拦路虎，消除恐惧最好的方法即为面对恐惧，我对各个知识点逐个进行解析，倒不是说为了出书之类的，自问没有那个本事，只是说可以在学习过程中记录一些知识点和思考所得，可以在后来反复进行探究，不要学了很多遍知识最后却一点东西都没有剩下，对于集合框架的源码分析，难度不算太高，但是我觉得这对我编程的提升有很大帮助，尽量去思考内在逻辑是最有帮助的，希望可以收获更多。</p>
<h1 id="2-已经分析过的知识"><a href="#2-已经分析过的知识" class="headerlink" title="2.已经分析过的知识"></a>2.已经分析过的知识</h1><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><ol>
<li><a href="https://dongxiem.github.io/2020/03/31/java-ji-he-kuang-jia-arraylist-fen-xi/">Java 集合框架 - ArrayList 分析</a></li>
<li><a href="https://dongxiem.github.io/2020/03/31/java-ji-he-kuang-jia-copyonwritearraylist-fen-xi/">Java 集合框架 - CopyOnWriteArrayList 分析</a></li>
<li><a href="https://dongxiem.github.io/2020/03/31/java-ji-he-kuang-jia-linkedlist-fen-xi/">Java 集合框架 - LinkedList 分析</a></li>
</ol>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ol>
<li><a href="https://dongxiem.github.io/2020/03/31/java-ji-he-kuang-jia-hashset-fen-xi/">Java 集合框架 - HashSet 分析</a></li>
</ol>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ol>
<li><a href="https://dongxiem.github.io/2020/03/29/java-ji-he-kuang-jia-hashmap-fen-xi/">Java 集合框架 - HashMap 分析</a></li>
<li><a href="https://dongxiem.github.io/2020/03/31/java-ji-he-kuang-jia-hashmap-ren-shi-yu-li-jie/">Java 集合框架 - HashMap 认识与理解</a></li>
<li><a href="https://dongxiem.github.io/2020/03/31/java-ji-he-kuang-jia-treemap-fen-xi/">Java 集合框架 - TreeMap 分析</a></li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol>
<li><a href="https://dongxiem.github.io/2020/03/31/java-ji-he-kuang-jia-hashtable-fen-xi/">Java 集合框架 - HashTable 分析</a></li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>导页</tag>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - 导页</title>
    <url>/2019/10/05/java-bing-fa-dao-ye/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>Java并发是我在学习Java过程中涉及到的知识点较多的一块，里面的内容较杂乱，需要去好好的梳理一下，归纳总结一些基础的知识点，再对底层的实现原理进行逐一认识了解，在开展各个知识点的认识之前，应先要把基础的特性与概念先了解一下，这样会更好的帮助后面的了解；</p>
<p>在这块当中是十分复杂的，一路过来看得有些头疼，不过发现一些知识内功心法掌握了之后，再回过头看看，好像就很好理解了好多，比如像AQS的源码看了一遍之后，再去看ReentrantLock等等就会简单很多，所以还是要戒骄戒躁，把该理清的思路理清，然后学习到的东西才会更加容易和深刻的进行掌握，路漫漫其修远兮，不可能一口吃成一个大胖子，在分析的过程中，有些内容我似乎还是有些快速的略过，记录的目的是为了不断地正视过去的认识，我觉得这就是Blog记录的好处所在了，只有不断的进行审查排除，才会进步！</p>
<h1 id="2-已经分析过的知识"><a href="#2-已经分析过的知识" class="headerlink" title="2.已经分析过的知识"></a>2.已经分析过的知识</h1><p>关于这个专辑里面的内容，先暂定如下几个内容进行分析，围着各个点进行开展深入学习，深入分析底层原理，弄清各个点之间的联系，联系到实际应用中去，想着如果在高并发状态该如何去解决问题、如何使用以下知识点去优化项目，以后再在实际工作中该如何使用，至少应该明白大体的工作原理及工作流程。</p>
<p>主要涉及的源码及原理分析如下：</p>
<h2 id="2-1-并发基础原理分析"><a href="#2-1-并发基础原理分析" class="headerlink" title="2.1 并发基础原理分析"></a>2.1 并发基础原理分析</h2><ol>
<li><a href="https://dongxiem.github.io/2020/03/31/java-bing-fa-guan-yu-zhi-ling-chong-pai-xu-de-ji-ge-yi-wen/">Java 并发 - 关于指令重排序的几个疑问</a></li>
<li><a href="https://dongxiem.github.io/2020/04/09/java-bing-fa-shang-xia-wen-qie-huan-de-li-jie/">Java 并发 - 上下文切换的理解</a></li>
<li><a href="https://dongxiem.github.io/2020/04/09/java-bing-fa-volatile-fen-xi/">Java 并发 - Volatile 分析</a></li>
<li><a href="https://dongxiem.github.io/2020/03/31/java-bing-fa-cas-fen-xi/">Java 并发 - CAS 分析</a></li>
<li><a href="https://dongxiem.github.io/2020/03/31/java-bing-fa-shen-ru-xian-cheng-chi-yuan-li/">Java 并发 - 深入线程池原理</a></li>
<li><a href="https://dongxiem.github.io/2020/03/31/java-bing-fa-synchronized-yuan-li-fen-xi/">Java 并发 - Synchronized 原理分析</a></li>
<li><a href="https://dongxiem.github.io/2020/03/31/java-bing-fa-synchronized-ji-chong-shi-yong-fang-shi/">Java 并发 - Synchronized 几种使用方式</a></li>
<li><a href="https://dongxiem.github.io/2020/03/31/java-bing-fa-synchronized-yu-qi-ta-yi-xie-suo-ji-zhi-de-dui-bi/">Java 并发 - Synchronized 与其他一些锁机制的对比</a></li>
<li><a href="https://dongxiem.github.io/2020/03/31/java-bing-fa-aqs-kuang-jia-fen-xi/">Java 并发 - AQS：框架分析</a></li>
<li><a href="https://dongxiem.github.io/2020/04/11/java-bing-fa-aqs-locksupport-zu-sai-huan-xing-xian-cheng/">Java 并发 - AQS：LockSupport阻塞唤醒线程</a></li>
<li><a href="https://dongxiem.github.io/2020/04/14/java-bing-fa-aqs-zi-ding-yi-tong-bu-gong-ju/">Java 并发 - AQS：自定义同步工具</a></li>
</ol>
<h2 id="2-2-多线程与线程池"><a href="#2-2-多线程与线程池" class="headerlink" title="2.2 多线程与线程池"></a>2.2 多线程与线程池</h2><ol>
<li><a href="https://dongxiem.github.io/2020/04/01/java-bing-fa-xian-cheng-chuang-jian-de-ji-chong-fang-shi/">Java 并发 - 线程创建的几种方式</a></li>
<li><a href="https://dongxiem.github.io/2020/04/10/java-bing-fa-futuretask-yuan-ma-fen-xi/#2-6-%E5%8F%96%E6%B6%88%E4%BB%BB%E5%8A%A1">Java 并发 - FutureTask源码分析</a></li>
<li><a href="https://dongxiem.github.io/2020/03/31/java-bing-fa-ru-he-ting-zhi-yi-ge-xian-cheng/">Java 并发 - 如何停止一个线程</a></li>
<li><a href="https://dongxiem.github.io/2020/03/31/java-bing-fa-shen-ru-xian-cheng-chi-yuan-li/">Java 并发 - 深入线程池原理</a></li>
<li><a href="https://dongxiem.github.io/2020/04/08/java-bing-fa-xian-cheng-chi-de-shi-yong/">Java 并发 - 线程池的使用</a></li>
</ol>
<h2 id="2-3-锁相关接口与类"><a href="#2-3-锁相关接口与类" class="headerlink" title="2.3 锁相关接口与类"></a>2.3 锁相关接口与类</h2><h3 id="2-3-1-锁的几个分类"><a href="#2-3-1-锁的几个分类" class="headerlink" title="2.3.1 锁的几个分类"></a>2.3.1 锁的几个分类</h3><ol>
<li><a href="https://dongxiem.github.io/2020/04/09/java-bing-fa-suo-xiang-guan-suo-de-ji-chong-ji-ben-fen-lei/">Java 并发 - 锁相关：锁的几种基本分类</a></li>
</ol>
<h3 id="2-3-2-锁相关的几个接口"><a href="#2-3-2-锁相关的几个接口" class="headerlink" title="2.3.2 锁相关的几个接口"></a>2.3.2 锁相关的几个接口</h3><ol>
<li><a href="https://dongxiem.github.io/2020/03/31/java-bing-fa-suo-xiang-guan-condition-jie-kou-fen-xi/">Java 并发 - 锁相关：Condition 接口分析</a></li>
<li><a href="https://dongxiem.github.io/2020/04/09/java-bing-fa-suo-xiang-guan-lock-jie-kou-fen-xi/">Java 并发 - 锁相关：Lock接口分析</a></li>
<li><a href="https://dongxiem.github.io/2020/04/09/java-bing-fa-suo-xiang-guan-readwritelock-jie-kou-fen-xi/">Java 并发 - 锁相关：ReadWriteLock接口分析</a></li>
</ol>
<h3 id="2-3-3-锁相关的几个类"><a href="#2-3-3-锁相关的几个类" class="headerlink" title="2.3.3 锁相关的几个类"></a>2.3.3 锁相关的几个类</h3><ol>
<li><a href="https://dongxiem.github.io/2020/04/09/java-bing-fa-suo-xiang-guan-reentrantlock-fen-xi/">Java 并发 - 锁相关：ReentrantLock 分析</a></li>
<li><a href="https://dongxiem.github.io/2020/03/31/java-bing-fa-suo-xiang-guan-reentrantreadwritelock-fen-xi/">Java 并发 - 锁相关：ReentrantReadWriteLock 分析</a></li>
</ol>
<h2 id="2-4-通信工具类"><a href="#2-4-通信工具类" class="headerlink" title="2.4 通信工具类"></a>2.4 通信工具类</h2><ol>
<li><a href="https://dongxiem.github.io/2020/03/31/java-bing-fa-tong-xin-gong-ju-lei-semaphore-fen-xi/">Java 并发 - 通信工具类：Semaphore 分析</a></li>
<li><a href="https://dongxiem.github.io/2020/03/31/java-bing-fa-tong-xin-gong-ju-lei-exchanger-fen-xi/">Java 并发 - 通信工具类：Exchanger 分析</a></li>
<li><a href="https://dongxiem.github.io/2020/03/31/java-bing-fa-tong-xin-gong-ju-lei-countdownlatch-fen-xi/">Java 并发 - 通信工具类：CountDownLatch 分析</a></li>
<li><a href="https://dongxiem.github.io/2020/03/31/java-bing-fa-tong-xin-gong-ju-lei-cyclibarrier-fen-xi/">Java 并发 - 通信工具类：Cyclibarrier 分析</a></li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>导页</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础 - 导页</title>
    <url>/2019/10/05/java-ji-chu-dao-ye/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>Java基础是很重要的一些东西，除了集合和并发，基础也是相当需要重视的一块，对于基础我没怎么可以去记录一些认识，前人已经完成了大部分内容了，我所做的是将将自己的一些认识记录下来，方便自己日后的查阅，大部分都是一些琐碎的知识，并不能串联成线，基础这些方面的知识还是看书比较好些，因为书上能够更加详细的讲述出来。</p>
<h1 id="2-已经分析过的知识"><a href="#2-已经分析过的知识" class="headerlink" title="2.已经分析过的知识"></a>2.已经分析过的知识</h1><p><a href="https://dongxiem.github.io/2020/03/31/java-ji-chu-string-de-yi-xie-ren-shi/">Java 基础 - String的一些认识</a></p>
<p><a href="https://dongxiem.github.io/2020/03/31/java-ji-chu-int-he-integer-de-yi-xie-ren-shi/">Java 基础 - Int和Integer的一些认识</a></p>
<p><a href="https://dongxiem.github.io/2020/03/31/java-ji-chu-guan-yu-object-de-yi-xie-ren-shi/">Java 基础 - 关于Object的一些认识</a></p>
<p><a href="https://dongxiem.github.io/2020/03/31/java-ji-chu-static-guan-jian-zi-de-yi-xie-ren-shi/">Java 基础 - Static关键字的一些认识</a></p>
<p><a href="https://dongxiem.github.io/2020/03/31/java-ji-chu-guan-yu-fan-she-de-yi-xie-ren-shi/">Java 基础 - 关于反射的一些认识</a></p>
<p><a href="https://dongxiem.github.io/2020/03/31/java-ji-chu-guan-yu-fan-xing-de-yi-xie-ren-shi/">Java 基础 - 关于泛型的一些认识</a></p>
<p><a href="https://dongxiem.github.io/2020/03/31/java-ji-chu-guan-yu-xu-lie-hua-de-yi-xie-ren-shi/">Java 基础 - 关于序列化的一些认识</a></p>
<p><a href="https://dongxiem.github.io/2020/03/31/java-ji-chu-java8-de-yi-xie-ren-shi/">Java 基础 - Java8的一些认识</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java基础知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>导页</tag>
      </tags>
  </entry>
</search>

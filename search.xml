<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HashMap源码分析</title>
    <url>/2020/03/29/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="1-HashMap实现原理"><a href="#1-HashMap实现原理" class="headerlink" title="1.HashMap实现原理"></a>1.HashMap实现原理</h1><p>首先，先进行查看一下HashMap的继承体系：</p>
<p>我们可以从体系的继承看出来：</p>
<ul>
<li>HashMap实现了Cloneable，可以被克隆。</li>
<li>HashMap实现了Serializable，可以被序列化。</li>
<li>HashMap继承自AbstractMap，实现了Map接口，具有Map的所有功能。</li>
</ul>
<p><strong>简述HashMap的工作原理：</strong></p>
<ul>
<li>HashMap是<strong>基于散列法（又称哈希法）的原理</strong>，使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。使用HashMap进行查询和修改的速度都很快，平均时间复杂度O(1)。HashMap非线程安全，如果需要考虑并发，则需要使用ConcurrentHashMap，且HashMap不保证存储元素的序列；</li>
</ul>
<hr>
<h1 id="2-HashMap的底层结构"><a href="#2-HashMap的底层结构" class="headerlink" title="2.HashMap的底层结构"></a>2.HashMap的底层结构</h1><ul>
<li>JDK1.8之后：数组+链表+红黑树</li>
<li>特点是HashMap采用Entry数组来存储key-value对，每一个键值对组成了一个Entry实体，Entry类实际上是一个单向的链表结构，它具有Next指针，可以连接下一个Entry实体。只是在JDK1.8中，链表长度大于8的时候，链表会转成红黑树！</li>
<li>底层结构具体如下所示：</li>
</ul>
<p>在开始查看源码之前，我有如下几个疑问，在通过查看了源码和结合了他人的分析之后，给出了如下的参考：</p>
<ol>
<li><p><strong>为什么用数组+链表？</strong></p>
<ul>
<li>我认为数组是用来确定桶的位置，利用元素的key的hash值对数组长度取模得到.</li>
<li>链表是用来解决hash冲突问题，当出现hash值一样的情形，就在数组上的对应位置形成一条链表。</li>
<li>注：这里的hash值并不是指hashcode，而是将hashcode高低十六位异或过的。</li>
</ul>
</li>
<li><p>那我用<strong>LinkedList代替数组结构</strong>可以么？</p>
<ul>
<li>这里的意思是，源码中是这样的：<code>Entry[] table = new Entry[capacity];</code><ul>
<li>ps：Entry就是一个链表节点。</li>
</ul>
</li>
<li>那我用下面这样表示：<ul>
<li><code>List&lt;Entry&gt; table = new LinkedList&lt;Entry&gt;();</code></li>
</ul>
</li>
<li>所以没毛病是可以使用用LinkedList代替数组结构</li>
</ul>
</li>
<li><p>那既然是可以的，<strong>为什么HashMap不用LinkedList，而选用数组?</strong></p>
<ul>
<li>因为用数组效率最高！在HashMap中，定位桶的位置是利用元素的key的哈希值对数组长度取模得到。此时，我们已得到桶的位置。显然数组的查找效率比LinkedList大。</li>
</ul>
</li>
<li><p>继续挖一下，那ArrayList，底层也是数组，查找也快啊，<strong>为什么不用ArrayList?</strong></p>
<ul>
<li><p>因为采用基本数组结构，扩容机制可以自己定义，HashMap中数组扩容刚好是2的次幂，在做取模运算的效率高。而ArrayList的扩容机制是1.5倍扩容。</p>
</li>
<li><p>而为什么需要两倍扩容，现在此处存疑，在下面我会进行展开分析一下。</p>
</li>
</ul>
</li>
</ol>
<p>关于红黑树相关的知识：</p>
<ul>
<li>可以看这篇文章：    </li>
</ul>
<hr>
<h1 id="3-源码阅读"><a href="#3-源码阅读" class="headerlink" title="3.源码阅读"></a>3.源码阅读</h1><h2 id="3-1-HashMap的继承与实现"><a href="#3-1-HashMap的继承与实现" class="headerlink" title="3.1.HashMap的继承与实现"></a>3.1.HashMap的继承与实现</h2><ul>
<li>HashMap实现了Cloneable，可以被克隆。</li>
<li>HashMap实现了Serializable，可以被序列化。</li>
<li>HashMap继承自AbstractMap，实现了Map接口，具有Map的所有功能。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-2-HashMap的基本属性及内部类"><a href="#3-2-HashMap的基本属性及内部类" class="headerlink" title="3.2.HashMap的基本属性及内部类"></a>3.2.HashMap的基本属性及内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 哈希数组初始容量</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 哈希数组最大容量</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * HashMap默认装载因子（负载因子）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 当前 HashMap 所能容纳键值对数量的最大值，超过这个值，则需扩容</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 哈希槽（链）上的红黑树上的元素数量减少到此值时，将红黑树转换为链表</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 当桶的个数达到64的时候才进行树化</span></span><br><span class="line"><span class="comment">  * 即是说当桶数组容量小于该值时，优先进行扩容，而不是树化</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 哈希数组</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * entry集合</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * HashMap的元素数量</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *  HashMap结构的修改次数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * (The javadoc description is true upon serialization.</span></span><br><span class="line"><span class="comment">  * Additionally, if the table array has not been allocated, this</span></span><br><span class="line"><span class="comment">  * field holds the initial array capacity, or zero signifying</span></span><br><span class="line"><span class="comment">  * DEFAULT_INITIAL_CAPACITY.)</span></span><br><span class="line"><span class="comment">  * HashMap扩容阈值，并没有默认阈值，原因是阈值可由容量乘上负载因子计算而来（注释中有说明）</span></span><br><span class="line"><span class="comment">  * 计算公式：threshold = capacity * loadFactor</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * HashMap当前使用的装载因子</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>

<p>上面举例了一些HashMap的属性字段，比较有意思的是羡慕几个属性字段，在接下来中会单拎出来进行详细讲解。：</p>
<ul>
<li>哈希数组的初始容量：DEFAULT_INITIAL_CAPACITY</li>
<li>负载因子：loadFactor</li>
<li>链表树化与树化链表的两个阈值：UNTREEIFY_THRESHOLD 和TREEIFY_THRESHOLD</li>
</ul>
<h2 id="3-3-HashMap的四种构造及参数分析"><a href="#3-3-HashMap的四种构造及参数分析" class="headerlink" title="3.3.HashMap的四种构造及参数分析"></a>3.3.HashMap的四种构造及参数分析</h2><ol>
<li>无参构造，初始化一个哈希数组容量为16，装载因子为0.75的HashMap</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &#123;<span class="doctag">@code</span> HashMap&#125; with the default initial capacity</span></span><br><span class="line"><span class="comment"> * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>初始化一个哈希数组容量为initialCapacity，装载因子为0.75的HashMap</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &#123;<span class="doctag">@code</span> HashMap&#125; with the specified initial</span></span><br><span class="line"><span class="comment"> * capacity and the default load factor (0.75).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity the initial capacity.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>初始化一个哈希数组容量为initialCapacity，装载因子为loadFactor的HashMap</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Constructs an empty &#123;<span class="doctag">@code</span> HashMap&#125; with the specified initial</span></span><br><span class="line"><span class="comment">   * capacity and load factor.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment">   *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 检查传入的初始容量是否合法</span></span><br><span class="line">      <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                             initialCapacity);</span><br><span class="line">      <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">          initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">      <span class="comment">// 检查装载因子是否合法</span></span><br><span class="line">      <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                             loadFactor);</span><br><span class="line">      <span class="comment">// 初始化装载因子</span></span><br><span class="line">      <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">      <span class="comment">// 用初始容量信息来计算扩容门槛</span></span><br><span class="line">      <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用指定的HashMap中的元素来初始化一个新的HashMap</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new &#123;<span class="doctag">@code</span> HashMap&#125; with the same mappings as the</span></span><br><span class="line"><span class="comment"> * specified &#123;<span class="doctag">@code</span> Map&#125;.  The &#123;<span class="doctag">@code</span> HashMap&#125; is created with</span></span><br><span class="line"><span class="comment"> * default load factor (0.75) and an initial capacity sufficient to</span></span><br><span class="line"><span class="comment"> * hold the mappings in the specified &#123;<span class="doctag">@code</span> Map&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   m the map whose mappings are to be placed in this map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    <span class="comment">// 将指定HashMap中的元素存入到当前HashMap（允许覆盖）</span></span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们这这里对几个字段进行解释一下：</p>
<h2 id="3-4-查询"><a href="#3-4-查询" class="headerlink" title="3.4.查询"></a>3.4.查询</h2><h3 id="3-4-1-查询HashMap大小"><a href="#3-4-1-查询HashMap大小" class="headerlink" title="3.4.1.查询HashMap大小"></a>3.4.1.查询HashMap大小</h3><p>该方法返回HashMap的大小，键值对的数目：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-2-查询HashMap是否为空"><a href="#3-4-2-查询HashMap是否为空" class="headerlink" title="3.4.2 查询HashMap是否为空"></a>3.4.2 查询HashMap是否为空</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-3-查询HashMap是否存在指定key"><a href="#3-4-3-查询HashMap是否存在指定key" class="headerlink" title="3.4.3.查询HashMap是否存在指定key"></a>3.4.3.查询HashMap是否存在指定key</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getNode(hash(key), key) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-4-查询HashMap中是否存在指定value的元素"><a href="#3-4-4-查询HashMap中是否存在指定value的元素" class="headerlink" title="3.4.4.查询HashMap中是否存在指定value的元素"></a>3.4.4.查询HashMap中是否存在指定value的元素</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; V v;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 进行循环遍历查找value</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; e : tab) &#123;</span><br><span class="line">            <span class="keyword">for</span> (; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((v = e.value) == value ||</span><br><span class="line">                    (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-5-取值"><a href="#3-5-取值" class="headerlink" title="3.5.取值"></a>3.5.取值</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它调用了<code>getNode(int hash, Object key)</code>方法，详细代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">      <span class="comment">// 如果桶的数量大于0，并且所查找的key所在的桶的第一个元素不为空</span></span><br><span class="line">      <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">          (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 检查第一个元素是不是要查的元素，如果是则直接返回</span></span><br><span class="line">          <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">              ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">              <span class="keyword">return</span> first;</span><br><span class="line">          <span class="comment">// 如果不止一个元素，则继续寻找</span></span><br><span class="line">          <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// 如果第一个元素是树节点，则按树的方式查找</span></span><br><span class="line">              <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                  <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">              <span class="keyword">do</span> &#123;</span><br><span class="line">                  <span class="comment">// 否则就遍历整个链表查找该元素</span></span><br><span class="line">                  <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                      ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                      <span class="keyword">return</span> e;</span><br><span class="line">              &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-6-添加"><a href="#3-6-添加" class="headerlink" title="3.6.添加"></a>3.6.添加</h2><h3 id="3-6-1-HashMap的添加过程"><a href="#3-6-1-HashMap的添加过程" class="headerlink" title="3.6.1.HashMap的添加过程"></a>3.6.1.HashMap的添加过程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上它调用了<code>putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict)</code>方法，详细代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 向当前Map中存入新的元素，并返回旧元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * hash         key的哈希值</span></span><br><span class="line"><span class="comment"> * onlyIfAbsent 是否需要维持原状（不覆盖旧值）</span></span><br><span class="line"><span class="comment"> * evict        如果为false，则表处于创建模式。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回同位元素的旧值（在当前Map中占据相同位置的元素）</span></span><br><span class="line"><span class="comment"> * 如果不存在同位元素，即插入了新元素，则返回null</span></span><br><span class="line"><span class="comment"> * 如果存在同位元素，但同位元素的旧值为null，那么也返回null</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 如果桶的长度为0，未初始化，则进行初始化并得到长度n</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 调用resize进行初始化</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 如果桶中还没有元素，则将要插入的key和value放到第一位</span></span><br><span class="line">    <span class="comment">// 使用(n - 1) &amp; hash 计算元素在哪个桶中</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">// 桶中此时已存在元素</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 如果待插入的元素的hash值和key值与第一个元素的哈希值和key相同，保存到e用于后续修改value值</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 如果桶的第一个元素为树节点，则调用树节点的putTreeVal方法插入元素</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历这个桶对应的链表，binCount用于存储链表中元素的个数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 遍历整个链表，没有相同哈希值和key的元素，则在链表最后插入该key和value结点</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 如果插入结点之后的长度大于等于8，则树化</span></span><br><span class="line">                    <span class="comment">// 这里-1的解释为：因为第一个元素没有加到binCount中，所以这里-1</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">// 进行树化</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 假如待插入的key在链表中找到，则退出循环</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到了对应key的元素</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;   <span class="comment">// 记录旧值</span></span><br><span class="line">            <span class="comment">// 判断是否需要替换旧值</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;    <span class="comment">// 替换旧值为新值</span></span><br><span class="line">            <span class="comment">// 在节点被访问后做点什么事，在LinkedHashMap中用到</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到了此处证明没有找到元素，即添加了新元素，修改次数加1</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 如果哈希数组的容量已超过阈值，则需要对哈希数组扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 在节点插入后做点什么事，在LinkedHashMap中用到</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加方法除了可以单个key-value键值对的添加，还可以将指定HashMap中的元素存入到当前HashMap中（允许覆盖），详细代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前HashMap的哈希数组还未初始化</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">// 根据HashMap中的元素数量反推哈希数组的最低容量要求</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;  <span class="comment">// 注意这里!!!!</span></span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">// 如果大于需要扩容的阈值，则重新计算扩容阈值</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Because of linked-list bucket constraints, we cannot</span></span><br><span class="line">            <span class="comment">// expand all at once, but can reduce total resize</span></span><br><span class="line">            <span class="comment">// effort by repeated doubling now vs later</span></span><br><span class="line">            <span class="comment">// 由于链表存储桶的限制，我们无法一次全部扩展</span></span><br><span class="line">            <span class="comment">// 但可以通过立即加倍与以后加倍来减少总的调整工作量</span></span><br><span class="line">            <span class="comment">// 初始化哈希数组，或者对哈希数组扩容，并返回新的哈希数组</span></span><br><span class="line">            <span class="keyword">while</span> (s &gt; threshold &amp;&amp; table.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                resize();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环遍历进行添加，允许覆盖</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-2-HashMap的扩容过程"><a href="#3-6-2-HashMap的扩容过程" class="headerlink" title="3.6.2.HashMap的扩容过程"></a>3.6.2.HashMap的扩容过程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 扩容机制：在初始化时、对哈希数组扩容时两种情况下调用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// 旧数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 旧容量，或者未初始化时的容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">// 旧扩容阈值</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="comment">// 新容量、新扩容阈值</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果哈希数组已经初始化，不是首次进入</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果旧容量大于最大容量，则不再扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果旧容量的两倍（左移一位）小于最大容量，并且大于默认初始容量（16）</span></span><br><span class="line">        <span class="comment">// 则新容量扩大为旧容量的两倍，扩容阈值也扩大为旧阈值的两倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果哈希数组还未初始化（首次进来）并且实例化HashMap的时候指定了初始容量</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        <span class="comment">// 则将哈希数组的当前容量初始化为与旧阈值一样大（传入初始容量时候会调用tableSizeFor()方法）</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">// 如果哈希数组还未初始化（首次进来）并且实例化HashMap的时候没有指定了初始容量</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">// 则使用默认的初始容量（16）和默认公式计算的阈值</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果新扩容阈值为0，则使用公式计算得到新的扩容阈值，并且不可超过最大容量</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 赋值扩容阈值为新扩容阈值</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">// 根据新扩容容量建立一个新容量的数组</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    <span class="comment">// 将桶赋值为新数组</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">// 旧数组不为空，则搬移元素</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历旧数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">// 如果桶中的第一个元素不为空，则赋值给e</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 清空旧桶，帮助GC</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 如果桶中只有一个元素，进行新桶的位置定位，并搬迁</span></span><br><span class="line">                <span class="comment">// 注意：只有第一个元素才可以这样，因为每次扩容都是两倍</span></span><br><span class="line">                <span class="comment">//       则第一个元素搬移到新桶的时候肯定还没有元素</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 如果该哈希槽上链接了不止一个元素，且该元素是TreeNode类型</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 如果第一个元素是树节点，则把这颗树打散成两颗树插入到新桶中去</span></span><br><span class="line">                    <span class="comment">// 拆分红黑树</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 如果这个链表不止一个元素且不是一颗树</span></span><br><span class="line">                    <span class="comment">// 则进行分化成两个链表插到新的桶中</span></span><br><span class="line">                    <span class="comment">// 举例：假如原来容量为4，3、7、11、15这四个元素都在三号桶中</span></span><br><span class="line">                    <span class="comment">// 现在扩容到8，则3和11还是在三号桶，7和15要搬移到七号桶中去</span></span><br><span class="line">                    <span class="comment">// 也就是分化成了两个链表</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// (e.hash &amp; oldCap) == 0的元素放在低位链表中</span></span><br><span class="line">                        <span class="comment">// 比如，3 &amp; 4 == 0</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// (e.hash &amp; oldCap) != 0的元素放在高位链表中</span></span><br><span class="line">                            <span class="comment">// 比如，7 &amp; 4 != 0</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 遍历完成得到两个链表</span></span><br><span class="line">                    <span class="comment">// 低位链表在新桶的位置与旧桶一样（即3和11还在三号桶中）</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 高位链表在新桶中的位置正好是原来的位置加上旧容量（即7和15搬移到七号桶了）</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-3-HashMap扩容的思考"><a href="#3-6-3-HashMap扩容的思考" class="headerlink" title="3.6.3.HashMap扩容的思考"></a>3.6.3.HashMap扩容的思考</h3><h3 id="3-6-4-树化与链化过程"><a href="#3-6-4-树化与链化过程" class="headerlink" title="3.6.4.树化与链化过程"></a>3.6.4.树化与链化过程</h3><h2 id="3-7-移除"><a href="#3-7-移除" class="headerlink" title="3.7.移除"></a>3.7.移除</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 根据传入的key进行数据移除元素，并返回刚刚移除的元素的值</span><br><span class="line"> *&#x2F;</span><br><span class="line">public V remove(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e &#x3D; removeNode(hash(key), key, null, false, true)) &#x3D;&#x3D; null ?</span><br><span class="line">        null : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上它调用了<code>removeNode(int hash, Object key, Object value,boolean matchValue, boolean movable)</code>方法，详细代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 从HashMap中移除指定的元素，并返回刚刚移除的元素（移除失败返回null）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * matchValue 移除元素时是否需要考虑value的匹配问题</span></span><br><span class="line"><span class="comment"> * movable    移除元素后如果红黑树根结点发生了变化，那么是否需要改变结点在链表上的顺序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">// 如果桶的数量大于0（不空）且待删除的元素所在的桶的第一个元素不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">// 如果键的值与链表第一个节点相等，则将 node 指向该节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果该Tab的第一个元素是树节点，则以树的方式进行寻找</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则，就以链表的形式进行遍历寻找</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果找到了该元素，则进行值比对</span></span><br><span class="line">        <span class="comment">// 根据传递进来的matchValue判断是否需要匹配</span></span><br><span class="line">        <span class="comment">// 如果不需要匹配直接删除，如果需要匹配看是否与传入的value相等</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="comment">// 如果是树结点，则调用树的删除方法；</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="comment">// 如果待删除的元素是第一个元素，则将第二个元素移到到第一个元素的位置</span></span><br><span class="line">            <span class="comment">// 注意：上面的代码可知，node==p的情况只有待删除元素node是第一个结点才会发生</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="comment">// 如果待删除的元素不是第一个元素，则将中间结点连接断开（单向链表）</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            <span class="comment">// 修改次数＋1</span></span><br><span class="line">            ++modCount;</span><br><span class="line">            <span class="comment">// size-1</span></span><br><span class="line">            --size;</span><br><span class="line">            <span class="comment">// 删除结点之后应处理的事情</span></span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="4-HashMap的其他问题思考"><a href="#4-HashMap的其他问题思考" class="headerlink" title="4.HashMap的其他问题思考"></a>4.HashMap的其他问题思考</h1><hr>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h1>]]></content>
  </entry>
  <entry>
    <title>关于对Java编程的一些理解</title>
    <url>/2020/03/29/%E5%85%B3%E4%BA%8E%E5%AF%B9Java%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h4 id="Java是解析运行吗？"><a href="#Java是解析运行吗？" class="headerlink" title="Java是解析运行吗？"></a>Java是解析运行吗？</h4><p>不是的！Java源代码经过Javac编译成.class文件，class文件经JVM解析或编译运行。</p>
<ul>
<li>解析: .class文件经过JVM内嵌的解析器解析执行。</li>
<li>编译:存在JIT编译器（Just In Time Compile 即时编译器）把经常运行的代码作为”热点代码”编译与本地平台相关的机器码，并进行各种层次的优化。</li>
<li>AOT编译器: Java 9提供的直接将所有代码编译成机器码执行。</li>
</ul>
<p>写个程序直接执行字节码就是解释执行。写个程序运行时把字节码动态翻译成机器码就是jit。写个程序把java源代码直接翻译为机器码就是aot。造个CPU直接执行字节码，字节码就是机器码。<br>因为如果虚拟机加载字节码后，完全进行解释执行，这势必会影响执行效率。所以，对于这个运行环节，虚拟机会进行一些优化处理，例如JIT技术，会将某些运行特别频繁的代码编译成机器码。而AOT技术，是在运行前，通过工具直接将字节码转换为机器码。</p>
<h4 id="上面提到了JIT-AOT，他们两个之间的区别是什么呢？"><a href="#上面提到了JIT-AOT，他们两个之间的区别是什么呢？" class="headerlink" title="上面提到了JIT,AOT，他们两个之间的区别是什么呢？"></a>上面提到了JIT,AOT，他们两个之间的区别是什么呢？</h4><ul>
<li>JIT是运行时才做的，需要预热才知道哪些是热点；</li>
<li>AOT是编译期，静态的，直接编成类似类库的东西</li>
</ul>
<p>接下来关于几个问题的理解：</p>
<ul>
<li>理解一下：『Write once, run anywhere』 “书写一次，到处运行”？<ul>
<li>“一次编译、到处运行”说的是Java语言跨平台的特性， Java的跨平台特性与Java虚拟机的存在密不可分，可在不同的环境中运行。比如说Windows平台和Linux平台都有相应的JDK，安装好JDK后也就有了Java语言的运行环境。其实Java语言本身与其他的编程语言没有特别大的差异，并不是说Java语言可以跨平台，而是在不同的平台都有可以让Java语言运行的环境而已，所以才有了Java一次编译，到处运行这样的效果。</li>
<li>严格的讲，跨平台的语言不止Java一种，但Java是较为成熟的一种。 “一次编译，到处运行”这种效果跟编译器有关。编程语言的处理需要编译器和解释器。 Java虚拟机和DOS类似，相当于一个供程序运行的平台。</li>
<li>程序从源代码到运行的三个阶段：编码——编译——运行——调试。 Java在编译阶段则体现了跨平台的特点。编译过程大概是这样的：首先是将Java源代码转化成.CLASS文件字节码，这是第一次编译。 .class文件就是可以到处运行的文件。然后Java字节码会被转化为目标机器代码，这是是由JVM来执行的，即Java的第二次编译。</li>
<li>到处运行”的关键和前提就是JVM。因为在第二次编译中JVM起着关键作用。在可以运行Java虚拟机的地方都内含着一个JVM操作系统。从而使JAVA提供了各种不同平台上的虚拟机制，因此实现了“到处运行”的效果。需要强调的一点是， java并不是编译机制，而是解释机制。 Java字节码的设计充分考虑了JIT这一即时编译方式，可以将字节码直接转化成高性能的本地机器码，这同样是虚拟机的一个构成部分。</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Spring IoC源码分析 - 深入理解IoC</title>
    <url>/2020/03/29/Spring%20IoC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3IoC/</url>
    <content><![CDATA[<p>在开始IOC源码之前先了解清楚一下理论知识，因为IOC和DI（即依赖注入）大概分为一下几点：</p>
<ol>
<li>IoC是什么？</li>
<li>IoC能做什么？</li>
<li>IoC的别名：DI(依赖注入)</li>
<li>IoC和DI的关系是什么？</li>
</ol>
<h4 id="1-IoC是什么？"><a href="#1-IoC是什么？" class="headerlink" title="1.IoC是什么？"></a>1.IoC是什么？</h4><p>IoC 全称为 Inversion of Control，翻译为 “控制反转”，可以说这并不是一项技术，只是一种思想而已。<strong>在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。</strong> 理解IoC主要的关键在于理解两个问题：</p>
<ol>
<li><strong>谁控制谁，控制什么</strong>：<u>直接说明，是IoC容器控制了对象，控制了外部资源的获取（不只是对象，还有文件等等）</u><ul>
<li>在传统Java SE程序设计中，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建；</li>
</ul>
</li>
<li><strong>为何是反转，哪些方面反转了</strong>：<ul>
<li>首先需要理解的是，正转的意思：在传统应用程序中，是由我们自己在对象中主动控制去直接获取依赖对象，这就是正转。</li>
<li>反转的意思： 由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，这是反转。 </li>
<li>哪些方面反转了呢：依赖对象的获取被反转了。</li>
</ul>
</li>
</ol>
<p>总的来说对于IoC一句话概括为：<strong>所谓IoC就是由 Spring IOC 容器来负责对象的生命周期和对象之间的关系。</strong> 其理念即为：让别人为你服务。</p>
]]></content>
  </entry>
  <entry>
    <title>Spring 源码导读</title>
    <url>/2020/03/29/Spring%20%E6%BA%90%E7%A0%81%E5%AF%BC%E8%AF%BB/</url>
    <content><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>Spring 是分层的 Java SE/EE 应用 full-stack 轻量级开源框架，以 IoC（Inverse Of Control：反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）为内核，提供了展现层 Spring MVC 和持久层 Spring JDBC 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的 Java EE 企业应用开源框架。</p>
<p>因为这阵子学习Java框架但是只是会表面的进行一些使用，对内部的结构原理并没有深入的去了解，所以觉得还是有必要进行一下源码的解读，一方面可以对Spring的原理更加深入的了解，另一方面也学习如下如何更加系统的阅读代码。主要还是跟着书籍及一些博主进行阅读，最好的当然是有自己的认识，多写注释多画图，相信会有一些收获的。</p>
<p>可从GitHub上面拉取进行源码分析：<a href="https://github.com/spring-projects/spring-framework。" target="_blank" rel="noopener">https://github.com/spring-projects/spring-framework。</a> 我是直接进行了最新版本的clone：version=5.2.4.BUILD-SNAPSHOT。应该不会有什么问题，进行源码的阅读也仅仅是基础模块，不会对新的内容方向进行深入了解。</p>
<p>所使用的工具及版本号如下：</p>
<ul>
<li>JDK1.8+</li>
<li>IntelliJ IDEA 2019.2</li>
<li>spring-framework 5.2.4.BUILD-SNAPSHOT</li>
</ul>
<h3 id="2-文章的排序"><a href="#2-文章的排序" class="headerlink" title="2.文章的排序"></a>2.文章的排序</h3><p>对于Spring框架的庞大早有耳闻，鉴于自己的水平不够，只能先制订一下大体阅读Spring源码的方向，再各个方向去进行攻克，如果发现有可以继续深入探索的地方，则后面续上；大体上对Spring源码的阅读分为两大部分：IOC 及 AOP</p>
<ul>
<li>IOC方面主要深入了解：<ul>
<li>IOC的基础原理，IOC特性及IOC的使用认识。</li>
<li>单例Bean的注册、获取、创建、解析、加载等等过程。</li>
<li>分析单例Bean的生命周期。</li>
<li>分析BeanDefinitions装载过程。</li>
<li>分析BeanWrapper。</li>
<li></li>
</ul>
</li>
<li>AOP方面主要深入了解：<ul>
<li>AOP的基础原理，</li>
<li>基于XML和基于注解的使用</li>
<li>创建代理对象的过程</li>
<li>请求的完整过程</li>
<li></li>
</ul>
</li>
</ul>
<h3 id="3-Spring-模块结构"><a href="#3-Spring-模块结构" class="headerlink" title="3.Spring 模块结构"></a>3.Spring 模块结构</h3><h3 id="4-结束语"><a href="#4-结束语" class="headerlink" title="4.结束语"></a>4.结束语</h3><p>附录：Spring 源码分析文章列表</p>
<table>
<thead>
<tr>
<th>更新时间</th>
<th>更新文章</th>
</tr>
</thead>
<tbody><tr>
<td>2020-2-13</td>
<td></td>
</tr>
<tr>
<td>2020-2-13</td>
<td></td>
</tr>
<tr>
<td>content1</td>
<td>content2</td>
</tr>
<tr>
<td>content1</td>
<td>content2</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>Java并发源码分析导页</title>
    <url>/2020/03/29/Java%E5%B9%B6%E5%8F%91%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%AF%BC%E9%A1%B5/</url>
    <content><![CDATA[<h1 id="一-简介"><a href="#一-简介" class="headerlink" title="一.简介"></a>一.简介</h1><p>Java并发是我在学习Java过程中涉及到的知识点较多的一块，里面的内容较杂乱，需要去好好的梳理一下，归纳总结一些基础的知识点，再对底层的实现原理进行逐一认识了解，在开展各个知识点的认识之前，应先要把基础的特性与概念先了解一下，这样会更好的帮助后面的了解；Java并发所涉及到的知识点大概为：线程的安全、线程调度、各种容器、AQS、J.U.C等等；</p>
<p>在进行并发深入了解之前，先明白并发、并行、高并发的概念：</p>
<ul>
<li>并发：是指在某个时间段内，多任务交替的执行任务。当有多个线程在操作时，把CPU运行时间划分成若干个时间段,再将时间段分配给各个线程执行。 在一个时间段的线程代码运行时，其它线程处于挂起状。</li>
<li>并行：是指同一时刻同时处理多任务的能力。当有多个线程在操作时，cpu同时处理这些线程请求的能力。</li>
<li>高并发：它通常是指，通过设计保证系统能够同时并行处理很多请求。</li>
</ul>
<h1 id="二-文章的排序"><a href="#二-文章的排序" class="headerlink" title="二.文章的排序"></a>二.文章的排序</h1><p>关于这个专辑里面的内容，先暂定如下几个内容进行分析，围着各个点进行开展深入学习，深入分析底层原理，弄清各个点之间的联系，联系到实际应用中去，想着如果在高并发状态该如何去解决问题、如何使用以下知识点去优化项目，以后再在实际工作中该如何使用，至少应该明白大体的工作原理及工作流程。</p>
<p>主要涉及的源码及原理分析如下：</p>
<ul>
<li>Java 线程池分析</li>
<li>Synchronized、Volatile 原理分析</li>
<li>J.U.C AQS分析</li>
<li>J.U.C 重入锁及读写锁分析</li>
<li>J.U.C 并发工具类分析</li>
<li>J.U.C 并发容器分析</li>
<li>Java 阻塞队列分析</li>
<li>Java CAS 原理分析</li>
<li></li>
</ul>
<h1 id="三-内容窥探"><a href="#三-内容窥探" class="headerlink" title="三.内容窥探"></a>三.内容窥探</h1><ol>
<li>线程与进程：<ol>
<li>我们需要理解线程与进程的概念与联系、线程的底层数据结构源码的解析。</li>
<li>线程的几种创建方式，这几种实现方式的源码的异同在哪里。</li>
</ol>
</li>
<li>线程池：<ol>
<li>理解线程池的基本概念与基本架构</li>
<li>ThreadPoolExecutor</li>
<li>ScheduledThreadPoolExecutor</li>
</ol>
</li>
<li>Synchronized：<ol>
<li>理解Synchronized的作用</li>
<li>进行Synchronized的代码解析</li>
</ol>
</li>
<li>Volatile：<ol>
<li>理解Volatile的作用</li>
<li>进行Volatile的代码解析</li>
</ol>
</li>
<li>AQS：AbstractQueuedSynvhronizer<ol>
<li>同步队列</li>
<li>同步状态</li>
<li>阻塞与幻想线程</li>
<li>独占/共享模式</li>
<li></li>
</ol>
</li>
<li>J.U.C 重入锁ReentrantLock、读写锁ReentrantReadWriteLock<ol>
<li>理解各自的原理与作用</li>
<li>进行代码解析</li>
<li>进行使用对比</li>
<li></li>
</ol>
</li>
<li>J.U.C 并发工具类：<ol>
<li>CountDownLatch</li>
<li>CyclicBarrier</li>
<li>Semaphore</li>
<li>Exchanger</li>
<li></li>
</ol>
</li>
<li>J.U.C 并发容器：<ol>
<li>ConcurrentHashMap</li>
<li>ConcurrentLinkedQueue</li>
<li>ConcurrentSkipListMap</li>
</ol>
</li>
<li>J.U.C 阻塞队列：<ol>
<li>ArrayBlockingQueue</li>
<li>PriorityBlockingQueue</li>
<li>DelayQueue</li>
<li>SynchronousQueue</li>
<li>LinkedTransferQueue</li>
<li>LinkedBlockingDeque</li>
</ol>
</li>
</ol>
<h1 id="四-结束语"><a href="#四-结束语" class="headerlink" title="四.结束语"></a>四.结束语</h1><p>因为我觉得我还是对一些高并发、高可用的知识较为感兴趣，所以对这一章节的内容可能会深入的探究一下，最好的方法我觉得还是看官方文档，这就需要一定的英语知识，可以采取的措施即为多看一下计算机相关的专业英语，实在不行的话借助翻译器也是一个方法；多动手去完成一些demo，进行编译Debug，这对以后工作状态当中进行排查错误是一个很好的方法，很多人只是了解基础知识，并没有去实践，这是一个问题所在；</p>
]]></content>
  </entry>
  <entry>
    <title>Java集合源码分析导页</title>
    <url>/2020/03/29/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%AF%BC%E9%A1%B5/</url>
    <content><![CDATA[<h2 id="一-简介"><a href="#一-简介" class="headerlink" title="一.简介"></a>一.简介</h2><p>对于集合的学习，或者说对于所有知识的学习，总结一点我觉得非常重要的就是：假如可以带着问题去看知识的话那我觉得会更加深入，因为在这个过程当中我们会反复的推问原理为何，才能到达更深入的地步，所以在此系列文章的开头我都会尽量去整理问题的所在点，然后分析源代码，进行知识的总结，在最后再将思考所得写在下一篇文章当中，我觉得这样一来对知识的学习帮助或者更大。<br>集合的内容也是繁多，跟并发结合在一起两大模块成为Java学习过程当中的拦路虎，消除恐惧最好的方法即为面对恐惧，我对各个知识点逐个进行解析，倒不是说为了出书之类的，自问没有那个本事，只是说可以在学习过程中记录一些知识点和思考所得，可以在后来反复进行探究，不要学了很多遍知识最后却一点东西都没有剩下，对于集合框架的源码分析，难度不算太高，但是我觉得这对我编程的提升有很大帮助，尽量去思考内在逻辑是最有帮助的，希望可以收获更多。</p>
<p>工具与源码版本：</p>
<ul>
<li>IntelliJ IDEA 2019.2</li>
<li>jdk-15+9 （直接从<a href="https://github.com/openjdk/jdk" target="_blank" rel="noopener">https://github.com/openjdk/jdk</a> Clone下来的）</li>
</ul>
<h2 id="二-知识的窥探"><a href="#二-知识的窥探" class="headerlink" title="二.知识的窥探"></a>二.知识的窥探</h2><p>如若按照Collection和Map的归类来分的话，可以分为以下几部分：</p>
<ul>
<li><strong>Collection</strong> <ol>
<li><strong>List</strong><ol>
<li>Arraylist： Object数。</li>
<li>Vector： Object数组。</li>
<li>LinkedList： 双向链表(JDK1.6之前为循环链表，JDK1.7取消了循环)。</li>
</ol>
</li>
<li><strong>Set</strong><ol>
<li>LinkedHashSet： LinkedHashSet 继承于 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 HashMap 实现一样，不过还是有一点点区别的。</li>
<li>HashSet（无序，唯一）: 基于 HashMap 实现的，底层采用 HashMap 来保存元素。</li>
<li>TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树)。</li>
</ol>
</li>
</ol>
</li>
<li><strong>Map</strong><ol>
<li>HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</li>
<li>LinkedHashMap： LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：《LinkedHashMap 源码详细分析（JDK1.8）》</li>
<li>Hashtable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li>
<li>TreeMap： 红黑树（自平衡的排序二叉树）</li>
</ol>
</li>
<li><strong>注：如何选用集合?</strong><ul>
<li>主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用Map接口下的集合，需要排序时选择TreeMap，不需要排序时就选择HashMap，需要保证线程安全就选用ConcurrentHashMap.当我们只需要存放元素值时，就选择实现Collection接口的集合，需要保证元素唯一时选择实现Set接口的集合比如TreeSet或HashSet，不需要就选择实现List接口的比如ArrayList或LinkedList，然后再根据实现这些接口的集合的特点来选用。</li>
</ul>
</li>
</ul>
<h2 id="三-源码分析的排序"><a href="#三-源码分析的排序" class="headerlink" title="三.源码分析的排序"></a>三.源码分析的排序</h2><p>主要涉及的源码及原理分析如下：</p>
<ol>
<li>ArrayList 源码分析</li>
<li>LinkedList 源码分析</li>
<li><a href="">HashMap 源码分析</a></li>
<li>ConcurrentHashMap 源码分析</li>
<li>HashSet源码分析</li>
<li>LinkedHashMap 源码分析</li>
<li>TreeMap 源码分析</li>
<li>CopyOnWriteArrayList 源码分析</li>
<li></li>
</ol>
<h2 id="四-结束语"><a href="#四-结束语" class="headerlink" title="四.结束语"></a>四.结束语</h2><p>对于这个模块的学习，看源码是最好的，稍后补充</p>
]]></content>
  </entry>
  <entry>
    <title>Java基础知识导页</title>
    <url>/2020/03/29/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AF%BC%E9%A1%B5/</url>
    <content><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><h2 id="2-文章的排序"><a href="#2-文章的排序" class="headerlink" title="2.文章的排序"></a>2.文章的排序</h2><ol>
<li></li>
<li></li>
</ol>
<h2 id="3-结束语"><a href="#3-结束语" class="headerlink" title="3. 结束语"></a>3. 结束语</h2><p>语言的基础知识理解是最重要的，万丈高楼平地起，只有把基础知识解决了，后面的工作才会更好的进行下去，希望这个专辑能帮助我和大家更好的理解一下基础的语言知识</p>
<h2 id="4-阅读书籍介绍"><a href="#4-阅读书籍介绍" class="headerlink" title="4. 阅读书籍介绍"></a>4. 阅读书籍介绍</h2>]]></content>
  </entry>
</search>

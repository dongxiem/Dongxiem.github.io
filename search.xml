<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Mybatis 框架分析（2） -  简单Demo</title>
    <url>/2020/04/01/Mybatis%20%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90%EF%BC%882%EF%BC%89%20-%20%20%E7%AE%80%E5%8D%95Demo/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1.环境配置"></a>1.环境配置</h1><p>目的：使用Mybatis 去查询数据库的表，并且打印出来</p>
<p>IDEA：IDEA 2019.2.3</p>
<p>MySql：Mysql 5.7.22</p>
<p>MyBatis：MyBatis 3.4.5</p>
<p>Maven：Maven 3.5.2</p>
<h1 id="2-使用Mybatis查询数据库内容"><a href="#2-使用Mybatis查询数据库内容" class="headerlink" title="2.使用Mybatis查询数据库内容"></a>2.使用Mybatis查询数据库内容</h1><h2 id="2-1-New-一个新的Project，Maven项目："><a href="#2-1-New-一个新的Project，Maven项目：" class="headerlink" title="2.1 New 一个新的Project，Maven项目："></a>2.1 New 一个新的Project，Maven项目：</h2><p><img src="https://i.loli.net/2020/04/01/hcSMWl7FdIkVAr4.png" alt="image.png"></p>
<p>接着进行Project 的信息填写如下：</p>
<p><img src="https://i.loli.net/2020/04/01/ATzZGfEcrIjKp5x.png" alt="image.png"></p>
<p>新创建之后的Project如下：</p>
<p><img src="https://i.loli.net/2020/04/01/Rq2hcEUbnyJjx5m.png" alt="image.png"></p>
<h2 id="2-2-进行一些准备工作"><a href="#2-2-进行一些准备工作" class="headerlink" title="2.2 进行一些准备工作"></a>2.2 进行一些准备工作</h2><h3 id="2-2-1-填充Mysql数据："><a href="#2-2-1-填充Mysql数据：" class="headerlink" title="2.2.1 填充Mysql数据："></a>2.2.1 填充Mysql数据：</h3><p>进行如下数据的填充，方面接下来的Demo的一些操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE mybatis_demo;</span><br><span class="line">use mybatis_demo;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE USER(</span><br><span class="line">	ID INT(20) not null PRIMARY KEY,</span><br><span class="line">	NAME VARCHAR(30) DEFAULT NULL,</span><br><span class="line">	PWD VARCHAR(30) DEFAULT NULL</span><br><span class="line">)ENGINE&#x3D;INNODB, CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO USER (ID, NAME, PWD) VALUES (1,&#39;cici&#39;,123),(2,&#39;pipi&#39;,456),(3,&#39;gigi&#39;,789);</span><br></pre></td></tr></table></figure>

<p>可以看到数据库已经有如下数据了：</p>
<p><img src="https://i.loli.net/2020/04/01/Dgi7x1dmFUu8zQV.png" alt="image.png"></p>
<h3 id="2-2-2-调整一些Project目录"><a href="#2-2-2-调整一些Project目录" class="headerlink" title="2.2.2 调整一些Project目录"></a>2.2.2 调整一些Project目录</h3><p>首先删除src，然后创建新的子模块，因为我们会在这个项目里建立多个子项目，这样可以节省创建新项目的时间。</p>
<p><img src="https://i.loli.net/2020/04/01/lT78fDtNyJVSWYL.png" alt="image.png"></p>
<p>创建新的子模块如下：</p>
<p><img src="https://i.loli.net/2020/04/01/YZmC1HD6sjoKF8W.png" alt="image.png"></p>
<p>创建完成如下：</p>
<p><img src="https://i.loli.net/2020/04/01/lFzIarxZVQWRc3s.png" alt="image.png"></p>
<h3 id="2-2-3-配置Pom-xml"><a href="#2-2-3-配置Pom-xml" class="headerlink" title="2.2.3 配置Pom.xml"></a>2.2.3 配置Pom.xml</h3><p>进行Pom.xml 的配置，主要就是一些dependecy的填充。</p>
<ol>
<li>mybatis的dependency可以在官网中找到<ul>
<li><img src="https://i.loli.net/2020/04/01/NGRMBp5n4O87SDT.png" alt="image.png"></li>
</ul>
</li>
<li>junit 是单元测试</li>
<li>mysql 的依赖一样需要添加</li>
<li>log4j 是日志，添加上。</li>
</ol>
<p>pom.xml 详细配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 父工程 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis_demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.garmen<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis_demo01<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>同时将log4j 的配置文件添加到src下面，如下所示：</p>
<p><img src="https://i.loli.net/2020/04/01/5w4Ue2HoJCPpNrf.png" alt="image.png"></p>
<p>lo4j 内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Set root category priority to INFO and its only appender to CONSOLE.</span><br><span class="line">#log4j.rootCategory&#x3D;INFO, CONSOLE            debug   info   warn error fatal</span><br><span class="line">log4j.rootCategory&#x3D;debug, CONSOLE, LOGFILE</span><br><span class="line"></span><br><span class="line"># Set the enterprise logger category to FATAL and its only appender to CONSOLE.</span><br><span class="line">log4j.logger.org.apache.axis.enterprise&#x3D;FATAL, CONSOLE</span><br><span class="line"></span><br><span class="line"># CONSOLE is set to be a ConsoleAppender using a PatternLayout.</span><br><span class="line">log4j.appender.CONSOLE&#x3D;org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.CONSOLE.layout&#x3D;org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.CONSOLE.layout.ConversionPattern&#x3D;%d&#123;ISO8601&#125; %-6r [%15.15t] %-5p %30.30c %x - %m\n</span><br><span class="line"></span><br><span class="line"># LOGFILE is set to be a File appender using a PatternLayout.</span><br><span class="line">log4j.appender.LOGFILE&#x3D;org.apache.log4j.FileAppender</span><br><span class="line">log4j.appender.LOGFILE.File&#x3D;d:\axis.log</span><br><span class="line">log4j.appender.LOGFILE.Append&#x3D;true</span><br><span class="line">log4j.appender.LOGFILE.layout&#x3D;org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.LOGFILE.layout.ConversionPattern&#x3D;%d&#123;ISO8601&#125; %-6r [%15.15t] %-5p %30.30c %x - %m\n</span><br></pre></td></tr></table></figure>



<h2 id="2-3-配置-Mybatis-核心配置文件"><a href="#2-3-配置-Mybatis-核心配置文件" class="headerlink" title="2.3 配置 Mybatis 核心配置文件"></a>2.3 配置 Mybatis 核心配置文件</h2><p>我们使用官网提供的方法，官网中说明有两种方式可以构建 SqlSessionFactory，一种是使用XML，一种是不使用XML，<strong>这个Demo暂定选择使用XML来进行构建SqlSessionFactory</strong>。</p>
<p>官网所给建议截图如下：</p>
<p><img src="https://i.loli.net/2020/04/01/HOkQoJGInL41vE6.png" alt="image.png"></p>
<p>于是我们创建并编写 SqlMapConfig.xml 配置文件。</p>
<ul>
<li>注意：这个XML 配置文件，包含了对 MyBatis 系统的核心设置，包括获取数据库连接实例的数据源（DataSource）以及决定事务作用域和控制方式的事务管理器 （TransactionManager）。</li>
<li>其实主要的就是你机子里面的数据库信息，就是配置环境。</li>
</ul>
<p>需要注意的是，这个头部是通用的，我们可以先保存下来：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span>  </span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span>  </span></span><br><span class="line"><span class="meta">  <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>进行扩充之后如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">&lt;!-- mybaits的主配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置环境 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置Mysql的环境 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--  配置事物的类型 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 配置数据源（连接池） --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 配置连接数据库的4个基本信息 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/mybatis_demo"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>截图如下所示：</p>
<p><img src="https://i.loli.net/2020/04/01/LIOaz32UtsfQjbd.png" alt="image.png"></p>
<h2 id="2-4-编写实体类"><a href="#2-4-编写实体类" class="headerlink" title="2.4 编写实体类"></a><strong>2.4 编写实体类</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.garmen.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ID;</span><br><span class="line">    <span class="keyword">private</span> String NAME;</span><br><span class="line">    <span class="keyword">private</span> String PWD;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> ID, String NAME, String PWD)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ID = ID;</span><br><span class="line">        <span class="keyword">this</span>.NAME = NAME;</span><br><span class="line">        <span class="keyword">this</span>.PWD = PWD;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 隐藏geter、seter、toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="2-5-编写持久层相关"><a href="#2-5-编写持久层相关" class="headerlink" title="2.5 编写持久层相关"></a><strong>2.5 编写持久层相关</strong></h2><p>其实这一步就是创建持久层Dao接口并且创建其映射文件，并在总的配置文件中进行绑定即可。</p>
<ul>
<li>此处有需要注意的一点就是：持久层接口 必须要和 持久层接口的映射文件的名称保持一致，下面便是一个很好的示范！</li>
</ul>
<h3 id="2-5-1-编写持久层接口-UserDao"><a href="#2-5-1-编写持久层接口-UserDao" class="headerlink" title="2.5.1 编写持久层接口 UserDao"></a><strong>2.5.1 编写持久层接口 UserDao</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-5-2-编程持久层接口的映射文件-UserDao-xml"><a href="#2-5-2-编程持久层接口的映射文件-UserDao-xml" class="headerlink" title="2.5.2 编程持久层接口的映射文件 UserDao.xml"></a><strong>2.5.2 编程持久层接口的映射文件 UserDao.xml</strong></h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.garmen.dao.UserDao"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置查询所有 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultType</span>=<span class="string">"com.garmen.domain.User"</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>需要注意的如下：</p>
<ol>
<li>namespace的路径需要绑定到对应的接口</li>
<li>select标签代表的就是查询语句</li>
<li>select中的id需要和接口中的方法名称相同！！！</li>
<li>resultType代表着返回结果类型，我们要获取所有的User，所以此处为garmen包中的User类。</li>
<li>resultType 需要指定，这个标签不可以不写，不然会报错。</li>
<li>select标签中，填写我们相应的语句。</li>
</ol>
<p>此时目录概括如下：</p>
<p><img src="https://i.loli.net/2020/04/01/LnhbTOKlB2FCmso.png" alt="目录概括.png"></p>
<h3 id="2-5-3-进行接口的绑定"><a href="#2-5-3-进行接口的绑定" class="headerlink" title="2.5.3 进行接口的绑定"></a><strong>2.5.3 进行接口的绑定</strong></h3><p>有一个问题就是，我们刚刚配置完的UserDao.xml添加到哪里呢？</p>
<ul>
<li>添加到SqlMapConfig.xml中，告诉它有这个UserDao.xml 东西！</li>
</ul>
<p>即在SqlMapConfig.xml，进行添加mappers映射，和上面已经填写完成之后的SqlMapConfig.xml 文件进行扩充之后如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- mybaits的主配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置环境 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置Mysql的环境 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--  配置事物的类型 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 配置数据源（连接池） --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 配置连接数据库的4个基本信息 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/mybatis_demo"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"com/garmen/dao/UserDao.xml"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="2-6-创建测试文件"><a href="#2-6-创建测试文件" class="headerlink" title="2.6 创建测试文件"></a>2.6 创建测试文件</h2><p>根据官网提供给的工具，我们可以进行代码的编写了</p>
<p>其实官网提供的也就是：从XML中构建了 SqlSessionFactory</p>
<p><img src="https://i.loli.net/2020/04/01/NHB5j29XtcOirPY.png" alt="image.png"></p>
<p>然后从已经构建了的 SqlSessionFactory 中获取 SqlSession 的实例。SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。</p>
<p><img src="https://i.loli.net/2020/04/01/SvPAdH63NkQLjME.png" alt="image.png"></p>
<p>在Test目录下创建测试文件，并进行代码填写：</p>
<p><img src="https://i.loli.net/2020/04/01/oXKZYSgDGItnsHd.png" alt="image.png"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1、读取配置文件</span></span><br><span class="line">        InputStream in = Resources.getResourceAsStream(<span class="string">"SqlMapConfig.xml"</span>);</span><br><span class="line">        <span class="comment">//2、创建SqlSessionFactory工厂</span></span><br><span class="line">        SqlSessionFactoryBuilder builder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">        SqlSessionFactory factory = builder.build(in);</span><br><span class="line">        <span class="comment">//3、使用工厂生产SqlSeesion对象</span></span><br><span class="line">        SqlSession session = factory.openSession();</span><br><span class="line">        <span class="comment">//4、使用SqlSession创建Dao接口的代理对象</span></span><br><span class="line">        UserDao userDao = session.getMapper(UserDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//5、使用代理对象执行方法</span></span><br><span class="line">        List&lt;User&gt; users = userDao.findAll();</span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6、释放资源</span></span><br><span class="line">        session.close();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>对于上面的几个看起来怪怪的东西，其实官网都已经给出了解释：</p>
<p><strong>SqlSessionFactoryBuilder</strong>：这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。 你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但最好还是不要一直保留着它，以保证所有的 XML 解析资源可以被释放给更重要的事情。</p>
<p><strong>SqlSessionFactory</strong>：SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏习惯”。因此 SqlSessionFactory 的最佳作用域是应用作用域。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</p>
<p><strong>SqlSession</strong>：每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。 如果你现在正在使用一种 Web 框架，考虑将 SqlSession 放在一个和 HTTP 请求相似的作用域中。 换句话说，每次收到 HTTP 请求，就可以打开一个 SqlSession，返回一个响应后，就关闭它。 这个关闭操作很重要，为了确保每次都能执行关闭操作，你应该把这个关闭操作放到 finally 块中。 下面的示例就是一个确保 SqlSession 关闭的标准模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  <span class="comment">// 你的应用逻辑代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有上面的那个mapper 其实是映射器的原理，这是一个映射器示例，关于映射器是什么意思？官网也很会，他给出的解释如下：</p>
<p><u>映射器是一些绑定映射语句的接口</u>。映射器接口的实例是从 SqlSession 中获得的。虽然从技术层面上来讲，任何映射器实例的最大作用域与请求它们的 SqlSession 相同。但方法作用域才是映射器实例的最合适的作用域。 也就是说，映射器实例应该在调用它们的方法中被获取，使用完毕之后即可丢弃。 映射器实例并不需要被显式地关闭。尽管在整个请求作用域保留映射器实例不会有什么问题，但是你很快会发现，在这个作用域上管理太多像 SqlSession 的资源会让你忙不过来。 因此，最好将映射器放在方法作用域内。就像下面的例子一样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  BlogMapper mapper = session.getMapper(BlogMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  <span class="comment">// 你的应用逻辑代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这些东西当然在后面我会进行深入解释一下的。</p>
<h2 id="2-7-结果显示如下"><a href="#2-7-结果显示如下" class="headerlink" title="2.7 结果显示如下"></a>2.7 结果显示如下</h2><p>Test 所获得的结果如下所示：</p>
<p><img src="https://i.loli.net/2020/04/01/DjIO3RpSJv2zWqi.png" alt="image.png"></p>
<h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h1><p>只要遵循上面的这个做法，程序是可以跑起来并且去查询到我们数据库相关的信息的，这只是一个小Demo，主要是我们可以了解到了Mybatis 原来作用是这样，让Mybatis工作的方式还有很多种，这只是其中一种，关于Demo的展示我应该写得更加细致一点，因为这样比较方便我们进行重新观看的时候一头雾水：我写的究竟是什么东西？？？当然上面也了解到了一些零碎的知识，不理解的东西还有很多，需要接下来一点点展开深入了解一下其内部的机制流程，在接下来的几章会详细展开。</p>
<p>关于这个Demo相关的内容已上传Github：<a href="https://github.com/dongxiem/Mybatis-Study" target="_blank" rel="noopener">https://github.com/dongxiem/Mybatis-Study</a></p>
]]></content>
  </entry>
  <entry>
    <title>Mybatis 框架分析（1） -  总体分析</title>
    <url>/2020/04/01/Mybatis%20%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90%EF%BC%881%EF%BC%89%20-%20%20%E6%80%BB%E4%BD%93%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-MyBatis-认识与了解"><a href="#1-MyBatis-认识与了解" class="headerlink" title="1. MyBatis 认识与了解"></a>1. MyBatis 认识与了解</h1><h2 id="1-1-Jdbc的一些认识"><a href="#1-1-Jdbc的一些认识" class="headerlink" title="1.1 Jdbc的一些认识"></a>1.1 Jdbc的一些认识</h2><p>通过 JDBC 来操作数据库，需要以下几个<code>步骤</code>：</p>
<ol>
<li>加载数据库驱动</li>
<li>创建并获取数据库链接</li>
<li>创建 jdbc statement 对象</li>
<li>编写 sql 语句</li>
<li>设置 sql 语句中的参数(使用 <code>preparedStatement</code>)</li>
<li>通过 statement 执行 sql 并获取结果</li>
<li>对 sql 执行结果进行解析处理</li>
<li>释放资源(<code>resultSet</code>、<code>preparedstatement</code>、<code>connection</code>)</li>
</ol>
<p>给出使用JDBC的Demo如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>为了解决这么麻烦的一系列步骤，有人就提出来了MyBatis这个框架了！</p>
<h2 id="1-2-MyBatis的大概介绍及其特点"><a href="#1-2-MyBatis的大概介绍及其特点" class="headerlink" title="1.2 MyBatis的大概介绍及其特点"></a>1.2 MyBatis的大概介绍及其特点</h2><p>Mybatis 是 JAVA 的一个<code>持久层框架</code>，什么是持久层？持久层就是能够长期保存数据的一层，例如我们的数据写在硬盘上，这说明我们的数据是持久的，如果写在内存当中，我们的数据就是不持久的。</p>
<p>根据官方文档的介绍，MyBatis大概如下：</p>
<ul>
<li>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</li>
</ul>
<p>百度百科总结的挺好，详细讲述了MyBatis的特点，如下：</p>
<ul>
<li>简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个 jar 文件+配置几个 sql 映射文件易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。</li>
<li>灵活：mybatis 不会对应用程序或者数据库的现有设计强加任何影响。sql 写在 xml 里，便于统一管理和优化。通过 sql 语句可以满足操作数据库的所有需求。</li>
<li>解除 sql 与程序代码的耦合：通过提供 DAO 层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql 和代码的分离，提高了可维护性。</li>
<li>提供映射标签，支持对象与数据库的 orm 字段关系映射</li>
<li>提供对象关系映射标签，支持对象关系组建维护</li>
<li>提供 xml 标签，支持编写动态 sql。</li>
</ul>
<h1 id="2-Mybatis-总体框架"><a href="#2-Mybatis-总体框架" class="headerlink" title="2.Mybatis 总体框架"></a>2.Mybatis 总体框架</h1><p>MyBatis的总体框架大体如下：</p>
<p><img src="https://i.loli.net/2020/04/01/duibL3NkmMJGc27.png" alt="MyBatis的总体框架.png"></p>
<p>对于Mybatis 框架的整体学习，我主要进行深入了解的是以下几个方面：</p>
<ul>
<li>缓存原理</li>
<li>映射文件的解析过程</li>
<li>配置文件的解析过程</li>
<li>SQL 的执行过程</li>
</ul>
<p>3.</p>
]]></content>
  </entry>
  <entry>
    <title>Java 并发 - 多线程 线程创建的几种方式</title>
    <url>/2020/04/01/Java%20%E5%B9%B6%E5%8F%91%20-%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li><p>categories: “Java并发”<br>tags:   </p>
<ul>
<li>Java</li>
<li>并发</li>
<li>多线程</li>
</ul>
</li>
</ul>
<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>总的来说有两种实现线程的方式：</p>
<ol>
<li><strong>实现Runnable接口</strong></li>
<li><strong>继承Thread类</strong></li>
</ol>
<h1 id="2-几种实现方式详解"><a href="#2-几种实现方式详解" class="headerlink" title="2.几种实现方式详解"></a>2.几种实现方式详解</h1><h2 id="2-1-继承Thread类"><a href="#2-1-继承Thread类" class="headerlink" title="2.1 继承Thread类"></a>2.1 继承Thread类</h2><p>实现：</p>
<ol>
<li>需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。</li>
<li>当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。</li>
</ol>
<p>Demo如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.printl(<span class="string">"MyThread"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Thread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>关于start()方法需要注意的有两点：</p>
<ol>
<li>我们在程序里面调用了start()方法后，虚拟机会先为我们创建一个线程，然后等到这个线程第一次得到时间片时再调用run()方法。</li>
<li>注意不可多次调用start()方法。在第一次调用start()方法后，再次调用start()方法会抛出异常。</li>
</ol>
<p>此处我有两个疑惑，根据平时的积累之后给出了答案，问题如下：</p>
<ol>
<li><strong>start()方法和run()方法的区别？</strong><ul>
<li>只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。</li>
</ul>
</li>
<li><strong>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</strong><ul>
<li>new 一个 Thread，线程进入了新建状态；调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</li>
<li>总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</li>
</ul>
</li>
</ol>
<h2 id="2-2-实现Runnable接口"><a href="#2-2-实现Runnable接口" class="headerlink" title="2.2 实现Runnable接口"></a>2.2 实现Runnable接口</h2><p>实现：</p>
<ul>
<li>需要实现接口中的 run() 方法。</li>
<li>使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 start() 方法来启动线程。</li>
</ul>
<p><code>Runnable</code>是一个函数式接口，这意味着我们可以使用<strong>Java 8的函数式编程</strong>来简化代码。</p>
<p>函数式编程是个什么东西？</p>
<ul>
<li>这是在Java 8 之后才有的，它的声明是通过一个注解来实现的，可以查看Runnable 的接口实现便可知道</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Demo如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"MyThread"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Java 8 之后的函数式编程如下</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            Ststem.out.println(<span class="string">"Java 8 匿名内部类"</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-3-实现-Callable接口"><a href="#2-3-实现-Callable接口" class="headerlink" title="2.3 实现 Callable接口"></a>2.3 实现 Callable接口</h2><h3 id="2-3-1-Callable接口"><a href="#2-3-1-Callable接口" class="headerlink" title="2.3.1 Callable接口"></a>2.3.1 Callable接口</h3><p>实现：</p>
<ol>
<li>其实也算是实现Runnable接口！</li>
<li>与 Runnable 相比，<strong>Callable 可以有返回值</strong>，返回值通过 <strong>FutureTask</strong> 进行封装。</li>
</ol>
<h3 id="2-3-2-Future接口"><a href="#2-3-2-Future接口" class="headerlink" title="2.3.2 Future接口"></a>2.3.2 Future接口</h3><h3 id="2-3-3-Future-Task类"><a href="#2-3-3-Future-Task类" class="headerlink" title="2.3.3 Future Task类"></a>2.3.3 Future Task类</h3><h4 id="2-3-3-1-什么是FutureTask？"><a href="#2-3-3-1-什么是FutureTask？" class="headerlink" title="2.3.3.1 什么是FutureTask？"></a>2.3.3.1 什么是FutureTask？</h4><h4 id="2-3-3-2-FutureTask如何使用？"><a href="#2-3-3-2-FutureTask如何使用？" class="headerlink" title="2.3.3.2 FutureTask如何使用？"></a>2.3.3.2 FutureTask如何使用？</h4><h4 id="2-3-3-3-FutureTask的实现"><a href="#2-3-3-3-FutureTask的实现" class="headerlink" title="2.3.3.3 FutureTask的实现"></a>2.3.3.3 FutureTask的实现</h4><h4 id="2-3-3-4-FutureTask的几个状态"><a href="#2-3-3-4-FutureTask的几个状态" class="headerlink" title="2.3.3.4 FutureTask的几个状态"></a>2.3.3.4 FutureTask的几个状态</h4><h1 id="3-比较"><a href="#3-比较" class="headerlink" title="3. 比较"></a>3. 比较</h1><h2 id="3-1-实现接口-VS-继承-Thread"><a href="#3-1-实现接口-VS-继承-Thread" class="headerlink" title="3.1 实现接口 VS 继承 Thread"></a>3.1 <strong>实现接口 VS 继承 Thread</strong></h2><p>我理解的实现接口会更好一些，因为：</p>
<ol>
<li>Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；</li>
<li>类可能只要求可执行就行，继承整个 Thread 类开销过大，如果使用线程时不需要使用Thread类的诸多方法，显然使用<code>Runnable</code> 接口更为轻量。</li>
<li><code>Runnable</code> 接口出现更符合面向对象，将线程单独进行对象的封装。</li>
<li><code>Runnable</code> 接口出现，降低了线程对象和线程任务的耦合性。</li>
</ol>
<p>所以总的来说，还是优先使用实现<code>Runnable</code> 接口方式进行线程的实现较为友好。</p>
<h2 id="3-2-Runnable接口和Callable接口的区别？"><a href="#3-2-Runnable接口和Callable接口的区别？" class="headerlink" title="3.2 Runnable接口和Callable接口的区别？"></a>3.2 <strong>Runnable接口和Callable接口的区别？</strong></h2><p>Runnable自Java 1.0以来一直存在，但Callable仅在Java 1.5中引入,目的就是为了来处理Runnable不支持的用例。Runnable 接口不会返回结果或抛出检查异常，但是Callable 接口可以。所以，如果任务不需要返回结果或抛出异常推荐使用 Runnable 接口，这样代码看起来会更加简洁。</p>
<p>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 被线程执行，没有返回值也无法抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Callable接口中的<strong>call()方法是有返回值的，是一个泛型</strong>，和Future、FutureTask配合可以用来获取异步执行的结果。</p>
<p>这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为<strong>多线程充满着未知性</strong>，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 计算结果，或者在无法这样做的时候抛出异常</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 计算得出的结果</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> 如果无法计算结果，则抛出异常</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>注意：</p>
<ul>
<li><strong>工具类 Executors 可以实现 Runnable 对象和 Callable 对象之间的相互转换</strong>。（<code>Executors.callable（Runnable task）</code>或 <code>Executors.callable（Runnable task，Object resule）</code>）。</li>
</ul>
<h2 id="3-3-Futuretask和callable的区别？"><a href="#3-3-Futuretask和callable的区别？" class="headerlink" title="3.3 Futuretask和callable的区别？"></a>3.3 <strong>Futuretask和callable的区别？</strong></h2>]]></content>
  </entry>
  <entry>
    <title>Java 并发 - 关于指令重排序的几个疑问</title>
    <url>/2020/03/31/Java%20%E5%B9%B6%E5%8F%91%20-%20%E5%85%B3%E4%BA%8E%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F%E7%9A%84%E5%87%A0%E4%B8%AA%E7%96%91%E9%97%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-指令重排序"><a href="#1-指令重排序" class="headerlink" title="1.指令重排序"></a>1.指令重排序</h1><p>计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排。</p>
<p>指令重排一般分为以下三种：</p>
<ol>
<li>编译器优化重排：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序</li>
<li>指令并行重排：现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性(即后一个执行的语句无需依赖前面执行的语句的结果)，处理器可以改变语句对应的机器指令的执行顺序。</li>
<li>内存系统重排： 由于处理器使用缓存和读写缓存冲区，这使得加载(load)和存储(store)操作看上去可能是在乱序执行，因为三级缓存的存在，导致内存与缓存的数据同步存在时间差。</li>
</ol>
<h1 id="2-关于指令重排序的几个问题"><a href="#2-关于指令重排序的几个问题" class="headerlink" title="2.关于指令重排序的几个问题"></a>2.关于指令重排序的几个问题</h1><h2 id="2-1为什么指令重排序可以提高性能？"><a href="#2-1为什么指令重排序可以提高性能？" class="headerlink" title="2.1为什么指令重排序可以提高性能？"></a>2.1为什么指令重排序可以提高性能？</h2><p>简单地说，每一个指令都会包含多个步骤，每个步骤可能使用不同的硬件。因此，流水线技术产生了，它的原理是指令1还没有执行完，就可以开始执行指令2，而不用等到指令1执行结束之后再执行指令2，这样就大大提高了效率。</p>
<ul>
<li><p>举个例子：</p>
<ul>
<li><pre><code class="java">a = b + c;
d = e - f;    </code></pre>
</li>
</ul>
</li>
<li><p>先加载b、c（注意，即有可能先加载b，也有可能先加载c），但是在执行add(b,c)的时候，需要等待b、c装载结束才能继续执行，也就是增加了停顿，那么后面的指令也会依次有停顿,这降低了计算机的执行效率。</p>
</li>
<li><p>为了减少这个停顿，我们可以先加载e和f，然后再去加载add(b,c)，这样做对程序（串行）是没有影响的，但却减少了停顿。既然add(b,c)需要停顿，那还不如去做些有意义的事情。</p>
</li>
</ul>
<p>综上所述，指令重排对于提高CPU处理性能十分必要。虽然由此带来了乱序的问题，但是这点牺牲是值得的。</p>
<h2 id="2-2-那么为什么指令重排会出现问题呢？"><a href="#2-2-那么为什么指令重排会出现问题呢？" class="headerlink" title="2.2 那么为什么指令重排会出现问题呢？"></a>2.2 <strong>那么为什么指令重排会出现问题呢？</strong></h2><p>指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致。所以在多线程下，指令重排序可能会导致一些问题。</p>
<h1 id="3-指令重排序的解决方法"><a href="#3-指令重排序的解决方法" class="headerlink" title="3.指令重排序的解决方法"></a>3.指令重排序的解决方法</h1><p>所以，由此引出了<code>Volatile</code>，在一个知识体系中，进行知识的串联是尤为重要的，这就是有些东西的存在必定存在其相对的意义，知其然，知其所以然，才能更好的进行运用。对于Volatile相关的知识，查看后面的内容。</p>
<hr>
<p>以上引用的博客和文章：</p>
<ol>
<li>书籍：并发编程的艺术</li>
<li>书籍：深入浅出Java多线程</li>
</ol>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - Synchronized 与其他一些锁机制的对比</title>
    <url>/2020/03/31/Java%20%E5%B9%B6%E5%8F%91%20-%20Synchronized%20%E4%B8%8E%E5%85%B6%E4%BB%96%E4%B8%80%E4%BA%9B%E9%94%81%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>我们前面已经 Synchronized 在JDK1.6 进行哪一些方面的优化，通过这些底层的优化之后Synchronized  变得好用了很多，那么它究竟和其他锁机制有什么差别？换种方式说，我在进行编程的过程中，究竟要如何进行选择？什么时候应该选择Synchronized？而什么时候不选用Synchronized而选用其他的锁机制。</p>
<p>总感觉学习了Synchronized之后，对于其内部原理熟悉了，不知道有没有其他人跟我一样困惑，我究竟该何时进行使用它呢？在哪个场景下我该第一时间想到这货？我觉得进行选择还应该先进行对比，将和我们之前学习到的一些同步机制进行联系起来，有对比才有总结，尽量多进行比较，多点思考，才有更深入的理解与认识。</p>
<h1 id="2-区别分析"><a href="#2-区别分析" class="headerlink" title="2.区别分析"></a>2.区别分析</h1><h2 id="2-1-Synchronized-和-Reentrantlock（可重入锁）的联系与区别："><a href="#2-1-Synchronized-和-Reentrantlock（可重入锁）的联系与区别：" class="headerlink" title="2.1 Synchronized 和 Reentrantlock（可重入锁）的联系与区别："></a>2.1 Synchronized 和 Reentrantlock（可重入锁）的联系与区别：</h2><ul>
<li><p><strong>总体而言</strong>：Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。</p>
<ul>
<li>注意：ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。</li>
</ul>
</li>
<li><p><strong>联系</strong>：</p>
<ul>
<li><strong>两者都是可重入锁</strong><ul>
<li>“可重入锁”  概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>区别</strong>：</p>
<ul>
<li><strong>锁的实现：</strong>synchronized 依赖于 JVM ，而 ReentrantLock 依赖于 API。<ul>
<li>synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</li>
</ul>
</li>
<li><strong>性能：</strong>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。 性能已不是选择标准。</li>
<li><strong>ReentrantLock 比 synchronized 增加了一些高级功能：</strong><ol>
<li><strong>等待可中断：</strong>ReentrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li>
<li><strong>公平锁：</strong>ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。 ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的ReentrantLock(boolean fair)构造方法来制定是否是公平的。</li>
<li><strong>锁绑定多个条件：</strong>synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知”，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>使用选择</strong>：<u>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized</u>。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p>
</li>
</ul>
<h2 id="2-2-Synchronized-和-lock-的联系与区别："><a href="#2-2-Synchronized-和-lock-的联系与区别：" class="headerlink" title="2.2 Synchronized 和 lock 的联系与区别："></a>2.2 Synchronized 和 lock 的联系与区别：</h2><ul>
<li><strong>总的来说：</strong>Synchronized是 Java 内置关键字在 Jvm 层面，Lock是个 Java 类。Lock有比 Synchronized 更精确的线程语义和更好的性能。Lock的锁定是通过代码实现的，而Synchronized是在 JVM 层面上实现的。</li>
<li><strong>区别</strong>：<ul>
<li>是否可以获得锁状态：<ul>
<li>synchronized无法判断是否获取锁的状态；</li>
<li>Lock可以判断是否获取到锁，并且可以主动尝试去获取锁。</li>
</ul>
</li>
<li>是否自动释放锁：<ul>
<li>synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)；</li>
<li>Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁。</li>
</ul>
</li>
<li>是否阻塞：<ul>
<li>用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去；</li>
<li>而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了。它的tryLock方法可以非阻塞方式去拿锁。</li>
</ul>
</li>
<li>范围：<ul>
<li>Lock锁的范围有局限性，块范围；</li>
<li>而synchronized可以锁住块、对象、类。</li>
</ul>
</li>
</ul>
</li>
<li><strong>区别小结：</strong>synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）</li>
<li><strong>适用场景：</strong><u>Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题</u>。</li>
</ul>
<h2 id="2-3-Synchronized-和-CAS-联系与区别？"><a href="#2-3-Synchronized-和-CAS-联系与区别？" class="headerlink" title="2.3 Synchronized 和 CAS 联系与区别？"></a>2.3 <strong>Synchronized 和 CAS 联系与区别？</strong></h2><ul>
<li><strong>总括：</strong><u>简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）。</u></li>
<li><strong>使用场景选择</strong>：<ul>
<li>对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</li>
<li>对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</li>
</ul>
</li>
<li><strong>补充</strong>： Java并发编程这个领域中synchronized关键字一直都是元老级的角色，很久之前很多人都会称它为 “重量级锁” 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 偏向锁 和 轻量级锁 以及其它各种优化之后变得在某些情况下并不是那么重了。synchronized的底层实现主要依靠 Lock-Free 的队列，基本思路是 自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。</li>
</ul>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - Synchronized 几种使用方式</title>
    <url>/2020/03/31/Java%20%E5%B9%B6%E5%8F%91%20-%20Synchronized%20%E5%87%A0%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-概括"><a href="#1-概括" class="headerlink" title="1.概括"></a>1.概括</h1><p>Synchronized 可以有几种修饰方法，总体使用如下图所示：</p>
<p><img src="https://i.loli.net/2020/03/31/HiZIwJm32rGoFPv.png" alt="image.png"></p>
<h1 id="2-具体使用"><a href="#2-具体使用" class="headerlink" title="2.具体使用"></a>2.具体使用</h1><h2 id="2-1-修饰代码块"><a href="#2-1-修饰代码块" class="headerlink" title="2.1 修饰代码块"></a>2.1 <strong>修饰代码块</strong></h2><p>指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</p>
<ul>
<li>注意：<u>它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步</u>。和 synchronized 方法一样，synchronized(this)代码块也是锁定当前对象的。synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。这里再提一下：synchronized关键字加到非 static 静态方法上是给对象实例上锁。另外需要注意的是：尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓冲功能！</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="2-2-修饰实例方法"><a href="#2-2-修饰实例方法" class="headerlink" title="2.2 修饰实例方法"></a>2.2 <strong>修饰实例方法</strong></h2><ul>
<li>作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁。</li>
<li>注意：它和同步代码块一样，作用于同一个对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-3-同步一个类"><a href="#2-3-同步一个类" class="headerlink" title="2.3 同步一个类"></a>2.3 <strong>同步一个类</strong></h2><ul>
<li>注意：作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SynchronizedExample<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-4-修饰静态方法"><a href="#2-4-修饰静态方法" class="headerlink" title="2.4 修饰静态方法"></a>2.4 <strong>修饰静态方法</strong></h2><p>作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁 。</p>
<ul>
<li>注意：作用于整个类。也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份，所以对该类的所有对象都加了锁）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> synchronzied <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Synchronized 修饰静态方法相当于如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 修饰静态方法</span></span><br><span class="line">    <span class="keyword">synchronized</span>(X<span class="class">.<span class="keyword">class</span>) <span class="title">static</span> <span class="title">void</span> <span class="title">bar</span>()</span>&#123;</span><br><span class="line">        <span class="comment">// 临界区</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - Synchronized 原理分析</title>
    <url>/2020/03/31/Java%20%E5%B9%B6%E5%8F%91%20-%20Synchronized%20%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><p>JDK1.6 之后 Synchronized  的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。</p>
<p>Java中的<code>synchronized</code> 的偏向锁、轻量级锁、重量级锁三种形式，分别对应了锁只被一个线程持有、不同线程交替持有锁、多线程竞争锁三种情况。当条件不满足时，锁会按偏向锁-&gt;轻量级锁-&gt;重量级锁 的顺序升级。JVM种的锁也是能降级的，只不过条件很苛刻，可以相当于没有了，策略是为了提高获得锁和释放锁的效率。</p>
<p>所以对Synchronized 的重点分析应该是其升级流程，以前是我觉得So easy，不就这几个状态升上去而已，不过在某天看了 <a href="https://github.com/farmerjohngit/myblog/issues/12" target="_blank" rel="noopener">死磕Synchronized底层实现</a> 之后，发现我还是太嫩了，这才是真正的深入，也许对知识的求知就该如此不断的进行深入，对于Synchronized 还是有很多值得发现的知识，以下记录了学习到的一些笔记，大概对一整个锁的升级流程有了一些认识和了解。</p>
<ul>
<li>锁升级的过程可以具体看该图，大致的流程框架图很清晰（文末已注明出处）</li>
</ul>
<p><img src="https://i.loli.net/2020/03/31/nCGAmlfKqzhjdv1.png" alt="Synchronized锁升级流程图"></p>
<h1 id="2-Synchronized-锁升级流程分析"><a href="#2-Synchronized-锁升级流程分析" class="headerlink" title="2.Synchronized 锁升级流程分析"></a>2.Synchronized 锁升级流程分析</h1><h2 id="2-1-偏向锁"><a href="#2-1-偏向锁" class="headerlink" title="2.1 偏向锁"></a>2.1 <strong>偏向锁</strong></h2><ul>
<li><p><strong>目的：</strong>引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径。但是不同是：轻量级锁在无竞争的情况下使用 <code>CAS</code> 操作去代替使用互斥量，而偏向锁在无竞争的情况下会把整个同步都消除掉。那么偏向锁是如何来减少不必要的<code>CAS</code>操作呢？我们可以查看<code>Mark work</code>的结构就明白了。只需要检查是否为偏向锁、锁标识为以及<code>ThreadID</code>即可。</p>
</li>
<li><ul>
<li>注意：Java并发编程的艺术中是这么讲的：HotSpot[1]的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。</li>
</ul>
</li>
<li><p><strong>定义：</strong>偏向锁的“偏”就是偏心的偏，它的意思是会偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步！关于偏向锁的原理可以查看《深入理解Java虚拟机：JVM高级特性与最佳实践》第二版的13章第三节锁优化。当<code>JVM</code>启用了偏向锁模式（<code>JDK6</code>以上默认开启），新创建对象的Mark Word中的<code>Thread Id</code>为0，说明此时处于可偏向但未偏向任何线程，也叫<strong>做匿名偏向状态(anonymously biased)。</strong></p>
</li>
<li><p><strong>适用场合：</strong>但是对于锁竞争比较激烈的场合，偏向锁就失效了，<strong>因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失</strong>，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。</p>
</li>
<li><p><strong>关闭偏向锁：</strong>偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用<code>JVM</code>参数来关闭延迟：<code>-XX:BiasedLockingStartupDelay</code>=0。如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过<code>JVM</code>参数关闭偏向锁：<code>-XX:-UseBiasedLocking</code>=false，那么程序默认会进入轻量级锁状态。</p>
</li>
</ul>
<h3 id="2-1-1-Mark-Work-结构"><a href="#2-1-1-Mark-Work-结构" class="headerlink" title="2.1.1 Mark Work 结构"></a>2.1.1 Mark Work 结构</h3><p>关于<code>Mark work</code>结构，可以在任何一本关于Java内存结构的书中了解到很详细了，我们主要关注的是下面的几个字段：<code>thread id</code>、lock flag、biased lock flag。</p>
<p><img src="https://i.loli.net/2020/03/31/tBr7NFPumz63acj.png" alt="image.png"></p>
<h3 id="2-1-2-对象创建"><a href="#2-1-2-对象创建" class="headerlink" title="2.1.2 对象创建"></a>2.1.2 对象创建</h3><p>当 <code>JVM</code> 启用了偏向锁模式（1.6以上默认开启），当新创建一个对象的时候，如果该对象所属的class没有关闭偏向锁模式（默认所有class的偏向模式都是是开启的），那新创建对象的<code>mark word</code>将是可偏向状态，此时mark word中的thread id（参见上文偏向状态下的<code>mark word</code>格式）为0，表示未偏向任何线程，也叫做<u>匿名偏向(anonymously biased)</u>。</p>
<h3 id="2-1-3-偏向锁加锁"><a href="#2-1-3-偏向锁加锁" class="headerlink" title="2.1.3 偏向锁加锁"></a>2.1.3 偏向锁加锁</h3><p>对于偏向锁的加锁，主要分为三种不同情况来看：</p>
<ul>
<li><code>case 1</code>：当该对象第一次被线程获得锁的时候，发现是匿名偏向状态（可偏向未锁定），则会用CAS指令，将<code>mark word</code>中的<code>thread id</code>由0改成当前线程Id。如果成功，则代表获得了偏向锁，继续执行同步块中的代码。否则，即<code>CAS</code>竞争锁失败，对象锁已经被其他线程占用，证明当前存在多线程竞争情况，当到达全局安全点（即为<code>safepoint</code>，<code>safepoint</code>是什么可以具体参考这篇文章：<a href="https://blog.csdn.net/iter_zc/article/details/41847887" target="_blank" rel="noopener">聊聊JVM（六）理解JVM的safepoint</a>），将偏向锁撤销，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块；</li>
<li><code>case 2</code>：当被偏向的线程再次进入同步块时，发现锁对象偏向的就是当前线程（对象头Mark Word中Thread Id是当前线程ID），在通过一些额外的检查后（细节见后面的文章），会往当前线程的栈中添加一条Displaced Mark Word为空的Lock Record中，用来统计重入的次数（如图为当对象所处于偏向锁时，当前线程重入3次，线程栈帧中Lock Record记录）。然后继续执行同步块的代码，因为操纵的是线程私有的栈，因此不需要用到CAS指令；由此可见偏向锁模式下，当被偏向的线程再次尝试获得锁时，仅仅进行几个简单的操作就可以了，在这种情况下，synchronized关键字带来的性能开销基本可以忽略。<ul>
<li><img src="https://i.loli.net/2020/03/31/AtEPUg6GSiOurk3.png" alt="线程栈帧"></li>
</ul>
</li>
<li>case 3.当其他线程进入同步块时，发现已经有偏向的线程了，则会进入到撤销偏向锁的逻辑里，一般来说，会在<code>safepoint</code>中去查看偏向的线程是否还存活，如果存活且还在同步块中则将锁升级为轻量级锁，原偏向的线程继续拥有锁，当前线程则走入到锁升级的逻辑里；如果偏向的线程已经不存活或者不在同步块中，则将对象头的<code>mark word</code>改为无锁状态（<code>unlocked</code>），之后再升级为轻量级锁。</li>
</ul>
<p>由此可见，偏向锁升级的时机为：当锁已经发生偏向后，只要有另一个线程尝试获得偏向锁，则该偏向锁就会升级成轻量级锁。当然这个说法不绝对，因为还有批量重偏向这一机制。</p>
<h3 id="2-1-4-偏向锁解锁"><a href="#2-1-4-偏向锁解锁" class="headerlink" title="2.1.4 偏向锁解锁"></a>2.1.4 偏向锁解锁</h3><p>当有其他线程尝试获得锁时，是根据遍历偏向线程的<code>lock record</code>来确定该线程是否还在执行同步块中的代码。因此偏向锁的解锁很简单，仅仅将栈中的最近一条<code>lock record</code>的obj字段设置为null。需要注意的是，偏向锁的解锁步骤中并不会修改对象头中的<code>thread id</code>。</p>
<h3 id="2-1-5-偏向锁获取锁"><a href="#2-1-5-偏向锁获取锁" class="headerlink" title="2.1.5 偏向锁获取锁"></a>2.1.5 偏向锁获取锁</h3><p><strong>取自Java并发编程的艺术：</strong></p>
<ol>
<li>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行<code>CAS</code>操作来加锁和解锁，只需简单地测试一下对象头的<code>Mark Word</code>里是否存储着指向当前线程的偏向锁。</li>
<li>如果测试成功，表示线程已经获得了锁。</li>
<li>如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS<code>竞争</code>锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程</li>
</ol>
<p>网上参考了很多文章，发现说辞不一，十分混乱，大部分都各持己见，这让我看得很晕乎，于是还是更相信底层代码的逻辑，查看官方提供给的 JVM 底层C++代码： <a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/interpreter/bytecodeInterpreter.cpp#l1816" target="_blank" rel="noopener">bytecodeInterpreter.cpp#1816</a>，结合 <a href="https://github.com/farmerjohngit/myblog" target="_blank" rel="noopener">farmerjohngit</a> 大佬所给的一些解释，可以对整个底层实现有更加深刻的理解。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CASE(_monitorenter): &#123;</span><br><span class="line">  <span class="comment">// lockee 就是锁对象</span></span><br><span class="line">  oop lockee = STACK_OBJECT(<span class="number">-1</span>);</span><br><span class="line">  <span class="comment">// derefing's lockee ought to provoke implicit null check</span></span><br><span class="line">  CHECK_NULL(lockee);</span><br><span class="line">  <span class="comment">// code 1：找到一个空闲的Lock Record</span></span><br><span class="line">  BasicObjectLock* limit = istate-&gt;monitor_base();</span><br><span class="line">  BasicObjectLock* most_recent = (BasicObjectLock*) istate-&gt;stack_base();</span><br><span class="line">  BasicObjectLock* entry = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">while</span> (most_recent != limit ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (most_recent-&gt;obj() == <span class="literal">NULL</span>) entry = most_recent;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (most_recent-&gt;obj() == lockee) <span class="keyword">break</span>;</span><br><span class="line">    most_recent++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//entry不为null，代表还有空闲的Lock Record</span></span><br><span class="line">  <span class="keyword">if</span> (entry != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// code 2：将Lock Record的obj指针指向锁对象</span></span><br><span class="line">    entry-&gt;set_obj(lockee);</span><br><span class="line">    <span class="keyword">int</span> success = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">uintptr_t</span> epoch_mask_in_place = (<span class="keyword">uintptr_t</span>)markOopDesc::epoch_mask_in_place;</span><br><span class="line">	<span class="comment">// markoop即对象头的mark word</span></span><br><span class="line">    markOop mark = lockee-&gt;mark();</span><br><span class="line">    <span class="keyword">intptr_t</span> hash = (<span class="keyword">intptr_t</span>) markOopDesc::no_hash;</span><br><span class="line">    <span class="comment">// code 3：如果锁对象的mark word的状态是偏向模式</span></span><br><span class="line">    <span class="keyword">if</span> (mark-&gt;has_bias_pattern()) &#123;</span><br><span class="line">      <span class="keyword">uintptr_t</span> thread_ident;</span><br><span class="line">      <span class="keyword">uintptr_t</span> anticipated_bias_locking_value;</span><br><span class="line">      thread_ident = (<span class="keyword">uintptr_t</span>)istate-&gt;thread();</span><br><span class="line">     <span class="comment">// code 4：这里有几步操作，下文分析</span></span><br><span class="line">      anticipated_bias_locking_value =</span><br><span class="line">        (((<span class="keyword">uintptr_t</span>)lockee-&gt;klass()-&gt;prototype_header() | thread_ident) ^ (<span class="keyword">uintptr_t</span>)mark) &amp;</span><br><span class="line">        ~((<span class="keyword">uintptr_t</span>) markOopDesc::age_mask_in_place);</span><br><span class="line">	 <span class="comment">// code 5：如果偏向的线程是自己且epoch等于class的epoch</span></span><br><span class="line">      <span class="keyword">if</span>  (anticipated_bias_locking_value == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// already biased towards this thread, nothing to do</span></span><br><span class="line">        <span class="keyword">if</span> (PrintBiasedLockingStatistics) &#123;</span><br><span class="line">          (* BiasedLocking::biased_lock_entry_count_addr())++;</span><br><span class="line">        &#125;</span><br><span class="line">        success = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">// code 6：如果偏向模式关闭，则尝试撤销偏向锁</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((anticipated_bias_locking_value &amp; markOopDesc::biased_lock_mask_in_place) != <span class="number">0</span>) &#123;</span><br><span class="line">        markOop header = lockee-&gt;klass()-&gt;prototype_header();</span><br><span class="line">        <span class="keyword">if</span> (hash != markOopDesc::no_hash) &#123;</span><br><span class="line">          header = header-&gt;copy_set_hash(hash);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 利用CAS操作将mark word替换为class中的mark word</span></span><br><span class="line">        <span class="keyword">if</span> (Atomic::cmpxchg_ptr(header, lockee-&gt;mark_addr(), mark) == mark) &#123;</span><br><span class="line">          <span class="keyword">if</span> (PrintBiasedLockingStatistics)</span><br><span class="line">            (*BiasedLocking::revoked_lock_entry_count_addr())++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">         <span class="comment">// code 7：如果epoch不等于class中的epoch，则尝试重偏向</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((anticipated_bias_locking_value &amp; epoch_mask_in_place) !=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 构造一个偏向当前线程的mark word</span></span><br><span class="line">        markOop new_header = (markOop) ( (<span class="keyword">intptr_t</span>) lockee-&gt;klass()-&gt;prototype_header() | thread_ident);</span><br><span class="line">        <span class="keyword">if</span> (hash != markOopDesc::no_hash) &#123;</span><br><span class="line">          new_header = new_header-&gt;copy_set_hash(hash);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// CAS替换对象头的mark word  </span></span><br><span class="line">        <span class="keyword">if</span> (Atomic::cmpxchg_ptr((<span class="keyword">void</span>*)new_header, lockee-&gt;mark_addr(), mark) == mark) &#123;</span><br><span class="line">          <span class="keyword">if</span> (PrintBiasedLockingStatistics)</span><br><span class="line">            (* BiasedLocking::rebiased_lock_entry_count_addr())++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 重偏向失败，代表存在多线程竞争，则调用monitorenter方法进行锁升级</span></span><br><span class="line">          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);</span><br><span class="line">        &#125;</span><br><span class="line">        success = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 走到这里说明当前要么偏向别的线程，要么是匿名偏向（即没有偏向任何线程）</span></span><br><span class="line">       	<span class="comment">// code 8：下面构建一个匿名偏向的mark word，尝试用CAS指令替换掉锁对象的mark word</span></span><br><span class="line">        markOop header = (markOop) ((<span class="keyword">uintptr_t</span>) mark &amp; ((<span class="keyword">uintptr_t</span>)markOopDesc::biased_lock_mask_in_place |(<span class="keyword">uintptr_t</span>)markOopDesc::age_mask_in_place |epoch_mask_in_place));</span><br><span class="line">        <span class="keyword">if</span> (hash != markOopDesc::no_hash) &#123;</span><br><span class="line">          header = header-&gt;copy_set_hash(hash);</span><br><span class="line">        &#125;</span><br><span class="line">        markOop new_header = (markOop) ((<span class="keyword">uintptr_t</span>) header | thread_ident);</span><br><span class="line">        <span class="comment">// debugging hint</span></span><br><span class="line">        DEBUG_ONLY(entry-&gt;lock()-&gt;set_displaced_header((markOop) (<span class="keyword">uintptr_t</span>) <span class="number">0xdeaddead</span>);)</span><br><span class="line">        <span class="keyword">if</span> (Atomic::cmpxchg_ptr((<span class="keyword">void</span>*)new_header, lockee-&gt;mark_addr(), header) == header) &#123;</span><br><span class="line">           <span class="comment">// CAS修改成功</span></span><br><span class="line">          <span class="keyword">if</span> (PrintBiasedLockingStatistics)</span><br><span class="line">            (* BiasedLocking::anonymously_biased_lock_entry_count_addr())++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 如果修改失败说明存在多线程竞争，所以进入monitorenter方法</span></span><br><span class="line">          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);</span><br><span class="line">        &#125;</span><br><span class="line">        success = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果偏向线程不是当前线程或没有开启偏向模式等原因都会导致success==false</span></span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">      <span class="comment">// 轻量级锁的逻辑</span></span><br><span class="line">      <span class="comment">//code 9: 构造一个无锁状态的Displaced Mark Word，并将Lock Record的lock指向它</span></span><br><span class="line">      markOop displaced = lockee-&gt;mark()-&gt;set_unlocked();</span><br><span class="line">      entry-&gt;lock()-&gt;set_displaced_header(displaced);</span><br><span class="line">      <span class="comment">//如果指定了-XX:+UseHeavyMonitors，则call_vm=true，代表禁用偏向锁和轻量级锁</span></span><br><span class="line">      <span class="keyword">bool</span> call_vm = UseHeavyMonitors;</span><br><span class="line">      <span class="comment">// 利用CAS将对象头的mark word替换为指向Lock Record的指针</span></span><br><span class="line">      <span class="keyword">if</span> (call_vm || Atomic::cmpxchg_ptr(entry, lockee-&gt;mark_addr(), displaced) != displaced) &#123;</span><br><span class="line">        <span class="comment">// 判断是不是锁重入</span></span><br><span class="line">        <span class="keyword">if</span> (!call_vm &amp;&amp; THREAD-&gt;is_lock_owned((address) displaced-&gt;clear_lock_bits())) &#123;		<span class="comment">//code 10: 如果是锁重入，则直接将Displaced Mark Word设置为null</span></span><br><span class="line">          entry-&gt;lock()-&gt;set_displaced_header(<span class="literal">NULL</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    UPDATE_PC_AND_TOS_AND_CONTINUE(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// lock record不够，重新执行</span></span><br><span class="line">    istate-&gt;set_msg(more_monitors);</span><br><span class="line">    UPDATE_PC_AND_RETURN(<span class="number">0</span>); <span class="comment">// Re-execute</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>JVM中的每个类也有一个类似mark word的prototype_header，用来标记该class的epoch和偏向开关等信息。上面的代码中<code>lockee-&gt;klass()-&gt;prototype_header()</code>即获取class的prototype_header。</p>
<p><code>code 1</code></p>
<ul>
<li>从当前线程的栈中找到一个空闲的<code>Lock Record</code>（<strong>即代码中的BasicObjectLock，下文都用Lock Record代指</strong>），判断<code>Lock Record</code>是否空闲的依据是其obj字段 是否为null。注意这里是按内存地址从低往高找到最后一个可用的<code>Lock Record</code>，换而言之，就是找到内存地址最高的可用<code>Lock Record</code>。</li>
</ul>
<p><code>code 2</code></p>
<ul>
<li>获取到<code>Lock Record</code>后，首先要做的就是为其obj字段赋值。</li>
</ul>
<p><code>code 3</code></p>
<ul>
<li>判断锁对象的<code>mark word</code>是否是偏向模式，即低3位是否为101。</li>
</ul>
<p><code>code 4</code></p>
<ul>
<li>这里有几步位运算的操作<code>anticipated_bias_locking_value = (((uintptr_t)lockee-&gt;klass()-&gt;prototype_header() | thread_ident) ^ (uintptr_t)mark) &amp;  ~((uintptr_t) markOopDesc::age_mask_in_place);</code> 这个位运算可以分为3个部分。<ul>
<li>第一部分<code>((uintptr_t)lockee-&gt;klass()-&gt;prototype_header() | thread_ident)</code> 将当前线程id和类的prototype_header相或，这样得到的值为（当前线程id + prototype_header中的（epoch + 分代年龄 + 偏向锁标志 + 锁标志位）），注意prototype_header的分代年龄那4个字节为0</li>
<li>第二部分 <code>^ (uintptr_t)mark</code> 将上面计算得到的结果与锁对象的markOop进行异或，相等的位全部被置为0，只剩下不相等的位。</li>
<li>第三部分 <code>&amp; ~((uintptr_t) markOopDesc::age_mask_in_place)</code> markOopDesc::age_mask_in_place为…0001111000,取反后，变成了…1110000111,除了分代年龄那4位，其他位全为1；将取反后的结果再与上面的结果相与，将上面异或得到的结果中分代年龄给忽略掉。</li>
</ul>
</li>
</ul>
<p><code>code 5</code></p>
<ul>
<li><code>anticipated_bias_locking_value==0</code>代表偏向的线程是当前线程且<code>mark word</code>的epoch等于class的epoch，这种情况下什么都不用做。</li>
</ul>
<p><code>code 6</code></p>
<ul>
<li><p><code>(anticipated_bias_locking_value &amp; markOopDesc::biased_lock_mask_in_place) != 0</code>代表class的prototype_header或对象的<code>mark word</code>中偏向模式是关闭的，又因为能走到这已经通过了<code>mark-&gt;has_bias_pattern()</code>判断，即对象的<code>mark word</code>中偏向模式是开启的，那也就是说class的prototype_header不是偏向模式。</p>
</li>
<li><p>然后利用<code>CAS</code>指令<code>Atomic::cmpxchg_ptr(header, lockee-&gt;mark_addr(), mark) == mark</code>撤销偏向锁，我们知道<code>CAS</code>会有几个参数，1是预期的原值，2是预期修改后的值 ，3是要修改的对象，与之对应，<code>cmpxchg_ptr</code>方法第一个参数是预期修改后的值，第2个参数是修改的对象，第3个参数是预期原值，方法返回实际原值，如果等于预期原值则说明修改成功。</p>
</li>
</ul>
<p><code>code 7</code></p>
<ul>
<li>如果epoch已过期，则需要重偏向，利用CAS指令将锁对象的<code>mark word</code>替换为一个偏向当前线程且epoch为类的epoch的新的<code>mark word</code>。</li>
</ul>
<p><code>code 8</code></p>
<ul>
<li>CAS将偏向线程改为当前线程，如果当前是匿名偏向则能修改成功，否则进入锁升级的逻辑。</li>
</ul>
<p><code>code 9</code></p>
<ul>
<li>这一步已经是轻量级锁的逻辑了。从上图的<code>mark word</code>的格式可以看到，轻量级锁中<code>mark word</code>存的是指向<code>Lock Record</code>的指针。这里构造一个无锁状态的<code>mark word</code>，然后存储到<code>Lock Record</code>（<code>Lock Record</code>的格式可以看第一篇文章）。设置<code>mark word</code>是无锁状态的原因是：轻量级锁解锁时是将对象头的<code>mark word</code>设置为<code>Lock Record</code>中的<code>Displaced Mark Word</code>，所以创建时设置为无锁状态，解锁时直接用CAS替换就好了。</li>
</ul>
<p><code>code 10</code></p>
<ul>
<li>如果是锁重入，则将<code>Lock Record</code>的<code>Displaced Mark Word</code>设置为null，起到一个锁重入计数的作用。</li>
</ul>
<p>通过这部分代码，其实可以对偏向锁加锁的流程（包括部分轻量级锁的加锁流程）有一定的认识了，如果当前锁已偏向其他线程||epoch值过期||偏向模式关闭||获取偏向锁的过程中存在并发冲突，都会进入到<code>InterpreterRuntime::monitorenter</code>方法， 在该方法中会对偏向锁撤销和升级。</p>
<h3 id="2-1-6-偏向锁释放"><a href="#2-1-6-偏向锁释放" class="headerlink" title="2.1.6 偏向锁释放"></a>2.1.6 偏向锁释放</h3><p>偏向锁的释放入口：<a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/interpreter/bytecodeInterpreter.cpp#l1923" target="_blank" rel="noopener">bytecodeInterpreter.cpp#1923</a></p>
<p>上面的代码结合注释理解起来应该不难，偏向锁的释放很简单，只要将对应Lock Record释放就好了，而轻量级锁则需要将Displaced Mark Word替换到对象头的mark word中。如果CAS失败或者是重量级锁则进入到<code>InterpreterRuntime::monitorexit</code>方法中。</p>
<ul>
<li>注意：撤销是指在获取偏向锁的过程因为不满足条件导致要将锁对象改为非偏向锁状态；释放是指退出同步块时的过程</li>
</ul>
<h3 id="2-1-7-偏向锁撤销"><a href="#2-1-7-偏向锁撤销" class="headerlink" title="2.1.7 偏向锁撤销"></a>2.1.7 偏向锁撤销</h3><p>偏向锁的撤销采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）。其步骤如下：</p>
<ol>
<li>暂停拥有偏向锁的线程，检查持有偏向锁的线程状态（遍历当前<code>JVM</code>的所有线程，如果能找到，则说明偏向的线程还存活）；<code>JVM</code>维护了一个集合存放所有存活的线程，通过遍历该集合判断某个线程是否存活。</li>
<li>如果线程还存活，则检查线程是否在执行同步代码块中的代码，如果是，则升级为轻量级锁，进行CAS竞争锁；<ul>
<li>注：每次进入同步块（即执行<code>monitorenter</code>）的时候都会以从高往低的顺序在栈中找到第一个可用的<code>Lock Record</code>，并设置偏向线程ID；每次解锁（即执行<code>monitorexit</code>）的时候都会从最低的一个<code>Lock Record</code>移除。所以如果能找到对应的Lock Record说明偏向的线程还在执行同步代码块中的代码。</li>
</ul>
</li>
<li>如果持有偏向锁的线程未存活，或者持有偏向锁的线程未在执行同步代码块中的代码，则进行校验是否允许重偏向：<ul>
<li>如果不允许重偏向，则撤销偏向锁，将<code>Mark Word</code>设置为无锁状态（未锁定不可偏向状态），然后升级为轻量级锁，进行CAS<code>竞争</code>锁；</li>
<li>如果允许重偏向，设置为匿名偏向锁状态,<code>CAS</code>将偏向锁重新指向线程A（在对象头和线程栈帧的锁记录中存储当前线程ID）；</li>
</ul>
</li>
<li>唤醒暂停的线程，从安全点继续执行代码。</li>
</ol>
<p>偏向锁撤销的具体流程如下所示：</p>
<p><img src="https://i.loli.net/2020/03/31/EUIOaiTgNluLqzw.png" alt="偏向锁撤销流程图"></p>
<p>偏向锁撤销的具体底层代码分析如下：</p>
<h3 id="2-1-8-批量重偏向与撤销"><a href="#2-1-8-批量重偏向与撤销" class="headerlink" title="2.1.8 批量重偏向与撤销"></a>2.1.8 批量重偏向与撤销</h3><p>JVM中还增加了一种批量重偏向/撤销的机制，主要是解决如下两种情况：</p>
<ol>
<li>重偏向（<code>bulk rebias</code>）机制解决的场景：一个线程创建了大量对象并执行了初始的同步操作，之后在另一个线程中将这些对象作为锁进行之后的操作。这种case下，会导致大量的偏向锁撤销操作。</li>
<li>批量撤销（<code>bulk revoke</code>）解决的场景：存在明显多线程竞争的场景下使用偏向锁是不合适的，例如生产者/消费者队列。</li>
</ol>
<h2 id="2-2-轻量级锁"><a href="#2-2-轻量级锁" class="headerlink" title="2.2 轻量级锁"></a>2.2 轻量级锁</h2><ul>
<li><strong>描述：</strong>倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)。== 轻量级锁不是为了代替重量级锁，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量。== 另外，轻量级锁的加锁和解锁都用到了CAS操作。 关于轻量级锁的加锁和解锁的原理可以查看《深入理解Java虚拟机：JVM高级特性与最佳实践》第二版的13章第三节锁优化。</li>
<li><strong>轻量级锁能够提升程序同步性能的依据：</strong>“对于绝大部分锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用 <code>CAS</code> 操作避免了使用互斥操作的开销。但如果存在锁竞争，除了互斥量开销外，还会额外发生<code>CAS</code>操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁！</li>
</ul>
<h3 id="2-2-1-轻量级锁获取锁"><a href="#2-2-1-轻量级锁获取锁" class="headerlink" title="2.2.1 轻量级锁获取锁"></a>2.2.1 轻量级锁获取锁</h3><p>其获取锁步骤如下：</p>
<ol>
<li>判断当前对象是否处于无锁状态（<code>hashcode</code>、0、01），若是，则JVM首先将在当前线程的栈帧中建立一个名为锁记录（<code>Lock Record</code>）的空间，用于存储锁对象目前的Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即<code>Displaced Mark Word</code>）；否则执行步骤（3）；</li>
<li><code>JVM</code>利用<code>CAS</code>操作尝试将对象的<code>Mark Word</code>更新为指向<code>Lock Record</code>的指正，如果成功表示竞争到锁，则将锁标志位变成00（表示此对象处于轻量级锁状态），执行同步操作；如果失败则执行步骤（3）；</li>
<li>判断当前对象的<code>Mark Word</code>是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态；</li>
</ol>
<p>栈帧 与 <code>Mark Work</code> 关系图示如下：</p>
<p><img src="https://i.loli.net/2020/03/31/pKTxoGV4clYetOL.png" alt="image.png"></p>
<p>整体流程图示如下：</p>
<p><img src="https://i.loli.net/2020/03/31/dCB5fQcuU49j3Pn.png" alt="image.png"></p>
<p>轻量级锁的锁获取源码：</p>
<h3 id="2-2-2-轻量级锁释放锁"><a href="#2-2-2-轻量级锁释放锁" class="headerlink" title="2.2.2 轻量级锁释放锁"></a>2.2.2 轻量级锁释放锁</h3><p>其释放锁步骤如下（轻量级锁的释放也是通过CAS操作来进行的）：</p>
<ol>
<li>取出在获取轻量级锁保存在<code>Displaced Mark Word</code>中的数据；</li>
<li>用<code>CAS</code>操作将取出的数据替换当前对象的<code>Mark Word</code>中，如果成功，则说明释放锁成功，否则执行（3）；</li>
<li>如果<code>CAS</code>操作替换失败，说明有其他线程尝试获取该锁，则需要在释放锁的同时需要唤醒被挂起的线程。</li>
</ol>
<p>其过程流程图如下所示：</p>
<p><img src="https://i.loli.net/2020/03/31/8WLE1HjunDXfxJO.png" alt="轻量级锁释放锁.png"></p>
<h3 id="2-2-3-轻量级锁膨胀"><a href="#2-2-3-轻量级锁膨胀" class="headerlink" title="2.2.3 轻量级锁膨胀"></a>2.2.3 轻量级锁膨胀</h3><p>其过程流程图如下所示</p>
<p><img src="https://i.loli.net/2020/03/31/QZesVDEtJqmHl9C.png" alt="轻量级锁膨胀.png"></p>
<ul>
<li><strong>一个问题：为什么在撤销轻量级锁的时候会有失败的可能？</strong><ul>
<li>假设<code>thread1</code>拥有了轻量级锁，Mark Word指向<code>thread1</code>栈帧，<code>thread2</code>请求锁的时候，就会膨胀初始化<code>ObjectMonitor</code>对象，将Mark Word更新为指向<code>ObjectMonitor</code>的指针，那么在thread1退出的时候，<code>CAS</code>操作会失败，因为Mark Word不再指向<code>thread1</code>的栈帧，这个时候<code>thread1</code>自旋等待<code>infalte</code>完毕，执行重量级锁的退出操作</li>
</ul>
</li>
</ul>
<h2 id="2-3-自旋锁和自适应自旋"><a href="#2-3-自旋锁和自适应自旋" class="headerlink" title="2.3 自旋锁和自适应自旋"></a>2.3 <strong>自旋锁和自适应自旋</strong></h2><h3 id="2-3-1-自旋锁"><a href="#2-3-1-自旋锁" class="headerlink" title="2.3.1 自旋锁"></a>2.3.1 自旋锁</h3><ul>
<li><strong>描述：</strong>一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的。 所以，虚拟机的开发团队就这样去考虑：“我们能不能让后面来的请求获取锁的线程等待一会而不被挂起呢？看看持有锁的线程是否很快就会释放锁”。为了让一个线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就叫做自旋。<ul>
<li>百度百科对自旋锁的解释：何谓自旋锁？它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。</li>
</ul>
</li>
<li><strong>使用时机：</strong>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。<ul>
<li>互斥同步对性能最大的影响就是阻塞的实现，因为挂起线程/恢复线程的操作都需要转入内核态中完成（用户态转换到内核态会耗费时间）。</li>
</ul>
</li>
<li><strong>关闭与开启：</strong>自旋锁在 <code>JDK1.6</code> 之前其实就已经引入了，不过是默认关闭的，需要通过<code>--XX:+UseSpinning</code>参数来开启。<code>JDK1.6</code>及1.6之后，就改为默认开启的了。需要注意的是：自旋等待不能完全替代阻塞，因为它还是要占用处理器时间。如果锁被占用的时间短，那么效果当然就很好了！反之，相反！自旋等待的时间必须要有限度。如果自旋超过了限定次数任然没有获得锁，就应该挂起线程。自旋次数的默认值是10次，用户可以修改-<code>-XX:PreBlockSpin</code>来更改。</li>
</ul>
<h3 id="2-3-2-自适应自旋锁："><a href="#2-3-2-自适应自旋锁：" class="headerlink" title="2.3.2 自适应自旋锁："></a>2.3.2 <strong>自适应自旋锁：</strong></h3><ul>
<li>描述：在 JDK1.6 中引入了自适应的自旋锁。自适应的自旋锁带来的改进就是：自旋的时间不再固定了，而是和前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定，虚拟机变得越来越“聪明”了。</li>
<li>实现原理：它怎么做呢？线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。 有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测会越来越准确，虚拟机会变得越来越聪明。</li>
</ul>
<h2 id="2-4-重量级锁"><a href="#2-4-重量级锁" class="headerlink" title="2.4 重量级锁"></a>2.4 重量级锁</h2><ul>
<li>描述：重量级锁通过对象内部的监视器（<code>monitor</code>）实现，其中<code>monitor</code>的本质是依赖于底层操作系统的<code>Mutex Lock</code>实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</li>
</ul>
<h1 id="3-Synchronized-的其他细节问题"><a href="#3-Synchronized-的其他细节问题" class="headerlink" title="3.Synchronized 的其他细节问题"></a>3.Synchronized 的其他细节问题</h1><h1 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h1><h2 id="4-1-总结锁的升级流程："><a href="#4-1-总结锁的升级流程：" class="headerlink" title="4.1 总结锁的升级流程："></a>4.1 总结锁的升级流程：</h2><p>每一个线程在准备获取共享资源时： </p>
<ol>
<li>第一步：检查<code>MarkWord</code>里面是不是放的自己的<code>ThreadId</code> ,如果是，表示当前线程是处于 “偏向锁” 。  </li>
<li>第二步：如果<code>MarkWord</code>不是自己的<code>ThreadId</code>，锁升级，这时候，使用<code>CAS</code>来执行切换，新的线程根据<code>MarkWord</code>里面现有的<code>ThreadId</code>，通知之前线程暂停，之前线程将<code>Markword</code>的内容置为空。</li>
<li>第三步：两个线程都把锁对象的<code>HashCode</code>复制到自己新建的用于存储锁的记录空间，接着开始通过<code>CAS</code>操作， 把锁对象的<code>MarKword</code>的内容修改为自己新建的记录空间的地址的方式竞争<code>MarkWord</code>。  </li>
<li>第四步：第三步中成功执行<code>CAS</code>的获得资源，失败的则进自旋 。</li>
<li>第五步：自旋的线程在自旋过程中，成功获得资源(即之前获的资源的线程执行完成并释放了共享资源)，则整个状态依然处于轻量级锁的状态，如果自旋失败进入第六步 。</li>
<li>第六步：进行重量级锁的状态，这个时候，自旋的线程进行阻塞，等待之前线程执行完成并唤醒自己。</li>
</ol>
<h2 id="4-2-几种锁的优缺点对比"><a href="#4-2-几种锁的优缺点对比" class="headerlink" title="4.2 几种锁的优缺点对比"></a>4.2 几种锁的优缺点对比</h2><p>下图摘自：并发编程的艺术</p>
<p><img src="https://i.loli.net/2020/03/31/8U6mNSjGLeKMrEB.png" alt="image.png"></p>
<p>以上参考文章：</p>
<ul>
<li><a href="https://blog.dreamtobe.cn/2015/11/13/java_synchronized/" target="_blank" rel="noopener">Java Synchronised机制</a></li>
<li><a href="https://github.com/farmerjohngit/myblog/issues/13" target="_blank" rel="noopener">死磕Synchronized底层实现–偏向锁</a></li>
<li><a href="https://blog.csdn.net/iter_zc/article/details/41847887" target="_blank" rel="noopener">聊聊JVM（六）理解JVM的safepoint</a></li>
<li><a href="http://cmsblogs.com/?p=2071" target="_blank" rel="noopener">【死磕Java并发】—–深入分析synchronized的实现原理</a></li>
<li>书籍：Java 并发编程的艺术</li>
<li>书籍：深入理解Java虚拟机：JVM高级特性与最佳实践</li>
<li>书籍：深入浅出Java 多线程</li>
</ul>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础 - Static关键字的一些认识</title>
    <url>/2020/03/31/Java%20%E5%9F%BA%E7%A1%80%20-%20Static%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%A4%E8%AF%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2>]]></content>
      <categories>
        <category>Java基础知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础 - 关于Object的一些认识</title>
    <url>/2020/03/31/Java%20%E5%9F%BA%E7%A1%80%20-%20%E5%85%B3%E4%BA%8EObject%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%A4%E8%AF%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2>]]></content>
      <categories>
        <category>Java基础知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础 - Int和Integer的一些认识</title>
    <url>/2020/03/31/Java%20%E5%9F%BA%E7%A1%80%20-%20Int%E5%92%8CInteger%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%A4%E8%AF%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2>]]></content>
      <categories>
        <category>Java基础知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础 - String的一些认识</title>
    <url>/2020/03/31/Java%20%E5%9F%BA%E7%A1%80%20-%20String%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%A4%E8%AF%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2>]]></content>
      <categories>
        <category>Java基础知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础 - Java8的一些认识</title>
    <url>/2020/03/31/Java%20%E5%9F%BA%E7%A1%80%20-%20Java8%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%A4%E8%AF%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2>]]></content>
      <categories>
        <category>Java基础知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础 - 关于序列化的一些认识</title>
    <url>/2020/03/31/Java%20%E5%9F%BA%E7%A1%80%20-%20%E5%85%B3%E4%BA%8E%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%A4%E8%AF%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2>]]></content>
      <categories>
        <category>Java基础知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础 - 关于泛型的一些认识</title>
    <url>/2020/03/31/Java%20%E5%9F%BA%E7%A1%80%20-%20%E5%85%B3%E4%BA%8E%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%A4%E8%AF%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2>]]></content>
      <categories>
        <category>Java基础知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础 - 一些认识与思考</title>
    <url>/2020/03/31/Java%20%E5%9F%BA%E7%A1%80%20-%20%E4%B8%80%E4%BA%9B%E8%AE%A4%E8%AF%86%E4%B8%8E%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2>]]></content>
      <categories>
        <category>Java基础知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础 - 关于反射的一些认识</title>
    <url>/2020/03/31/Java%20%E5%9F%BA%E7%A1%80%20-%20%E5%85%B3%E4%BA%8E%E5%8F%8D%E5%B0%84%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%A4%E8%AF%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2>]]></content>
      <categories>
        <category>Java基础知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - 线程池 深入线程池原理</title>
    <url>/2020/03/31/Java%20%E5%B9%B6%E5%8F%91%20-%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%20%E6%B7%B1%E5%85%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - CAS 分析</title>
    <url>/2020/03/31/Java%20%E5%B9%B6%E5%8F%91%20-%20CAS%20%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
  </entry>
  <entry>
    <title>Java 并发 - AQS同步组件：ReentrantReadWriteLock 分析</title>
    <url>/2020/03/31/Java%20%E5%B9%B6%E5%8F%91%20-%20AQS%E5%90%8C%E6%AD%A5%E7%BB%84%E4%BB%B6%EF%BC%9AReentrantReadWriteLock%20%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>AQS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - AQS同步组件：ReentrantLock 分析</title>
    <url>/2020/03/31/Java%20%E5%B9%B6%E5%8F%91%20-%20AQS%E5%90%8C%E6%AD%A5%E7%BB%84%E4%BB%B6%EF%BC%9AReentrantLock%20%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>AQS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - AQS同步组件：Semaphore 分析</title>
    <url>/2020/03/31/Java%20%E5%B9%B6%E5%8F%91%20-%20AQS%E5%90%8C%E6%AD%A5%E7%BB%84%E4%BB%B6%EF%BC%9ASemaphore%20%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>AQS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 集合框架 - HashTable 分析</title>
    <url>/2020/03/31/Java%20%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%20-%20HashTable%20%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 集合框架 - CopyOnWriteArrayList 分析</title>
    <url>/2020/03/31/Java%20%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%20-%20CopyOnWriteArrayList%20%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 集合框架 - TreeMap 分析</title>
    <url>/2020/03/31/Java%20%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%20-%20TreeMap%20%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 集合框架 - HashSet 分析</title>
    <url>/2020/03/31/Java%20%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%20-%20HashSet%20%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 框架分析 - 设计模式</title>
    <url>/2020/03/31/Spring%20%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90%20-%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
  </entry>
  <entry>
    <title>Java 并发 - 并发工具类：Exchanger 分析</title>
    <url>/2020/03/31/Java%20%E5%B9%B6%E5%8F%91%20-%20%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%9AExchanger%20%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - AQS同步组件：CountDownLatch 分析</title>
    <url>/2020/03/31/Java%20%E5%B9%B6%E5%8F%91%20-%20AQS%E5%90%8C%E6%AD%A5%E7%BB%84%E4%BB%B6%EF%BC%9ACountDownLatch%20%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>AQS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - AQS同步组件：Cyclibarrier 分析</title>
    <url>/2020/03/31/Java%20%E5%B9%B6%E5%8F%91%20-%20AQS%E5%90%8C%E6%AD%A5%E7%BB%84%E4%BB%B6%EF%BC%9ACyclibarrier%20%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>AQS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - Condition 分析</title>
    <url>/2020/03/31/Java%20%E5%B9%B6%E5%8F%91%20-%20Condition%20%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
  </entry>
  <entry>
    <title>Java 并发 - AQS：基本框架分析总括</title>
    <url>/2020/03/31/Java%20%E5%B9%B6%E5%8F%91%20-%20AQS%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90%E6%80%BB%E6%8B%AC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>AQS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - 多线程 分析总括</title>
    <url>/2020/03/31/Java%20%E5%B9%B6%E5%8F%91%20-%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20%E5%88%86%E6%9E%90%E6%80%BB%E6%8B%AC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - 线程池 分析总括</title>
    <url>/2020/03/31/Java%20%E5%B9%B6%E5%8F%91%20-%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%20%E5%88%86%E6%9E%90%E6%80%BB%E6%8B%AC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 集合框架 - ArrayList 分析</title>
    <url>/2020/03/31/Java%20%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%20-%20ArrayList%20%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 集合框架 - LinkedList 分析</title>
    <url>/2020/03/31/Java%20%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%20-%20LinkedList%20%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 集合框架 - HashMap 认识与理解</title>
    <url>/2020/03/31/Java%20%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%20-%20HashMap%20%E8%AE%A4%E8%AF%86%E4%B8%8E%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
  </entry>
  <entry>
    <title>WTIM 简介</title>
    <url>/2020/03/30/WTIM%20%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>搭建一个基于分布式的IM（即时通讯）系统</p>
]]></content>
      <categories>
        <category>WTIM</category>
      </categories>
      <tags>
        <tag>WTIM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 集合框架 - HashMap 深入分析</title>
    <url>/2020/03/29/Java%20%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%20-%20HashMap%20%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-HashMap实现原理"><a href="#1-HashMap实现原理" class="headerlink" title="1.HashMap实现原理"></a>1.HashMap实现原理</h1><p>首先，先进行查看一下HashMap的继承体系：</p>
<p>我们可以从体系的继承看出来：</p>
<ul>
<li>HashMap实现了Cloneable，可以被克隆。</li>
<li>HashMap实现了Serializable，可以被序列化。</li>
<li>HashMap继承自AbstractMap，实现了Map接口，具有Map的所有功能。</li>
</ul>
<p><strong>简述HashMap的工作原理：</strong></p>
<ul>
<li>HashMap是<strong>基于散列法（又称哈希法）的原理</strong>，使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。使用HashMap进行查询和修改的速度都很快，平均时间复杂度O(1)。HashMap非线程安全，如果需要考虑并发，则需要使用ConcurrentHashMap，且HashMap不保证存储元素的序列；</li>
</ul>
<hr>
<h1 id="2-HashMap的底层结构"><a href="#2-HashMap的底层结构" class="headerlink" title="2.HashMap的底层结构"></a>2.HashMap的底层结构</h1><ul>
<li>JDK1.8之后：数组+链表+红黑树</li>
<li>特点是HashMap采用Entry数组来存储key-value对，每一个键值对组成了一个Entry实体，Entry类实际上是一个单向的链表结构，它具有Next指针，可以连接下一个Entry实体。只是在JDK1.8中，链表长度大于8的时候，链表会转成红黑树！</li>
<li>底层结构具体如下所示：</li>
</ul>
<p>在开始查看源码之前，我有如下几个疑问，在通过查看了源码和结合了他人的分析之后，给出了如下的参考：</p>
<ol>
<li><p><strong>为什么用数组+链表？</strong></p>
<ul>
<li>我认为数组是用来确定桶的位置，利用元素的key的hash值对数组长度取模得到.</li>
<li>链表是用来解决hash冲突问题，当出现hash值一样的情形，就在数组上的对应位置形成一条链表。</li>
<li>注：这里的hash值并不是指hashcode，而是将hashcode高低十六位异或过的。</li>
</ul>
</li>
<li><p>那我用<strong>LinkedList代替数组结构</strong>可以么？</p>
<ul>
<li>这里的意思是，源码中是这样的：<code>Entry[] table = new Entry[capacity];</code><ul>
<li>ps：Entry就是一个链表节点。</li>
</ul>
</li>
<li>那我用下面这样表示：<ul>
<li><code>List&lt;Entry&gt; table = new LinkedList&lt;Entry&gt;();</code></li>
</ul>
</li>
<li>所以没毛病是可以使用用LinkedList代替数组结构</li>
</ul>
</li>
<li><p>那既然是可以的，<strong>为什么HashMap不用LinkedList，而选用数组?</strong></p>
<ul>
<li>因为用数组效率最高！在HashMap中，定位桶的位置是利用元素的key的哈希值对数组长度取模得到。此时，我们已得到桶的位置。显然数组的查找效率比LinkedList大。</li>
</ul>
</li>
<li><p>继续挖一下，那ArrayList，底层也是数组，查找也快啊，<strong>为什么不用ArrayList?</strong></p>
<ul>
<li><p>因为采用基本数组结构，扩容机制可以自己定义，HashMap中数组扩容刚好是2的次幂，在做取模运算的效率高。而ArrayList的扩容机制是1.5倍扩容。</p>
</li>
<li><p>而为什么需要两倍扩容，现在此处存疑，在下面我会进行展开分析一下。</p>
</li>
</ul>
</li>
</ol>
<p>关于红黑树相关的知识：</p>
<ul>
<li>可以看这篇文章：    </li>
</ul>
<hr>
<h1 id="3-源码阅读"><a href="#3-源码阅读" class="headerlink" title="3.源码阅读"></a>3.源码阅读</h1><h2 id="3-1-HashMap的继承与实现"><a href="#3-1-HashMap的继承与实现" class="headerlink" title="3.1.HashMap的继承与实现"></a>3.1.HashMap的继承与实现</h2><ul>
<li>HashMap实现了Cloneable，可以被克隆。</li>
<li>HashMap实现了Serializable，可以被序列化。</li>
<li>HashMap继承自AbstractMap，实现了Map接口，具有Map的所有功能。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-2-HashMap的基本属性及内部类"><a href="#3-2-HashMap的基本属性及内部类" class="headerlink" title="3.2.HashMap的基本属性及内部类"></a>3.2.HashMap的基本属性及内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 哈希数组初始容量</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 哈希数组最大容量</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * HashMap默认装载因子（负载因子）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 当前 HashMap 所能容纳键值对数量的最大值，超过这个值，则需扩容</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 哈希槽（链）上的红黑树上的元素数量减少到此值时，将红黑树转换为链表</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 当桶的个数达到64的时候才进行树化</span></span><br><span class="line"><span class="comment">  * 即是说当桶数组容量小于该值时，优先进行扩容，而不是树化</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 哈希数组</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * entry集合</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * HashMap的元素数量</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *  HashMap结构的修改次数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * (The javadoc description is true upon serialization.</span></span><br><span class="line"><span class="comment">  * Additionally, if the table array has not been allocated, this</span></span><br><span class="line"><span class="comment">  * field holds the initial array capacity, or zero signifying</span></span><br><span class="line"><span class="comment">  * DEFAULT_INITIAL_CAPACITY.)</span></span><br><span class="line"><span class="comment">  * HashMap扩容阈值，并没有默认阈值，原因是阈值可由容量乘上负载因子计算而来（注释中有说明）</span></span><br><span class="line"><span class="comment">  * 计算公式：threshold = capacity * loadFactor</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * HashMap当前使用的装载因子</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>

<p>上面举例了一些HashMap的属性字段，比较有意思的是羡慕几个属性字段，在接下来中会单拎出来进行详细讲解。：</p>
<ul>
<li>哈希数组的初始容量：DEFAULT_INITIAL_CAPACITY</li>
<li>负载因子：loadFactor</li>
<li>链表树化与树化链表的两个阈值：UNTREEIFY_THRESHOLD 和TREEIFY_THRESHOLD</li>
</ul>
<h2 id="3-3-HashMap的四种构造及参数分析"><a href="#3-3-HashMap的四种构造及参数分析" class="headerlink" title="3.3.HashMap的四种构造及参数分析"></a>3.3.HashMap的四种构造及参数分析</h2><ol>
<li>无参构造，初始化一个哈希数组容量为16，装载因子为0.75的HashMap</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &#123;<span class="doctag">@code</span> HashMap&#125; with the default initial capacity</span></span><br><span class="line"><span class="comment"> * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>初始化一个哈希数组容量为initialCapacity，装载因子为0.75的HashMap</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &#123;<span class="doctag">@code</span> HashMap&#125; with the specified initial</span></span><br><span class="line"><span class="comment"> * capacity and the default load factor (0.75).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity the initial capacity.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>初始化一个哈希数组容量为initialCapacity，装载因子为loadFactor的HashMap</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Constructs an empty &#123;<span class="doctag">@code</span> HashMap&#125; with the specified initial</span></span><br><span class="line"><span class="comment">   * capacity and load factor.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment">   *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 检查传入的初始容量是否合法</span></span><br><span class="line">      <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                             initialCapacity);</span><br><span class="line">      <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">          initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">      <span class="comment">// 检查装载因子是否合法</span></span><br><span class="line">      <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                             loadFactor);</span><br><span class="line">      <span class="comment">// 初始化装载因子</span></span><br><span class="line">      <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">      <span class="comment">// 用初始容量信息来计算扩容门槛</span></span><br><span class="line">      <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用指定的HashMap中的元素来初始化一个新的HashMap</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new &#123;<span class="doctag">@code</span> HashMap&#125; with the same mappings as the</span></span><br><span class="line"><span class="comment"> * specified &#123;<span class="doctag">@code</span> Map&#125;.  The &#123;<span class="doctag">@code</span> HashMap&#125; is created with</span></span><br><span class="line"><span class="comment"> * default load factor (0.75) and an initial capacity sufficient to</span></span><br><span class="line"><span class="comment"> * hold the mappings in the specified &#123;<span class="doctag">@code</span> Map&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   m the map whose mappings are to be placed in this map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    <span class="comment">// 将指定HashMap中的元素存入到当前HashMap（允许覆盖）</span></span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们这这里对几个字段进行解释一下：</p>
<h2 id="3-4-查询"><a href="#3-4-查询" class="headerlink" title="3.4.查询"></a>3.4.查询</h2><h3 id="3-4-1-查询HashMap大小"><a href="#3-4-1-查询HashMap大小" class="headerlink" title="3.4.1.查询HashMap大小"></a>3.4.1.查询HashMap大小</h3><p>该方法返回HashMap的大小，键值对的数目：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-2-查询HashMap是否为空"><a href="#3-4-2-查询HashMap是否为空" class="headerlink" title="3.4.2 查询HashMap是否为空"></a>3.4.2 查询HashMap是否为空</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-3-查询HashMap是否存在指定key"><a href="#3-4-3-查询HashMap是否存在指定key" class="headerlink" title="3.4.3.查询HashMap是否存在指定key"></a>3.4.3.查询HashMap是否存在指定key</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getNode(hash(key), key) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-4-查询HashMap中是否存在指定value的元素"><a href="#3-4-4-查询HashMap中是否存在指定value的元素" class="headerlink" title="3.4.4.查询HashMap中是否存在指定value的元素"></a>3.4.4.查询HashMap中是否存在指定value的元素</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; V v;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 进行循环遍历查找value</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; e : tab) &#123;</span><br><span class="line">            <span class="keyword">for</span> (; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((v = e.value) == value ||</span><br><span class="line">                    (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-5-取值"><a href="#3-5-取值" class="headerlink" title="3.5.取值"></a>3.5.取值</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它调用了<code>getNode(int hash, Object key)</code>方法，详细代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">      <span class="comment">// 如果桶的数量大于0，并且所查找的key所在的桶的第一个元素不为空</span></span><br><span class="line">      <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">          (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 检查第一个元素是不是要查的元素，如果是则直接返回</span></span><br><span class="line">          <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">              ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">              <span class="keyword">return</span> first;</span><br><span class="line">          <span class="comment">// 如果不止一个元素，则继续寻找</span></span><br><span class="line">          <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// 如果第一个元素是树节点，则按树的方式查找</span></span><br><span class="line">              <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                  <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">              <span class="keyword">do</span> &#123;</span><br><span class="line">                  <span class="comment">// 否则就遍历整个链表查找该元素</span></span><br><span class="line">                  <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                      ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                      <span class="keyword">return</span> e;</span><br><span class="line">              &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-6-添加"><a href="#3-6-添加" class="headerlink" title="3.6.添加"></a>3.6.添加</h2><h3 id="3-6-1-HashMap的添加过程"><a href="#3-6-1-HashMap的添加过程" class="headerlink" title="3.6.1.HashMap的添加过程"></a>3.6.1.HashMap的添加过程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上它调用了<code>putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict)</code>方法，详细代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 向当前Map中存入新的元素，并返回旧元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * hash         key的哈希值</span></span><br><span class="line"><span class="comment"> * onlyIfAbsent 是否需要维持原状（不覆盖旧值）</span></span><br><span class="line"><span class="comment"> * evict        如果为false，则表处于创建模式。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回同位元素的旧值（在当前Map中占据相同位置的元素）</span></span><br><span class="line"><span class="comment"> * 如果不存在同位元素，即插入了新元素，则返回null</span></span><br><span class="line"><span class="comment"> * 如果存在同位元素，但同位元素的旧值为null，那么也返回null</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 如果桶的长度为0，未初始化，则进行初始化并得到长度n</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 调用resize进行初始化</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 如果桶中还没有元素，则将要插入的key和value放到第一位</span></span><br><span class="line">    <span class="comment">// 使用(n - 1) &amp; hash 计算元素在哪个桶中</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">// 桶中此时已存在元素</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 如果待插入的元素的hash值和key值与第一个元素的哈希值和key相同，保存到e用于后续修改value值</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 如果桶的第一个元素为树节点，则调用树节点的putTreeVal方法插入元素</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历这个桶对应的链表，binCount用于存储链表中元素的个数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 遍历整个链表，没有相同哈希值和key的元素，则在链表最后插入该key和value结点</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 如果插入结点之后的长度大于等于8，则树化</span></span><br><span class="line">                    <span class="comment">// 这里-1的解释为：因为第一个元素没有加到binCount中，所以这里-1</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">// 进行树化</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 假如待插入的key在链表中找到，则退出循环</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到了对应key的元素</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;   <span class="comment">// 记录旧值</span></span><br><span class="line">            <span class="comment">// 判断是否需要替换旧值</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;    <span class="comment">// 替换旧值为新值</span></span><br><span class="line">            <span class="comment">// 在节点被访问后做点什么事，在LinkedHashMap中用到</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到了此处证明没有找到元素，即添加了新元素，修改次数加1</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 如果哈希数组的容量已超过阈值，则需要对哈希数组扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 在节点插入后做点什么事，在LinkedHashMap中用到</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加方法除了可以单个key-value键值对的添加，还可以将指定HashMap中的元素存入到当前HashMap中（允许覆盖），详细代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前HashMap的哈希数组还未初始化</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">// 根据HashMap中的元素数量反推哈希数组的最低容量要求</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;  <span class="comment">// 注意这里!!!!</span></span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">// 如果大于需要扩容的阈值，则重新计算扩容阈值</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Because of linked-list bucket constraints, we cannot</span></span><br><span class="line">            <span class="comment">// expand all at once, but can reduce total resize</span></span><br><span class="line">            <span class="comment">// effort by repeated doubling now vs later</span></span><br><span class="line">            <span class="comment">// 由于链表存储桶的限制，我们无法一次全部扩展</span></span><br><span class="line">            <span class="comment">// 但可以通过立即加倍与以后加倍来减少总的调整工作量</span></span><br><span class="line">            <span class="comment">// 初始化哈希数组，或者对哈希数组扩容，并返回新的哈希数组</span></span><br><span class="line">            <span class="keyword">while</span> (s &gt; threshold &amp;&amp; table.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                resize();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环遍历进行添加，允许覆盖</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-2-HashMap的扩容过程"><a href="#3-6-2-HashMap的扩容过程" class="headerlink" title="3.6.2.HashMap的扩容过程"></a>3.6.2.HashMap的扩容过程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 扩容机制：在初始化时、对哈希数组扩容时两种情况下调用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// 旧数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 旧容量，或者未初始化时的容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">// 旧扩容阈值</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="comment">// 新容量、新扩容阈值</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果哈希数组已经初始化，不是首次进入</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果旧容量大于最大容量，则不再扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果旧容量的两倍（左移一位）小于最大容量，并且大于默认初始容量（16）</span></span><br><span class="line">        <span class="comment">// 则新容量扩大为旧容量的两倍，扩容阈值也扩大为旧阈值的两倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果哈希数组还未初始化（首次进来）并且实例化HashMap的时候指定了初始容量</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        <span class="comment">// 则将哈希数组的当前容量初始化为与旧阈值一样大（传入初始容量时候会调用tableSizeFor()方法）</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">// 如果哈希数组还未初始化（首次进来）并且实例化HashMap的时候没有指定了初始容量</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">// 则使用默认的初始容量（16）和默认公式计算的阈值</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果新扩容阈值为0，则使用公式计算得到新的扩容阈值，并且不可超过最大容量</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 赋值扩容阈值为新扩容阈值</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">// 根据新扩容容量建立一个新容量的数组</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    <span class="comment">// 将桶赋值为新数组</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">// 旧数组不为空，则搬移元素</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历旧数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">// 如果桶中的第一个元素不为空，则赋值给e</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 清空旧桶，帮助GC</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 如果桶中只有一个元素，进行新桶的位置定位，并搬迁</span></span><br><span class="line">                <span class="comment">// 注意：只有第一个元素才可以这样，因为每次扩容都是两倍</span></span><br><span class="line">                <span class="comment">//       则第一个元素搬移到新桶的时候肯定还没有元素</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 如果该哈希槽上链接了不止一个元素，且该元素是TreeNode类型</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 如果第一个元素是树节点，则把这颗树打散成两颗树插入到新桶中去</span></span><br><span class="line">                    <span class="comment">// 拆分红黑树</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 如果这个链表不止一个元素且不是一颗树</span></span><br><span class="line">                    <span class="comment">// 则进行分化成两个链表插到新的桶中</span></span><br><span class="line">                    <span class="comment">// 举例：假如原来容量为4，3、7、11、15这四个元素都在三号桶中</span></span><br><span class="line">                    <span class="comment">// 现在扩容到8，则3和11还是在三号桶，7和15要搬移到七号桶中去</span></span><br><span class="line">                    <span class="comment">// 也就是分化成了两个链表</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// (e.hash &amp; oldCap) == 0的元素放在低位链表中</span></span><br><span class="line">                        <span class="comment">// 比如，3 &amp; 4 == 0</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// (e.hash &amp; oldCap) != 0的元素放在高位链表中</span></span><br><span class="line">                            <span class="comment">// 比如，7 &amp; 4 != 0</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 遍历完成得到两个链表</span></span><br><span class="line">                    <span class="comment">// 低位链表在新桶的位置与旧桶一样（即3和11还在三号桶中）</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 高位链表在新桶中的位置正好是原来的位置加上旧容量（即7和15搬移到七号桶了）</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-3-HashMap扩容的思考"><a href="#3-6-3-HashMap扩容的思考" class="headerlink" title="3.6.3.HashMap扩容的思考"></a>3.6.3.HashMap扩容的思考</h3><h3 id="3-6-4-树化与链化过程"><a href="#3-6-4-树化与链化过程" class="headerlink" title="3.6.4.树化与链化过程"></a>3.6.4.树化与链化过程</h3><h2 id="3-7-移除"><a href="#3-7-移除" class="headerlink" title="3.7.移除"></a>3.7.移除</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 根据传入的key进行数据移除元素，并返回刚刚移除的元素的值</span><br><span class="line"> *&#x2F;</span><br><span class="line">public V remove(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e &#x3D; removeNode(hash(key), key, null, false, true)) &#x3D;&#x3D; null ?</span><br><span class="line">        null : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上它调用了<code>removeNode(int hash, Object key, Object value,boolean matchValue, boolean movable)</code>方法，详细代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 从HashMap中移除指定的元素，并返回刚刚移除的元素（移除失败返回null）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * matchValue 移除元素时是否需要考虑value的匹配问题</span></span><br><span class="line"><span class="comment"> * movable    移除元素后如果红黑树根结点发生了变化，那么是否需要改变结点在链表上的顺序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">// 如果桶的数量大于0（不空）且待删除的元素所在的桶的第一个元素不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">// 如果键的值与链表第一个节点相等，则将 node 指向该节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果该Tab的第一个元素是树节点，则以树的方式进行寻找</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则，就以链表的形式进行遍历寻找</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果找到了该元素，则进行值比对</span></span><br><span class="line">        <span class="comment">// 根据传递进来的matchValue判断是否需要匹配</span></span><br><span class="line">        <span class="comment">// 如果不需要匹配直接删除，如果需要匹配看是否与传入的value相等</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="comment">// 如果是树结点，则调用树的删除方法；</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="comment">// 如果待删除的元素是第一个元素，则将第二个元素移到到第一个元素的位置</span></span><br><span class="line">            <span class="comment">// 注意：上面的代码可知，node==p的情况只有待删除元素node是第一个结点才会发生</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="comment">// 如果待删除的元素不是第一个元素，则将中间结点连接断开（单向链表）</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            <span class="comment">// 修改次数＋1</span></span><br><span class="line">            ++modCount;</span><br><span class="line">            <span class="comment">// size-1</span></span><br><span class="line">            --size;</span><br><span class="line">            <span class="comment">// 删除结点之后应处理的事情</span></span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="4-HashMap的其他问题思考"><a href="#4-HashMap的其他问题思考" class="headerlink" title="4.HashMap的其他问题思考"></a>4.HashMap的其他问题思考</h1><hr>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h1>]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>关于对Java编程的一些理解</title>
    <url>/2020/03/29/%E5%85%B3%E4%BA%8E%E5%AF%B9Java%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="Java是解析运行吗？"><a href="#Java是解析运行吗？" class="headerlink" title="Java是解析运行吗？"></a>Java是解析运行吗？</h4><p>不是的！Java源代码经过Javac编译成.class文件，class文件经JVM解析或编译运行。</p>
<ul>
<li>解析: .class文件经过JVM内嵌的解析器解析执行。</li>
<li>编译:存在JIT编译器（Just In Time Compile 即时编译器）把经常运行的代码作为”热点代码”编译与本地平台相关的机器码，并进行各种层次的优化。</li>
<li>AOT编译器: Java 9提供的直接将所有代码编译成机器码执行。</li>
</ul>
<p>写个程序直接执行字节码就是解释执行。写个程序运行时把字节码动态翻译成机器码就是jit。写个程序把java源代码直接翻译为机器码就是aot。造个CPU直接执行字节码，字节码就是机器码。<br>因为如果虚拟机加载字节码后，完全进行解释执行，这势必会影响执行效率。所以，对于这个运行环节，虚拟机会进行一些优化处理，例如JIT技术，会将某些运行特别频繁的代码编译成机器码。而AOT技术，是在运行前，通过工具直接将字节码转换为机器码。</p>
<h4 id="上面提到了JIT-AOT，他们两个之间的区别是什么呢？"><a href="#上面提到了JIT-AOT，他们两个之间的区别是什么呢？" class="headerlink" title="上面提到了JIT,AOT，他们两个之间的区别是什么呢？"></a>上面提到了JIT,AOT，他们两个之间的区别是什么呢？</h4><ul>
<li>JIT是运行时才做的，需要预热才知道哪些是热点；</li>
<li>AOT是编译期，静态的，直接编成类似类库的东西</li>
</ul>
<p>接下来关于几个问题的理解：</p>
<ul>
<li>理解一下：『Write once, run anywhere』 “书写一次，到处运行”？<ul>
<li>“一次编译、到处运行”说的是Java语言跨平台的特性， Java的跨平台特性与Java虚拟机的存在密不可分，可在不同的环境中运行。比如说Windows平台和Linux平台都有相应的JDK，安装好JDK后也就有了Java语言的运行环境。其实Java语言本身与其他的编程语言没有特别大的差异，并不是说Java语言可以跨平台，而是在不同的平台都有可以让Java语言运行的环境而已，所以才有了Java一次编译，到处运行这样的效果。</li>
<li>严格的讲，跨平台的语言不止Java一种，但Java是较为成熟的一种。 “一次编译，到处运行”这种效果跟编译器有关。编程语言的处理需要编译器和解释器。 Java虚拟机和DOS类似，相当于一个供程序运行的平台。</li>
<li>程序从源代码到运行的三个阶段：编码——编译——运行——调试。 Java在编译阶段则体现了跨平台的特点。编译过程大概是这样的：首先是将Java源代码转化成.CLASS文件字节码，这是第一次编译。 .class文件就是可以到处运行的文件。然后Java字节码会被转化为目标机器代码，这是是由JVM来执行的，即Java的第二次编译。</li>
<li>到处运行”的关键和前提就是JVM。因为在第二次编译中JVM起着关键作用。在可以运行Java虚拟机的地方都内含着一个JVM操作系统。从而使JAVA提供了各种不同平台上的虚拟机制，因此实现了“到处运行”的效果。需要强调的一点是， java并不是编译机制，而是解释机制。 Java字节码的设计充分考虑了JIT这一即时编译方式，可以将字节码直接转化成高性能的本地机器码，这同样是虚拟机的一个构成部分。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java基础知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring IoC源码分析 - 深入理解IoC</title>
    <url>/2020/03/29/Spring%20IoC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3IoC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在开始IOC源码之前先了解清楚一下理论知识，因为IOC和DI（即依赖注入）大概分为一下几点：</p>
<ol>
<li>IoC是什么？</li>
<li>IoC能做什么？</li>
<li>IoC的别名：DI(依赖注入)</li>
<li>IoC和DI的关系是什么？</li>
</ol>
<h4 id="1-IoC是什么？"><a href="#1-IoC是什么？" class="headerlink" title="1.IoC是什么？"></a>1.IoC是什么？</h4><p>IoC 全称为 Inversion of Control，翻译为 “控制反转”，可以说这并不是一项技术，只是一种思想而已。<strong>在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。</strong> 理解IoC主要的关键在于理解两个问题：</p>
<ol>
<li><strong>谁控制谁，控制什么</strong>：<u>直接说明，是IoC容器控制了对象，控制了外部资源的获取（不只是对象，还有文件等等）</u><ul>
<li>在传统Java SE程序设计中，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建；</li>
</ul>
</li>
<li><strong>为何是反转，哪些方面反转了</strong>：<ul>
<li>首先需要理解的是，正转的意思：在传统应用程序中，是由我们自己在对象中主动控制去直接获取依赖对象，这就是正转。</li>
<li>反转的意思： 由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，这是反转。 </li>
<li>哪些方面反转了呢：依赖对象的获取被反转了。</li>
</ul>
</li>
</ol>
<p>总的来说对于IoC一句话概括为：<strong>所谓IoC就是由 Spring IOC 容器来负责对象的生命周期和对象之间的关系。</strong> 其理念即为：让别人为你服务。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring IoC</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 框架分析 - 导页</title>
    <url>/2020/03/29/Spring%20%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90%20-%20%E5%AF%BC%E9%A1%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>Spring 是分层的 Java SE/EE 应用 full-stack 轻量级开源框架，以 IoC（Inverse Of Control：反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）为内核，提供了展现层 Spring MVC 和持久层 Spring JDBC 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的 Java EE 企业应用开源框架。</p>
<p>因为这阵子学习Java框架但是只是会表面的进行一些使用，对内部的结构原理并没有深入的去了解，所以觉得还是有必要进行一下源码的解读，一方面可以对Spring的原理更加深入的了解，另一方面也学习如下如何更加系统的阅读代码。主要还是跟着书籍及一些博主进行阅读，最好的当然是有自己的认识，多写注释多画图，相信会有一些收获的。</p>
<p>可从GitHub上面拉取进行源码分析：<a href="https://github.com/spring-projects/spring-framework。" target="_blank" rel="noopener">https://github.com/spring-projects/spring-framework。</a> 我是直接进行了最新版本的clone：version=5.2.4.BUILD-SNAPSHOT。应该不会有什么问题，进行源码的阅读也仅仅是基础模块，不会对新的内容方向进行深入了解。</p>
<p>所使用的工具及版本号如下：</p>
<ul>
<li>JDK1.8+</li>
<li>IntelliJ IDEA 2019.2</li>
<li>spring-framework 5.2.4.BUILD-SNAPSHOT</li>
</ul>
<h3 id="2-文章的排序"><a href="#2-文章的排序" class="headerlink" title="2.文章的排序"></a>2.文章的排序</h3><p>对于Spring框架的庞大早有耳闻，鉴于自己的水平不够，只能先制订一下大体阅读Spring源码的方向，再各个方向去进行攻克，如果发现有可以继续深入探索的地方，则后面续上；大体上对Spring源码的阅读分为两大部分：IOC 及 AOP</p>
<ul>
<li>IOC方面主要深入了解：<ul>
<li>IOC的基础原理，IOC特性及IOC的使用认识。</li>
<li>单例Bean的注册、获取、创建、解析、加载等等过程。</li>
<li>分析单例Bean的生命周期。</li>
<li>分析BeanDefinitions装载过程。</li>
<li>分析BeanWrapper。</li>
<li></li>
</ul>
</li>
<li>AOP方面主要深入了解：<ul>
<li>AOP的基础原理，</li>
<li>基于XML和基于注解的使用</li>
<li>创建代理对象的过程</li>
<li>请求的完整过程</li>
<li></li>
</ul>
</li>
</ul>
<h3 id="3-Spring-模块结构"><a href="#3-Spring-模块结构" class="headerlink" title="3.Spring 模块结构"></a>3.Spring 模块结构</h3><h3 id="4-结束语"><a href="#4-结束语" class="headerlink" title="4.结束语"></a>4.结束语</h3><p>附录：Spring 源码分析文章列表</p>
<table>
<thead>
<tr>
<th>更新时间</th>
<th>更新文章</th>
</tr>
</thead>
<tbody><tr>
<td>2020-2-13</td>
<td></td>
</tr>
<tr>
<td>2020-2-13</td>
<td></td>
</tr>
<tr>
<td>content1</td>
<td>content2</td>
</tr>
<tr>
<td>content1</td>
<td>content2</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>导页</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - 导页</title>
    <url>/2020/03/29/Java%20%E5%B9%B6%E5%8F%91%20-%20%E5%AF%BC%E9%A1%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-简介"><a href="#一-简介" class="headerlink" title="一.简介"></a>一.简介</h1><p>Java并发是我在学习Java过程中涉及到的知识点较多的一块，里面的内容较杂乱，需要去好好的梳理一下，归纳总结一些基础的知识点，再对底层的实现原理进行逐一认识了解，在开展各个知识点的认识之前，应先要把基础的特性与概念先了解一下，这样会更好的帮助后面的了解；Java并发所涉及到的知识点大概为：线程的安全、线程调度、各种容器、AQS、J.U.C等等；</p>
<p>在进行并发深入了解之前，先明白并发、并行、高并发的概念：</p>
<ul>
<li>并发：是指在某个时间段内，多任务交替的执行任务。当有多个线程在操作时，把CPU运行时间划分成若干个时间段,再将时间段分配给各个线程执行。 在一个时间段的线程代码运行时，其它线程处于挂起状。</li>
<li>并行：是指同一时刻同时处理多任务的能力。当有多个线程在操作时，cpu同时处理这些线程请求的能力。</li>
<li>高并发：它通常是指，通过设计保证系统能够同时并行处理很多请求。</li>
</ul>
<h1 id="二-文章的排序"><a href="#二-文章的排序" class="headerlink" title="二.文章的排序"></a>二.文章的排序</h1><p>关于这个专辑里面的内容，先暂定如下几个内容进行分析，围着各个点进行开展深入学习，深入分析底层原理，弄清各个点之间的联系，联系到实际应用中去，想着如果在高并发状态该如何去解决问题、如何使用以下知识点去优化项目，以后再在实际工作中该如何使用，至少应该明白大体的工作原理及工作流程。</p>
<p>主要涉及的源码及原理分析如下：</p>
<ul>
<li>Java 线程池分析</li>
<li>Synchronized、Volatile 原理分析</li>
<li>J.U.C AQS分析</li>
<li>J.U.C 重入锁及读写锁分析</li>
<li>J.U.C 并发工具类分析</li>
<li>J.U.C 并发容器分析</li>
<li>Java 阻塞队列分析</li>
<li>Java CAS 原理分析</li>
<li></li>
</ul>
<h1 id="三-内容窥探"><a href="#三-内容窥探" class="headerlink" title="三.内容窥探"></a>三.内容窥探</h1><ol>
<li>线程与进程：<ol>
<li>我们需要理解线程与进程的概念与联系、线程的底层数据结构源码的解析。</li>
<li>线程的几种创建方式，这几种实现方式的源码的异同在哪里。</li>
</ol>
</li>
<li>线程池：<ol>
<li>理解线程池的基本概念与基本架构</li>
<li>ThreadPoolExecutor</li>
<li>ScheduledThreadPoolExecutor</li>
</ol>
</li>
<li>Synchronized：<ol>
<li>理解Synchronized的作用</li>
<li>进行Synchronized的代码解析</li>
</ol>
</li>
<li>Volatile：<ol>
<li>理解Volatile的作用</li>
<li>进行Volatile的代码解析</li>
</ol>
</li>
<li>AQS：AbstractQueuedSynvhronizer<ol>
<li>同步队列</li>
<li>同步状态</li>
<li>阻塞与幻想线程</li>
<li>独占/共享模式</li>
<li></li>
</ol>
</li>
<li>J.U.C 重入锁ReentrantLock、读写锁ReentrantReadWriteLock<ol>
<li>理解各自的原理与作用</li>
<li>进行代码解析</li>
<li>进行使用对比</li>
<li></li>
</ol>
</li>
<li>J.U.C 并发工具类：<ol>
<li>CountDownLatch</li>
<li>CyclicBarrier</li>
<li>Semaphore</li>
<li>Exchanger</li>
<li></li>
</ol>
</li>
<li>J.U.C 并发容器：<ol>
<li>ConcurrentHashMap</li>
<li>ConcurrentLinkedQueue</li>
<li>ConcurrentSkipListMap</li>
</ol>
</li>
<li>J.U.C 阻塞队列：<ol>
<li>ArrayBlockingQueue</li>
<li>PriorityBlockingQueue</li>
<li>DelayQueue</li>
<li>SynchronousQueue</li>
<li>LinkedTransferQueue</li>
<li>LinkedBlockingDeque</li>
</ol>
</li>
</ol>
<h1 id="四-结束语"><a href="#四-结束语" class="headerlink" title="四.结束语"></a>四.结束语</h1><p>因为我觉得我还是对一些高并发、高可用的知识较为感兴趣，所以对这一章节的内容可能会深入的探究一下，最好的方法我觉得还是看官方文档，这就需要一定的英语知识，可以采取的措施即为多看一下计算机相关的专业英语，实在不行的话借助翻译器也是一个方法；多动手去完成一些demo，进行编译Debug，这对以后工作状态当中进行排查错误是一个很好的方法，很多人只是了解基础知识，并没有去实践，这是一个问题所在；</p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>导页</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 集合框架 - 导页</title>
    <url>/2020/03/29/Java%20%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%20-%20%E5%AF%BC%E9%A1%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一-简介"><a href="#一-简介" class="headerlink" title="一.简介"></a>一.简介</h2><p>对于集合的学习，或者说对于所有知识的学习，总结一点我觉得非常重要的就是：假如可以带着问题去看知识的话那我觉得会更加深入，因为在这个过程当中我们会反复的推问原理为何，才能到达更深入的地步，所以在此系列文章的开头我都会尽量去整理问题的所在点，然后分析源代码，进行知识的总结，在最后再将思考所得写在下一篇文章当中，我觉得这样一来对知识的学习帮助或者更大。<br>集合的内容也是繁多，跟并发结合在一起两大模块成为Java学习过程当中的拦路虎，消除恐惧最好的方法即为面对恐惧，我对各个知识点逐个进行解析，倒不是说为了出书之类的，自问没有那个本事，只是说可以在学习过程中记录一些知识点和思考所得，可以在后来反复进行探究，不要学了很多遍知识最后却一点东西都没有剩下，对于集合框架的源码分析，难度不算太高，但是我觉得这对我编程的提升有很大帮助，尽量去思考内在逻辑是最有帮助的，希望可以收获更多。</p>
<p>工具与源码版本：</p>
<ul>
<li>IntelliJ IDEA 2019.2</li>
<li>jdk-15+9 （直接从<a href="https://github.com/openjdk/jdk" target="_blank" rel="noopener">https://github.com/openjdk/jdk</a> Clone下来的）</li>
</ul>
<h2 id="二-知识的窥探"><a href="#二-知识的窥探" class="headerlink" title="二.知识的窥探"></a>二.知识的窥探</h2><p>如若按照Collection和Map的归类来分的话，可以分为以下几部分：</p>
<ul>
<li><strong>Collection</strong> <ol>
<li><strong>List</strong><ol>
<li>Arraylist： Object数。</li>
<li>Vector： Object数组。</li>
<li>LinkedList： 双向链表(JDK1.6之前为循环链表，JDK1.7取消了循环)。</li>
</ol>
</li>
<li><strong>Set</strong><ol>
<li>LinkedHashSet： LinkedHashSet 继承于 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 HashMap 实现一样，不过还是有一点点区别的。</li>
<li>HashSet（无序，唯一）: 基于 HashMap 实现的，底层采用 HashMap 来保存元素。</li>
<li>TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树)。</li>
</ol>
</li>
</ol>
</li>
<li><strong>Map</strong><ol>
<li>HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</li>
<li>LinkedHashMap： LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：《LinkedHashMap 源码详细分析（JDK1.8）》</li>
<li>Hashtable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li>
<li>TreeMap： 红黑树（自平衡的排序二叉树）</li>
</ol>
</li>
<li><strong>注：如何选用集合?</strong><ul>
<li>主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用Map接口下的集合，需要排序时选择TreeMap，不需要排序时就选择HashMap，需要保证线程安全就选用ConcurrentHashMap.当我们只需要存放元素值时，就选择实现Collection接口的集合，需要保证元素唯一时选择实现Set接口的集合比如TreeSet或HashSet，不需要就选择实现List接口的比如ArrayList或LinkedList，然后再根据实现这些接口的集合的特点来选用。</li>
</ul>
</li>
</ul>
<h2 id="三-源码分析的排序"><a href="#三-源码分析的排序" class="headerlink" title="三.源码分析的排序"></a>三.源码分析的排序</h2><p>主要涉及的源码及原理分析如下：</p>
<ol>
<li>ArrayList 源码分析</li>
<li>LinkedList 源码分析</li>
<li><a href="">HashMap 源码分析</a></li>
<li>ConcurrentHashMap 源码分析</li>
<li>HashSet源码分析</li>
<li>LinkedHashMap 源码分析</li>
<li>TreeMap 源码分析</li>
<li>CopyOnWriteArrayList 源码分析</li>
<li></li>
</ol>
<h2 id="四-结束语"><a href="#四-结束语" class="headerlink" title="四.结束语"></a>四.结束语</h2><p>对于这个模块的学习，看源码是最好的，稍后补充</p>
]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java集合</tag>
        <tag>导页</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础 - 导页</title>
    <url>/2020/03/29/Java%20%E5%9F%BA%E7%A1%80%20-%20%E5%AF%BC%E9%A1%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><h2 id="2-文章的排序"><a href="#2-文章的排序" class="headerlink" title="2.文章的排序"></a>2.文章的排序</h2><ol>
<li></li>
<li></li>
</ol>
<h2 id="3-结束语"><a href="#3-结束语" class="headerlink" title="3. 结束语"></a>3. 结束语</h2><p>语言的基础知识理解是最重要的，万丈高楼平地起，只有把基础知识解决了，后面的工作才会更好的进行下去，希望这个专辑能帮助我和大家更好的理解一下基础的语言知识</p>
<h2 id="4-阅读书籍介绍"><a href="#4-阅读书籍介绍" class="headerlink" title="4. 阅读书籍介绍"></a>4. 阅读书籍介绍</h2>]]></content>
      <categories>
        <category>Java基础知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>导页</tag>
      </tags>
  </entry>
</search>

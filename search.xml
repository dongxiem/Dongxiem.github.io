<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Mybatis 框架分析（2） - 基于注解方式的简单Demo</title>
    <url>/2020/04/06/mybatis-kuang-jia-fen-xi-2-ji-yu-zhu-jie-fang-shi-de-jian-dan-demo/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 65 - 矩阵中的路径</title>
    <url>/2020/04/02/jian-zhi-offer-65-ju-zhen-zhong-de-lu-jing/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 64 - 滑动窗口的最大值</title>
    <url>/2020/04/02/jian-zhi-offer-64-hua-dong-chuang-kou-de-zui-da-zhi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 63 - 数据流中的中位数</title>
    <url>/2020/04/02/jian-zhi-offer-63-shu-ju-liu-zhong-de-zhong-wei-shu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 66 - 机器人的运动范围</title>
    <url>/2020/04/02/jian-zhi-offer-66-ji-qi-ren-de-yun-dong-fan-wei/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 61 - 序列化二叉树</title>
    <url>/2020/04/02/jian-zhi-offer-61-xu-lie-hua-er-cha-shu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 60 - 把二叉树打印成多行</title>
    <url>/2020/04/02/jian-zhi-offer-60-ba-er-cha-shu-da-yin-cheng-duo-xing/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 59 - 按之字形顺序打印二叉树</title>
    <url>/2020/04/02/jian-zhi-offer-59-an-zhi-zi-xing-shun-xu-da-yin-er-cha-shu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 58 - 对称的二叉树</title>
    <url>/2020/04/02/jian-zhi-offer-58-dui-cheng-de-er-cha-shu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 57 - 二叉树的下一个结点</title>
    <url>/2020/04/02/jian-zhi-offer-57-er-cha-shu-de-xia-yi-ge-jie-dian/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 62 - 二叉搜索树的第k个结点</title>
    <url>/2020/04/02/jian-zhi-offer-62-er-cha-sou-suo-shu-de-di-k-ge-jie-dian/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 55 - 链表中环的入口结点</title>
    <url>/2020/04/02/jian-zhi-offer-55-lian-biao-zhong-huan-de-ru-kou-jie-dian/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 54 - 字符流中第一个不重复的字符</title>
    <url>/2020/04/02/jian-zhi-offer-54-zi-fu-liu-zhong-di-yi-ge-bu-chong-fu-de-zi-fu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 53 - 表示数值的字符串</title>
    <url>/2020/04/02/jian-zhi-offer-53-biao-shi-shu-zhi-de-zi-fu-chuan/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 52 - 正则表达式匹配</title>
    <url>/2020/04/02/jian-zhi-offer-52-zheng-ze-biao-da-shi-pi-pei/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 51 - 构建乘积数组</title>
    <url>/2020/04/02/jian-zhi-offer-51-gou-jian-cheng-ji-shu-zu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 50 - 数组中重复的数字 - 副本</title>
    <url>/2020/04/02/jian-zhi-offer-50-shu-zu-zhong-chong-fu-de-shu-zi-fu-ben/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 49 - 把字符串转换成整数</title>
    <url>/2020/04/02/jian-zhi-offer-49-ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 48 - 不用加减乘除做加法</title>
    <url>/2020/04/02/jian-zhi-offer-48-bu-yong-jia-jian-cheng-chu-zuo-jia-fa/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 47 - 求1+2+3+...+n</title>
    <url>/2020/04/02/jian-zhi-offer-47-qiu-1-2-3...n/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 46 - 孩子们的游戏(圆圈中最后剩下的数)(约瑟夫环)</title>
    <url>/2020/04/02/jian-zhi-offer-46-hai-zi-men-de-you-xi-yuan-quan-zhong-zui-hou-sheng-xia-de-shu-yue-se-fu-huan/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 45 - 扑克牌顺子</title>
    <url>/2020/04/02/jian-zhi-offer-45-bu-ke-pai-shun-zi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 44 - 翻转单词顺序列</title>
    <url>/2020/04/02/jian-zhi-offer-44-fan-zhuan-dan-ci-shun-xu-lie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 41 - 和为S的连续正数序列</title>
    <url>/2020/04/02/jian-zhi-offer-41-he-wei-s-de-lian-xu-zheng-shu-xu-lie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 40 - 数组中只出现一次的数字</title>
    <url>/2020/04/02/jian-zhi-offer-40-shu-zu-zhong-zhi-chu-xian-yi-ci-de-shu-zi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 39 - 平衡二叉树</title>
    <url>/2020/04/02/jian-zhi-offer-39-ping-heng-er-cha-shu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 38 - 二叉树的深度</title>
    <url>/2020/04/02/jian-zhi-offer-38-er-cha-shu-de-shen-du/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 37 - 数字在排序数组中出现的次数</title>
    <url>/2020/04/02/jian-zhi-offer-37-shu-zi-zai-pai-xu-shu-zu-zhong-chu-xian-de-ci-shu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 36 - 两个链表的第一个公共结点</title>
    <url>/2020/04/02/jian-zhi-offer-36-liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 35 - 数组中的逆序对</title>
    <url>/2020/04/02/jian-zhi-offer-35-shu-zu-zhong-de-ni-xu-dui/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 32 - 把数组排成最小的数</title>
    <url>/2020/04/02/jian-zhi-offer-32-ba-shu-zu-pai-cheng-zui-xiao-de-shu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 42 - 和为S的两个数字(排序数组)</title>
    <url>/2020/04/02/jian-zhi-offer-42-he-wei-s-de-liang-ge-shu-zi-pai-xu-shu-zu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 31 - 整数中1出现的次数（从1到n整数中1出现的次数）</title>
    <url>/2020/04/02/jian-zhi-offer-31-zheng-shu-zhong-1-chu-xian-de-ci-shu-cong-1-dao-n-zheng-shu-zhong-1-chu-xian-de-ci-shu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 30 - 连续子数组的最大和</title>
    <url>/2020/04/02/jian-zhi-offer-30-lian-xu-zi-shu-zu-de-zui-da-he/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 29 - 最小的K个数</title>
    <url>/2020/04/02/jian-zhi-offer-29-zui-xiao-de-k-ge-shu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 28 - 数组中出现次数超过一半的数字</title>
    <url>/2020/04/02/jian-zhi-offer-28-shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 27 - 字符串的排列</title>
    <url>/2020/04/02/jian-zhi-offer-27-zi-fu-chuan-de-pai-lie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 26 - 二叉搜索树与双向链表</title>
    <url>/2020/04/02/jian-zhi-offer-26-er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 25 - 复杂链表的复制</title>
    <url>/2020/04/02/jian-zhi-offer-25-fu-za-lian-biao-de-fu-zhi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 22 - 从上往下打印二叉树</title>
    <url>/2020/04/02/jian-zhi-offer-22-cong-shang-wang-xia-da-yin-er-cha-shu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 33 - 丑数</title>
    <url>/2020/04/02/jian-zhi-offer-33-chou-shu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 21 - 栈的压入、弹出序列</title>
    <url>/2020/04/02/jian-zhi-offer-21-zhan-de-ya-ru-dan-chu-xu-lie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 20 - 包含min函数的栈</title>
    <url>/2020/04/02/jian-zhi-offer-20-bao-han-min-han-shu-de-zhan/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 19 - 顺时针打印矩阵</title>
    <url>/2020/04/02/jian-zhi-offer-19-shun-shi-zhen-da-yin-ju-zhen/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 18 - 二叉树的镜像</title>
    <url>/2020/04/02/jian-zhi-offer-18-er-cha-shu-de-jing-xiang/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 17 - 树的子结构</title>
    <url>/2020/04/02/jian-zhi-offer-17-shu-de-zi-jie-gou/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 16 - 合并两个排序的链表</title>
    <url>/2020/04/02/jian-zhi-offer-16-he-bing-liang-ge-pai-xu-de-lian-biao/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 15 - 反转链表</title>
    <url>/2020/04/02/jian-zhi-offer-15-fan-zhuan-lian-biao/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 14 - 链表中倒数第k个结点</title>
    <url>/2020/04/02/jian-zhi-offer-14-lian-biao-zhong-dao-shu-di-k-ge-jie-dian/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 12 - 数值的整数次方</title>
    <url>/2020/04/02/jian-zhi-offer-12-shu-zhi-de-zheng-shu-ci-fang/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 11 - 二进制中1的个数</title>
    <url>/2020/04/02/jian-zhi-offer-11-er-jin-zhi-zhong-1-de-ge-shu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 10 - 矩形覆盖</title>
    <url>/2020/04/02/jian-zhi-offer-10-ju-xing-fu-gai/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 09 - 变态跳台阶</title>
    <url>/2020/04/02/jian-zhi-offer-09-bian-tai-tiao-tai-jie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 08 - 跳台阶</title>
    <url>/2020/04/02/jian-zhi-offer-08-tiao-tai-jie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 07 - 斐波那契数列</title>
    <url>/2020/04/02/jian-zhi-offer-07-fei-bo-na-qi-shu-lie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 06 - 旋转数组的最小数字</title>
    <url>/2020/04/02/jian-zhi-offer-06-xuan-zhuan-shu-zu-de-zui-xiao-shu-zi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 05 - 用两个栈实现一个队列</title>
    <url>/2020/04/02/jian-zhi-offer-05-yong-liang-ge-zhan-shi-xian-yi-ge-dui-lie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 04 - 重建二叉树</title>
    <url>/2020/04/02/jian-zhi-offer-04-chong-jian-er-cha-shu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 03 - 从尾到头打印链表</title>
    <url>/2020/04/02/jian-zhi-offer-03-cong-wei-dao-tou-da-yin-lian-biao/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 02 - 替换空格</title>
    <url>/2020/04/02/jian-zhi-offer-02-ti-huan-kong-ge/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 13 - 调增数组顺序使奇数位于偶数前面</title>
    <url>/2020/04/02/jian-zhi-offer-13-diao-zeng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 23 - 二叉搜索树的后序遍历序列</title>
    <url>/2020/04/02/jian-zhi-offer-23-er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 34 - 第一个只出现一次的字符</title>
    <url>/2020/04/02/jian-zhi-offer-34-di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 43 - 左旋转字符串</title>
    <url>/2020/04/02/jian-zhi-offer-43-zuo-xuan-zhuan-zi-fu-chuan/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 50 - 数组中重复的数字</title>
    <url>/2020/04/02/jian-zhi-offer-50-shu-zu-zhong-chong-fu-de-shu-zi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer - 01 - 二维数组中的查找</title>
    <url>/2020/04/02/jian-zhi-offer-01-er-wei-shu-zu-zhong-de-cha-zhao/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目链接：</p>
<p>题目描述：</p>
<p>解题思路：</p>
<p>代码：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer</title>
    <url>/2020/04/02/jian-zhi-offer/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h1><p>剑指offer还是挺有意思的，以下是我个人的学习笔记</p>
<h1 id="二-开始着手"><a href="#二-开始着手" class="headerlink" title="二.开始着手"></a>二.开始着手</h1><p>剑指Offer - 01 - 二维数组中的查找<br>剑指Offer - 02 - 替换空格<br>剑指Offer - 03 - 从尾到头打印链表<br>剑指Offer - 04 - 重建二叉树<br>剑指Offer - 05 - 用两个栈实现一个队列<br>剑指Offer - 06 - 旋转数组的最小数字<br>剑指Offer - 07 - 斐波那契数列<br>剑指Offer - 08 - 跳台阶<br>剑指Offer - 09 - 变态跳台阶<br>剑指Offer - 10 - 矩形覆盖<br>剑指Offer - 11 - 二进制中1的个数<br>剑指Offer - 12 - 数值的整数次方<br>剑指Offer - 13 - 调增数组顺序使奇数位于偶数前面<br>剑指Offer - 14 - 链表中倒数第k个结点<br>剑指Offer - 15 - 反转链表<br>剑指Offer - 16 - 合并两个排序的链表<br>剑指Offer - 17 - 树的子结构<br>剑指Offer - 18 - 二叉树的镜像<br>剑指Offer - 19 - 顺时针打印矩阵<br>剑指Offer - 20 - 包含min函数的栈<br>剑指Offer - 21 - 栈的压入、弹出序列<br>剑指Offer - 22 - 从上往下打印二叉树<br>剑指Offer - 23 - 二叉搜索树的后序遍历序列<br>剑指Offer - 24 - 二叉树中和为某一值的路径<br>剑指Offer - 25 - 复杂链表的复制<br>剑指Offer - 26 - 二叉搜索树与双向链表<br>剑指Offer - 27 - 字符串的排列<br>剑指Offer - 28 - 数组中出现次数超过一半的数字<br>剑指Offer - 29 - 最小的K个数<br>剑指Offer - 30 - 连续子数组的最大和<br>剑指Offer - 31 - 整数中1出现的次数（从1到n整数中1出现的次数）<br>剑指Offer - 32 - 把数组排成最小的数<br>剑指Offer - 33 - 丑数<br>剑指Offer - 34 - 第一个只出现一次的字符<br>剑指Offer - 35 - 数组中的逆序对<br>剑指Offer - 36 - 两个链表的第一个公共结点<br>剑指Offer - 37 - 数字在排序数组中出现的次数<br>剑指Offer - 38 - 二叉树的深度<br>剑指Offer - 39 - 平衡二叉树<br>剑指Offer - 40 - 数组中只出现一次的数字<br>剑指Offer - 41 - 和为S的连续正数序列<br>剑指Offer - 42 - 和为S的两个数字(排序数组)<br>剑指Offer - 43 - 左旋转字符串<br>剑指Offer - 44 - 翻转单词顺序列<br>剑指Offer - 45 - 扑克牌顺子<br>剑指Offer - 46 - 孩子们的游戏(圆圈中最后剩下的数)(约瑟夫环)<br>剑指Offer - 47 - 求1+2+3+…+n<br>剑指Offer - 48 - 不用加减乘除做加法<br>剑指Offer - 49 - 把字符串转换成整数<br>剑指Offer - 50 - 数组中重复的数字<br>剑指Offer - 51 - 构建乘积数组<br>剑指Offer - 52 - 正则表达式匹配<br>剑指Offer - 53 - 表示数值的字符串<br>剑指Offer - 54 - 字符流中第一个不重复的字符<br>剑指Offer - 55 - 链表中环的入口结点<br>剑指Offer - 56 - 删除链表中重复的节点<br>剑指Offer - 57 - 二叉树的下一个结点<br>剑指Offer - 58 - 对称的二叉树<br>剑指Offer - 59 - 按之字形顺序打印二叉树<br>剑指Offer - 60 - 把二叉树打印成多行<br>剑指Offer - 61 - 序列化二叉树<br>剑指Offer - 62 - 二叉搜索树的第k个结点<br>剑指Offer - 63 - 数据流中的中位数<br>剑指Offer - 64 - 滑动窗口的最大值<br>剑指Offer - 65 - 矩阵中的路径<br>剑指Offer - 66 - 机器人的运动范围</p>
<h1 id="三-小结"><a href="#三-小结" class="headerlink" title="三.小结"></a>三.小结</h1><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>导页</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 - 什么是跳跃表</title>
    <url>/2020/04/01/shu-ju-jie-gou-shi-me-shi-tiao-yue-biao/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 - 什么是B+树？</title>
    <url>/2020/04/01/shu-ju-jie-gou-shi-me-shi-b-shu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis 源码分析（1） - 配置文件解析过程</title>
    <url>/2020/04/01/mybatis-yuan-ma-fen-xi-1-pei-zhi-wen-jian-jie-xi-guo-cheng/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis 源码分析（2） - 映射文件解析过程</title>
    <url>/2020/04/01/mybatis-yuan-ma-fen-xi-2-ying-she-wen-jian-jie-xi-guo-cheng/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis 源码分析（3） - SQL执行过程</title>
    <url>/2020/04/01/mybatis-yuan-ma-fen-xi-3-sql-zhi-xing-guo-cheng/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis 框架分析（5） - 连接池管理机制</title>
    <url>/2020/04/01/mybatis-kuang-jia-fen-xi-5-lian-jie-chi-guan-li-ji-zhi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis 框架分析（6） - 缓存机制</title>
    <url>/2020/04/01/mybatis-kuang-jia-fen-xi-6-huan-cun-ji-zhi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis 框架分析（4） - 事务管理机制</title>
    <url>/2020/04/01/mybatis-kuang-jia-fen-xi-4-shi-wu-guan-li-ji-zhi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis 框架分析（3） - 使用Mybatis进行CRUD</title>
    <url>/2020/04/01/mybatis-kuang-jia-fen-xi-3-shi-yong-mybatis-jin-xing-crud/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis 框架分析（2） - 基于XML配置文件的方式的简单Demo</title>
    <url>/2020/04/01/mybatis-kuang-jia-fen-xi-2-ji-yu-xml-pei-zhi-wen-jian-de-fang-shi-de-jian-dan-demo/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1.环境配置"></a>1.环境配置</h1><p>目的：使用Mybatis 去查询数据库的表，并且打印出来</p>
<p>IDEA：IDEA 2019.2.3</p>
<p>MySql：Mysql 5.7.22</p>
<p>MyBatis：MyBatis 3.4.5</p>
<p>Maven：Maven 3.5.2</p>
<h1 id="2-使用Mybatis查询数据库内容"><a href="#2-使用Mybatis查询数据库内容" class="headerlink" title="2.使用Mybatis查询数据库内容"></a>2.使用Mybatis查询数据库内容</h1><h2 id="2-1-New-一个新的Project，Maven项目："><a href="#2-1-New-一个新的Project，Maven项目：" class="headerlink" title="2.1 New 一个新的Project，Maven项目："></a>2.1 New 一个新的Project，Maven项目：</h2><p><img src="https://i.loli.net/2020/04/01/hcSMWl7FdIkVAr4.png" alt="image.png"></p>
<p>接着进行Project 的信息填写如下：</p>
<p><img src="https://i.loli.net/2020/04/01/ATzZGfEcrIjKp5x.png" alt="image.png"></p>
<p>新创建之后的Project如下：</p>
<p><img src="https://i.loli.net/2020/04/01/Rq2hcEUbnyJjx5m.png" alt="image.png"></p>
<h2 id="2-2-进行一些准备工作"><a href="#2-2-进行一些准备工作" class="headerlink" title="2.2 进行一些准备工作"></a>2.2 进行一些准备工作</h2><h3 id="2-2-1-填充Mysql数据："><a href="#2-2-1-填充Mysql数据：" class="headerlink" title="2.2.1 填充Mysql数据："></a>2.2.1 填充Mysql数据：</h3><p>进行如下数据的填充，方面接下来的Demo的一些操作：</p>
<pre class=" language-mysql"><code class="language-mysql">CREATE DATABASE mybatis_demo;
use mybatis_demo;</code></pre>
<pre class=" language-mysql"><code class="language-mysql">CREATE TABLE USER(
    ID INT(20) not null PRIMARY KEY,
    NAME VARCHAR(30) DEFAULT NULL,
    PWD VARCHAR(30) DEFAULT NULL
)ENGINE=INNODB, CHARSET=utf8;</code></pre>
<pre class=" language-mysql"><code class="language-mysql">INSERT INTO USER (ID, NAME, PWD) VALUES (1,'cici',123),(2,'pipi',456),(3,'gigi',789);</code></pre>
<p>可以看到数据库已经有如下数据了：</p>
<p><img src="https://i.loli.net/2020/04/01/Dgi7x1dmFUu8zQV.png" alt="image.png"></p>
<h3 id="2-2-2-调整一些Project目录"><a href="#2-2-2-调整一些Project目录" class="headerlink" title="2.2.2 调整一些Project目录"></a>2.2.2 调整一些Project目录</h3><p>首先删除src，然后创建新的子模块，因为我们会在这个项目里建立多个子项目，这样可以节省创建新项目的时间。</p>
<p><img src="https://i.loli.net/2020/04/01/lT78fDtNyJVSWYL.png" alt="image.png"></p>
<p>创建新的子模块如下：</p>
<p><img src="https://i.loli.net/2020/04/01/YZmC1HD6sjoKF8W.png" alt="image.png"></p>
<p>创建完成如下：</p>
<p><img src="https://i.loli.net/2020/04/01/lFzIarxZVQWRc3s.png" alt="image.png"></p>
<h3 id="2-2-3-配置Pom-xml"><a href="#2-2-3-配置Pom-xml" class="headerlink" title="2.2.3 配置Pom.xml"></a>2.2.3 配置Pom.xml</h3><p>进行Pom.xml 的配置，主要就是一些dependecy的填充。</p>
<ol>
<li>mybatis的dependency可以在官网中找到<ul>
<li><img src="https://i.loli.net/2020/04/01/NGRMBp5n4O87SDT.png" alt="image.png"></li>
</ul>
</li>
<li>junit 是单元测试</li>
<li>mysql 的依赖一样需要添加</li>
<li>log4j 是日志，添加上。</li>
</ol>
<p>pom.xml 详细配置如下：</p>
<pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span>
         <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>
         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token comment" spellcheck="true">&lt;!-- 父工程 --></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis_demo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.garmen<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.0-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis_demo01<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mybatis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.4.5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.10<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.1.6<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>runtime<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>log4j<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>log4j<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.2.12<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span></code></pre>
<p>同时将log4j 的配置文件添加到src下面，如下所示：</p>
<p><img src="https://i.loli.net/2020/04/01/5w4Ue2HoJCPpNrf.png" alt="image.png"></p>
<p>lo4j 内容如下：</p>
<pre><code># Set root category priority to INFO and its only appender to CONSOLE.
#log4j.rootCategory=INFO, CONSOLE            debug   info   warn error fatal
log4j.rootCategory=debug, CONSOLE, LOGFILE

# Set the enterprise logger category to FATAL and its only appender to CONSOLE.
log4j.logger.org.apache.axis.enterprise=FATAL, CONSOLE

# CONSOLE is set to be a ConsoleAppender using a PatternLayout.
log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender
log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout
log4j.appender.CONSOLE.layout.ConversionPattern=%d{ISO8601} %-6r [%15.15t] %-5p %30.30c %x - %m\n

# LOGFILE is set to be a File appender using a PatternLayout.
log4j.appender.LOGFILE=org.apache.log4j.FileAppender
log4j.appender.LOGFILE.File=d:\axis.log
log4j.appender.LOGFILE.Append=true
log4j.appender.LOGFILE.layout=org.apache.log4j.PatternLayout
log4j.appender.LOGFILE.layout.ConversionPattern=%d{ISO8601} %-6r [%15.15t] %-5p %30.30c %x - %m\n</code></pre><h2 id="2-3-配置-Mybatis-核心配置文件"><a href="#2-3-配置-Mybatis-核心配置文件" class="headerlink" title="2.3 配置 Mybatis 核心配置文件"></a>2.3 配置 Mybatis 核心配置文件</h2><p>我们使用官网提供的方法，官网中说明有两种方式可以构建 SqlSessionFactory，一种是使用XML，一种是不使用XML，<strong>这个Demo暂定选择使用XML来进行构建SqlSessionFactory</strong>。</p>
<p>官网所给建议截图如下：</p>
<p><img src="https://i.loli.net/2020/04/01/HOkQoJGInL41vE6.png" alt="image.png"></p>
<p>于是我们创建并编写 SqlMapConfig.xml 配置文件。</p>
<ul>
<li>注意：这个XML 配置文件，包含了对 MyBatis 系统的核心设置，包括获取数据库连接实例的数据源（DataSource）以及决定事务作用域和控制方式的事务管理器 （TransactionManager）。</li>
<li>其实主要的就是你机子里面的数据库信息，就是配置环境。</li>
</ul>
<p>需要注意的是，这个头部是通用的，我们可以先保存下来：</p>
<pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span>
<span class="token doctype">&lt;!DOCTYPE mapper  
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"  
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd"></span></code></pre>
<p>进行扩充之后如下：</p>
<pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span>
<span class="token doctype">&lt;!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd"></span>

<span class="token comment" spellcheck="true">&lt;!-- mybaits的主配置文件 --></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>
    <span class="token comment" spellcheck="true">&lt;!-- 配置环境 --></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>environments</span> <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mysql<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
        <span class="token comment" spellcheck="true">&lt;!-- 配置Mysql的环境 --></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>environment</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mysql<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
            <span class="token comment" spellcheck="true">&lt;!--  配置事物的类型 --></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transactionManager</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>JDBC<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transactionManager</span><span class="token punctuation">></span></span>
            <span class="token comment" spellcheck="true">&lt;!-- 配置数据源（连接池） --></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataSource</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>POOLED<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
                <span class="token comment" spellcheck="true">&lt;!-- 配置连接数据库的4个基本信息 --></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>driver<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.mysql.jdbc.Driver<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>url<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc:mysql://localhost:3306/mybatis_demo<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataSource</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>environment</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>environments</span><span class="token punctuation">></span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span></code></pre>
<p>截图如下所示：</p>
<p><img src="https://i.loli.net/2020/04/01/LIOaz32UtsfQjbd.png" alt="image.png"></p>
<h2 id="2-4-编写实体类"><a href="#2-4-编写实体类" class="headerlink" title="2.4 编写实体类"></a><strong>2.4 编写实体类</strong></h2><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>garmen<span class="token punctuation">.</span>domain<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> ID<span class="token punctuation">;</span>
    <span class="token keyword">private</span> String NAME<span class="token punctuation">;</span>
    <span class="token keyword">private</span> String PWD<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token keyword">int</span> ID<span class="token punctuation">,</span> String NAME<span class="token punctuation">,</span> String PWD<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>ID <span class="token operator">=</span> ID<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>NAME <span class="token operator">=</span> NAME<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>PWD <span class="token operator">=</span> PWD<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 隐藏geter、seter、toString</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="2-5-编写持久层相关"><a href="#2-5-编写持久层相关" class="headerlink" title="2.5 编写持久层相关"></a><strong>2.5 编写持久层相关</strong></h2><p>其实这一步就是创建持久层Dao接口并且创建其映射文件，并在总的配置文件中进行绑定即可。</p>
<ul>
<li>此处有需要注意的一点就是：持久层接口 必须要和 持久层接口的映射文件的名称保持一致，下面便是一个很好的示范！</li>
</ul>
<h3 id="2-5-1-编写持久层接口-UserDao"><a href="#2-5-1-编写持久层接口-UserDao" class="headerlink" title="2.5.1 编写持久层接口 UserDao"></a><strong>2.5.1 编写持久层接口 UserDao</strong></h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserDao</span> <span class="token punctuation">{</span>

    <span class="token comment" spellcheck="true">/**
     * 查询所有用户
     * @return
     */</span>
    List<span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span></code></pre>
<h3 id="2-5-2-编程持久层接口的映射文件-UserDao-xml"><a href="#2-5-2-编程持久层接口的映射文件-UserDao-xml" class="headerlink" title="2.5.2 编程持久层接口的映射文件 UserDao.xml"></a><strong>2.5.2 编程持久层接口的映射文件 UserDao.xml</strong></h3><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span>
<span class="token doctype">&lt;!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.garmen.dao.UserDao<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token comment" spellcheck="true">&lt;!-- 配置查询所有 --></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>findAll<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.garmen.domain.User<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
        select * from user
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mapper</span><span class="token punctuation">></span></span></code></pre>
<p>需要注意的如下：</p>
<ol>
<li>namespace的路径需要绑定到对应的接口</li>
<li>select标签代表的就是查询语句</li>
<li>select中的id需要和接口中的方法名称相同！！！</li>
<li>resultType代表着返回结果类型，我们要获取所有的User，所以此处为garmen包中的User类。</li>
<li>resultType 需要指定，这个标签不可以不写，不然会报错。</li>
<li>select标签中，填写我们相应的语句。</li>
</ol>
<p>此时目录概括如下：</p>
<p><img src="https://i.loli.net/2020/04/01/LnhbTOKlB2FCmso.png" alt="目录概括.png"></p>
<h3 id="2-5-3-进行接口的绑定"><a href="#2-5-3-进行接口的绑定" class="headerlink" title="2.5.3 进行接口的绑定"></a><strong>2.5.3 进行接口的绑定</strong></h3><p>有一个问题就是，我们刚刚配置完的UserDao.xml添加到哪里呢？</p>
<ul>
<li>添加到SqlMapConfig.xml中，告诉它有这个UserDao.xml 东西！</li>
</ul>
<p>即在SqlMapConfig.xml，进行添加mappers映射，和上面已经填写完成之后的SqlMapConfig.xml 文件进行扩充之后如下：</p>
<pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span>
<span class="token doctype">&lt;!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd"></span>

<span class="token comment" spellcheck="true">&lt;!-- mybaits的主配置文件 --></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>
    <span class="token comment" spellcheck="true">&lt;!-- 配置环境 --></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>environments</span> <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mysql<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
        <span class="token comment" spellcheck="true">&lt;!-- 配置Mysql的环境 --></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>environment</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mysql<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
            <span class="token comment" spellcheck="true">&lt;!--  配置事物的类型 --></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transactionManager</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>JDBC<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transactionManager</span><span class="token punctuation">></span></span>
            <span class="token comment" spellcheck="true">&lt;!-- 配置数据源（连接池） --></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataSource</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>POOLED<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
                <span class="token comment" spellcheck="true">&lt;!-- 配置连接数据库的4个基本信息 --></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>driver<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.mysql.jdbc.Driver<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>url<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc:mysql://localhost:3306/mybatis_demo<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataSource</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>environment</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>environments</span><span class="token punctuation">></span></span>


    <span class="token comment" spellcheck="true">&lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件 --></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mappers</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com/garmen/dao/UserDao.xml<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mapper</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mappers</span><span class="token punctuation">></span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span></code></pre>
<h2 id="2-6-创建测试文件"><a href="#2-6-创建测试文件" class="headerlink" title="2.6 创建测试文件"></a>2.6 创建测试文件</h2><p>根据官网提供给的工具，我们可以进行代码的编写了</p>
<p>其实官网提供的也就是：从XML中构建了 SqlSessionFactory</p>
<p><img src="https://i.loli.net/2020/04/01/NHB5j29XtcOirPY.png" alt="image.png"></p>
<p>然后从已经构建了的 SqlSessionFactory 中获取 SqlSession 的实例。SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。</p>
<p><img src="https://i.loli.net/2020/04/01/SvPAdH63NkQLjME.png" alt="image.png"></p>
<p>在Test目录下创建测试文件，并进行代码填写：</p>
<p><img src="https://i.loli.net/2020/04/01/oXKZYSgDGItnsHd.png" alt="image.png"></p>
<p>代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MybatisTest</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//1、读取配置文件</span>
        InputStream in <span class="token operator">=</span> Resources<span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token string">"SqlMapConfig.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//2、创建SqlSessionFactory工厂</span>
        SqlSessionFactoryBuilder builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SqlSessionFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        SqlSessionFactory factory <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//3、使用工厂生产SqlSeesion对象</span>
        SqlSession session <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//4、使用SqlSession创建Dao接口的代理对象</span>
        UserDao userDao <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span>UserDao<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//5、使用代理对象执行方法</span>
        List<span class="token operator">&lt;</span>User<span class="token operator">></span> users <span class="token operator">=</span> userDao<span class="token punctuation">.</span><span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>User user <span class="token operator">:</span> users<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">//6、释放资源</span>
        session<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        in<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>对于上面的几个看起来怪怪的东西，其实官网都已经给出了解释：</p>
<p><strong>SqlSessionFactoryBuilder</strong>：这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。 你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但最好还是不要一直保留着它，以保证所有的 XML 解析资源可以被释放给更重要的事情。</p>
<p><strong>SqlSessionFactory</strong>：SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏习惯”。因此 SqlSessionFactory 的最佳作用域是应用作用域。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</p>
<p><strong>SqlSession</strong>：每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。 如果你现在正在使用一种 Web 框架，考虑将 SqlSession 放在一个和 HTTP 请求相似的作用域中。 换句话说，每次收到 HTTP 请求，就可以打开一个 SqlSession，返回一个响应后，就关闭它。 这个关闭操作很重要，为了确保每次都能执行关闭操作，你应该把这个关闭操作放到 finally 块中。 下面的示例就是一个确保 SqlSession 关闭的标准模式：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">(</span>SqlSession session <span class="token operator">=</span> sqlSessionFactory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 你的应用逻辑代码</span>
<span class="token punctuation">}</span></code></pre>
<p>还有上面的那个mapper 其实是映射器的原理，这是一个映射器示例，关于映射器是什么意思？官网也很会，他给出的解释如下：</p>
<p><u>映射器是一些绑定映射语句的接口</u>。映射器接口的实例是从 SqlSession 中获得的。虽然从技术层面上来讲，任何映射器实例的最大作用域与请求它们的 SqlSession 相同。但方法作用域才是映射器实例的最合适的作用域。 也就是说，映射器实例应该在调用它们的方法中被获取，使用完毕之后即可丢弃。 映射器实例并不需要被显式地关闭。尽管在整个请求作用域保留映射器实例不会有什么问题，但是你很快会发现，在这个作用域上管理太多像 SqlSession 的资源会让你忙不过来。 因此，最好将映射器放在方法作用域内。就像下面的例子一样：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">(</span>SqlSession session <span class="token operator">=</span> sqlSessionFactory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  BlogMapper mapper <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span>BlogMapper<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 你的应用逻辑代码</span>
<span class="token punctuation">}</span></code></pre>
<p>这些东西当然在后面我会进行深入解释一下的。</p>
<h2 id="2-7-结果显示如下"><a href="#2-7-结果显示如下" class="headerlink" title="2.7 结果显示如下"></a>2.7 结果显示如下</h2><p>Test 所获得的结果如下所示：</p>
<p><img src="https://i.loli.net/2020/04/01/DjIO3RpSJv2zWqi.png" alt="image.png"></p>
<h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h1><p>只要遵循上面的这个做法，程序是可以跑起来并且去查询到我们数据库相关的信息的，这只是一个小Demo，主要是我们可以了解到了Mybatis 原来作用是这样，让Mybatis工作的方式还有很多种，这只是其中一种，关于Demo的展示我应该写得更加细致一点，因为这样比较方便我们进行重新观看的时候一头雾水：我写的究竟是什么东西？？？当然上面也了解到了一些零碎的知识，不理解的东西还有很多，需要接下来一点点展开深入了解一下其内部的机制流程，在接下来的几章会详细展开。</p>
<p>关于这个Demo相关的内容已上传Github：<a href="https://github.com/dongxiem/Mybatis-Study" target="_blank" rel="noopener">https://github.com/dongxiem/Mybatis-Study</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis 框架分析（1） - 总体概述</title>
    <url>/2020/04/01/mybatis-kuang-jia-fen-xi-1-zong-ti-gai-shu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-MyBatis-认识与了解"><a href="#1-MyBatis-认识与了解" class="headerlink" title="1. MyBatis 认识与了解"></a>1. MyBatis 认识与了解</h1><h2 id="1-1-Jdbc的一些认识"><a href="#1-1-Jdbc的一些认识" class="headerlink" title="1.1 Jdbc的一些认识"></a>1.1 Jdbc的一些认识</h2><p>通过 JDBC 来操作数据库，需要以下几个<code>步骤</code>：</p>
<ol>
<li>加载数据库驱动</li>
<li>创建并获取数据库链接</li>
<li>创建 jdbc statement 对象</li>
<li>编写 sql 语句</li>
<li>设置 sql 语句中的参数(使用 <code>preparedStatement</code>)</li>
<li>通过 statement 执行 sql 并获取结果</li>
<li>对 sql 执行结果进行解析处理</li>
<li>释放资源(<code>resultSet</code>、<code>preparedstatement</code>、<code>connection</code>)</li>
</ol>
<p>给出使用JDBC的Demo如下：</p>
<pre class=" language-java"><code class="language-java"></code></pre>
<p>为了解决这么麻烦的一系列步骤，有人就提出来了MyBatis这个框架了！</p>
<hr>
<h2 id="1-2-MyBatis的大概介绍及其特点"><a href="#1-2-MyBatis的大概介绍及其特点" class="headerlink" title="1.2 MyBatis的大概介绍及其特点"></a>1.2 MyBatis的大概介绍及其特点</h2><p>Mybatis 是 JAVA 的一个<code>持久层框架</code>，什么是持久层？持久层就是能够长期保存数据的一层，例如我们的数据写在硬盘上，这说明我们的数据是持久的，如果写在内存当中，我们的数据就是不持久的。</p>
<p>根据官方文档的介绍，MyBatis大概如下：</p>
<ul>
<li>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</li>
</ul>
<p>百度百科总结的挺好，详细讲述了MyBatis的特点，如下：</p>
<ul>
<li>简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个 jar 文件+配置几个 sql 映射文件易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。</li>
<li>灵活：mybatis 不会对应用程序或者数据库的现有设计强加任何影响。sql 写在 xml 里，便于统一管理和优化。通过 sql 语句可以满足操作数据库的所有需求。</li>
<li>解除 sql 与程序代码的耦合：通过提供 DAO 层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql 和代码的分离，提高了可维护性。</li>
<li>提供映射标签，支持对象与数据库的 orm 字段关系映射</li>
<li>提供对象关系映射标签，支持对象关系组建维护</li>
<li>提供 xml 标签，支持编写动态 sql。</li>
</ul>
<hr>
<h1 id="2-Mybatis-总体框架"><a href="#2-Mybatis-总体框架" class="headerlink" title="2.Mybatis 总体框架"></a>2.Mybatis 总体框架</h1><p>MyBatis的总体框架大体如下（图源文末注明出处）：</p>
<p><img src="https://i.loli.net/2020/04/01/duibL3NkmMJGc27.png" alt="MyBatis的总体框架.png"></p>
<p>其实了解Mybatis，可以了解其大体框架就知道它在做什么事情了。</p>
<p>总体流程：</p>
<p><strong>(1)加载配置并初始化</strong></p>
<ul>
<li><strong>触发条件：</strong>加载配置文件</li>
<li>配置来源于两个地方，一处是配置文件，一处是Java代码的注解，将SQL的配置信息加载成为一个个MappedStatement对象（包括了传入参数映射配置、执行的SQL语句、结果映射配置），存储在内存中。</li>
</ul>
<p><strong>(2)接收调用请求</strong></p>
<ul>
<li><strong>触发条件：</strong>调用Mybatis提供的API</li>
<li><strong>传入参数</strong>：为SQL的ID和传入参数对象</li>
<li><strong>处理过程：</strong>将请求传递给下层的数据处理层进行处理。</li>
</ul>
<p><strong>(3)处理操作请求</strong></p>
<ul>
<li><strong>触发条件：</strong>API接口层传递请求过来</li>
<li><strong>传入参数</strong>：为SQL的ID和传入参数对象</li>
<li><strong>处理过程：</strong><ol>
<li>根据SQL的ID查找对应的MappedStatement对象。</li>
<li>根据传入参数对象解析MappedStatement对象，得到最终要执行的SQL和执行传入参数。</li>
<li>获取数据库连接，根据得到的最终SQL语句和执行传入参数到数据库执行，并得到执行结果。</li>
<li>根据MappedStatement对象中的结果映射配置对得到的执行结果进行转换处理，并得到最终的处理结果。</li>
<li>释放连接资源。</li>
</ol>
</li>
</ul>
<p><strong>(4)返回处理结果</strong></p>
<ul>
<li>将最终的处理结果返回。</li>
</ul>
<hr>
<h2 id="2-1-接口层"><a href="#2-1-接口层" class="headerlink" title="2.1 接口层"></a>2.1 接口层</h2><p>所谓的接口层，就是MyBatis和数据库的交互，而MyBatis和数据库的交互大体上有两种方式，分别如下：</p>
<ol>
<li>使用传统的MyBatis提供的API；</li>
<li>使用Mapper接口</li>
</ol>
<h3 id="2-1-1-使用传统的MyBatis提供的API"><a href="#2-1-1-使用传统的MyBatis提供的API" class="headerlink" title="2.1.1 使用传统的MyBatis提供的API"></a>2.1.1 使用传统的MyBatis提供的API</h3><p>这是传统的传递Statement Id 和查询参数给 SqlSession 对象，使用 SqlSession对象完成和数据库的交互；MyBatis 提供了非常方便和简单的API，供用户实现对数据库的增删改查数据操作，以及对数据库连接信息和MyBatis 自身配置信息的维护操作。</p>
<p><img src="https://i.loli.net/2020/04/02/YnPoiOGlMk1Lg53.png" alt="image.png"></p>
<p>上述使用MyBatis 的方法，是创建一个和数据库打交道的SqlSession对象，然后根据Statement Id 和参数来操作数据库，这种方式固然很简单和实用，但是它不符合面向对象语言的概念和面向接口编程的编程习惯。由于面向接口的编程是面向对象的大趋势，MyBatis 为了适应这一趋势，增加了第二种使用MyBatis 支持接口（Interface）调用方式。</p>
<h3 id="2-1-2-使用Mapper接口"><a href="#2-1-2-使用Mapper接口" class="headerlink" title="2.1.2 使用Mapper接口"></a>2.1.2 使用Mapper接口</h3><p>MyBatis 将配置文件中的每一个<code>&lt;mapper&gt;</code> 节点抽象为一个 Mapper 接口，而这个接口中声明的方法和跟<mapper> 节点中的<code>&lt;select|update|delete|insert&gt;</code> 节点项对应，即<code>&lt;select|update|delete|insert&gt;</code> 节点的id值为Mapper 接口中的方法名称，<code>parameterType</code> 值表示Mapper 对应方法的入参类型，而<code>resultMap</code> 值则对应了Mapper 接口表示的返回值类型或者返回结果集的元素类型。</mapper></p>
<p><img src="https://i.loli.net/2020/04/02/OjXWJ6Pw7gySeYU.png" alt="Mapper接口机制.png"></p>
<p>根据<strong>MyBatis</strong> 的配置规范配置好后，通过<code>SqlSession.getMapper(XXXMapper.class)</code> 方法，MyBatis 会根据相应的接口声明的方法信息，通过<strong>动态代理机制</strong>生成一个Mapper 实例，我们使用Mapper 接口的某一个方法时，MyBatis 会根据这个方法的方法名和参数类型，确定Statement Id，底层还是通过<code>SqlSession.select("statementId",parameterObject);</code>或者<code>SqlSession.update("statementId",parameterObject);</code> 等等来实现对数据库的操作<br>MyBatis 引用Mapper 接口这种调用方式，纯粹是为了满足面向接口编程的需要。（其实还有一个原因是在于，面向接口的编程，使得用户在接口上可以使用注解来配置SQL语句，<strong>这样就可以脱离XML配置文件，实现“0配置”</strong>）。</p>
<hr>
<h2 id="2-2-数据处理层"><a href="#2-2-数据处理层" class="headerlink" title="2.2 数据处理层"></a>2.2 数据处理层</h2><p>数据处理层可以说是<strong>MyBatis</strong> 的核心，从大的方面上讲，它要完成两个功能：</p>
<ol>
<li><em>通过传入参数构建动态SQL语句；</em></li>
<li><em>SQL语句的执行以及封装查询结果集成List</em></li>
</ol>
<h3 id="2-2-1-参数映射和动态SQL语句生成"><a href="#2-2-1-参数映射和动态SQL语句生成" class="headerlink" title="2.2.1 参数映射和动态SQL语句生成"></a>2.2.1 <strong>参数映射和动态SQL语句生成</strong></h3><p>动态语句生成可以说是MyBatis框架非常优雅的一个设计，MyBatis通过传入的参数值，使用 <strong>Ognl</strong> 来动态地构造SQL语句，使得MyBatis有很强的灵活性和扩展性。</p>
<p>参数映射指的是对于java 数据类型和jdbc数据类型之间的转换：这里有包括两个过程：</p>
<ul>
<li>查询阶段，我们要将java类型的数据，转换成jdbc类型的数据，通过 preparedStatement.setXXX() 来设值；</li>
<li>另一个就是对resultset查询结果集的jdbcType 数据转换成java 数据类型。</li>
</ul>
<h3 id="2-2-2-SQL语句的执行以及封装查询结果集成List"><a href="#2-2-2-SQL语句的执行以及封装查询结果集成List" class="headerlink" title="2.2.2 SQL语句的执行以及封装查询结果集成List"></a>2.2.2 <strong>SQL语句的执行以及封装查询结果集成List</strong></h3><p>动态SQL语句生成之后，MyBatis 将执行SQL语句，并将可能返回的结果集转换成List 列表。MyBatis 在对结果集的处理中，<strong>支持结果集关系一对多和多对一的转换</strong>，并且有两种支持方式，<strong>一种为嵌套查询语句的查询，还有一种是嵌套结果集的查询</strong>。</p>
<hr>
<h2 id="2-3-框架支撑层"><a href="#2-3-框架支撑层" class="headerlink" title="2.3 框架支撑层"></a>2.3 框架支撑层</h2><p>如上图所示，主要有四种机制，我想接下来可以一一对这些机制进行展开认识一下，都是挺重要的一些机制了。</p>
<h3 id="2-3-1-事务管理机制"><a href="#2-3-1-事务管理机制" class="headerlink" title="2.3.1 事务管理机制"></a>2.3.1 <strong>事务管理机制</strong></h3><p>了解数据库之后，应该都很清楚事务是一个什么东西，对于数据库，事务管理是其非常重要的一个方面，所以Mybatis 也相对应的给出了这个方面的机制。</p>
<p>MyBatis的事务管理分为两种形式：</p>
<ol>
<li><strong>使用JDBC的事务管理机制</strong>：即利用java.sql.Connection对象完成对事务的提交（commit()）、回滚（rollback()）、关闭（close()）等</li>
<li><strong>使用MANAGED的事务管理机制：</strong>这种机制MyBatis自身不会去实现事务管理，而是让程序的容器如（JBOSS，Weblogic）来实现对事务的管理</li>
</ol>
<p>具体查看分析：</p>
<h3 id="2-3-2-连接池管理机制"><a href="#2-3-2-连接池管理机制" class="headerlink" title="2.3.2 连接池管理机制"></a>2.3.2 <strong>连接池管理机制</strong></h3><p>有个疑惑：<strong>为什么要使用连接池？</strong></p>
<p>这是因为创建一个java.sql.Connection对象的代价是如此巨大，创建一个Connection对象的过程，在底层就相当于和数据库建立的通信连接，在建立通信连接的过程，消耗了这么多的时间，而往往我们建立连接后（即创建Connection对象后），就执行一个简单的SQL语句，然后就要抛弃掉，这是一个非常大的资源浪费！</p>
<p>所以聪明的大叔们认为对于需要频繁地跟数据库交互的应用程序，可以在创建了Connection对象，并操作完数据库后，可以不释放掉资源，而是将它放到内存中，当下次需要操作数据库时，可以直接从内存中取出Connection对象，不需要再创建了，这样就极大地节省了创建Connection对象的资源消耗。由于内存也是有限和宝贵的，这又对我们对内存中的Connection对象怎么有效地维护提出了很高的要求。我们将在内存中存放Connection对象的容器称之为 连接池（Connection Pool）。</p>
<p>具体查看分析：</p>
<h3 id="2-3-3-缓存机制"><a href="#2-3-3-缓存机制" class="headerlink" title="2.3.3 缓存机制"></a>2.3.3 <strong>缓存机制</strong></h3><p>所以还是说，计算机的很多方面都是相同的，缓存机制，特别是对于需要查询的一些相关操作，能节省时间尽量节省时间，也就是说为了提高数据利用率和减小服务器和数据库的压力，研究MyBatis 的大叔们会对于一些查询提供会话级别的数据缓存，会将对某一次查询，放置到<strong>SqlSession</strong> 中，在允许的时间间隔内，对于完全相同的查询，MyBatis 会直接将缓存结果返回给用户，而不用再到数据库中查找。</p>
<p>具体查看分析：</p>
<h3 id="2-3-4-SQL语句的配置方式"><a href="#2-3-4-SQL语句的配置方式" class="headerlink" title="2.3.4 SQL语句的配置方式"></a>2.3.4 SQL语句的配置方式</h3><p>传统的MyBatis 配置SQL 语句方式就是使用XML文件进行配置的，但是这种方式不能很好地支持面向接口编程的理念，为了支持面向接口的编程，<strong>MyBatis 引入了Mapper接口的概念</strong>，面向接口的引入，对使用注解来配置SQL 语句成为可能，用户只需要在接口上添加必要的注解即可，不用再去配置XML文件了，但是，目前的MyBatis 只是对注解配置SQL 语句提供了有限的支持，某些高级功能还是要依赖XML配置文件配置SQL 语句。</p>
<hr>
<h2 id="2-4-引导层"><a href="#2-4-引导层" class="headerlink" title="2.4 引导层"></a>2.4 引导层</h2><p><strong>引导层是配置和启动MyBatis 配置信息的方式</strong>。MyBatis 提供两种方式来引导MyBatis ：</p>
<ol>
<li>基于XML配置文件的方式</li>
<li>基于Java API 的方式</li>
</ol>
<hr>
<h1 id="3-主要深入方面"><a href="#3-主要深入方面" class="headerlink" title="3.主要深入方面"></a>3.主要深入方面</h1><p>对于Mybatis 的主要运行方式，给出两种Demo：</p>
<ul>
<li>Mybatis 基于DAO的传统开发方式</li>
<li>Mybatis 基于注解的开发方式</li>
</ul>
<p>再给出Mybatis 完成CRUD 的一个Demo：</p>
<ul>
<li>Mybatis 完成CRUD操作</li>
</ul>
<p>对于Mybatis 框架的整体学习，我主要进行深入了解的是以下几个方面：</p>
<ul>
<li>事务管理机制</li>
<li>连接池管理机制</li>
<li>缓存机制</li>
</ul>
<p>而对于源码的剖析，主要涉及到的是以下几个方面：</p>
<ul>
<li>映射文件的解析过程</li>
<li>配置文件的解析过程</li>
<li>SQL 的执行过程</li>
<li>缓存原理</li>
</ul>
<h1 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h1><p>我想通过这么一个流程系列下来，我对Mybatis 的整个流程机制已经有一定的认识了，但是可能还是有些地方不够深入，还是要多去探究一下，Mybatis 对于开发来说是很重要的一个部分，希望自己在犯错的路上可以少走一些，借助前人的经验才能走得更加长远。</p>
<p>以上参考文章：</p>
<ul>
<li><a href="https://blog.csdn.net/luanlouis/article/details/40422941" target="_blank" rel="noopener">《深入理解mybatis原理》 MyBatis的架构设计以及实例分析</a></li>
<li><a href="https://www.iteye.com/blog/chenjc-it-1460990" target="_blank" rel="noopener">原理分析之二：框架整体设计</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/index.html" target="_blank" rel="noopener">Mybatis 官方文档</a></li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>导页</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - 多线程 线程创建的几种方式</title>
    <url>/2020/04/01/java-bing-fa-duo-xian-cheng-xian-cheng-chuang-jian-de-ji-chong-fang-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>总的来说有两种实现线程的方式：</p>
<ol>
<li><strong>实现Runnable接口</strong></li>
<li><strong>继承Thread类</strong></li>
</ol>
<h1 id="2-几种实现方式详解"><a href="#2-几种实现方式详解" class="headerlink" title="2.几种实现方式详解"></a>2.几种实现方式详解</h1><h2 id="2-1-继承Thread类"><a href="#2-1-继承Thread类" class="headerlink" title="2.1 继承Thread类"></a>2.1 继承Thread类</h2><p>实现：</p>
<ol>
<li>需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。</li>
<li>当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。</li>
</ol>
<p>Demo如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printl</span><span class="token punctuation">(</span><span class="token string">"MyThread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
        Thread myThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        myThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>关于start()方法需要注意的有两点：</p>
<ol>
<li>我们在程序里面调用了start()方法后，虚拟机会先为我们创建一个线程，然后等到这个线程第一次得到时间片时再调用run()方法。</li>
<li>注意不可多次调用start()方法。在第一次调用start()方法后，再次调用start()方法会抛出异常。</li>
</ol>
<p>此处我有两个疑惑，根据平时的积累之后给出了答案，问题如下：</p>
<ol>
<li><strong>start()方法和run()方法的区别？</strong><ul>
<li>只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。</li>
</ul>
</li>
<li><strong>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</strong><ul>
<li>new 一个 Thread，线程进入了新建状态；调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</li>
<li>总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</li>
</ul>
</li>
</ol>
<h2 id="2-2-实现Runnable接口"><a href="#2-2-实现Runnable接口" class="headerlink" title="2.2 实现Runnable接口"></a>2.2 实现Runnable接口</h2><p>实现：</p>
<ul>
<li>需要实现接口中的 run() 方法。</li>
<li>使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 start() 方法来启动线程。</li>
</ul>
<p><code>Runnable</code>是一个函数式接口，这意味着我们可以使用<strong>Java 8的函数式编程</strong>来简化代码。</p>
<p>函数式编程是个什么东西？</p>
<ul>
<li>这是在Java 8 之后才有的，它的声明是通过一个注解来实现的，可以查看Runnable 的接口实现便可知道</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>Demo如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"MyThread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>

        <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// Java 8 之后的函数式编程如下</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
            Ststem<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Java 8 匿名内部类"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="2-3-实现-Callable接口"><a href="#2-3-实现-Callable接口" class="headerlink" title="2.3 实现 Callable接口"></a>2.3 实现 Callable接口</h2><h3 id="2-3-1-Callable接口"><a href="#2-3-1-Callable接口" class="headerlink" title="2.3.1 Callable接口"></a>2.3.1 Callable接口</h3><p>实现：</p>
<ol>
<li>其实也算是实现Runnable接口！</li>
<li>与 Runnable 相比，<strong>Callable 可以有返回值</strong>，返回值通过 <strong>FutureTask</strong> 进行封装。</li>
</ol>
<h3 id="2-3-2-Future接口"><a href="#2-3-2-Future接口" class="headerlink" title="2.3.2 Future接口"></a>2.3.2 Future接口</h3><h3 id="2-3-3-Future-Task类"><a href="#2-3-3-Future-Task类" class="headerlink" title="2.3.3 Future Task类"></a>2.3.3 Future Task类</h3><h4 id="2-3-3-1-什么是FutureTask？"><a href="#2-3-3-1-什么是FutureTask？" class="headerlink" title="2.3.3.1 什么是FutureTask？"></a>2.3.3.1 什么是FutureTask？</h4><h4 id="2-3-3-2-FutureTask如何使用？"><a href="#2-3-3-2-FutureTask如何使用？" class="headerlink" title="2.3.3.2 FutureTask如何使用？"></a>2.3.3.2 FutureTask如何使用？</h4><h4 id="2-3-3-3-FutureTask的实现"><a href="#2-3-3-3-FutureTask的实现" class="headerlink" title="2.3.3.3 FutureTask的实现"></a>2.3.3.3 FutureTask的实现</h4><h4 id="2-3-3-4-FutureTask的几个状态"><a href="#2-3-3-4-FutureTask的几个状态" class="headerlink" title="2.3.3.4 FutureTask的几个状态"></a>2.3.3.4 FutureTask的几个状态</h4><h1 id="3-比较"><a href="#3-比较" class="headerlink" title="3. 比较"></a>3. 比较</h1><h2 id="3-1-实现接口-VS-继承-Thread"><a href="#3-1-实现接口-VS-继承-Thread" class="headerlink" title="3.1 实现接口 VS 继承 Thread"></a>3.1 <strong>实现接口 VS 继承 Thread</strong></h2><p>我理解的实现接口会更好一些，因为：</p>
<ol>
<li>Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；</li>
<li>类可能只要求可执行就行，继承整个 Thread 类开销过大，如果使用线程时不需要使用Thread类的诸多方法，显然使用<code>Runnable</code> 接口更为轻量。</li>
<li><code>Runnable</code> 接口出现更符合面向对象，将线程单独进行对象的封装。</li>
<li><code>Runnable</code> 接口出现，降低了线程对象和线程任务的耦合性。</li>
</ol>
<p>所以总的来说，还是优先使用实现<code>Runnable</code> 接口方式进行线程的实现较为友好。</p>
<h2 id="3-2-Runnable接口和Callable接口的区别？"><a href="#3-2-Runnable接口和Callable接口的区别？" class="headerlink" title="3.2 Runnable接口和Callable接口的区别？"></a>3.2 <strong>Runnable接口和Callable接口的区别？</strong></h2><p>Runnable自Java 1.0以来一直存在，但Callable仅在Java 1.5中引入,目的就是为了来处理Runnable不支持的用例。Runnable 接口不会返回结果或抛出检查异常，但是Callable 接口可以。所以，如果任务不需要返回结果或抛出异常推荐使用 Runnable 接口，这样代码看起来会更加简洁。</p>
<p>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 被线程执行，没有返回值也无法抛出异常</span>
    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>Callable接口中的<strong>call()方法是有返回值的，是一个泛型</strong>，和Future、FutureTask配合可以用来获取异步执行的结果。</p>
<p>这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为<strong>多线程充满着未知性</strong>，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token punctuation">{</span>
   <span class="token comment" spellcheck="true">/**
    * 计算结果，或者在无法这样做的时候抛出异常
    * @return 计算得出的结果
    * @throws 如果无法计算结果，则抛出异常
    */</span>
    V <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>注意：</p>
<ul>
<li><strong>工具类 Executors 可以实现 Runnable 对象和 Callable 对象之间的相互转换</strong>。（<code>Executors.callable（Runnable task）</code>或 <code>Executors.callable（Runnable task，Object resule）</code>）。</li>
</ul>
<h2 id="3-3-Futuretask和callable的区别？"><a href="#3-3-Futuretask和callable的区别？" class="headerlink" title="3.3 Futuretask和callable的区别？"></a>3.3 <strong>Futuretask和callable的区别？</strong></h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - 关于指令重排序的几个疑问</title>
    <url>/2020/03/31/java-bing-fa-guan-yu-zhi-ling-chong-pai-xu-de-ji-ge-yi-wen/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-指令重排序"><a href="#1-指令重排序" class="headerlink" title="1.指令重排序"></a>1.指令重排序</h1><p>计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排。</p>
<p>指令重排一般分为以下三种：</p>
<ol>
<li>编译器优化重排：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序</li>
<li>指令并行重排：现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性(即后一个执行的语句无需依赖前面执行的语句的结果)，处理器可以改变语句对应的机器指令的执行顺序。</li>
<li>内存系统重排： 由于处理器使用缓存和读写缓存冲区，这使得加载(load)和存储(store)操作看上去可能是在乱序执行，因为三级缓存的存在，导致内存与缓存的数据同步存在时间差。</li>
</ol>
<h1 id="2-关于指令重排序的几个问题"><a href="#2-关于指令重排序的几个问题" class="headerlink" title="2.关于指令重排序的几个问题"></a>2.关于指令重排序的几个问题</h1><h2 id="2-1为什么指令重排序可以提高性能？"><a href="#2-1为什么指令重排序可以提高性能？" class="headerlink" title="2.1为什么指令重排序可以提高性能？"></a>2.1为什么指令重排序可以提高性能？</h2><p>简单地说，每一个指令都会包含多个步骤，每个步骤可能使用不同的硬件。因此，流水线技术产生了，它的原理是指令1还没有执行完，就可以开始执行指令2，而不用等到指令1执行结束之后再执行指令2，这样就大大提高了效率。</p>
<ul>
<li><p>举个例子：</p>
<ul>
<li><pre class=" language-java"><code class="language-java">a <span class="token operator">=</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>
d <span class="token operator">=</span> e <span class="token operator">-</span> f<span class="token punctuation">;</span>    </code></pre>
</li>
</ul>
</li>
<li><p>先加载b、c（注意，即有可能先加载b，也有可能先加载c），但是在执行add(b,c)的时候，需要等待b、c装载结束才能继续执行，也就是增加了停顿，那么后面的指令也会依次有停顿,这降低了计算机的执行效率。</p>
</li>
<li><p>为了减少这个停顿，我们可以先加载e和f，然后再去加载add(b,c)，这样做对程序（串行）是没有影响的，但却减少了停顿。既然add(b,c)需要停顿，那还不如去做些有意义的事情。</p>
</li>
</ul>
<p>综上所述，指令重排对于提高CPU处理性能十分必要。虽然由此带来了乱序的问题，但是这点牺牲是值得的。</p>
<h2 id="2-2-那么为什么指令重排会出现问题呢？"><a href="#2-2-那么为什么指令重排会出现问题呢？" class="headerlink" title="2.2 那么为什么指令重排会出现问题呢？"></a>2.2 <strong>那么为什么指令重排会出现问题呢？</strong></h2><p>指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致。所以在多线程下，指令重排序可能会导致一些问题。</p>
<h1 id="3-指令重排序的解决方法"><a href="#3-指令重排序的解决方法" class="headerlink" title="3.指令重排序的解决方法"></a>3.指令重排序的解决方法</h1><p>所以，由此引出了<code>Volatile</code>，在一个知识体系中，进行知识的串联是尤为重要的，这就是有些东西的存在必定存在其相对的意义，知其然，知其所以然，才能更好的进行运用。对于Volatile相关的知识，查看后面的内容。</p>
<hr>
<p>以上引用的博客和文章：</p>
<ol>
<li>书籍：并发编程的艺术</li>
<li>书籍：深入浅出Java多线程</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - Synchronized 与其他一些锁机制的对比</title>
    <url>/2020/03/31/java-bing-fa-synchronized-yu-qi-ta-yi-xie-suo-ji-zhi-de-dui-bi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>我们前面已经 Synchronized 在JDK1.6 进行哪一些方面的优化，通过这些底层的优化之后Synchronized  变得好用了很多，那么它究竟和其他锁机制有什么差别？换种方式说，我在进行编程的过程中，究竟要如何进行选择？什么时候应该选择Synchronized？而什么时候不选用Synchronized而选用其他的锁机制。</p>
<p>总感觉学习了Synchronized之后，对于其内部原理熟悉了，不知道有没有其他人跟我一样困惑，我究竟该何时进行使用它呢？在哪个场景下我该第一时间想到这货？我觉得进行选择还应该先进行对比，将和我们之前学习到的一些同步机制进行联系起来，有对比才有总结，尽量多进行比较，多点思考，才有更深入的理解与认识。</p>
<h1 id="2-区别分析"><a href="#2-区别分析" class="headerlink" title="2.区别分析"></a>2.区别分析</h1><h2 id="2-1-Synchronized-和-Reentrantlock（可重入锁）的联系与区别："><a href="#2-1-Synchronized-和-Reentrantlock（可重入锁）的联系与区别：" class="headerlink" title="2.1 Synchronized 和 Reentrantlock（可重入锁）的联系与区别："></a>2.1 Synchronized 和 Reentrantlock（可重入锁）的联系与区别：</h2><ul>
<li><p><strong>总体而言</strong>：Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。</p>
<ul>
<li>注意：ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。</li>
</ul>
</li>
<li><p><strong>联系</strong>：</p>
<ul>
<li><strong>两者都是可重入锁</strong><ul>
<li>“可重入锁”  概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>区别</strong>：</p>
<ul>
<li><strong>锁的实现：</strong>synchronized 依赖于 JVM ，而 ReentrantLock 依赖于 API。<ul>
<li>synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</li>
</ul>
</li>
<li><strong>性能：</strong>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。 性能已不是选择标准。</li>
<li><strong>ReentrantLock 比 synchronized 增加了一些高级功能：</strong><ol>
<li><strong>等待可中断：</strong>ReentrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li>
<li><strong>公平锁：</strong>ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。 ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的ReentrantLock(boolean fair)构造方法来制定是否是公平的。</li>
<li><strong>锁绑定多个条件：</strong>synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知”，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>使用选择</strong>：<u>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized</u>。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p>
</li>
</ul>
<h2 id="2-2-Synchronized-和-lock-的联系与区别："><a href="#2-2-Synchronized-和-lock-的联系与区别：" class="headerlink" title="2.2 Synchronized 和 lock 的联系与区别："></a>2.2 Synchronized 和 lock 的联系与区别：</h2><ul>
<li><strong>总的来说：</strong>Synchronized是 Java 内置关键字在 Jvm 层面，Lock是个 Java 类。Lock有比 Synchronized 更精确的线程语义和更好的性能。Lock的锁定是通过代码实现的，而Synchronized是在 JVM 层面上实现的。</li>
<li><strong>区别</strong>：<ul>
<li>是否可以获得锁状态：<ul>
<li>synchronized无法判断是否获取锁的状态；</li>
<li>Lock可以判断是否获取到锁，并且可以主动尝试去获取锁。</li>
</ul>
</li>
<li>是否自动释放锁：<ul>
<li>synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)；</li>
<li>Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁。</li>
</ul>
</li>
<li>是否阻塞：<ul>
<li>用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去；</li>
<li>而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了。它的tryLock方法可以非阻塞方式去拿锁。</li>
</ul>
</li>
<li>范围：<ul>
<li>Lock锁的范围有局限性，块范围；</li>
<li>而synchronized可以锁住块、对象、类。</li>
</ul>
</li>
</ul>
</li>
<li><strong>区别小结：</strong>synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）</li>
<li><strong>适用场景：</strong><u>Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题</u>。</li>
</ul>
<h2 id="2-3-Synchronized-和-CAS-联系与区别？"><a href="#2-3-Synchronized-和-CAS-联系与区别？" class="headerlink" title="2.3 Synchronized 和 CAS 联系与区别？"></a>2.3 <strong>Synchronized 和 CAS 联系与区别？</strong></h2><ul>
<li><strong>总括：</strong><u>简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）。</u></li>
<li><strong>使用场景选择</strong>：<ul>
<li>对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</li>
<li>对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</li>
</ul>
</li>
<li><strong>补充</strong>： Java并发编程这个领域中synchronized关键字一直都是元老级的角色，很久之前很多人都会称它为 “重量级锁” 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 偏向锁 和 轻量级锁 以及其它各种优化之后变得在某些情况下并不是那么重了。synchronized的底层实现主要依靠 Lock-Free 的队列，基本思路是 自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - Synchronized 几种使用方式</title>
    <url>/2020/03/31/java-bing-fa-synchronized-ji-chong-shi-yong-fang-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-概括"><a href="#1-概括" class="headerlink" title="1.概括"></a>1.概括</h1><p>Synchronized 可以有几种修饰方法，总体使用如下图所示：</p>
<p><img src="https://i.loli.net/2020/03/31/HiZIwJm32rGoFPv.png" alt="image.png"></p>
<h1 id="2-具体使用"><a href="#2-具体使用" class="headerlink" title="2.具体使用"></a>2.具体使用</h1><h2 id="2-1-修饰代码块"><a href="#2-1-修饰代码块" class="headerlink" title="2.1 修饰代码块"></a>2.1 <strong>修饰代码块</strong></h2><p>指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</p>
<ul>
<li>注意：<u>它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步</u>。和 synchronized 方法一样，synchronized(this)代码块也是锁定当前对象的。synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。这里再提一下：synchronized关键字加到非 static 静态方法上是给对象实例上锁。另外需要注意的是：尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓冲功能！</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// ...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="2-2-修饰实例方法"><a href="#2-2-修饰实例方法" class="headerlink" title="2.2 修饰实例方法"></a>2.2 <strong>修饰实例方法</strong></h2><ul>
<li>作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁。</li>
<li>注意：它和同步代码块一样，作用于同一个对象。</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="2-3-同步一个类"><a href="#2-3-同步一个类" class="headerlink" title="2.3 同步一个类"></a>2.3 <strong>同步一个类</strong></h2><ul>
<li>注意：作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>SynchronizedExample<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// ...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h2 id="2-4-修饰静态方法"><a href="#2-4-修饰静态方法" class="headerlink" title="2.4 修饰静态方法"></a>2.4 <strong>修饰静态方法</strong></h2><p>作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁 。</p>
<ul>
<li>注意：作用于整个类。也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份，所以对该类的所有对象都加了锁）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> synchronzied <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">func</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span></code></pre>
<p>Synchronized 修饰静态方法相当于如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">X</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 修饰静态方法</span>
    <span class="token keyword">synchronized</span><span class="token punctuation">(</span>X<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 临界区</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - Synchronized 原理分析</title>
    <url>/2020/03/31/java-bing-fa-synchronized-yuan-li-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><p>JDK1.6 之后 Synchronized  的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。</p>
<p>Java中的<code>synchronized</code> 的偏向锁、轻量级锁、重量级锁三种形式，分别对应了锁只被一个线程持有、不同线程交替持有锁、多线程竞争锁三种情况。当条件不满足时，锁会按偏向锁-&gt;轻量级锁-&gt;重量级锁 的顺序升级。JVM种的锁也是能降级的，只不过条件很苛刻，可以相当于没有了，策略是为了提高获得锁和释放锁的效率。</p>
<p>所以对Synchronized 的重点分析应该是其升级流程，以前是我觉得So easy，不就这几个状态升上去而已，不过在某天看了 <a href="https://github.com/farmerjohngit/myblog/issues/12" target="_blank" rel="noopener">死磕Synchronized底层实现</a> 之后，发现我还是太嫩了，这才是真正的深入，也许对知识的求知就该如此不断的进行深入，对于Synchronized 还是有很多值得发现的知识，以下记录了学习到的一些笔记，大概对一整个锁的升级流程有了一些认识和了解。</p>
<ul>
<li>锁升级的过程可以具体看该图，大致的流程框架图很清晰（文末已注明出处）</li>
</ul>
<p><img src="https://i.loli.net/2020/03/31/nCGAmlfKqzhjdv1.png" alt="Synchronized锁升级流程图"></p>
<h1 id="2-Synchronized-锁升级流程分析"><a href="#2-Synchronized-锁升级流程分析" class="headerlink" title="2.Synchronized 锁升级流程分析"></a>2.Synchronized 锁升级流程分析</h1><h2 id="2-1-偏向锁"><a href="#2-1-偏向锁" class="headerlink" title="2.1 偏向锁"></a>2.1 <strong>偏向锁</strong></h2><ul>
<li><p><strong>目的：</strong>引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径。但是不同是：轻量级锁在无竞争的情况下使用 <code>CAS</code> 操作去代替使用互斥量，而偏向锁在无竞争的情况下会把整个同步都消除掉。那么偏向锁是如何来减少不必要的<code>CAS</code>操作呢？我们可以查看<code>Mark work</code>的结构就明白了。只需要检查是否为偏向锁、锁标识为以及<code>ThreadID</code>即可。</p>
</li>
<li><ul>
<li>注意：Java并发编程的艺术中是这么讲的：HotSpot[1]的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。</li>
</ul>
</li>
<li><p><strong>定义：</strong>偏向锁的“偏”就是偏心的偏，它的意思是会偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步！关于偏向锁的原理可以查看《深入理解Java虚拟机：JVM高级特性与最佳实践》第二版的13章第三节锁优化。当<code>JVM</code>启用了偏向锁模式（<code>JDK6</code>以上默认开启），新创建对象的Mark Word中的<code>Thread Id</code>为0，说明此时处于可偏向但未偏向任何线程，也叫<strong>做匿名偏向状态(anonymously biased)。</strong></p>
</li>
<li><p><strong>适用场合：</strong>但是对于锁竞争比较激烈的场合，偏向锁就失效了，<strong>因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失</strong>，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。</p>
</li>
<li><p><strong>关闭偏向锁：</strong>偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用<code>JVM</code>参数来关闭延迟：<code>-XX:BiasedLockingStartupDelay</code>=0。如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过<code>JVM</code>参数关闭偏向锁：<code>-XX:-UseBiasedLocking</code>=false，那么程序默认会进入轻量级锁状态。</p>
</li>
</ul>
<h3 id="2-1-1-Mark-Work-结构"><a href="#2-1-1-Mark-Work-结构" class="headerlink" title="2.1.1 Mark Work 结构"></a>2.1.1 Mark Work 结构</h3><p>关于<code>Mark work</code>结构，可以在任何一本关于Java内存结构的书中了解到很详细了，我们主要关注的是下面的几个字段：<code>thread id</code>、lock flag、biased lock flag。</p>
<p><img src="https://i.loli.net/2020/03/31/tBr7NFPumz63acj.png" alt="image.png"></p>
<h3 id="2-1-2-对象创建"><a href="#2-1-2-对象创建" class="headerlink" title="2.1.2 对象创建"></a>2.1.2 对象创建</h3><p>当 <code>JVM</code> 启用了偏向锁模式（1.6以上默认开启），当新创建一个对象的时候，如果该对象所属的class没有关闭偏向锁模式（默认所有class的偏向模式都是是开启的），那新创建对象的<code>mark word</code>将是可偏向状态，此时mark word中的thread id（参见上文偏向状态下的<code>mark word</code>格式）为0，表示未偏向任何线程，也叫做<u>匿名偏向(anonymously biased)</u>。</p>
<h3 id="2-1-3-偏向锁加锁"><a href="#2-1-3-偏向锁加锁" class="headerlink" title="2.1.3 偏向锁加锁"></a>2.1.3 偏向锁加锁</h3><p>对于偏向锁的加锁，主要分为三种不同情况来看：</p>
<ul>
<li><code>case 1</code>：当该对象第一次被线程获得锁的时候，发现是匿名偏向状态（可偏向未锁定），则会用CAS指令，将<code>mark word</code>中的<code>thread id</code>由0改成当前线程Id。如果成功，则代表获得了偏向锁，继续执行同步块中的代码。否则，即<code>CAS</code>竞争锁失败，对象锁已经被其他线程占用，证明当前存在多线程竞争情况，当到达全局安全点（即为<code>safepoint</code>，<code>safepoint</code>是什么可以具体参考这篇文章：<a href="https://blog.csdn.net/iter_zc/article/details/41847887" target="_blank" rel="noopener">聊聊JVM（六）理解JVM的safepoint</a>），将偏向锁撤销，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块；</li>
<li><code>case 2</code>：当被偏向的线程再次进入同步块时，发现锁对象偏向的就是当前线程（对象头Mark Word中Thread Id是当前线程ID），在通过一些额外的检查后（细节见后面的文章），会往当前线程的栈中添加一条Displaced Mark Word为空的Lock Record中，用来统计重入的次数（如图为当对象所处于偏向锁时，当前线程重入3次，线程栈帧中Lock Record记录）。然后继续执行同步块的代码，因为操纵的是线程私有的栈，因此不需要用到CAS指令；由此可见偏向锁模式下，当被偏向的线程再次尝试获得锁时，仅仅进行几个简单的操作就可以了，在这种情况下，synchronized关键字带来的性能开销基本可以忽略。<ul>
<li><img src="https://i.loli.net/2020/03/31/AtEPUg6GSiOurk3.png" alt="线程栈帧"></li>
</ul>
</li>
<li>case 3.当其他线程进入同步块时，发现已经有偏向的线程了，则会进入到撤销偏向锁的逻辑里，一般来说，会在<code>safepoint</code>中去查看偏向的线程是否还存活，如果存活且还在同步块中则将锁升级为轻量级锁，原偏向的线程继续拥有锁，当前线程则走入到锁升级的逻辑里；如果偏向的线程已经不存活或者不在同步块中，则将对象头的<code>mark word</code>改为无锁状态（<code>unlocked</code>），之后再升级为轻量级锁。</li>
</ul>
<p>由此可见，偏向锁升级的时机为：当锁已经发生偏向后，只要有另一个线程尝试获得偏向锁，则该偏向锁就会升级成轻量级锁。当然这个说法不绝对，因为还有批量重偏向这一机制。</p>
<h3 id="2-1-4-偏向锁解锁"><a href="#2-1-4-偏向锁解锁" class="headerlink" title="2.1.4 偏向锁解锁"></a>2.1.4 偏向锁解锁</h3><p>当有其他线程尝试获得锁时，是根据遍历偏向线程的<code>lock record</code>来确定该线程是否还在执行同步块中的代码。因此偏向锁的解锁很简单，仅仅将栈中的最近一条<code>lock record</code>的obj字段设置为null。需要注意的是，偏向锁的解锁步骤中并不会修改对象头中的<code>thread id</code>。</p>
<h3 id="2-1-5-偏向锁获取锁"><a href="#2-1-5-偏向锁获取锁" class="headerlink" title="2.1.5 偏向锁获取锁"></a>2.1.5 偏向锁获取锁</h3><p><strong>取自Java并发编程的艺术：</strong></p>
<ol>
<li>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行<code>CAS</code>操作来加锁和解锁，只需简单地测试一下对象头的<code>Mark Word</code>里是否存储着指向当前线程的偏向锁。</li>
<li>如果测试成功，表示线程已经获得了锁。</li>
<li>如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS<code>竞争</code>锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程</li>
</ol>
<p>网上参考了很多文章，发现说辞不一，十分混乱，大部分都各持己见，这让我看得很晕乎，于是还是更相信底层代码的逻辑，查看官方提供给的 JVM 底层C++代码： <a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/interpreter/bytecodeInterpreter.cpp#l1816" target="_blank" rel="noopener">bytecodeInterpreter.cpp#1816</a>，结合 <a href="https://github.com/farmerjohngit/myblog" target="_blank" rel="noopener">farmerjohngit</a> 大佬所给的一些解释，可以对整个底层实现有更加深刻的理解。</p>
<pre class=" language-c++"><code class="language-c++">CASE(_monitorenter): {
  // lockee 就是锁对象
  oop lockee = STACK_OBJECT(-1);
  // derefing's lockee ought to provoke implicit null check
  CHECK_NULL(lockee);
  // code 1：找到一个空闲的Lock Record
  BasicObjectLock* limit = istate->monitor_base();
  BasicObjectLock* most_recent = (BasicObjectLock*) istate->stack_base();
  BasicObjectLock* entry = NULL;
  while (most_recent != limit ) {
    if (most_recent->obj() == NULL) entry = most_recent;
    else if (most_recent->obj() == lockee) break;
    most_recent++;
  }
  //entry不为null，代表还有空闲的Lock Record
  if (entry != NULL) {
    // code 2：将Lock Record的obj指针指向锁对象
    entry->set_obj(lockee);
    int success = false;
    uintptr_t epoch_mask_in_place = (uintptr_t)markOopDesc::epoch_mask_in_place;
    // markoop即对象头的mark word
    markOop mark = lockee->mark();
    intptr_t hash = (intptr_t) markOopDesc::no_hash;
    // code 3：如果锁对象的mark word的状态是偏向模式
    if (mark->has_bias_pattern()) {
      uintptr_t thread_ident;
      uintptr_t anticipated_bias_locking_value;
      thread_ident = (uintptr_t)istate->thread();
     // code 4：这里有几步操作，下文分析
      anticipated_bias_locking_value =
        (((uintptr_t)lockee->klass()->prototype_header() | thread_ident) ^ (uintptr_t)mark) &
        ~((uintptr_t) markOopDesc::age_mask_in_place);
     // code 5：如果偏向的线程是自己且epoch等于class的epoch
      if  (anticipated_bias_locking_value == 0) {
        // already biased towards this thread, nothing to do
        if (PrintBiasedLockingStatistics) {
          (* BiasedLocking::biased_lock_entry_count_addr())++;
        }
        success = true;
      }
       // code 6：如果偏向模式关闭，则尝试撤销偏向锁
      else if ((anticipated_bias_locking_value & markOopDesc::biased_lock_mask_in_place) != 0) {
        markOop header = lockee->klass()->prototype_header();
        if (hash != markOopDesc::no_hash) {
          header = header->copy_set_hash(hash);
        }
        // 利用CAS操作将mark word替换为class中的mark word
        if (Atomic::cmpxchg_ptr(header, lockee->mark_addr(), mark) == mark) {
          if (PrintBiasedLockingStatistics)
            (*BiasedLocking::revoked_lock_entry_count_addr())++;
        }
      }
         // code 7：如果epoch不等于class中的epoch，则尝试重偏向
      else if ((anticipated_bias_locking_value & epoch_mask_in_place) !=0) {
        // 构造一个偏向当前线程的mark word
        markOop new_header = (markOop) ( (intptr_t) lockee->klass()->prototype_header() | thread_ident);
        if (hash != markOopDesc::no_hash) {
          new_header = new_header->copy_set_hash(hash);
        }
        // CAS替换对象头的mark word  
        if (Atomic::cmpxchg_ptr((void*)new_header, lockee->mark_addr(), mark) == mark) {
          if (PrintBiasedLockingStatistics)
            (* BiasedLocking::rebiased_lock_entry_count_addr())++;
        }
        else {
          // 重偏向失败，代表存在多线程竞争，则调用monitorenter方法进行锁升级
          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);
        }
        success = true;
      }
      else {
         // 走到这里说明当前要么偏向别的线程，要么是匿名偏向（即没有偏向任何线程）
           // code 8：下面构建一个匿名偏向的mark word，尝试用CAS指令替换掉锁对象的mark word
        markOop header = (markOop) ((uintptr_t) mark & ((uintptr_t)markOopDesc::biased_lock_mask_in_place |(uintptr_t)markOopDesc::age_mask_in_place |epoch_mask_in_place));
        if (hash != markOopDesc::no_hash) {
          header = header->copy_set_hash(hash);
        }
        markOop new_header = (markOop) ((uintptr_t) header | thread_ident);
        // debugging hint
        DEBUG_ONLY(entry->lock()->set_displaced_header((markOop) (uintptr_t) 0xdeaddead);)
        if (Atomic::cmpxchg_ptr((void*)new_header, lockee->mark_addr(), header) == header) {
           // CAS修改成功
          if (PrintBiasedLockingStatistics)
            (* BiasedLocking::anonymously_biased_lock_entry_count_addr())++;
        }
        else {
          // 如果修改失败说明存在多线程竞争，所以进入monitorenter方法
          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);
        }
        success = true;
      }
    }

    // 如果偏向线程不是当前线程或没有开启偏向模式等原因都会导致success==false
    if (!success) {
      // 轻量级锁的逻辑
      //code 9: 构造一个无锁状态的Displaced Mark Word，并将Lock Record的lock指向它
      markOop displaced = lockee->mark()->set_unlocked();
      entry->lock()->set_displaced_header(displaced);
      //如果指定了-XX:+UseHeavyMonitors，则call_vm=true，代表禁用偏向锁和轻量级锁
      bool call_vm = UseHeavyMonitors;
      // 利用CAS将对象头的mark word替换为指向Lock Record的指针
      if (call_vm || Atomic::cmpxchg_ptr(entry, lockee->mark_addr(), displaced) != displaced) {
        // 判断是不是锁重入
        if (!call_vm && THREAD->is_lock_owned((address) displaced->clear_lock_bits())) {        //code 10: 如果是锁重入，则直接将Displaced Mark Word设置为null
          entry->lock()->set_displaced_header(NULL);
        } else {
          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);
        }
      }
    }
    UPDATE_PC_AND_TOS_AND_CONTINUE(1, -1);
  } else {
    // lock record不够，重新执行
    istate->set_msg(more_monitors);
    UPDATE_PC_AND_RETURN(0); // Re-execute
  }
}</code></pre>
<p>JVM中的每个类也有一个类似mark word的prototype_header，用来标记该class的epoch和偏向开关等信息。上面的代码中<code>lockee-&gt;klass()-&gt;prototype_header()</code>即获取class的prototype_header。</p>
<p><code>code 1</code></p>
<ul>
<li>从当前线程的栈中找到一个空闲的<code>Lock Record</code>（<strong>即代码中的BasicObjectLock，下文都用Lock Record代指</strong>），判断<code>Lock Record</code>是否空闲的依据是其obj字段 是否为null。注意这里是按内存地址从低往高找到最后一个可用的<code>Lock Record</code>，换而言之，就是找到内存地址最高的可用<code>Lock Record</code>。</li>
</ul>
<p><code>code 2</code></p>
<ul>
<li>获取到<code>Lock Record</code>后，首先要做的就是为其obj字段赋值。</li>
</ul>
<p><code>code 3</code></p>
<ul>
<li>判断锁对象的<code>mark word</code>是否是偏向模式，即低3位是否为101。</li>
</ul>
<p><code>code 4</code></p>
<ul>
<li>这里有几步位运算的操作<code>anticipated_bias_locking_value = (((uintptr_t)lockee-&gt;klass()-&gt;prototype_header() | thread_ident) ^ (uintptr_t)mark) &amp;  ~((uintptr_t) markOopDesc::age_mask_in_place);</code> 这个位运算可以分为3个部分。<ul>
<li>第一部分<code>((uintptr_t)lockee-&gt;klass()-&gt;prototype_header() | thread_ident)</code> 将当前线程id和类的prototype_header相或，这样得到的值为（当前线程id + prototype_header中的（epoch + 分代年龄 + 偏向锁标志 + 锁标志位）），注意prototype_header的分代年龄那4个字节为0</li>
<li>第二部分 <code>^ (uintptr_t)mark</code> 将上面计算得到的结果与锁对象的markOop进行异或，相等的位全部被置为0，只剩下不相等的位。</li>
<li>第三部分 <code>&amp; ~((uintptr_t) markOopDesc::age_mask_in_place)</code> markOopDesc::age_mask_in_place为…0001111000,取反后，变成了…1110000111,除了分代年龄那4位，其他位全为1；将取反后的结果再与上面的结果相与，将上面异或得到的结果中分代年龄给忽略掉。</li>
</ul>
</li>
</ul>
<p><code>code 5</code></p>
<ul>
<li><code>anticipated_bias_locking_value==0</code>代表偏向的线程是当前线程且<code>mark word</code>的epoch等于class的epoch，这种情况下什么都不用做。</li>
</ul>
<p><code>code 6</code></p>
<ul>
<li><p><code>(anticipated_bias_locking_value &amp; markOopDesc::biased_lock_mask_in_place) != 0</code>代表class的prototype_header或对象的<code>mark word</code>中偏向模式是关闭的，又因为能走到这已经通过了<code>mark-&gt;has_bias_pattern()</code>判断，即对象的<code>mark word</code>中偏向模式是开启的，那也就是说class的prototype_header不是偏向模式。</p>
</li>
<li><p>然后利用<code>CAS</code>指令<code>Atomic::cmpxchg_ptr(header, lockee-&gt;mark_addr(), mark) == mark</code>撤销偏向锁，我们知道<code>CAS</code>会有几个参数，1是预期的原值，2是预期修改后的值 ，3是要修改的对象，与之对应，<code>cmpxchg_ptr</code>方法第一个参数是预期修改后的值，第2个参数是修改的对象，第3个参数是预期原值，方法返回实际原值，如果等于预期原值则说明修改成功。</p>
</li>
</ul>
<p><code>code 7</code></p>
<ul>
<li>如果epoch已过期，则需要重偏向，利用CAS指令将锁对象的<code>mark word</code>替换为一个偏向当前线程且epoch为类的epoch的新的<code>mark word</code>。</li>
</ul>
<p><code>code 8</code></p>
<ul>
<li>CAS将偏向线程改为当前线程，如果当前是匿名偏向则能修改成功，否则进入锁升级的逻辑。</li>
</ul>
<p><code>code 9</code></p>
<ul>
<li>这一步已经是轻量级锁的逻辑了。从上图的<code>mark word</code>的格式可以看到，轻量级锁中<code>mark word</code>存的是指向<code>Lock Record</code>的指针。这里构造一个无锁状态的<code>mark word</code>，然后存储到<code>Lock Record</code>（<code>Lock Record</code>的格式可以看第一篇文章）。设置<code>mark word</code>是无锁状态的原因是：轻量级锁解锁时是将对象头的<code>mark word</code>设置为<code>Lock Record</code>中的<code>Displaced Mark Word</code>，所以创建时设置为无锁状态，解锁时直接用CAS替换就好了。</li>
</ul>
<p><code>code 10</code></p>
<ul>
<li>如果是锁重入，则将<code>Lock Record</code>的<code>Displaced Mark Word</code>设置为null，起到一个锁重入计数的作用。</li>
</ul>
<p>通过这部分代码，其实可以对偏向锁加锁的流程（包括部分轻量级锁的加锁流程）有一定的认识了，如果当前锁已偏向其他线程||epoch值过期||偏向模式关闭||获取偏向锁的过程中存在并发冲突，都会进入到<code>InterpreterRuntime::monitorenter</code>方法， 在该方法中会对偏向锁撤销和升级。</p>
<h3 id="2-1-6-偏向锁释放"><a href="#2-1-6-偏向锁释放" class="headerlink" title="2.1.6 偏向锁释放"></a>2.1.6 偏向锁释放</h3><p>偏向锁的释放入口：<a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/interpreter/bytecodeInterpreter.cpp#l1923" target="_blank" rel="noopener">bytecodeInterpreter.cpp#1923</a></p>
<p>上面的代码结合注释理解起来应该不难，偏向锁的释放很简单，只要将对应Lock Record释放就好了，而轻量级锁则需要将Displaced Mark Word替换到对象头的mark word中。如果CAS失败或者是重量级锁则进入到<code>InterpreterRuntime::monitorexit</code>方法中。</p>
<ul>
<li>注意：撤销是指在获取偏向锁的过程因为不满足条件导致要将锁对象改为非偏向锁状态；释放是指退出同步块时的过程</li>
</ul>
<h3 id="2-1-7-偏向锁撤销"><a href="#2-1-7-偏向锁撤销" class="headerlink" title="2.1.7 偏向锁撤销"></a>2.1.7 偏向锁撤销</h3><p>偏向锁的撤销采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）。其步骤如下：</p>
<ol>
<li>暂停拥有偏向锁的线程，检查持有偏向锁的线程状态（遍历当前<code>JVM</code>的所有线程，如果能找到，则说明偏向的线程还存活）；<code>JVM</code>维护了一个集合存放所有存活的线程，通过遍历该集合判断某个线程是否存活。</li>
<li>如果线程还存活，则检查线程是否在执行同步代码块中的代码，如果是，则升级为轻量级锁，进行CAS竞争锁；<ul>
<li>注：每次进入同步块（即执行<code>monitorenter</code>）的时候都会以从高往低的顺序在栈中找到第一个可用的<code>Lock Record</code>，并设置偏向线程ID；每次解锁（即执行<code>monitorexit</code>）的时候都会从最低的一个<code>Lock Record</code>移除。所以如果能找到对应的Lock Record说明偏向的线程还在执行同步代码块中的代码。</li>
</ul>
</li>
<li>如果持有偏向锁的线程未存活，或者持有偏向锁的线程未在执行同步代码块中的代码，则进行校验是否允许重偏向：<ul>
<li>如果不允许重偏向，则撤销偏向锁，将<code>Mark Word</code>设置为无锁状态（未锁定不可偏向状态），然后升级为轻量级锁，进行CAS<code>竞争</code>锁；</li>
<li>如果允许重偏向，设置为匿名偏向锁状态,<code>CAS</code>将偏向锁重新指向线程A（在对象头和线程栈帧的锁记录中存储当前线程ID）；</li>
</ul>
</li>
<li>唤醒暂停的线程，从安全点继续执行代码。</li>
</ol>
<p>偏向锁撤销的具体流程如下所示：</p>
<p><img src="https://i.loli.net/2020/03/31/EUIOaiTgNluLqzw.png" alt="偏向锁撤销流程图"></p>
<p>偏向锁撤销的具体底层代码分析如下：</p>
<h3 id="2-1-8-批量重偏向与撤销"><a href="#2-1-8-批量重偏向与撤销" class="headerlink" title="2.1.8 批量重偏向与撤销"></a>2.1.8 批量重偏向与撤销</h3><p>JVM中还增加了一种批量重偏向/撤销的机制，主要是解决如下两种情况：</p>
<ol>
<li>重偏向（<code>bulk rebias</code>）机制解决的场景：一个线程创建了大量对象并执行了初始的同步操作，之后在另一个线程中将这些对象作为锁进行之后的操作。这种case下，会导致大量的偏向锁撤销操作。</li>
<li>批量撤销（<code>bulk revoke</code>）解决的场景：存在明显多线程竞争的场景下使用偏向锁是不合适的，例如生产者/消费者队列。</li>
</ol>
<h2 id="2-2-轻量级锁"><a href="#2-2-轻量级锁" class="headerlink" title="2.2 轻量级锁"></a>2.2 轻量级锁</h2><ul>
<li><strong>描述：</strong>倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)。== 轻量级锁不是为了代替重量级锁，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量。== 另外，轻量级锁的加锁和解锁都用到了CAS操作。 关于轻量级锁的加锁和解锁的原理可以查看《深入理解Java虚拟机：JVM高级特性与最佳实践》第二版的13章第三节锁优化。</li>
<li><strong>轻量级锁能够提升程序同步性能的依据：</strong>“对于绝大部分锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用 <code>CAS</code> 操作避免了使用互斥操作的开销。但如果存在锁竞争，除了互斥量开销外，还会额外发生<code>CAS</code>操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁！</li>
</ul>
<h3 id="2-2-1-轻量级锁获取锁"><a href="#2-2-1-轻量级锁获取锁" class="headerlink" title="2.2.1 轻量级锁获取锁"></a>2.2.1 轻量级锁获取锁</h3><p>其获取锁步骤如下：</p>
<ol>
<li>判断当前对象是否处于无锁状态（<code>hashcode</code>、0、01），若是，则JVM首先将在当前线程的栈帧中建立一个名为锁记录（<code>Lock Record</code>）的空间，用于存储锁对象目前的Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即<code>Displaced Mark Word</code>）；否则执行步骤（3）；</li>
<li><code>JVM</code>利用<code>CAS</code>操作尝试将对象的<code>Mark Word</code>更新为指向<code>Lock Record</code>的指正，如果成功表示竞争到锁，则将锁标志位变成00（表示此对象处于轻量级锁状态），执行同步操作；如果失败则执行步骤（3）；</li>
<li>判断当前对象的<code>Mark Word</code>是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态；</li>
</ol>
<p>栈帧 与 <code>Mark Work</code> 关系图示如下：</p>
<p><img src="https://i.loli.net/2020/03/31/pKTxoGV4clYetOL.png" alt="image.png"></p>
<p>整体流程图示如下：</p>
<p><img src="https://i.loli.net/2020/03/31/dCB5fQcuU49j3Pn.png" alt="image.png"></p>
<p>轻量级锁的锁获取源码：</p>
<h3 id="2-2-2-轻量级锁释放锁"><a href="#2-2-2-轻量级锁释放锁" class="headerlink" title="2.2.2 轻量级锁释放锁"></a>2.2.2 轻量级锁释放锁</h3><p>其释放锁步骤如下（轻量级锁的释放也是通过CAS操作来进行的）：</p>
<ol>
<li>取出在获取轻量级锁保存在<code>Displaced Mark Word</code>中的数据；</li>
<li>用<code>CAS</code>操作将取出的数据替换当前对象的<code>Mark Word</code>中，如果成功，则说明释放锁成功，否则执行（3）；</li>
<li>如果<code>CAS</code>操作替换失败，说明有其他线程尝试获取该锁，则需要在释放锁的同时需要唤醒被挂起的线程。</li>
</ol>
<p>其过程流程图如下所示：</p>
<p><img src="https://i.loli.net/2020/03/31/8WLE1HjunDXfxJO.png" alt="轻量级锁释放锁.png"></p>
<h3 id="2-2-3-轻量级锁膨胀"><a href="#2-2-3-轻量级锁膨胀" class="headerlink" title="2.2.3 轻量级锁膨胀"></a>2.2.3 轻量级锁膨胀</h3><p>其过程流程图如下所示</p>
<p><img src="https://i.loli.net/2020/03/31/QZesVDEtJqmHl9C.png" alt="轻量级锁膨胀.png"></p>
<ul>
<li><strong>一个问题：为什么在撤销轻量级锁的时候会有失败的可能？</strong><ul>
<li>假设<code>thread1</code>拥有了轻量级锁，Mark Word指向<code>thread1</code>栈帧，<code>thread2</code>请求锁的时候，就会膨胀初始化<code>ObjectMonitor</code>对象，将Mark Word更新为指向<code>ObjectMonitor</code>的指针，那么在thread1退出的时候，<code>CAS</code>操作会失败，因为Mark Word不再指向<code>thread1</code>的栈帧，这个时候<code>thread1</code>自旋等待<code>infalte</code>完毕，执行重量级锁的退出操作</li>
</ul>
</li>
</ul>
<h2 id="2-3-自旋锁和自适应自旋"><a href="#2-3-自旋锁和自适应自旋" class="headerlink" title="2.3 自旋锁和自适应自旋"></a>2.3 <strong>自旋锁和自适应自旋</strong></h2><h3 id="2-3-1-自旋锁"><a href="#2-3-1-自旋锁" class="headerlink" title="2.3.1 自旋锁"></a>2.3.1 自旋锁</h3><ul>
<li><strong>描述：</strong>一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的。 所以，虚拟机的开发团队就这样去考虑：“我们能不能让后面来的请求获取锁的线程等待一会而不被挂起呢？看看持有锁的线程是否很快就会释放锁”。为了让一个线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就叫做自旋。<ul>
<li>百度百科对自旋锁的解释：何谓自旋锁？它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。</li>
</ul>
</li>
<li><strong>使用时机：</strong>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。<ul>
<li>互斥同步对性能最大的影响就是阻塞的实现，因为挂起线程/恢复线程的操作都需要转入内核态中完成（用户态转换到内核态会耗费时间）。</li>
</ul>
</li>
<li><strong>关闭与开启：</strong>自旋锁在 <code>JDK1.6</code> 之前其实就已经引入了，不过是默认关闭的，需要通过<code>--XX:+UseSpinning</code>参数来开启。<code>JDK1.6</code>及1.6之后，就改为默认开启的了。需要注意的是：自旋等待不能完全替代阻塞，因为它还是要占用处理器时间。如果锁被占用的时间短，那么效果当然就很好了！反之，相反！自旋等待的时间必须要有限度。如果自旋超过了限定次数任然没有获得锁，就应该挂起线程。自旋次数的默认值是10次，用户可以修改-<code>-XX:PreBlockSpin</code>来更改。</li>
</ul>
<h3 id="2-3-2-自适应自旋锁："><a href="#2-3-2-自适应自旋锁：" class="headerlink" title="2.3.2 自适应自旋锁："></a>2.3.2 <strong>自适应自旋锁：</strong></h3><ul>
<li>描述：在 JDK1.6 中引入了自适应的自旋锁。自适应的自旋锁带来的改进就是：自旋的时间不再固定了，而是和前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定，虚拟机变得越来越“聪明”了。</li>
<li>实现原理：它怎么做呢？线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。 有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测会越来越准确，虚拟机会变得越来越聪明。</li>
</ul>
<h2 id="2-4-重量级锁"><a href="#2-4-重量级锁" class="headerlink" title="2.4 重量级锁"></a>2.4 重量级锁</h2><ul>
<li>描述：重量级锁通过对象内部的监视器（<code>monitor</code>）实现，其中<code>monitor</code>的本质是依赖于底层操作系统的<code>Mutex Lock</code>实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</li>
</ul>
<h1 id="3-Synchronized-的其他细节问题"><a href="#3-Synchronized-的其他细节问题" class="headerlink" title="3.Synchronized 的其他细节问题"></a>3.Synchronized 的其他细节问题</h1><h1 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h1><h2 id="4-1-总结锁的升级流程："><a href="#4-1-总结锁的升级流程：" class="headerlink" title="4.1 总结锁的升级流程："></a>4.1 总结锁的升级流程：</h2><p>每一个线程在准备获取共享资源时： </p>
<ol>
<li>第一步：检查<code>MarkWord</code>里面是不是放的自己的<code>ThreadId</code> ,如果是，表示当前线程是处于 “偏向锁” 。  </li>
<li>第二步：如果<code>MarkWord</code>不是自己的<code>ThreadId</code>，锁升级，这时候，使用<code>CAS</code>来执行切换，新的线程根据<code>MarkWord</code>里面现有的<code>ThreadId</code>，通知之前线程暂停，之前线程将<code>Markword</code>的内容置为空。</li>
<li>第三步：两个线程都把锁对象的<code>HashCode</code>复制到自己新建的用于存储锁的记录空间，接着开始通过<code>CAS</code>操作， 把锁对象的<code>MarKword</code>的内容修改为自己新建的记录空间的地址的方式竞争<code>MarkWord</code>。  </li>
<li>第四步：第三步中成功执行<code>CAS</code>的获得资源，失败的则进自旋 。</li>
<li>第五步：自旋的线程在自旋过程中，成功获得资源(即之前获的资源的线程执行完成并释放了共享资源)，则整个状态依然处于轻量级锁的状态，如果自旋失败进入第六步 。</li>
<li>第六步：进行重量级锁的状态，这个时候，自旋的线程进行阻塞，等待之前线程执行完成并唤醒自己。</li>
</ol>
<h2 id="4-2-几种锁的优缺点对比"><a href="#4-2-几种锁的优缺点对比" class="headerlink" title="4.2 几种锁的优缺点对比"></a>4.2 几种锁的优缺点对比</h2><p>下图摘自：并发编程的艺术</p>
<p><img src="https://i.loli.net/2020/03/31/8U6mNSjGLeKMrEB.png" alt="image.png"></p>
<p>以上参考文章：</p>
<ul>
<li><a href="https://blog.dreamtobe.cn/2015/11/13/java_synchronized/" target="_blank" rel="noopener">Java Synchronised机制</a></li>
<li><a href="https://github.com/farmerjohngit/myblog/issues/13" target="_blank" rel="noopener">死磕Synchronized底层实现–偏向锁</a></li>
<li><a href="https://blog.csdn.net/iter_zc/article/details/41847887" target="_blank" rel="noopener">聊聊JVM（六）理解JVM的safepoint</a></li>
<li><a href="http://cmsblogs.com/?p=2071" target="_blank" rel="noopener">【死磕Java并发】—–深入分析synchronized的实现原理</a></li>
<li>书籍：Java 并发编程的艺术</li>
<li>书籍：深入理解Java虚拟机：JVM高级特性与最佳实践</li>
<li>书籍：深入浅出Java 多线程</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础 - Static关键字的一些认识</title>
    <url>/2020/03/31/java-ji-chu-static-guan-jian-zi-de-yi-xie-ren-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java基础知识</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础 - 关于Object的一些认识</title>
    <url>/2020/03/31/java-ji-chu-guan-yu-object-de-yi-xie-ren-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java基础知识</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础 - Int和Integer的一些认识</title>
    <url>/2020/03/31/java-ji-chu-int-he-integer-de-yi-xie-ren-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java基础知识</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础 - String的一些认识</title>
    <url>/2020/03/31/java-ji-chu-string-de-yi-xie-ren-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java基础知识</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础 - Java8的一些认识</title>
    <url>/2020/03/31/java-ji-chu-java8-de-yi-xie-ren-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java基础知识</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础 - 关于序列化的一些认识</title>
    <url>/2020/03/31/java-ji-chu-guan-yu-xu-lie-hua-de-yi-xie-ren-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java基础知识</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础 - 关于泛型的一些认识</title>
    <url>/2020/03/31/java-ji-chu-guan-yu-fan-xing-de-yi-xie-ren-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java基础知识</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础 - 一些认识与思考</title>
    <url>/2020/03/31/java-ji-chu-yi-xie-ren-shi-yu-si-kao/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java基础知识</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础 - 关于反射的一些认识</title>
    <url>/2020/03/31/java-ji-chu-guan-yu-fan-she-de-yi-xie-ren-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java基础知识</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - 深入线程池原理</title>
    <url>/2020/03/31/java-bing-fa-shen-ru-xian-cheng-chi-yuan-li/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-指令重排序"><a href="#1-指令重排序" class="headerlink" title="1.指令重排序"></a>1.指令重排序</h1><p>计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排。</p>
<p>指令重排一般分为以下三种：</p>
<ol>
<li>编译器优化重排：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序</li>
<li>指令并行重排：现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性(即后一个执行的语句无需依赖前面执行的语句的结果)，处理器可以改变语句对应的机器指令的执行顺序。</li>
<li>内存系统重排： 由于处理器使用缓存和读写缓存冲区，这使得加载(load)和存储(store)操作看上去可能是在乱序执行，因为三级缓存的存在，导致内存与缓存的数据同步存在时间差。</li>
</ol>
<h1 id="2-关于指令重排序的几个问题"><a href="#2-关于指令重排序的几个问题" class="headerlink" title="2.关于指令重排序的几个问题"></a>2.关于指令重排序的几个问题</h1><h2 id="2-1为什么指令重排序可以提高性能？"><a href="#2-1为什么指令重排序可以提高性能？" class="headerlink" title="2.1为什么指令重排序可以提高性能？"></a>2.1为什么指令重排序可以提高性能？</h2><p>简单地说，每一个指令都会包含多个步骤，每个步骤可能使用不同的硬件。因此，流水线技术产生了，它的原理是指令1还没有执行完，就可以开始执行指令2，而不用等到指令1执行结束之后再执行指令2，这样就大大提高了效率。</p>
<ul>
<li><p>举个例子：</p>
<ul>
<li><pre class=" language-java"><code class="language-java">a <span class="token operator">=</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>
d <span class="token operator">=</span> e <span class="token operator">-</span> f<span class="token punctuation">;</span>    </code></pre>
</li>
</ul>
</li>
<li><p>先加载b、c（注意，即有可能先加载b，也有可能先加载c），但是在执行add(b,c)的时候，需要等待b、c装载结束才能继续执行，也就是增加了停顿，那么后面的指令也会依次有停顿,这降低了计算机的执行效率。</p>
</li>
<li><p>为了减少这个停顿，我们可以先加载e和f，然后再去加载add(b,c)，这样做对程序（串行）是没有影响的，但却减少了停顿。既然add(b,c)需要停顿，那还不如去做些有意义的事情。</p>
</li>
</ul>
<p>综上所述，指令重排对于提高CPU处理性能十分必要。虽然由此带来了乱序的问题，但是这点牺牲是值得的。</p>
<h2 id="2-2-那么为什么指令重排会出现问题呢？"><a href="#2-2-那么为什么指令重排会出现问题呢？" class="headerlink" title="2.2 那么为什么指令重排会出现问题呢？"></a>2.2 <strong>那么为什么指令重排会出现问题呢？</strong></h2><p>指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致。所以在多线程下，指令重排序可能会导致一些问题。</p>
<h1 id="3-指令重排序的解决方法"><a href="#3-指令重排序的解决方法" class="headerlink" title="3.指令重排序的解决方法"></a>3.指令重排序的解决方法</h1><p>所以，由此引出了<code>Volatile</code>，在一个知识体系中，进行知识的串联是尤为重要的，这就是有些东西的存在必定存在其相对的意义，知其然，知其所以然，才能更好的进行运用。对于Volatile相关的知识，查看后面的内容。</p>
<hr>
<p>以上引用的博客和文章：</p>
<ol>
<li>书籍：并发编程的艺术</li>
<li>书籍：深入浅出Java多线程</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - CAS 分析</title>
    <url>/2020/03/31/java-bing-fa-cas-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - AQS同步组件：ReentrantReadWriteLock 分析</title>
    <url>/2020/03/31/java-bing-fa-aqs-tong-bu-zu-jian-reentrantreadwritelock-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>AQS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - AQS同步组件：ReentrantLock 分析</title>
    <url>/2020/03/31/java-bing-fa-aqs-tong-bu-zu-jian-reentrantlock-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>AQS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - AQS同步组件：Semaphore 分析</title>
    <url>/2020/03/31/java-bing-fa-aqs-tong-bu-zu-jian-semaphore-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>AQS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 集合框架 - HashTable 分析</title>
    <url>/2020/03/31/java-ji-he-kuang-jia-hashtable-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 集合框架 - CopyOnWriteArrayList 分析</title>
    <url>/2020/03/31/java-ji-he-kuang-jia-copyonwritearraylist-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 集合框架 - TreeMap 分析</title>
    <url>/2020/03/31/java-ji-he-kuang-jia-treemap-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 集合框架 - HashSet 分析</title>
    <url>/2020/03/31/java-ji-he-kuang-jia-hashset-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 框架分析 - 设计模式</title>
    <url>/2020/03/31/spring-kuang-jia-fen-xi-she-ji-mo-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - 并发工具类：Exchanger 分析</title>
    <url>/2020/03/31/java-bing-fa-bing-fa-gong-ju-lei-exchanger-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - AQS同步组件：CountDownLatch 分析</title>
    <url>/2020/03/31/java-bing-fa-aqs-tong-bu-zu-jian-countdownlatch-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>AQS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - AQS同步组件：Cyclibarrier 分析</title>
    <url>/2020/03/31/java-bing-fa-aqs-tong-bu-zu-jian-cyclibarrier-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>AQS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - Condition 分析</title>
    <url>/2020/03/31/java-bing-fa-condition-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - AQS：基本框架分析总括</title>
    <url>/2020/03/31/java-bing-fa-aqs-ji-ben-kuang-jia-fen-xi-zong-gua/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>AQS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - 多线程 分析总括</title>
    <url>/2020/03/31/java-bing-fa-duo-xian-cheng-fen-xi-zong-gua/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 集合框架 - ArrayList 分析</title>
    <url>/2020/03/31/java-ji-he-kuang-jia-arraylist-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 集合框架 - LinkedList 分析</title>
    <url>/2020/03/31/java-ji-he-kuang-jia-linkedlist-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>占个坑</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 集合框架 - HashMap 认识与理解</title>
    <url>/2020/03/31/java-ji-he-kuang-jia-hashmap-ren-shi-yu-li-jie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>关于HashMap 其实还是有很多困惑的，学习了这么长时间，一边记录遇到的一些问题，一边整理笔记，如下所示。</p>
<h1 id="2-主要一些知识点"><a href="#2-主要一些知识点" class="headerlink" title="2.主要一些知识点"></a>2.主要一些知识点</h1><h2 id="2-1-HashMap-底层结构的一些问题与解答"><a href="#2-1-HashMap-底层结构的一些问题与解答" class="headerlink" title="2.1 HashMap 底层结构的一些问题与解答"></a>2.1 HashMap 底层结构的一些问题与解答</h2><p>关于HashMap 的底层数据结构，我有以下这么几个疑问，当时也是查看书籍和百度谷歌了好一会儿，然后连带着寻找到其他的一些问题，如下。</p>
<hr>
<h3 id="数组与链表相关"><a href="#数组与链表相关" class="headerlink" title="数组与链表相关"></a>数组与链表相关</h3><p>关于底层数据结构为什么采用 数组+链表 这么一种组合的几个问题：</p>
<h4 id="1-为什么用数组-链表？"><a href="#1-为什么用数组-链表？" class="headerlink" title="1.为什么用数组+链表？"></a><strong>1.为什么用数组+链表？</strong></h4><ul>
<li>我认为数组是用来确定桶的位置，利用元素的key的hash值对数组长度取模得到.</li>
<li>链表是用来解决hash冲突问题，当出现hash值一样的情形，就在数组上的对应位置形成一条链表。</li>
<li>注：这里的hash值并不是指hashcode，而是将hashcode高低十六位异或过的。</li>
</ul>
<h4 id="2-那使用LinkedList代替数组结构可以么？"><a href="#2-那使用LinkedList代替数组结构可以么？" class="headerlink" title="2.那使用LinkedList代替数组结构可以么？"></a><strong>2.那使用LinkedList代替数组结构可以么？</strong></h4><ul>
<li>这里的意思是，源码中是这样的：<code>Entry[] table = new Entry[capacity];</code><ul>
<li>ps：Entry就是一个链表节点。</li>
</ul>
</li>
<li>那我用下面这样表示：<ul>
<li><code>List&lt;Entry&gt; table = new LinkedList&lt;Entry&gt;();</code></li>
</ul>
</li>
<li>所以没毛病是可以使用LinkedList代替数组结构</li>
</ul>
<h4 id="3-那既然是可以的，为什么HashMap不用LinkedList，而选用数组"><a href="#3-那既然是可以的，为什么HashMap不用LinkedList，而选用数组" class="headerlink" title="3.那既然是可以的，为什么HashMap不用LinkedList，而选用数组?"></a><strong>3.那既然是可以的，为什么HashMap不用LinkedList，而选用数组?</strong></h4><ul>
<li>因为用数组效率最高！在HashMap中，定位桶的位置是利用元素的key的哈希值对数组长度取模得到。此时，我们已得到桶的位置。显然数组的查找效率比LinkedList大。</li>
</ul>
<h4 id="4-继续挖一下，那ArrayList，底层也是数组，查找也快啊，为什么不用ArrayList"><a href="#4-继续挖一下，那ArrayList，底层也是数组，查找也快啊，为什么不用ArrayList" class="headerlink" title="4.继续挖一下，那ArrayList，底层也是数组，查找也快啊，为什么不用ArrayList?"></a><strong>4.继续挖一下，那ArrayList，底层也是数组，查找也快啊，为什么不用ArrayList?</strong></h4><ul>
<li>因为采用基本数组结构，扩容机制可以自己定义，HashMap中数组扩容刚好是2的次幂，在做取模运算的效率高。而ArrayList的扩容机制是1.5倍扩容。</li>
<li>而为什么需要两倍扩容，现在此处存疑，在下面我会进行展开分析一下。</li>
</ul>
<hr>
<h3 id="红黑树相关"><a href="#红黑树相关" class="headerlink" title="红黑树相关"></a>红黑树相关</h3><p>关于树化为什么采用红黑树、及红黑树的一些特性的一些问题、：</p>
<h4 id="1-如果进行树化了，为什么是红黑树？别的树不可以吗？"><a href="#1-如果进行树化了，为什么是红黑树？别的树不可以吗？" class="headerlink" title="1.如果进行树化了，为什么是红黑树？别的树不可以吗？"></a><strong>1.如果进行树化了，为什么是红黑树？别的树不可以吗？</strong></h4><ul>
<li>比如二叉查找树，是可以的。但是二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。</li>
<li>AVL树中，根到任何叶子的最短路径和最长路径之间的差异最多为1，而红黑树可以是两倍，虽然红黑树放弃了一定的平衡，但是当进行查找时AVL树可能需要O（Logn）次旋转，而红黑树只需要最多两次，红黑树更加适合插入修改密集型任务</li>
</ul>
<h4 id="2-为什么在解决hash冲突的时候，不直接用红黑树-而选择先用链表，再转红黑树"><a href="#2-为什么在解决hash冲突的时候，不直接用红黑树-而选择先用链表，再转红黑树" class="headerlink" title="2.为什么在解决hash冲突的时候，不直接用红黑树?而选择先用链表，再转红黑树?"></a><strong>2.为什么在解决hash冲突的时候，不直接用红黑树?而选择先用链表，再转红黑树?</strong></h4><ul>
<li><strong>因为红黑树需要进行</strong>左旋，右旋，变色这些操作来保持平衡，而单链表不需要。当元素小于8个当时候，此时做查询操作，链表结构已经能保证查询性能。当元素大于8个的时候，此时需要红黑树来加快查询速度，但是新增节点的效率变慢了。因此，如果一开始就用红黑树结构，元素太少，新增效率又比较慢，无疑这是浪费性能的。</li>
</ul>
<h4 id="3-当链表转为红黑树后，什么时候退化为链表"><a href="#3-当链表转为红黑树后，什么时候退化为链表" class="headerlink" title="3.当链表转为红黑树后，什么时候退化为链表?"></a><strong>3.当链表转为红黑树后，什么时候退化为链表?</strong></h4><ul>
<li>为6的时候退转为链表。中间有个差值7可以防止链表和树之间频繁的转换。假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。</li>
</ul>
<h4 id="4其实这样引出了一个问题：为什么链化阈值是-6-，树化阈值是-8（为什么8的时候树化，4不可以吗？）？"><a href="#4其实这样引出了一个问题：为什么链化阈值是-6-，树化阈值是-8（为什么8的时候树化，4不可以吗？）？" class="headerlink" title="4其实这样引出了一个问题：为什么链化阈值是 6 ，树化阈值是 8（为什么8的时候树化，4不可以吗？）？"></a><strong>4其实这样引出了一个问题：为什么链化阈值是 6 ，树化阈值是 8（为什么8的时候树化，4不可以吗？）？</strong></h4><ul>
<li>8树化，是经测试，冲突链表个数符合<u>泊松分布</u>，为8时概率零点几，为6而不是7退化，是为了避免7 8来回变引入不可变开销。线程数其实在考cpu密集型和io密集型。</li>
</ul>
<hr>
<h3 id="哈希相关"><a href="#哈希相关" class="headerlink" title="哈希相关"></a>哈希相关</h3><p>还有HashMap 中的哈希的一些问题</p>
<h4 id="1-HashMap-中哈希方法，为什么要选择31？？？"><a href="#1-HashMap-中哈希方法，为什么要选择31？？？" class="headerlink" title="1.HashMap 中哈希方法，为什么要选择31？？？"></a><strong>1.HashMap 中哈希方法，为什么要选择31？？？</strong></h4><p>首先看下String hashcode 的方法是如何实现的：</p>
<p><img src="https://i.loli.net/2020/04/02/gCVO9duskcUS1TP.png" alt="image.png"></p>
<p>我们可以由上面的 for 循环推导出一个计算公式，hashCode 方法注释中已经给出。如下：</p>
<p><img src="https://i.loli.net/2020/04/02/GtJUCvLyr19lIHj.png" alt="image.png"></p>
<p>这里说明一下，上面的 s 数组即源码中的 val 数组，是 String 内部维护的一个 char 类型数组。这里我来简单推导一下这个公式：</p>
<p><img src="https://i.loli.net/2020/04/02/6lyFtYu9bM5pz81.png" alt="image.png"></p>
<p>上面的公式包括公式的推导并不是本文的重点，大家了解了解即可。接下来来说说本文的重点，即选择31的理由。从网上的资料来看，一般有如下两个原因：</p>
<ol>
<li>第一，31是一个不大不小的质数，是作为 hashCode 乘子的优选质数之一。另外一些相近的质数，比如37、41、43等等，也都是不错的选择。那么为啥偏偏选中了31呢？请看第二个原因。<ul>
<li><strong>第一点解释一下：31是一个不大不小的质数，是优选乘子。那为啥同是质数的2和101（或者更大的质数）就不是优选乘子呢？</strong></li>
<li>这里先分析质数2。首先，假设 n = 6，然后把质数2和 n 带入上面的计算公式。并仅计算公式中次数最高的那一项，结果是2^5 = 32，是不是很小。所以这里可以断定，当字符串长度不是很长时，用质数2做为乘子算出的哈希值，数值不会很大。也就是说，哈希值会分布在一个较小的数值区间内，分布性不佳，最终可能会导致冲突率上升。</li>
<li>那么如果用一个较大的大质数101会产生什么样的结果呢？根据上面的分析，我想大家应该可以猜出结果了。就是不用再担心哈希值会分布在一个小的区间内了，因为101^5 = 10,510,100,501。但是要注意的是，这个计算结果太大了。如果用 int 类型表示哈希值，结果会溢出，最终导致数值信息丢失。尽管数值信息丢失并不一定会导致冲突率上升，但是我们暂且先认为质数101（或者更大的质数）也不是很好的选择。</li>
<li>最后，我们再来看看质数31的计算结果： 31^5 = 28629151，结果值相对于32和10,510,100,501来说。是不是很nice，不大不小。</li>
<li>总的来说，是100以内的比较好的奇质数（既要是奇数，又要是质数的数）</li>
</ul>
</li>
<li>第二、31可以被 JVM 优化，31 * i = (i &lt;&lt; 5) - i。</li>
</ol>
<p>Stack Overflow 上关于这个问题的讨论：Why does Java’s hashCode() in String use 31 as a multiplier?</p>
<p>其中排名第一的答案引用了《Effective Java》中的一段话，这里也引用一下：</p>
<blockquote>
<p>The value 31 was chosen because it is an odd prime. If it were even and the multiplication overflowed, information would be lost, as multiplication by 2 is equivalent to shifting. The advantage of using a prime is less clear, but it is traditional. A nice property of 31 is that the multiplication can be replaced by a shift and a subtraction for better performance: 31 * i == (i &lt;&lt; 5) - i`. Modern VMs do this sort of optimization automatically.</p>
</blockquote>
<p>翻译过来是这么说的：</p>
<ul>
<li>选择数字31是因为它是一个奇质数，如果选择一个偶数会在乘法运算中产生溢出，导致数值信息丢失，因为乘二相当于移位运算。</li>
<li>选择质数的优势并不是特别的明显，但这是一个传统。</li>
<li>同时，数字31有一个很好的特性，即乘法运算可以被移位和减法运算取代，来获取更好的性能：31 * i == (i &lt;&lt; 5) - i，现代的 Java 虚拟机可以自动的完成这个优化。</li>
</ul>
<p>排名第二的答案是这样说的：</p>
<blockquote>
<p>As Goodrich and Tamassia point out, If you take over 50,000 English words (formed as the union of the word lists provided in two variants of Unix), using the constants 31, 33, 37, 39, and 41 will produce less than 7 collisions in each case. Knowing this, it should come as no surprise that many Java implementations choose one of these constants.</p>
</blockquote>
<p>翻译过来是这样的：</p>
<ul>
<li>正如 Goodrich 和 Tamassia 指出的那样，如果你对超过 50,000 个英文单词（由两个不同版本的 Unix 字典合并而成）进行 hash code 运算，并使用常数 31, 33, 37, 39 和 41 作为乘子，每个常数算出的哈希值冲突数都小于7个，所以在上面几个常数中，常数 31 被 Java 实现所选用也就不足为奇了。</li>
</ul>
<h2 id="2-2-HashMap-容量相关的一些问题与解答"><a href="#2-2-HashMap-容量相关的一些问题与解答" class="headerlink" title="2.2 HashMap 容量相关的一些问题与解答"></a>2.2 HashMap 容量相关的一些问题与解答</h2><h2 id="2-3-HashMap-并发相关的一些问题与解答"><a href="#2-3-HashMap-并发相关的一些问题与解答" class="headerlink" title="2.3 HashMap 并发相关的一些问题与解答"></a>2.3 HashMap 并发相关的一些问题与解答</h2><h2 id="2-4-HashMap与其他一些容器的比较"><a href="#2-4-HashMap与其他一些容器的比较" class="headerlink" title="2.4 HashMap与其他一些容器的比较"></a>2.4 HashMap与其他一些容器的比较</h2><h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h1><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>WTIM 简介</title>
    <url>/2020/03/30/wtim-jian-jie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>搭建一个基于分布式的IM（即时通讯）系统</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>WTIM</category>
      </categories>
      <tags>
        <tag>WTIM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 集合框架 - HashMap 分析</title>
    <url>/2020/03/29/java-ji-he-kuang-jia-hashmap-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-HashMap实现原理"><a href="#1-HashMap实现原理" class="headerlink" title="1.HashMap实现原理"></a>1.HashMap实现原理</h1><p><strong>简述HashMap的工作原理：</strong></p>
<p>HashMap是<strong>基于散列法（又称哈希法）的原理</strong>，使用<code>put(key, value)</code>存储对象到HashMap中，使用<code>get(key)</code>从HashMap中获取对象。使用HashMap进行查询和修改的速度都很快，平均时间复杂度O(1)。HashMap非线程安全，如果需要考虑并发，则需要使用ConcurrentHashMap，且HashMap不保证存储元素的序列；</p>
<hr>
<h1 id="2-HashMap的底层结构"><a href="#2-HashMap的底层结构" class="headerlink" title="2.HashMap的底层结构"></a>2.HashMap的底层结构</h1><p>JDK18之前：数组+链表</p>
<p>JDK1.8之后：数组+链表+红黑树</p>
<p>特点是HashMap采用Entry数组来存储key-value对，每一个键值对组成了一个Entry实体，Entry类实际上是一个单向的链表结构，它具有Next指针，可以连接下一个Entry实体。只是在JDK1.8中，链表长度大于8的时候，链表会转成红黑树！</p>
<p>在添加元素时，会根据hash值算出元素在数组中的位置，如果该位置没有元素，则直接把元素放置在此处，如果该位置有元素了，则把元素以链表的形式放置在链表的尾部。</p>
<p>数组的查询效率为O(1)，链表的查询效率是O(k)，红黑树的查询效率是O(log k)，k为桶中的元素个数，所以当元素数量非常多的时候，转化为红黑树能极大地提高效率。</p>
<p>底层结构具体如下所示：</p>
<ol>
<li><p>关于红黑树相关的知识：</p>
</li>
</ol>
<ul>
<li>可以看这篇文章：    </li>
</ul>
<hr>
<h1 id="3-源码阅读"><a href="#3-源码阅读" class="headerlink" title="3.源码阅读"></a>3.源码阅读</h1><h2 id="3-1-HashMap的继承与实现"><a href="#3-1-HashMap的继承与实现" class="headerlink" title="3.1.HashMap的继承与实现"></a>3.1.HashMap的继承与实现</h2><ul>
<li>HashMap实现了Cloneable，可以被克隆。</li>
<li>HashMap实现了Serializable，可以被序列化。</li>
<li>HashMap继承自AbstractMap，实现了Map接口，具有Map的所有功能。</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span>
    <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">,</span> Cloneable<span class="token punctuation">,</span> Serializable <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre>
<p>具体继承如下所示：</p>
<p><img src="https://i.loli.net/2020/04/02/fZVderRq2NO81Sc.png" alt="HashMap.png"></p>
<h2 id="3-2-HashMap的基本属性及内部类"><a href="#3-2-HashMap的基本属性及内部类" class="headerlink" title="3.2.HashMap的基本属性及内部类"></a>3.2.HashMap的基本属性及内部类</h2><h3 id="3-2-1-基本属性"><a href="#3-2-1-基本属性" class="headerlink" title="3.2.1 基本属性"></a>3.2.1 基本属性</h3><pre class=" language-java"><code class="language-java">   <span class="token comment" spellcheck="true">/**
     * 哈希数组初始容量
     */</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// aka 16</span>

    <span class="token comment" spellcheck="true">/**
     * 哈希数组最大容量
     */</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * HashMap默认装载因子（负载因子）
     */</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 当前 HashMap 所能容纳键值对数量的最大值，超过这个值，则需扩容
     */</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 哈希槽（链）上的红黑树上的元素数量减少到此值时，将红黑树转换为链表
     */</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> UNTREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 当桶的个数达到64的时候才进行树化
     * 即是说当桶数组容量小于该值时，优先进行扩容，而不是树化
     */</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MIN_TREEIFY_CAPACITY <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 哈希数组
     */</span>
    <span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * entry集合
     */</span>
    <span class="token keyword">transient</span> Set<span class="token operator">&lt;</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">>></span> entrySet<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * HashMap的元素数量
     */</span>
    <span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     *  HashMap结构的修改次数
     */</span>
    <span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * (The javadoc description is true upon serialization.
     * Additionally, if the table array has not been allocated, this
     * field holds the initial array capacity, or zero signifying
     * DEFAULT_INITIAL_CAPACITY.)
     * HashMap扩容阈值，并没有默认阈值，原因是阈值可由容量乘上负载因子计算而来（注释中有说明）
     * 计算公式：threshold = capacity * loadFactor
     */</span>
    <span class="token keyword">int</span> threshold<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * HashMap当前使用的装载因子
     */</span>
    <span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span>
</code></pre>
<p>上面举例了一些HashMap的属性字段，比较有意思的是羡慕几个属性字段，在接下来中会单拎出来进行详细讲解。：</p>
<ul>
<li>哈希数组的初始容量：DEFAULT_INITIAL_CAPACITY</li>
<li>负载因子：loadFactor</li>
<li>链表树化与树化链表的两个阈值：UNTREEIFY_THRESHOLD 和TREEIFY_THRESHOLD</li>
</ul>
<h3 id="3-2-2-Node内部类"><a href="#3-2-2-Node内部类" class="headerlink" title="3.2.2 Node内部类"></a>3.2.2 Node内部类</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>
    <span class="token keyword">final</span> K key<span class="token punctuation">;</span>
    V value<span class="token punctuation">;</span>
    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>HashMap采用Entry数组来存储key-value对，每一个键值对组成了一个Entry实体，Entry类实际上是一个单向的链表结构，它具有Next指针，可以连接下一个Entry实体。只是在JDK1.8中，链表长度大于8的时候，链表会转成红黑树！</p>
<h3 id="3-2-3-TreeNode内部类"><a href="#3-2-3-TreeNode内部类" class="headerlink" title="3.2.3 TreeNode内部类"></a>3.2.3 TreeNode内部类</h3><p>TreeNode是一个典型的树型节点，其中，prev是链表中的节点，用于在删除元素的时候可以快速找到它的前置节点。</p>
<pre><code>// 位于HashMap中
static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; {
    TreeNode&lt;K,V&gt; parent;  // red-black tree links
    TreeNode&lt;K,V&gt; left;
    TreeNode&lt;K,V&gt; right;
    TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion
    boolean red;
}

// 位于LinkedHashMap中，典型的双向链表节点
static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; {
    Entry&lt;K,V&gt; before, after;
    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) {
        super(hash, key, value, next);
    }
}</code></pre><hr>
<h2 id="3-3-HashMap的四种构造及参数分析"><a href="#3-3-HashMap的四种构造及参数分析" class="headerlink" title="3.3.HashMap的四种构造及参数分析"></a>3.3.HashMap的四种构造及参数分析</h2><ol>
<li>无参构造，初始化一个哈希数组容量为16，装载因子为0.75的HashMap</li>
</ol>
<pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**
     * Constructs an empty {@code HashMap} with the default initial capacity
     * (16) and the default load factor (0.75).
     */</span>
    <span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// all other fields defaulted</span>
    <span class="token punctuation">}</span></code></pre>
<ol start="2">
<li>初始化一个哈希数组容量为initialCapacity，装载因子为0.75的HashMap</li>
</ol>
<pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**
     * Constructs an empty {@code HashMap} with the specified initial
     * capacity and the default load factor (0.75).
     *
     * @param  initialCapacity the initial capacity.
     * @throws IllegalArgumentException if the initial capacity is negative.
     */</span>
    <span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span></code></pre>
<ol start="3">
<li>初始化一个哈希数组容量为initialCapacity，装载因子为loadFactor的HashMap</li>
</ol>
<pre class=" language-java"><code class="language-java">  <span class="token comment" spellcheck="true">/**
     * Constructs an empty {@code HashMap} with the specified initial
     * capacity and load factor.
     *
     * @param  initialCapacity the initial capacity
     * @param  loadFactor      the load factor
     * @throws IllegalArgumentException if the initial capacity is negative
     *         or the load factor is nonpositive
     */</span>
    <span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 检查传入的初始容量是否合法</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal initial capacity: "</span> <span class="token operator">+</span>
                                               initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">></span> MAXIMUM_CAPACITY<span class="token punctuation">)</span>
            initialCapacity <span class="token operator">=</span> MAXIMUM_CAPACITY<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 检查装载因子是否合法</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>loadFactor <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> Float<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span>loadFactor<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal load factor: "</span> <span class="token operator">+</span>
                                               loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 初始化装载因子</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> loadFactor<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 用初始容量信息来计算扩容门槛</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span></code></pre>
<ol start="4">
<li>使用指定的HashMap中的元素来初始化一个新的HashMap</li>
</ol>
<pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**
     * Constructs a new {@code HashMap} with the same mappings as the
     * specified {@code Map}.  The {@code HashMap} is created with
     * default load factor (0.75) and an initial capacity sufficient to
     * hold the mappings in the specified {@code Map}.
     *
     * @param   m the map whose mappings are to be placed in this map
     * @throws  NullPointerException if the specified map is null
     */</span>
    <span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 将指定HashMap中的元素存入到当前HashMap（允许覆盖）</span>
        <span class="token function">putMapEntries</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span></code></pre>
<p>我们这这里对几个字段进行解释一下：</p>
<h2 id="3-4-查询"><a href="#3-4-查询" class="headerlink" title="3.4.查询"></a>3.4.查询</h2><h3 id="3-4-1-查询HashMap大小"><a href="#3-4-1-查询HashMap大小" class="headerlink" title="3.4.1.查询HashMap大小"></a>3.4.1.查询HashMap大小</h3><p>该方法返回HashMap的大小，键值对的数目：</p>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> size<span class="token punctuation">;</span>
    <span class="token punctuation">}</span></code></pre>
<h3 id="3-4-2-查询HashMap是否为空"><a href="#3-4-2-查询HashMap是否为空" class="headerlink" title="3.4.2 查询HashMap是否为空"></a>3.4.2 查询HashMap是否为空</h3><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span></code></pre>
<h3 id="3-4-3-查询HashMap是否存在指定key"><a href="#3-4-3-查询HashMap是否存在指定key" class="headerlink" title="3.4.3.查询HashMap是否存在指定key"></a>3.4.3.查询HashMap是否存在指定key</h3><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">containsKey</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">;</span>
    <span class="token punctuation">}</span></code></pre>
<h3 id="3-4-4-查询HashMap中是否存在指定value的元素"><a href="#3-4-4-查询HashMap中是否存在指定value的元素" class="headerlink" title="3.4.4.查询HashMap中是否存在指定value的元素"></a>3.4.4.查询HashMap中是否存在指定value的元素</h3><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">containsValue</span><span class="token punctuation">(</span>Object value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> V v<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> size <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 进行循环遍历查找value</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">:</span> tab<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>v <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token operator">==</span> value <span class="token operator">||</span>
                        <span class="token punctuation">(</span>value <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> value<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span></code></pre>
<h2 id="3-5-取值"><a href="#3-5-取值" class="headerlink" title="3.5.取值"></a>3.5.取值</h2><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">?</span> null <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span></code></pre>
<p>它调用了<code>getNode(int hash, Object key)</code>方法，详细代码如下所示：</p>
<pre class=" language-java"><code class="language-java">  <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> first<span class="token punctuation">,</span> e<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 如果桶的数量大于0，并且所查找的key所在的桶的第一个元素不为空</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>
            <span class="token punctuation">(</span>first <span class="token operator">=</span> tab<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 检查第一个元素是不是要查的元素，如果是则直接返回</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token comment" spellcheck="true">// always check first node</span>
                <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> first<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 如果不止一个元素，则继续寻找</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> first<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 如果第一个元素是树节点，则按树的方式查找</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
                    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>first<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">do</span> <span class="token punctuation">{</span>
                    <span class="token comment" spellcheck="true">// 否则就遍历整个链表查找该元素</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                        <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token keyword">return</span> e<span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> null<span class="token punctuation">;</span>
    <span class="token punctuation">}</span></code></pre>
<h2 id="3-6-添加"><a href="#3-6-添加" class="headerlink" title="3.6.添加"></a>3.6.添加</h2><h3 id="3-6-1-HashMap的添加过程"><a href="#3-6-1-HashMap的添加过程" class="headerlink" title="3.6.1.HashMap的添加过程"></a>3.6.1.HashMap的添加过程</h3><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span></code></pre>
<p>实际上它调用了<code>putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict)</code>方法，详细代码如下所示：</p>
<pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/*
     * 向当前Map中存入新的元素，并返回旧元素
     *
     * hash         key的哈希值
     * onlyIfAbsent 是否需要维持原状（不覆盖旧值）
     * evict        如果为false，则表处于创建模式。
     *
     * 返回同位元素的旧值（在当前Map中占据相同位置的元素）
     * 如果不存在同位元素，即插入了新元素，则返回null
     * 如果存在同位元素，但同位元素的旧值为null，那么也返回null
     *
     */</span>
    <span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>
                   <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 如果桶的长度为0，未初始化，则进行初始化并得到长度n</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token comment" spellcheck="true">// 调用resize进行初始化</span>
            n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 如果桶中还没有元素，则将要插入的key和value放到第一位</span>
        <span class="token comment" spellcheck="true">// 使用(n - 1) &amp; hash 计算元素在哪个桶中</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>
            tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 桶中此时已存在元素</span>
            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 如果待插入的元素的hash值和key值与第一个元素的哈希值和key相同，保存到e用于后续修改value值</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                e <span class="token operator">=</span> p<span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 如果桶的第一个元素为树节点，则调用树节点的putTreeVal方法插入元素</span>
                e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 遍历这个桶对应的链表，binCount用于存储链表中元素的个数</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment" spellcheck="true">// 遍历整个链表，没有相同哈希值和key的元素，则在链表最后插入该key和value结点</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token comment" spellcheck="true">// 如果插入结点之后的长度大于等于8，则树化</span>
                        <span class="token comment" spellcheck="true">// 这里-1的解释为：因为第一个元素没有加到binCount中，所以这里-1</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// -1 for 1st</span>
                            <span class="token comment" spellcheck="true">// 进行树化</span>
                            <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token comment" spellcheck="true">// 假如待插入的key在链表中找到，则退出循环</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                        <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                    p <span class="token operator">=</span> e<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token comment" spellcheck="true">// 找到了对应key的元素</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// existing mapping for key</span>
                V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 记录旧值</span>
                <span class="token comment" spellcheck="true">// 判断是否需要替换旧值</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> null<span class="token punctuation">)</span>
                    e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 替换旧值为新值</span>
                <span class="token comment" spellcheck="true">// 在节点被访问后做点什么事，在LinkedHashMap中用到</span>
                <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">// 返回旧值</span>
                <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 到了此处证明没有找到元素，即添加了新元素，修改次数加1</span>
        <span class="token operator">++</span>modCount<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 如果哈希数组的容量已超过阈值，则需要对哈希数组扩容</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">></span> threshold<span class="token punctuation">)</span>
            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 在节点插入后做点什么事，在LinkedHashMap中用到</span>
        <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> null<span class="token punctuation">;</span>
    <span class="token punctuation">}</span></code></pre>
<p>添加方法除了可以单个key-value键值对的添加，还可以将指定HashMap中的元素存入到当前HashMap中（允许覆盖），详细代码如下：</p>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">putMapEntries</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> m<span class="token punctuation">,</span> <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> s <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 如果当前HashMap的哈希数组还未初始化</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>table <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// pre-size</span>
                <span class="token comment" spellcheck="true">// 根据HashMap中的元素数量反推哈希数组的最低容量要求</span>
                <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>s <span class="token operator">/</span> loadFactor<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1.0F</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 注意这里!!!!</span>
                <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token operator">?</span>
                         <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">// 如果大于需要扩容的阈值，则重新计算扩容阈值</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">></span> threshold<span class="token punctuation">)</span>
                    threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// Because of linked-list bucket constraints, we cannot</span>
                <span class="token comment" spellcheck="true">// expand all at once, but can reduce total resize</span>
                <span class="token comment" spellcheck="true">// effort by repeated doubling now vs later</span>
                <span class="token comment" spellcheck="true">// 由于链表存储桶的限制，我们无法一次全部扩展</span>
                <span class="token comment" spellcheck="true">// 但可以通过立即加倍与以后加倍来减少总的调整工作量</span>
                <span class="token comment" spellcheck="true">// 初始化哈希数组，或者对哈希数组扩容，并返回新的哈希数组</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span>s <span class="token operator">></span> threshold <span class="token operator">&amp;&amp;</span> table<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span>
                    <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment" spellcheck="true">// 循环遍历进行添加，允许覆盖</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> e <span class="token operator">:</span> m<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                K key <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                V value <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> evict<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span></code></pre>
<h3 id="3-6-2-HashMap的扩容过程"><a href="#3-6-2-HashMap的扩容过程" class="headerlink" title="3.6.2.HashMap的扩容过程"></a>3.6.2.HashMap的扩容过程</h3><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/*
     * 扩容机制：在初始化时、对哈希数组扩容时两种情况下调用
     *
     */</span>
    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 旧数组</span>
        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 旧容量，或者未初始化时的容量</span>
        <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 旧扩容阈值</span>
        <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 新容量、新扩容阈值</span>
        <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 如果哈希数组已经初始化，不是首次进入</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 如果旧容量大于最大容量，则不再扩容</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                threshold <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>
                <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment" spellcheck="true">// 如果旧容量的两倍（左移一位）小于最大容量，并且大于默认初始容量（16）</span>
            <span class="token comment" spellcheck="true">// 则新容量扩大为旧容量的两倍，扩容阈值也扩大为旧阈值的两倍</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span>
                     oldCap <span class="token operator">>=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span>
                newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// double threshold</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 如果哈希数组还未初始化（首次进来）并且实例化HashMap的时候指定了初始容量</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// initial capacity was placed in threshold</span>
            <span class="token comment" spellcheck="true">// 则将哈希数组的当前容量初始化为与旧阈值一样大（传入初始容量时候会调用tableSizeFor()方法）</span>
            newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 如果哈希数组还未初始化（首次进来）并且实例化HashMap的时候没有指定了初始容量</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>               <span class="token comment" spellcheck="true">// zero initial threshold signifies using defaults</span>
            <span class="token comment" spellcheck="true">// 则使用默认的初始容量（16）和默认公式计算的阈值</span>
            newCap <span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">;</span>
            newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>DEFAULT_LOAD_FACTOR <span class="token operator">*</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 如果新扩容阈值为0，则使用公式计算得到新的扩容阈值，并且不可超过最大容量</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>
            newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY <span class="token operator">?</span>
                      <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 赋值扩容阈值为新扩容阈值</span>
        threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 根据新扩容容量建立一个新容量的数组</span>
        <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"rawtypes"</span><span class="token punctuation">,</span><span class="token string">"unchecked"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 将桶赋值为新数组</span>
        table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 旧数组不为空，则搬移元素</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 遍历旧数组</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">// 如果桶中的第一个元素不为空，则赋值给e</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment" spellcheck="true">// 清空旧桶，帮助GC</span>
                    oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>
                    <span class="token comment" spellcheck="true">// 如果桶中只有一个元素，进行新桶的位置定位，并搬迁</span>
                    <span class="token comment" spellcheck="true">// 注意：只有第一个元素才可以这样，因为每次扩容都是两倍</span>
                    <span class="token comment" spellcheck="true">//       则第一个元素搬移到新桶的时候肯定还没有元素</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span>
                        newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
                    <span class="token comment" spellcheck="true">// 如果该哈希槽上链接了不止一个元素，且该元素是TreeNode类型</span>
                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
                        <span class="token comment" spellcheck="true">// 如果第一个元素是树节点，则把这颗树打散成两颗树插入到新桶中去</span>
                        <span class="token comment" spellcheck="true">// 拆分红黑树</span>
                        <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// preserve order</span>
                        <span class="token comment" spellcheck="true">// 如果这个链表不止一个元素且不是一颗树</span>
                        <span class="token comment" spellcheck="true">// 则进行分化成两个链表插到新的桶中</span>
                        <span class="token comment" spellcheck="true">// 举例：假如原来容量为4，3、7、11、15这四个元素都在三号桶中</span>
                        <span class="token comment" spellcheck="true">// 现在扩容到8，则3和11还是在三号桶，7和15要搬移到七号桶中去</span>
                        <span class="token comment" spellcheck="true">// 也就是分化成了两个链表</span>
                        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> loHead <span class="token operator">=</span> null<span class="token punctuation">,</span> loTail <span class="token operator">=</span> null<span class="token punctuation">;</span>
                        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> hiHead <span class="token operator">=</span> null<span class="token punctuation">,</span> hiTail <span class="token operator">=</span> null<span class="token punctuation">;</span>
                        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>
                        <span class="token keyword">do</span> <span class="token punctuation">{</span>
                            next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                            <span class="token comment" spellcheck="true">// (e.hash &amp; oldCap) == 0的元素放在低位链表中</span>
                            <span class="token comment" spellcheck="true">// 比如，3 &amp; 4 == 0</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> null<span class="token punctuation">)</span>
                                    loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>
                                <span class="token keyword">else</span>
                                    loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>
                                loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>
                            <span class="token punctuation">}</span>
                            <span class="token keyword">else</span> <span class="token punctuation">{</span>
                                <span class="token comment" spellcheck="true">// (e.hash &amp; oldCap) != 0的元素放在高位链表中</span>
                                <span class="token comment" spellcheck="true">// 比如，7 &amp; 4 != 0</span>
                                <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> null<span class="token punctuation">)</span>
                                    hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>
                                <span class="token keyword">else</span>
                                    hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>
                                hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>
                            <span class="token punctuation">}</span>
                        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token comment" spellcheck="true">// 遍历完成得到两个链表</span>
                        <span class="token comment" spellcheck="true">// 低位链表在新桶的位置与旧桶一样（即3和11还在三号桶中）</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>
                            newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                        <span class="token comment" spellcheck="true">// 高位链表在新桶中的位置正好是原来的位置加上旧容量（即7和15搬移到七号桶了）</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>
                            newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> newTab<span class="token punctuation">;</span>
    <span class="token punctuation">}</span></code></pre>
<h3 id="3-6-3-HashMap扩容的思考"><a href="#3-6-3-HashMap扩容的思考" class="headerlink" title="3.6.3.HashMap扩容的思考"></a>3.6.3.HashMap扩容的思考</h3><h3 id="3-6-4-树化与链化过程"><a href="#3-6-4-树化与链化过程" class="headerlink" title="3.6.4.树化与链化过程"></a>3.6.4.树化与链化过程</h3><h2 id="3-7-移除"><a href="#3-7-移除" class="headerlink" title="3.7.移除"></a>3.7.移除</h2><pre><code>    /**
     * 根据传入的key进行数据移除元素，并返回刚刚移除的元素的值
     */
    public V remove(Object key) {
        Node&lt;K,V&gt; e;
        return (e = removeNode(hash(key), key, null, false, true)) == null ?
            null : e.value;
    }</code></pre><p>实际上它调用了<code>removeNode(int hash, Object key, Object value,boolean matchValue, boolean movable)</code>方法，详细代码如下所示：</p>
<pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/*
     * 从HashMap中移除指定的元素，并返回刚刚移除的元素（移除失败返回null）
     *
     * matchValue 移除元素时是否需要考虑value的匹配问题
     * movable    移除元素后如果红黑树根结点发生了变化，那么是否需要改变结点在链表上的顺序
     */</span>
    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> Object key<span class="token punctuation">,</span> Object value<span class="token punctuation">,</span>
                               <span class="token keyword">boolean</span> matchValue<span class="token punctuation">,</span> <span class="token keyword">boolean</span> movable<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> index<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 如果桶的数量大于0（不空）且待删除的元素所在的桶的第一个元素不为空</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>
            <span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>index <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> node <span class="token operator">=</span> null<span class="token punctuation">,</span> e<span class="token punctuation">;</span> K k<span class="token punctuation">;</span> V v<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 如果键的值与链表第一个节点相等，则将 node 指向该节点</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                node <span class="token operator">=</span> p<span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 如果该Tab的第一个元素是树节点，则以树的方式进行寻找</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
                    node <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    <span class="token comment" spellcheck="true">// 否则，就以链表的形式进行遍历寻找</span>
                    <span class="token keyword">do</span> <span class="token punctuation">{</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span>
                             <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            node <span class="token operator">=</span> e<span class="token punctuation">;</span>
                            <span class="token keyword">break</span><span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                        p <span class="token operator">=</span> e<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token comment" spellcheck="true">// 如果找到了该元素，则进行值比对</span>
            <span class="token comment" spellcheck="true">// 根据传递进来的matchValue判断是否需要匹配</span>
            <span class="token comment" spellcheck="true">// 如果不需要匹配直接删除，如果需要匹配看是否与传入的value相等</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>matchValue <span class="token operator">||</span> <span class="token punctuation">(</span>v <span class="token operator">=</span> node<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token operator">==</span> value <span class="token operator">||</span>
                                 <span class="token punctuation">(</span>value <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> value<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 如果是树结点，则调用树的删除方法；</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
                    <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">removeTreeNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> movable<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">// 如果待删除的元素是第一个元素，则将第二个元素移到到第一个元素的位置</span>
                <span class="token comment" spellcheck="true">// 注意：上面的代码可知，node==p的情况只有待删除元素node是第一个结点才会发生</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> p<span class="token punctuation">)</span>
                    tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">// 如果待删除的元素不是第一个元素，则将中间结点连接断开（单向链表）</span>
                <span class="token keyword">else</span>
                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">// 修改次数＋1</span>
                <span class="token operator">++</span>modCount<span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">// size-1</span>
                <span class="token operator">--</span>size<span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">// 删除结点之后应处理的事情</span>
                <span class="token function">afterNodeRemoval</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> node<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> null<span class="token punctuation">;</span>
    <span class="token punctuation">}</span></code></pre>
<hr>
<h1 id="4-HashMap的其他问题思考"><a href="#4-HashMap的其他问题思考" class="headerlink" title="4.HashMap的其他问题思考"></a>4.HashMap的其他问题思考</h1><hr>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h1><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>关于对Java编程的一些理解</title>
    <url>/2020/03/29/guan-yu-dui-java-bian-cheng-de-yi-xie-li-jie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="Java是解析运行吗？"><a href="#Java是解析运行吗？" class="headerlink" title="Java是解析运行吗？"></a>Java是解析运行吗？</h4><p>不是的！Java源代码经过Javac编译成.class文件，class文件经JVM解析或编译运行。</p>
<ul>
<li>解析: .class文件经过JVM内嵌的解析器解析执行。</li>
<li>编译:存在JIT编译器（Just In Time Compile 即时编译器）把经常运行的代码作为”热点代码”编译与本地平台相关的机器码，并进行各种层次的优化。</li>
<li>AOT编译器: Java 9提供的直接将所有代码编译成机器码执行。</li>
</ul>
<p>写个程序直接执行字节码就是解释执行。写个程序运行时把字节码动态翻译成机器码就是jit。写个程序把java源代码直接翻译为机器码就是aot。造个CPU直接执行字节码，字节码就是机器码。<br>因为如果虚拟机加载字节码后，完全进行解释执行，这势必会影响执行效率。所以，对于这个运行环节，虚拟机会进行一些优化处理，例如JIT技术，会将某些运行特别频繁的代码编译成机器码。而AOT技术，是在运行前，通过工具直接将字节码转换为机器码。</p>
<h4 id="上面提到了JIT-AOT，他们两个之间的区别是什么呢？"><a href="#上面提到了JIT-AOT，他们两个之间的区别是什么呢？" class="headerlink" title="上面提到了JIT,AOT，他们两个之间的区别是什么呢？"></a>上面提到了JIT,AOT，他们两个之间的区别是什么呢？</h4><ul>
<li>JIT是运行时才做的，需要预热才知道哪些是热点；</li>
<li>AOT是编译期，静态的，直接编成类似类库的东西</li>
</ul>
<p>接下来关于几个问题的理解：</p>
<ul>
<li>理解一下：『Write once, run anywhere』 “书写一次，到处运行”？<ul>
<li>“一次编译、到处运行”说的是Java语言跨平台的特性， Java的跨平台特性与Java虚拟机的存在密不可分，可在不同的环境中运行。比如说Windows平台和Linux平台都有相应的JDK，安装好JDK后也就有了Java语言的运行环境。其实Java语言本身与其他的编程语言没有特别大的差异，并不是说Java语言可以跨平台，而是在不同的平台都有可以让Java语言运行的环境而已，所以才有了Java一次编译，到处运行这样的效果。</li>
<li>严格的讲，跨平台的语言不止Java一种，但Java是较为成熟的一种。 “一次编译，到处运行”这种效果跟编译器有关。编程语言的处理需要编译器和解释器。 Java虚拟机和DOS类似，相当于一个供程序运行的平台。</li>
<li>程序从源代码到运行的三个阶段：编码——编译——运行——调试。 Java在编译阶段则体现了跨平台的特点。编译过程大概是这样的：首先是将Java源代码转化成.CLASS文件字节码，这是第一次编译。 .class文件就是可以到处运行的文件。然后Java字节码会被转化为目标机器代码，这是是由JVM来执行的，即Java的第二次编译。</li>
<li>到处运行”的关键和前提就是JVM。因为在第二次编译中JVM起着关键作用。在可以运行Java虚拟机的地方都内含着一个JVM操作系统。从而使JAVA提供了各种不同平台上的虚拟机制，因此实现了“到处运行”的效果。需要强调的一点是， java并不是编译机制，而是解释机制。 Java字节码的设计充分考虑了JIT这一即时编译方式，可以将字节码直接转化成高性能的本地机器码，这同样是虚拟机的一个构成部分。</li>
</ul>
</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java基础知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring IoC源码分析 - 深入理解IoC</title>
    <url>/2020/03/29/spring-ioc-yuan-ma-fen-xi-shen-ru-li-jie-ioc/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在开始IOC源码之前先了解清楚一下理论知识，因为IOC和DI（即依赖注入）大概分为一下几点：</p>
<ol>
<li>IoC是什么？</li>
<li>IoC能做什么？</li>
<li>IoC的别名：DI(依赖注入)</li>
<li>IoC和DI的关系是什么？</li>
</ol>
<h4 id="1-IoC是什么？"><a href="#1-IoC是什么？" class="headerlink" title="1.IoC是什么？"></a>1.IoC是什么？</h4><p>IoC 全称为 Inversion of Control，翻译为 “控制反转”，可以说这并不是一项技术，只是一种思想而已。<strong>在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。</strong> 理解IoC主要的关键在于理解两个问题：</p>
<ol>
<li><strong>谁控制谁，控制什么</strong>：<u>直接说明，是IoC容器控制了对象，控制了外部资源的获取（不只是对象，还有文件等等）</u><ul>
<li>在传统Java SE程序设计中，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建；</li>
</ul>
</li>
<li><strong>为何是反转，哪些方面反转了</strong>：<ul>
<li>首先需要理解的是，正转的意思：在传统应用程序中，是由我们自己在对象中主动控制去直接获取依赖对象，这就是正转。</li>
<li>反转的意思： 由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，这是反转。 </li>
<li>哪些方面反转了呢：依赖对象的获取被反转了。</li>
</ul>
</li>
</ol>
<p>总的来说对于IoC一句话概括为：<strong>所谓IoC就是由 Spring IOC 容器来负责对象的生命周期和对象之间的关系。</strong> 其理念即为：让别人为你服务。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 框架分析 - 导页</title>
    <url>/2020/03/29/spring-kuang-jia-fen-xi-dao-ye/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>Spring 是分层的 Java SE/EE 应用 full-stack 轻量级开源框架，以 IoC（Inverse Of Control：反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）为内核，提供了展现层 Spring MVC 和持久层 Spring JDBC 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的 Java EE 企业应用开源框架。</p>
<p>因为这阵子学习Java框架但是只是会表面的进行一些使用，对内部的结构原理并没有深入的去了解，所以觉得还是有必要进行一下源码的解读，一方面可以对Spring的原理更加深入的了解，另一方面也学习如下如何更加系统的阅读代码。主要还是跟着书籍及一些博主进行阅读，最好的当然是有自己的认识，多写注释多画图，相信会有一些收获的。</p>
<p>可从GitHub上面拉取进行源码分析：<a href="https://github.com/spring-projects/spring-framework。" target="_blank" rel="noopener">https://github.com/spring-projects/spring-framework。</a> 我是直接进行了最新版本的clone：version=5.2.4.BUILD-SNAPSHOT。应该不会有什么问题，进行源码的阅读也仅仅是基础模块，不会对新的内容方向进行深入了解。</p>
<p>所使用的工具及版本号如下：</p>
<ul>
<li>JDK1.8+</li>
<li>IntelliJ IDEA 2019.2</li>
<li>spring-framework 5.2.4.BUILD-SNAPSHOT</li>
</ul>
<h3 id="2-文章的排序"><a href="#2-文章的排序" class="headerlink" title="2.文章的排序"></a>2.文章的排序</h3><p>对于Spring框架的庞大早有耳闻，鉴于自己的水平不够，只能先制订一下大体阅读Spring源码的方向，再各个方向去进行攻克，如果发现有可以继续深入探索的地方，则后面续上；大体上对Spring源码的阅读分为两大部分：IOC 及 AOP</p>
<ul>
<li>IOC方面主要深入了解：<ul>
<li>IOC的基础原理，IOC特性及IOC的使用认识。</li>
<li>单例Bean的注册、获取、创建、解析、加载等等过程。</li>
<li>分析单例Bean的生命周期。</li>
<li>分析BeanDefinitions装载过程。</li>
<li>分析BeanWrapper。</li>
<li></li>
</ul>
</li>
<li>AOP方面主要深入了解：<ul>
<li>AOP的基础原理，</li>
<li>基于XML和基于注解的使用</li>
<li>创建代理对象的过程</li>
<li>请求的完整过程</li>
<li></li>
</ul>
</li>
</ul>
<h3 id="3-Spring-模块结构"><a href="#3-Spring-模块结构" class="headerlink" title="3.Spring 模块结构"></a>3.Spring 模块结构</h3><h3 id="4-结束语"><a href="#4-结束语" class="headerlink" title="4.结束语"></a>4.结束语</h3><p>附录：Spring 源码分析文章列表</p>
<table>
<thead>
<tr>
<th>更新时间</th>
<th>更新文章</th>
</tr>
</thead>
<tbody><tr>
<td>2020-2-13</td>
<td></td>
</tr>
<tr>
<td>2020-2-13</td>
<td></td>
</tr>
<tr>
<td>content1</td>
<td>content2</td>
</tr>
<tr>
<td>content1</td>
<td>content2</td>
</tr>
</tbody></table>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>导页</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发 - 导页</title>
    <url>/2020/03/29/java-bing-fa-dao-ye/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-简介"><a href="#一-简介" class="headerlink" title="一.简介"></a>一.简介</h1><p>Java并发是我在学习Java过程中涉及到的知识点较多的一块，里面的内容较杂乱，需要去好好的梳理一下，归纳总结一些基础的知识点，再对底层的实现原理进行逐一认识了解，在开展各个知识点的认识之前，应先要把基础的特性与概念先了解一下，这样会更好的帮助后面的了解；Java并发所涉及到的知识点大概为：线程的安全、线程调度、各种容器、AQS、J.U.C等等；</p>
<p>在进行并发深入了解之前，先明白并发、并行、高并发的概念：</p>
<ul>
<li>并发：是指在某个时间段内，多任务交替的执行任务。当有多个线程在操作时，把CPU运行时间划分成若干个时间段,再将时间段分配给各个线程执行。 在一个时间段的线程代码运行时，其它线程处于挂起状。</li>
<li>并行：是指同一时刻同时处理多任务的能力。当有多个线程在操作时，cpu同时处理这些线程请求的能力。</li>
<li>高并发：它通常是指，通过设计保证系统能够同时并行处理很多请求。</li>
</ul>
<h1 id="二-文章的排序"><a href="#二-文章的排序" class="headerlink" title="二.文章的排序"></a>二.文章的排序</h1><p>关于这个专辑里面的内容，先暂定如下几个内容进行分析，围着各个点进行开展深入学习，深入分析底层原理，弄清各个点之间的联系，联系到实际应用中去，想着如果在高并发状态该如何去解决问题、如何使用以下知识点去优化项目，以后再在实际工作中该如何使用，至少应该明白大体的工作原理及工作流程。</p>
<p>主要涉及的源码及原理分析如下：</p>
<ul>
<li>Java 线程池分析</li>
<li>Synchronized、Volatile 原理分析</li>
<li>J.U.C AQS分析</li>
<li>J.U.C 重入锁及读写锁分析</li>
<li>J.U.C 并发工具类分析</li>
<li>J.U.C 并发容器分析</li>
<li>Java 阻塞队列分析</li>
<li>Java CAS 原理分析</li>
<li></li>
</ul>
<h1 id="三-内容窥探"><a href="#三-内容窥探" class="headerlink" title="三.内容窥探"></a>三.内容窥探</h1><ol>
<li>线程与进程：<ol>
<li>我们需要理解线程与进程的概念与联系、线程的底层数据结构源码的解析。</li>
<li>线程的几种创建方式，这几种实现方式的源码的异同在哪里。</li>
</ol>
</li>
<li>线程池：<ol>
<li>理解线程池的基本概念与基本架构</li>
<li>ThreadPoolExecutor</li>
<li>ScheduledThreadPoolExecutor</li>
</ol>
</li>
<li>Synchronized：<ol>
<li>理解Synchronized的作用</li>
<li>进行Synchronized的代码解析</li>
</ol>
</li>
<li>Volatile：<ol>
<li>理解Volatile的作用</li>
<li>进行Volatile的代码解析</li>
</ol>
</li>
<li>AQS：AbstractQueuedSynvhronizer<ol>
<li>同步队列</li>
<li>同步状态</li>
<li>阻塞与幻想线程</li>
<li>独占/共享模式</li>
<li></li>
</ol>
</li>
<li>J.U.C 重入锁ReentrantLock、读写锁ReentrantReadWriteLock<ol>
<li>理解各自的原理与作用</li>
<li>进行代码解析</li>
<li>进行使用对比</li>
<li></li>
</ol>
</li>
<li>J.U.C 并发工具类：<ol>
<li>CountDownLatch</li>
<li>CyclicBarrier</li>
<li>Semaphore</li>
<li>Exchanger</li>
<li></li>
</ol>
</li>
<li>J.U.C 并发容器：<ol>
<li>ConcurrentHashMap</li>
<li>ConcurrentLinkedQueue</li>
<li>ConcurrentSkipListMap</li>
</ol>
</li>
<li>J.U.C 阻塞队列：<ol>
<li>ArrayBlockingQueue</li>
<li>PriorityBlockingQueue</li>
<li>DelayQueue</li>
<li>SynchronousQueue</li>
<li>LinkedTransferQueue</li>
<li>LinkedBlockingDeque</li>
</ol>
</li>
</ol>
<h1 id="四-结束语"><a href="#四-结束语" class="headerlink" title="四.结束语"></a>四.结束语</h1><p>因为我觉得我还是对一些高并发、高可用的知识较为感兴趣，所以对这一章节的内容可能会深入的探究一下，最好的方法我觉得还是看官方文档，这就需要一定的英语知识，可以采取的措施即为多看一下计算机相关的专业英语，实在不行的话借助翻译器也是一个方法；多动手去完成一些demo，进行编译Debug，这对以后工作状态当中进行排查错误是一个很好的方法，很多人只是了解基础知识，并没有去实践，这是一个问题所在；</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>导页</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 集合框架 - 导页</title>
    <url>/2020/03/29/java-ji-he-kuang-jia-dao-ye/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一-简介"><a href="#一-简介" class="headerlink" title="一.简介"></a>一.简介</h2><p>对于集合的学习，或者说对于所有知识的学习，总结一点我觉得非常重要的就是：假如可以带着问题去看知识的话那我觉得会更加深入，因为在这个过程当中我们会反复的推问原理为何，才能到达更深入的地步，所以在此系列文章的开头我都会尽量去整理问题的所在点，然后分析源代码，进行知识的总结，在最后再将思考所得写在下一篇文章当中，我觉得这样一来对知识的学习帮助或者更大。<br>集合的内容也是繁多，跟并发结合在一起两大模块成为Java学习过程当中的拦路虎，消除恐惧最好的方法即为面对恐惧，我对各个知识点逐个进行解析，倒不是说为了出书之类的，自问没有那个本事，只是说可以在学习过程中记录一些知识点和思考所得，可以在后来反复进行探究，不要学了很多遍知识最后却一点东西都没有剩下，对于集合框架的源码分析，难度不算太高，但是我觉得这对我编程的提升有很大帮助，尽量去思考内在逻辑是最有帮助的，希望可以收获更多。</p>
<p>工具与源码版本：</p>
<ul>
<li>IntelliJ IDEA 2019.2</li>
<li>jdk-15+9 （直接从<a href="https://github.com/openjdk/jdk" target="_blank" rel="noopener">https://github.com/openjdk/jdk</a> Clone下来的）</li>
</ul>
<h2 id="二-知识的窥探"><a href="#二-知识的窥探" class="headerlink" title="二.知识的窥探"></a>二.知识的窥探</h2><p>如若按照Collection和Map的归类来分的话，可以分为以下几部分：</p>
<ul>
<li><strong>Collection</strong> <ol>
<li><strong>List</strong><ol>
<li>Arraylist： Object数。</li>
<li>Vector： Object数组。</li>
<li>LinkedList： 双向链表(JDK1.6之前为循环链表，JDK1.7取消了循环)。</li>
</ol>
</li>
<li><strong>Set</strong><ol>
<li>LinkedHashSet： LinkedHashSet 继承于 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 HashMap 实现一样，不过还是有一点点区别的。</li>
<li>HashSet（无序，唯一）: 基于 HashMap 实现的，底层采用 HashMap 来保存元素。</li>
<li>TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树)。</li>
</ol>
</li>
</ol>
</li>
<li><strong>Map</strong><ol>
<li>HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</li>
<li>LinkedHashMap： LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：《LinkedHashMap 源码详细分析（JDK1.8）》</li>
<li>Hashtable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li>
<li>TreeMap： 红黑树（自平衡的排序二叉树）</li>
</ol>
</li>
<li><strong>注：如何选用集合?</strong><ul>
<li>主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用Map接口下的集合，需要排序时选择TreeMap，不需要排序时就选择HashMap，需要保证线程安全就选用ConcurrentHashMap.当我们只需要存放元素值时，就选择实现Collection接口的集合，需要保证元素唯一时选择实现Set接口的集合比如TreeSet或HashSet，不需要就选择实现List接口的比如ArrayList或LinkedList，然后再根据实现这些接口的集合的特点来选用。</li>
</ul>
</li>
</ul>
<h2 id="三-源码分析的排序"><a href="#三-源码分析的排序" class="headerlink" title="三.源码分析的排序"></a>三.源码分析的排序</h2><p>主要涉及的源码及原理分析如下：</p>
<ol>
<li>ArrayList 源码分析</li>
<li>LinkedList 源码分析</li>
<li><a href="">HashMap 源码分析</a></li>
<li>ConcurrentHashMap 源码分析</li>
<li>HashSet源码分析</li>
<li>LinkedHashMap 源码分析</li>
<li>TreeMap 源码分析</li>
<li>CopyOnWriteArrayList 源码分析</li>
<li></li>
</ol>
<h2 id="四-结束语"><a href="#四-结束语" class="headerlink" title="四.结束语"></a>四.结束语</h2><p>对于这个模块的学习，看源码是最好的，稍后补充</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>导页</tag>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础 - 导页</title>
    <url>/2020/03/29/java-ji-chu-dao-ye/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><h2 id="2-文章的排序"><a href="#2-文章的排序" class="headerlink" title="2.文章的排序"></a>2.文章的排序</h2><ol>
<li></li>
<li></li>
</ol>
<h2 id="3-结束语"><a href="#3-结束语" class="headerlink" title="3. 结束语"></a>3. 结束语</h2><p>语言的基础知识理解是最重要的，万丈高楼平地起，只有把基础知识解决了，后面的工作才会更好的进行下去，希望这个专辑能帮助我和大家更好的理解一下基础的语言知识</p>
<h2 id="4-阅读书籍介绍"><a href="#4-阅读书籍介绍" class="headerlink" title="4. 阅读书籍介绍"></a>4. 阅读书籍介绍</h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java基础知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>导页</tag>
      </tags>
  </entry>
</search>
